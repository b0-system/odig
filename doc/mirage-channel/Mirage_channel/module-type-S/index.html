<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>S (mirage-channel.Mirage_channel.S)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">mirage-channel</a> &#x00BB; <a href="../index.html">Mirage_channel</a> &#x00BB; S</nav><h1>Module type <code>Mirage_channel.S</code></h1></header><dl><dt class="spec type" id="type-error"><a href="#type-error" class="anchor"></a><code><span class="keyword">type</span> error</code></dt><dd><p>The type for errors.</p></dd></dl><dl><dt class="spec value" id="val-pp_error"><a href="#val-pp_error" class="anchor"></a><code><span class="keyword">val</span> pp_error : <a href="index.html#type-error">error</a> <a href="../../../fmt/Fmt/index.html#type-t">Fmt.t</a></code></dt><dd><p><code>pp_error</code> is the pretty-printer for errors.</p></dd></dl><dl><dt class="spec type" id="type-write_error#row"><a href="#type-write_error#row" class="anchor"></a><code><span class="keyword">type</span> write_error#row</code></dt><dd><p>The type for write errors.</p></dd></dl><dl><dt class="spec type" id="type-write_error"><a href="#type-write_error" class="anchor"></a><code><span class="keyword">and</span> write_error</code> = <span class="keyword">private</span> <code>[&gt; </code><table class="variant"><tr id="type-write_error.Mirage_flow.write_error" class="anchored"><td class="def type"><a href="#type-write_error.Mirage_flow.write_error" class="anchor"></a><code>| </code><code><a href="../../../mirage-flow/Mirage_flow/index.html#type-write_error">Mirage_flow.write_error</a></code></td></tr></table><code> ]</code></dt><dd><p>The type for write errors.</p></dd></dl><dl><dt class="spec value" id="val-pp_write_error"><a href="#val-pp_write_error" class="anchor"></a><code><span class="keyword">val</span> pp_write_error : <a href="index.html#type-write_error">write_error</a> <a href="../../../fmt/Fmt/index.html#type-t">Fmt.t</a></code></dt><dd><p><code>pp_write_error</code> is the pretty-printer for write errors.</p></dd></dl><dl><dt class="spec type" id="type-buffer"><a href="#type-buffer" class="anchor"></a><code><span class="keyword">type</span> buffer</code></dt><dd><p>The type for memory buffers.</p></dd></dl><dl><dt class="spec type" id="type-flow"><a href="#type-flow" class="anchor"></a><code><span class="keyword">type</span> flow</code></dt><dd><p>The type for unbuffered network flow.</p></dd></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><p>The type for the state associated with channels, such as the inflight buffers.</p></dd></dl><dl><dt class="spec type" id="type-io"><a href="#type-io" class="anchor"></a><code><span class="keyword">type</span> +'a io</code></dt><dd><p>The type for potentially blocking I/O operation</p></dd></dl><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : <a href="index.html#type-flow">flow</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>create flow</code> allocates send and receive buffers and associates them with the given unbuffered <code>flow</code>.</p></dd></dl><dl><dt class="spec value" id="val-to_flow"><a href="#val-to_flow" class="anchor"></a><code><span class="keyword">val</span> to_flow : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-flow">flow</a></code></dt><dd><p><code>to_flow t</code> returns the flow that backs this channel.</p></dd></dl><dl><dt class="spec value" id="val-read_char"><a href="#val-read_char" class="anchor"></a><code><span class="keyword">val</span> read_char : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (char <a href="../../../mirage-flow/Mirage_flow/index.html#type-or_eof">Mirage_flow.or_eof</a>, <a href="index.html#type-error">error</a>) <a href="../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a> <a href="index.html#type-io">io</a></code></dt><dd><p>Reads a single character from the channel, blocking if there is no immediately available input data.</p></dd></dl><dl><dt class="spec value" id="val-read_some"><a href="#val-read_some" class="anchor"></a><code><span class="keyword">val</span> read_some : ?&#8288;len:int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<a href="index.html#type-buffer">buffer</a> <a href="../../../mirage-flow/Mirage_flow/index.html#type-or_eof">Mirage_flow.or_eof</a>, <a href="index.html#type-error">error</a>) <a href="../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a> <a href="index.html#type-io">io</a></code></dt><dd><p><code>read_some ?len t</code> reads up to <code>len</code> characters from the input channel and at most a full <code>buffer</code>. If <code>len</code> is not specified, it reads all available data and returns that buffer.</p></dd></dl><dl><dt class="spec value" id="val-read_exactly"><a href="#val-read_exactly" class="anchor"></a><code><span class="keyword">val</span> read_exactly : len:int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<a href="index.html#type-buffer">buffer</a> list <a href="../../../mirage-flow/Mirage_flow/index.html#type-or_eof">Mirage_flow.or_eof</a>, <a href="index.html#type-error">error</a>) <a href="../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a> <a href="index.html#type-io">io</a></code></dt><dd><p><code>read_exactly len t</code> reads <code>len</code> bytes from the channel <code>t</code> or fails with <code>Eof</code>.</p></dd></dl><dl><dt class="spec value" id="val-read_line"><a href="#val-read_line" class="anchor"></a><code><span class="keyword">val</span> read_line : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<a href="index.html#type-buffer">buffer</a> list <a href="../../../mirage-flow/Mirage_flow/index.html#type-or_eof">Mirage_flow.or_eof</a>, <a href="index.html#type-error">error</a>) <a href="../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a> <a href="index.html#type-io">io</a></code></dt><dd><p><code>read_line t</code> reads a line of input, which is terminated either by a CRLF sequence, or the end of the channel (which counts as a line).</p><dl><dt>returns</dt><dd><p>Returns a list of views that terminates at EOF.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-write_char"><a href="#val-write_char" class="anchor"></a><code><span class="keyword">val</span> write_char : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> char <span>&#45;&gt;</span> unit</code></dt><dd><p><code>write_char t ch</code> writes a single character to the output channel.</p></dd></dl><dl><dt class="spec value" id="val-write_string"><a href="#val-write_string" class="anchor"></a><code><span class="keyword">val</span> write_string : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p><code>write_string t buf off len</code> writes <code>len</code> bytes from a string <code>buf</code>, starting from from offset <code>off</code>.</p></dd></dl><dl><dt class="spec value" id="val-write_buffer"><a href="#val-write_buffer" class="anchor"></a><code><span class="keyword">val</span> write_buffer : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-buffer">buffer</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>write_buffer t buf</code> copies the buffer to the channel's output buffer. The buffer should not be modified after being written, and it will be recycled into the buffer allocation pool at some future point.</p></dd></dl><dl><dt class="spec value" id="val-write_line"><a href="#val-write_line" class="anchor"></a><code><span class="keyword">val</span> write_line : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> unit</code></dt><dd><p><code>write_line t buf</code> writes the string <code>buf</code> to the output channel and append a newline character afterwards.</p></dd></dl><dl><dt class="spec value" id="val-flush"><a href="#val-flush" class="anchor"></a><code><span class="keyword">val</span> flush : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (unit, <a href="index.html#type-write_error">write_error</a>) <a href="../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a> <a href="index.html#type-io">io</a></code></dt><dd><p><code>flush t</code> flushes the output buffer and block if necessary until it is all written out to the flow.</p></dd></dl><dl><dt class="spec value" id="val-close"><a href="#val-close" class="anchor"></a><code><span class="keyword">val</span> close : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (unit, <a href="index.html#type-write_error">write_error</a>) <a href="../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a> <a href="index.html#type-io">io</a></code></dt><dd><p><code>close t</code> calls <a href="index.html#val-flush"><code>flush</code></a> and then close the underlying flow.</p></dd></dl></div></body></html>