<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Fpath (fpath.Fpath)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">fpath</a> &#x00BB; Fpath</nav><h1>Module <code>Fpath</code></h1><p>File system paths, file <a href="index.html#file_exts"><span>extensions</span></a>, path <a href="Set/index.html"><span>sets</span></a> and <a href="Map/index.html"><span>maps</span></a>.</p><p>A (file system) <em>path</em> specifies a file or a directory in a file system hierarchy. A path has three parts:</p><ol><li>An optional, platform-dependent, <a href="index.html#val-split_volume"><span>volume</span></a>.</li><li>An optional root directory separator <a href="index.html#val-dir_sep"><code>dir_sep</code></a> whose presence distinguishes <em>absolute</em> paths (<code>&quot;/a&quot;</code>) from <em>relative</em> ones (<code>&quot;a&quot;</code>)</li><li>A non-empty list of <a href="index.html#val-dir_sep"><code>dir_sep</code></a> separated segments. Segments are non empty strings except for maybe the last one. The latter distinguishes <em>directory paths</em> (<code>&quot;a/b/&quot;</code>) from <em>file paths</em> (<code>&quot;a/b&quot;</code>).</li></ol><p>The path segments <code>&quot;.&quot;</code> and <code>&quot;..&quot;</code> are <a href="index.html#val-is_rel_seg"><span><em>relative path segments</em></span></a> that respectively denote the current and parent directory. The <a href="index.html#val-basename"><span><em>basename</em></span></a> of a path is its last non-empty segment if it is not a relative path segment or the empty string otherwise.</p><p>Consult a few <a href="index.html#tips"><span>important tips</span></a>.</p><p><b>Note.</b> <code>Fpath</code> processes paths without accessing the file system.</p><p><em>v0.7.2 - <a href="http://erratique.ch/software/fpath">homepage</a></em></p><nav class="toc"><ul><li><a href="#segs">Separators and segments</a></li><li><a href="#paths">Paths</a></li><li><a href="#filedir">File and directory paths</a></li><li><a href="#parentbase">Base and parent paths</a></li><li><a href="#norm">Normalization</a></li><li><a href="#prefixes">Prefixes</a></li><li><a href="#rootrel">Roots and relativization</a></li><li><a href="#predicates">Predicates and comparison</a></li><li><a href="#conversions">Conversions and pretty printing</a></li><li><a href="#file_exts">File extensions</a></li><li><a href="#sets_maps">Path sets and maps</a></li><li><a href="#tips">Tips</a></li><li><a href="#ex">Examples</a><ul><li><a href="#ex_add_seg"><em></em></a></li><li><a href="#ex_append"><em></em></a></li><li><a href="#ex_segs"><em></em></a></li><li><a href="#ex_is_dir_path"><em></em></a></li><li><a href="#ex_is_file_path"><em></em></a></li><li><a href="#ex_to_dir_path"><em></em></a></li><li><a href="#ex_filename"><em></em></a></li><li><a href="#ex_split_base"><em></em></a></li><li><a href="#ex_basename"><em></em></a></li><li><a href="#ex_parent"><em></em></a></li><li><a href="#ex_rem_empty_seg"><em></em></a></li><li><a href="#ex_normalize"><em></em></a></li><li><a href="#ex_is_prefix"><em></em></a></li><li><a href="#ex_find_prefix"><em></em></a></li><li><a href="#ex_rem_prefix"><em></em></a></li><li><a href="#ex_relativize"><em></em></a></li><li><a href="#ex_is_rooted"><em></em></a></li><li><a href="#ex_is_root"><em></em></a></li><li><a href="#ex_get_ext"><em></em></a></li><li><a href="#ex_has_ext"><em></em></a></li><li><a href="#ex_exists_ext"><em></em></a></li><li><a href="#ex_add_ext"><em></em></a></li><li><a href="#ex_rem_ext"><em></em></a></li></ul></li></ul></nav></header><section><header><h2 id="segs"><a href="#segs" class="anchor"></a>Separators and segments</h2></header><dl><dt class="spec value" id="val-dir_sep"><a href="#val-dir_sep" class="anchor"></a><code><span class="keyword">val</span> dir_sep : string</code></dt><dd><p><code>dir_sep</code> is the platform dependent natural directory separator. This is <code>&quot;/&quot;</code> on POSIX and <code>&quot;\\&quot;</code> on Windows.</p></dd></dl><dl><dt class="spec value" id="val-is_seg"><a href="#val-is_seg" class="anchor"></a><code><span class="keyword">val</span> is_seg : string <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_seg s</code> is <code>true</code> iff <code>s</code> does not contain <a href="index.html#val-dir_sep"><code>dir_sep</code></a> or <code>'/'</code> or a <code>0x00</code> byte.</p></dd></dl><dl><dt class="spec value" id="val-is_rel_seg"><a href="#val-is_rel_seg" class="anchor"></a><code><span class="keyword">val</span> is_rel_seg : string <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_rel_seg s</code> is true iff <code>s</code> is a relative segment, that is <code>&quot;.&quot;</code> or <code>&quot;..&quot;</code>.</p></dd></dl></section><section><header><h2 id="paths"><a href="#paths" class="anchor"></a>Paths</h2></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><p>The type for paths.</p></dd></dl><dl><dt class="spec value" id="val-v"><a href="#val-v" class="anchor"></a><code><span class="keyword">val</span> v : string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>v s</code> is the string <code>s</code> as a path.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>s</code> is not a <a href="index.html#val-of_string"><span>valid path</span></a>. Use <a href="index.html#val-of_string"><code>of_string</code></a> to deal with untrusted input.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-add_seg"><a href="#val-add_seg" class="anchor"></a><code><span class="keyword">val</span> add_seg : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>add_seg p seg</code> adds segment <code>seg</code> to the segments of <code>p</code> if <code>p</code>'s last segment is non-empty or replaces the last empty segment with <code>seg</code>. <a href="index.html#ex_add_seg"><span>Examples</span></a>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <a href="index.html#val-is_seg"><code>is_seg</code></a><code> seg</code> is <code>false</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-(/)"><a href="#val-(/)" class="anchor"></a><code><span class="keyword">val</span> (/) : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>p / seg</code> is <a href="index.html#val-add_seg"><code>add_seg</code></a><code> p seg</code>. Left associative.</p></dd></dl><dl><dt class="spec value" id="val-append"><a href="#val-append" class="anchor"></a><code><span class="keyword">val</span> append : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>append p q</code> appends <code>q</code> to <code>p</code> as follows:</p><ul><li>If <code>q</code> is absolute or has a non-empty <a href="index.html#val-split_volume"><span>volume</span></a> then <code>q</code> is returned.</li><li>Otherwise appends <code>q</code>'s segments to <code>p</code> using <a href="index.html#val-add_seg"><code>add_seg</code></a>.</li></ul><p><a href="index.html#ex_append"><span>Examples</span></a>.</p></dd></dl><dl><dt class="spec value" id="val-(//)"><a href="#val-(//)" class="anchor"></a><code><span class="keyword">val</span> (//) : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>p // p'</code> is <a href="index.html#val-append"><code>append</code></a><code> p p'</code>. Left associative.</p></dd></dl><dl><dt class="spec value" id="val-split_volume"><a href="#val-split_volume" class="anchor"></a><code><span class="keyword">val</span> split_volume : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string * <a href="index.html#type-t">t</a></code></dt><dd><p><code>split_volume p</code> is the pair <code>(vol, q)</code> where <code>vol</code> is the platform dependent volume of <code>p</code> or the empty string if there is none and <code>q</code> the path <code>p</code> without its volume, that is its optional root <a href="index.html#val-dir_sep"><code>dir_sep</code></a> and segments.</p><p>On POSIX if <code>vol</code> is non-empty then it <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap03.html#tag_03_267">can</a> only be <code>&quot;/&quot;</code> (e.g. in <code>v &quot;//a/b&quot;</code>). On Windows <code>vol</code> may be one of the following prefixes parsed before an absolute root <a href="index.html#val-dir_sep"><code>dir_sep</code></a>, except in the first case where a relative path can follow:</p><pre><code class="ml">$(drive):
\\$(server)\$(share)
\\?\$(drive):
\\?\$(server)\$(share)
\\?\UNC\$(server)\$(share)
\\.\$(device)</code></pre><p>The following invariant holds:</p><ul><li><code>equal p (v @@ vol ^ (to_string q))</code></li></ul></dd></dl><dl><dt class="spec value" id="val-segs"><a href="#val-segs" class="anchor"></a><code><span class="keyword">val</span> segs : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string list</code></dt><dd><p><code>segs p</code> is <code>p</code>'s <em>non-empty</em> list of segments. Absolute paths have an initial empty string added, this allows to recover the path's string with <span class="xref-unresolved" title="unresolved reference to &quot;String.concat&quot;"><code>String</code>.concat</span><code> ~sep:dir_sep</code>. <a href="index.html#ex_segs"><span>Examples.</span></a></p><p>The following invariant holds:</p><ul><li><code>equal p (v @@ (fst @@ split_volume p) ^ (String.concat ~sep:dir_sep
       (segs p)))</code></li></ul></dd></dl></section><section><header><h2 id="filedir"><a href="#filedir" class="anchor"></a>File and directory paths</h2><p><b>Note.</b> The following functions use syntactic semantic properties of paths. Given a path, these properties can be different from the one your file system attributes to it.</p></header><dl><dt class="spec value" id="val-is_dir_path"><a href="#val-is_dir_path" class="anchor"></a><code><span class="keyword">val</span> is_dir_path : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_dir_path p</code> is <code>true</code> iff <code>p</code> represents a directory. This means that <code>p</code>'s last segment is either empty (<code>&quot;&quot;</code>) or <a href="index.html#val-is_rel_seg"><span>relative</span></a>. The property is invariant with respect to <a href="index.html#val-normalize"><span>normalization</span></a>. <a href="index.html#ex_is_dir_path"><span>Examples</span></a>.</p></dd></dl><dl><dt class="spec value" id="val-is_file_path"><a href="#val-is_file_path" class="anchor"></a><code><span class="keyword">val</span> is_file_path : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_file_path p</code> is <code>true</code> iff <code>p</code> represents a file. This is the negation of <a href="index.html#val-is_dir_path"><code>is_dir_path</code></a>. This means that <code>p</code>'s last segment is neither empty (<code>&quot;&quot;</code>) nor <a href="index.html#val-is_rel_seg"><span>relative</span></a>. The property is invariant with respect to <a href="index.html#val-normalize"><span>normalization</span></a>. <a href="index.html#ex_is_file_path"><span>Examples</span></a>.</p></dd></dl><dl><dt class="spec value" id="val-to_dir_path"><a href="#val-to_dir_path" class="anchor"></a><code><span class="keyword">val</span> to_dir_path : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>to_dir_path p</code> is <a href="index.html#val-add_seg"><code>add_seg</code></a><code> p &quot;&quot;</code>. It ensure that the result represents a <a href="index.html#val-is_dir_path"><span>directory</span></a> and, if converted to a string, that it ends with a <a href="index.html#val-dir_sep"><code>dir_sep</code></a>. <a href="index.html#ex_to_dir_path"><span>Examples</span></a>.</p></dd></dl><dl><dt class="spec value" id="val-filename"><a href="#val-filename" class="anchor"></a><code><span class="keyword">val</span> filename : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p><code>filename p</code> is the file name of <code>p</code>. This is the last segment of <code>p</code> if <code>p</code> is a <a href="index.html#val-is_file_path"><span>file path</span></a> and the empty string otherwise. The result is invariant with respect to <a href="index.html#val-normalize"><span>normalization</span></a>. See also <a href="index.html#val-basename"><code>basename</code></a>. <a href="index.html#ex_filename"><span>Examples</span></a>.</p></dd></dl></section><section><header><h2 id="parentbase"><a href="#parentbase" class="anchor"></a>Base and parent paths</h2></header><dl><dt class="spec value" id="val-split_base"><a href="#val-split_base" class="anchor"></a><code><span class="keyword">val</span> split_base : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> * <a href="index.html#type-t">t</a></code></dt><dd><p><code>split_base p</code> splits <code>p</code> into a directory <code>d</code> and a <em>relative</em> base path <code>b</code> such that:</p><ul><li><code>b</code> is a relative path that contains the segments of <code>p</code> that start at the last non-empty segment. This means that <code>b</code> has a <em>single</em> non-empty segment, and preserves <a href="index.html#val-is_dir_path"><span>directoryness</span></a> of <code>p</code>. If <code>p</code> is a <a href="index.html#val-is_root"><span>root path</span></a> there are no such segments and <code>b</code> is <code>&quot;./&quot;</code>.</li><li><code>d</code> is a <a href="index.html#val-is_dir_path"><span>directory</span></a> such that <code>d // b</code> represents the same path as <code>p</code>. They may however differ syntactically when converted to a string.</li></ul><p><a href="index.html#ex_split_base"><span>Examples</span></a>.</p><p><b>Note.</b> <a href="index.html#val-normalize"><span>Normalizing</span></a> <code>p</code> before using the function ensures that <code>b</code> is a <a href="index.html#val-is_rel_seg"><span>relative segment</span></a> iff <code>p</code> cannot be named (like in <code>&quot;.&quot;</code>, <code>&quot;../../&quot;</code>, <code>&quot;/&quot;</code>, etc.).</p></dd></dl><dl><dt class="spec value" id="val-base"><a href="#val-base" class="anchor"></a><code><span class="keyword">val</span> base : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>base p</code> is <code>snd (split_base p)</code>.</p></dd></dl><dl><dt class="spec value" id="val-basename"><a href="#val-basename" class="anchor"></a><code><span class="keyword">val</span> basename : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p><code>basename p</code> is <code>p</code>'s last non-empty segment if non-relative or the empty string otherwise. The latter occurs only on <a href="index.html#val-is_root"><span>root paths</span></a> and on paths whose last non-empty segment is a <a href="index.html#val-is_rel_seg"><span>relative segment</span></a>. See also <a href="index.html#val-filename"><code>filename</code></a> and <a href="index.html#val-base"><code>base</code></a>. <a href="index.html#ex_basename"><span>Examples</span></a>.</p><p><b>Note.</b> <a href="index.html#val-normalize"><span>Normalizing</span></a> <code>p</code> before using the function ensures the empty string is only returned iff <code>p</code> cannot be named (like in <code>&quot;.&quot;</code>, <code>&quot;../../&quot;</code>, <code>&quot;/&quot;</code>, etc.)</p></dd></dl><dl><dt class="spec value" id="val-parent"><a href="#val-parent" class="anchor"></a><code><span class="keyword">val</span> parent : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>parent p</code> is a <a href="index.html#val-is_dir_path"><span>directory path</span></a> that contains <code>p</code>. If <code>p</code> is a <a href="index.html#val-is_root"><span>root path</span></a> this is <code>p</code> itself. <a href="index.html#ex_parent"><span>Examples</span></a>.</p><p><b>Warning.</b> <code>parent p // base p</code> may not represent <code>p</code>, use <a href="index.html#val-split_base"><code>split_base</code></a> for this.</p></dd></dl></section><section><header><h2 id="norm"><a href="#norm" class="anchor"></a>Normalization</h2></header><dl><dt class="spec value" id="val-rem_empty_seg"><a href="#val-rem_empty_seg" class="anchor"></a><code><span class="keyword">val</span> rem_empty_seg : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>rem_empty_seg p</code> removes an existing last empty segment of <code>p</code> if <code>p</code> is not a <a href="index.html#val-is_root"><span>root path</span></a>. This ensure that if <code>p</code> is converted to a string it will not have a trailing <a href="index.html#val-dir_sep"><code>dir_sep</code></a> unless <code>p</code> is a root path. Note that this may affect <code>p</code>'s <a href="index.html#val-is_dir_path"><span>directoryness</span></a>. <a href="index.html#ex_rem_empty_seg"><span>Examples</span></a>.</p></dd></dl><dl><dt class="spec value" id="val-normalize"><a href="#val-normalize" class="anchor"></a><code><span class="keyword">val</span> normalize : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>normalize p</code> is a path that represents the same path as <code>p</code>, <a href="index.html#val-is_dir_path"><span>directoryness</span></a> included, and that has the following properties:</p><ul><li>If <code>p</code> is absolute the resulting path has no <code>&quot;.&quot;</code> and <code>&quot;..&quot;</code> segments.</li><li>If <code>p</code> is relative the resulting path is either <code>&quot;./&quot;</code> or it has no <code>&quot;.&quot;</code> segments and <code>&quot;..&quot;</code> segments may only appear as initial segments.</li><li>If <code>p</code> is a <a href="index.html#val-is_dir_path"><span>directory</span></a> it always end with an empty segment; this means it doesn't end with <code>&quot;.&quot;</code> or <code>&quot;..&quot;</code>.</li></ul><p><a href="index.html#ex_normalize"><span>Examples</span></a>.</p><p><b>Warning.</b> Like file and directory path <a href="index.html#filedir"><span>functions</span></a> this function does not consult the file system and is purely based on the syntactic semantic of paths which can be different from the one of your concrete file system attributes. For example in presence of symbolic links the resulting path may not point to the same entity. Use the normalization functions of your OS system library to ensure correct behaviour with respect to a concrete file system.</p></dd></dl></section><section><header><h2 id="prefixes"><a href="#prefixes" class="anchor"></a>Prefixes</h2><p><b>Warning.</b> The syntactic <a href="index.html#val-is_prefix"><span>prefix relation</span></a> between paths does not, in general, entail directory containement. The following examples show this:</p><pre><code class="ml">is_prefix (v &quot;..&quot;) (v &quot;../..&quot;) = true
is_prefix (v &quot;..&quot;) (v &quot;.&quot;) = false</code></pre><p>However, on <a href="index.html#val-normalize"><span>normalized</span></a>, <a href="index.html#val-is_abs"><span>absolute</span></a> paths, the prefix relation does entail directory containement. See also <a href="index.html#val-is_rooted"><code>is_rooted</code></a>.</p></header><dl><dt class="spec value" id="val-is_prefix"><a href="#val-is_prefix" class="anchor"></a><code><span class="keyword">val</span> is_prefix : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_prefix prefix p</code> is <code>true</code> if <code>prefix</code> is a prefix of <code>p</code>. This checks that:</p><ul><li><code>prefix</code> has the same optional volume as <code>p</code>.</li><li><code>prefix</code> has the same optional root directory separator as <code>p</code>.</li><li>The list of segments of <code>prefix</code> is a prefix of those of <code>p</code>, ignoring the last empty segment of <code>prefix</code> if the number of non-empty segments of <code>p</code> is strictly larger than those of <code>prefix</code>. This means that <code>is_prefix (v &quot;a/&quot;) (v &quot;a/b&quot;)</code> is <code>true</code> but <code>is_prefix (v &quot;a/&quot;) (v &quot;a&quot;)</code> is <code>false</code></li></ul><p><a href="index.html#ex_is_prefix"><span>Examples</span></a>.</p></dd></dl><dl><dt class="spec value" id="val-find_prefix"><a href="#val-find_prefix" class="anchor"></a><code><span class="keyword">val</span> find_prefix : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> option</code></dt><dd><p><code>find_prefix p p'</code> is <code>Some prefix</code> if there exists <code>prefix</code> such that <code>prefix</code> is the longest path with <code>is_prefix prefix p &amp;&amp;
    is_prefix prefix p' = true</code> and <code>None</code> otherwise. Note that if both <code>p</code> and <code>p'</code> are absolute and have the same volume then a prefix always exists: the <a href="index.html#val-is_root"><span>root path</span></a> of their volume. <a href="index.html#ex_find_prefix"><span>Examples</span></a>.</p></dd></dl><dl><dt class="spec value" id="val-rem_prefix"><a href="#val-rem_prefix" class="anchor"></a><code><span class="keyword">val</span> rem_prefix : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> option</code></dt><dd><p><code>rem_prefix prefix p</code> is:</p><ul><li><code>None</code> if <code>prefix</code> is not a <a href="index.html#val-is_prefix"><span>prefix</span></a> of <code>p</code> or if <code>prefix</code> and <code>p</code> are <a href="index.html#val-equal"><span>equal</span></a>.</li><li><code>Some q</code> otherwise where <code>q</code> is <code>p</code> without the prefix <code>prefix</code> and preserves <code>p</code>'s <a href="index.html#val-is_dir_path"><span>directoryness</span></a>. This means that <code>q</code> is a always <a href="index.html#val-is_rel"><span>relative</span></a> and that the path <code>prefix // q</code> and <code>p</code> represent the same paths. They may however differ syntactically when converted to a string.</li></ul><p><a href="index.html#ex_rem_prefix"><span>Examples</span></a>.</p></dd></dl></section><section><header><h2 id="rootrel"><a href="#rootrel" class="anchor"></a>Roots and relativization</h2></header><dl><dt class="spec value" id="val-relativize"><a href="#val-relativize" class="anchor"></a><code><span class="keyword">val</span> relativize : root:<a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> option</code></dt><dd><p><code>relativize ~root p</code> is:</p><ul><li><code>Some q</code> if there exists a <span class="xref-unresolved" title="unresolved reference to &quot;is_relative&quot;"><span>relative</span></span> path <code>q</code> such that <code>root // q</code> and <code>p</code> represent the same paths, <a href="index.html#val-is_dir_path"><span>directoryness</span></a> included. They may however differ syntactically when converted to a string. Note that <code>q</code> is <a href="index.html#val-normalize"><span>normalized</span></a>.</li><li><code>None</code> otherwise.</li></ul><p><a href="index.html#ex_relativize"><span>Examples</span></a>.</p></dd></dl><dl><dt class="spec value" id="val-is_rooted"><a href="#val-is_rooted" class="anchor"></a><code><span class="keyword">val</span> is_rooted : root:<a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_rooted root p</code> is <code>true</code> iff the path <code>p</code> is the <a href="index.html#val-is_dir_path"><span><em>directory</em></span></a> <code>root</code> or contained in <code>root</code> and that <code>p</code> can be <a href="index.html#val-relativize"><span>relativized</span></a> w.r.t. <code>root</code> (the normalized relative path will have no parent directory segments). <a href="index.html#ex_is_rooted"><span>Examples</span></a>.</p></dd></dl></section><section><header><h2 id="predicates"><a href="#predicates" class="anchor"></a>Predicates and comparison</h2></header><dl><dt class="spec value" id="val-is_rel"><a href="#val-is_rel" class="anchor"></a><code><span class="keyword">val</span> is_rel : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_rel p</code> is <code>true</code> iff <code>p</code> is a relative path, i.e. the root directory separator is missing in <code>p</code>.</p></dd></dl><dl><dt class="spec value" id="val-is_abs"><a href="#val-is_abs" class="anchor"></a><code><span class="keyword">val</span> is_abs : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_abs p</code> is <code>true</code> iff <code>p</code> is an absolute path, i.e. the root directory separator is present in <code>p</code>.</p></dd></dl><dl><dt class="spec value" id="val-is_root"><a href="#val-is_root" class="anchor"></a><code><span class="keyword">val</span> is_root : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_root p</code> is <code>true</code> iff <code>p</code> is a root directory, i.e. <code>p</code> has the root directory separator and a single, empty, segment. <a href="index.html#ex_is_root"><span>Examples</span></a>.</p><p><b>Warning.</b> By definition this is a syntactic test. For example it will return <code>false</code> on <code>&quot;/a/..&quot;</code> or <code>&quot;/..&quot;</code>. <a href="index.html#val-normalize"><span>Normalizing</span></a> the path before testing avoids this problem.</p></dd></dl><dl><dt class="spec value" id="val-is_current_dir"><a href="#val-is_current_dir" class="anchor"></a><code><span class="keyword">val</span> is_current_dir : ?&#8288;prefix:bool <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_current_dir p</code> is true iff <code>p</code> is the current relative directory, i.e. either <code>&quot;.&quot;</code> or <code>&quot;./&quot;</code>. If <code>prefix</code> is <code>true</code> (defaults to <code>false</code>) simply checks that <code>p</code> is <a href="index.html#val-is_rel"><span>relative</span></a> and its first segment is <code>&quot;.&quot;</code>.</p><p><b>Warning.</b> By definition this is a syntactic test. For example it will return <code>false</code> on <code>&quot;./a/..&quot;</code> or <code>&quot;./.&quot;</code>. <a href="index.html#val-normalize"><span>Normalizing</span></a> the path before testing avoids this problem.</p></dd></dl><dl><dt class="spec value" id="val-is_parent_dir"><a href="#val-is_parent_dir" class="anchor"></a><code><span class="keyword">val</span> is_parent_dir : ?&#8288;prefix:bool <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_parent_dir p</code> is <code>true</code> iff <code>p</code> is the relative parent directory, i.e. either <code>&quot;..&quot;</code> or <code>&quot;../&quot;</code>. If <code>prefix</code> is <code>true</code> (defaults to <code>false</code>), simply checks that <code>p</code> is <a href="index.html#val-is_rel"><span>relative</span></a> and its first segment is <code>&quot;..&quot;</code>.</p><p><b>Warning.</b> By definition this is a syntactic test. For example it will return <code>false</code> on <code>&quot;./a/../..&quot;</code> or <code>&quot;./..&quot;</code>. <a href="index.html#val-normalize"><span>Normalizing</span></a> the path before testing avoids this problem.</p></dd></dl><dl><dt class="spec value" id="val-is_dotfile"><a href="#val-is_dotfile" class="anchor"></a><code><span class="keyword">val</span> is_dotfile : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_dotfile p</code> is <code>true</code> iff <code>p</code>'s <a href="index.html#val-basename"><span>basename</span></a> is non empty and starts with a <code>'.'</code>.</p><p><b>Warning.</b> By definition this is a syntactic test. For example it will return <code>false</code> on <code>&quot;.ssh/.&quot;</code>. <a href="index.html#val-normalize"><span>Normalizing</span></a> the path before testing avoids this problem.</p></dd></dl><dl><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val</span> equal : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>equal p p'</code> is <code>true</code> if <code>p</code> and <code>p'</code> have the same volume are both relative or absolute and have the same segments.</p><p><b>Warning.</b> By definition this is a syntactic test. For example <code>equal (v &quot;./&quot;) (v &quot;a/..&quot;)</code> is <code>false</code>. <a href="index.html#val-normalize"><span>Normalizing</span></a> the paths before testing avoids this problem.</p></dd></dl><dl><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val</span> compare : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>compare p p'</code> is a total order on paths compatible with <a href="index.html#val-equal"><code>equal</code></a>.</p></dd></dl></section><section><header><h2 id="conversions"><a href="#conversions" class="anchor"></a>Conversions and pretty printing</h2></header><dl><dt class="spec value" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span class="keyword">val</span> to_string : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p><code>to_string p</code> is the path <code>p</code> as a string. The result can be safely converted back with <a href="index.html#val-v"><code>v</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-of_string"><a href="#val-of_string" class="anchor"></a><code><span class="keyword">val</span> of_string : string <span>&#45;&gt;</span> (<a href="index.html#type-t">t</a>,Â [ `Msg of string ]) <a href="../../result/Result/index.html#type-result">Result.result</a></code></dt><dd><p><code>of_string s</code> is the string <code>s</code> as a path. The following transformations are performed on the string:</p><ul><li>On Windows any <code>'/'</code> occurence is converted to <code>'\\'</code> before any processing occurs.</li><li>Non-initial empty segments are suppressed; <code>&quot;a//b&quot;</code> becomes <code>&quot;a/b&quot;</code>, <code>&quot;//a////b//&quot;</code> becomes <code>&quot;//a/b/&quot;</code>, etc.</li><li>On Windows empty absolute UNC paths are completed to their root. For example <code>&quot;\\\\server\\share&quot;</code> becomes <code>&quot;\\\\server\\share\\&quot;</code>, but incomplete UNC volumes like <code>&quot;\\\\a&quot;</code> return <code>Result.Error</code>.</li></ul><p><code>Result.Error (`Msg (strf &quot;%S: invalid path&quot; s))</code> is returned if</p><ul><li><code>s</code> or the path following the <a href="index.html#val-split_volume"><span>volume</span></a> is empty (<code>&quot;&quot;</code>), except on Windows UNC paths, see above.</li><li><code>s</code> has null byte (<code>'\x00'</code>).</li><li>On Windows, <code>s</code> is an invalid UNC path (e.g. <code>&quot;\\\\&quot;</code> or <code>&quot;\\\\a&quot;</code>)</li></ul></dd></dl><dl><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val</span> pp : <a href="../../ocaml/Stdlib/Format/index.html#type-formatter">Stdlib.Format.formatter</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp ppf p</code> prints path <code>p</code> on <code>ppf</code> using <a href="index.html#val-to_string"><code>to_string</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-dump"><a href="#val-dump" class="anchor"></a><code><span class="keyword">val</span> dump : <a href="../../ocaml/Stdlib/Format/index.html#type-formatter">Stdlib.Format.formatter</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>dump ppf p</code> prints path <code>p</code> on <code>ppf</code> using <span class="xref-unresolved" title="unresolved reference to &quot;String.dump&quot;"><code>String</code>.dump</span>.</p></dd></dl></section><section><header><h2 id="file_exts"><a href="#file_exts" class="anchor"></a>File extensions</h2><p>The <em>file extension</em> (resp. <em>multiple file extension</em>) of a path segment is the suffix that starts at the last (resp. first) occurence of a <code>'.'</code> that is preceeded by at least one non <code>'.'</code> character. If there is no such occurence in the segment, the extension is empty. With these definitions, <code>&quot;.&quot;</code>, <code>&quot;..&quot;</code>, <code>&quot;...&quot;</code> and dot files like <code>&quot;.ocamlinit&quot;</code> or <code>&quot;..ocamlinit&quot;</code> have no extension, but <code>&quot;.emacs.d&quot;</code> and <code>&quot;..emacs.d&quot;</code> do have one.</p><p><b>Warning.</b> The following functions act on paths whose <a href="index.html#val-basename"><span>basename</span></a> is non empty and do nothing otherwise. <a href="index.html#val-normalize"><span>Normalizing</span></a> <code>p</code> before using the functions ensures that the functions do nothing iff <code>p</code> cannot be named, see <a href="index.html#val-basename"><code>basename</code></a>.</p></header><dl><dt class="spec type" id="type-ext"><a href="#type-ext" class="anchor"></a><code><span class="keyword">type</span> ext</code><code> = string</code></dt><dd><p>The type for file extensions.</p></dd></dl><dl><dt class="spec value" id="val-get_ext"><a href="#val-get_ext" class="anchor"></a><code><span class="keyword">val</span> get_ext : ?&#8288;multi:bool <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-ext">ext</a></code></dt><dd><p><code>get_ext p</code> is <code>p</code>'s <a href="index.html#val-basename"><span>basename</span></a> file extension or the empty string if there is no extension. If <code>multi</code> is <code>true</code> (defaults to <code>false</code>), returns the multiple file extension. <a href="index.html#ex_get_ext"><span>Examples</span></a>.</p></dd></dl><dl><dt class="spec value" id="val-has_ext"><a href="#val-has_ext" class="anchor"></a><code><span class="keyword">val</span> has_ext : <a href="index.html#type-ext">ext</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>has_ext e p</code> is <code>true</code> iff <code>get_ext p = e || get_ext ~multi:true p = e</code>. If <code>e</code> doesn't start with a <code>'.'</code> one is prefixed before making the test. <a href="index.html#ex_has_ext"><span>Examples</span></a>.</p></dd></dl><dl><dt class="spec value" id="val-mem_ext"><a href="#val-mem_ext" class="anchor"></a><code><span class="keyword">val</span> mem_ext : <a href="index.html#type-ext">ext</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>mem_ext exts p</code> is <code>List.mem (get_ext p) exts || List.mem (get_ext ~multi:true p) exts</code>.</p></dd></dl><dl><dt class="spec value" id="val-exists_ext"><a href="#val-exists_ext" class="anchor"></a><code><span class="keyword">val</span> exists_ext : ?&#8288;multi:bool <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>exists_ext ~multi p</code> is <code>true</code> iff <code>p</code>'s <a href="index.html#val-basename"><span>basename</span></a> file extension is not empty. If <code>multi</code> is <code>true</code> (default to <code>false</code>) returns <code>true</code> iff <code>p</code> has <em>more than one</em> extension. <a href="index.html#ex_exists_ext"><span>Examples</span></a>.</p></dd></dl><dl><dt class="spec value" id="val-add_ext"><a href="#val-add_ext" class="anchor"></a><code><span class="keyword">val</span> add_ext : <a href="index.html#type-ext">ext</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>add_ext ext p</code> is <code>p</code> with the string <code>ext</code> concatenated to <code>p</code>'s <a href="index.html#val-basename"><span>basename</span></a>, if non empty. If <code>ext</code> doesn't start with a <code>'.'</code> one is prefixed to it before concatenation except if <code>ext</code> is <code>&quot;&quot;</code>. <a href="index.html#ex_add_ext"><span>Examples</span></a>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <a href="index.html#val-is_seg"><code>is_seg</code></a><code> ext</code> is <code>false</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-rem_ext"><a href="#val-rem_ext" class="anchor"></a><code><span class="keyword">val</span> rem_ext : ?&#8288;multi:bool <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>rem_ext p</code> is <code>p</code> with the extension of <code>p</code>'s <a href="index.html#val-basename"><span>basename</span></a> removed. If <code>multi</code> is <code>true</code> (default to <code>false</code>), the multiple file extension is removed. <a href="index.html#ex_rem_ext"><span>Examples</span></a>.</p></dd></dl><dl><dt class="spec value" id="val-set_ext"><a href="#val-set_ext" class="anchor"></a><code><span class="keyword">val</span> set_ext : ?&#8288;multi:bool <span>&#45;&gt;</span> <a href="index.html#type-ext">ext</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>set_ext ?multi ext p</code> is <code>add_ext ext (rem_ext ?multi p)</code>.</p></dd></dl><dl><dt class="spec value" id="val-split_ext"><a href="#val-split_ext" class="anchor"></a><code><span class="keyword">val</span> split_ext : ?&#8288;multi:bool <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> * <a href="index.html#type-ext">ext</a></code></dt><dd><p><code>split_ext ?multi p</code> is <code>(rem_ext ?multi p, get_ext ?multi p)</code>. If this is <code>(q, ext)</code> the following invariant holds:</p><ul><li><code>equal p (add_ext q ext)</code></li></ul></dd></dl><dl><dt class="spec value" id="val-(+)"><a href="#val-(+)" class="anchor"></a><code><span class="keyword">val</span> (+) : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-ext">ext</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>p + ext</code> is <code>add_ext ext p</code>. Left associative.</p></dd></dl><dl><dt class="spec value" id="val-(-+)"><a href="#val-(-+)" class="anchor"></a><code><span class="keyword">val</span> (-+) : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-ext">ext</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>p -+ ext</code> is <code>set_ext ext p</code>. Left associative.</p></dd></dl></section><section><header><h2 id="sets_maps"><a href="#sets_maps" class="anchor"></a>Path sets and maps</h2></header><dl><dt class="spec type" id="type-path"><a href="#type-path" class="anchor"></a><code><span class="keyword">type</span> path</code><code> = <a href="index.html#type-t">t</a></code></dt><dt class="spec type" id="type-set"><a href="#type-set" class="anchor"></a><code><span class="keyword">type</span> set</code></dt><dd><p>The type for path sets. Membership is determined according to <a href="index.html#val-equal"><code>equal</code></a>.</p></dd></dl><dl><dt class="spec module" id="module-Set"><a href="#module-Set" class="anchor"></a><code><span class="keyword">module</span> <a href="Set/index.html">Set</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Path sets.</p></dd></dl><dl><dt class="spec type" id="type-map"><a href="#type-map" class="anchor"></a><code><span class="keyword">type</span> +'a map</code></dt><dd><p>The type for maps from paths to values of type <code>'a</code>. Paths are compared with <a href="index.html#val-compare"><code>compare</code></a>.</p></dd></dl><dl><dt class="spec module" id="module-Map"><a href="#module-Map" class="anchor"></a><code><span class="keyword">module</span> <a href="Map/index.html">Map</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Path maps.</p></dd></dl></section><section><header><h2 id="tips"><a href="#tips" class="anchor"></a>Tips</h2><ul><li>The documentation sometimes talks about <em>the last non-empty segment of a path</em>. This usually means that we don't care whether the path is a <a href="index.html#val-is_file_path"><span>file path</span></a> (e.g. <code>&quot;a&quot;</code>) or a <a href="index.html#val-is_dir_path"><span>directory path</span></a> (e.g. <code>&quot;a/&quot;</code>).</li><li>Windows accepts both <code>'\\'</code> and <code>'/'</code> as directory separator. However <code>Fpath</code> on Windows converts <code>'/'</code> to <code>'\\'</code> on the fly. Therefore you should either use <code>'/'</code> for defining constant paths you inject with <a href="index.html#val-v"><code>v</code></a> or better, construct them directly with <a href="index.html#val-(/)"><code>(/)</code></a>. <a href="index.html#val-to_string"><code>to_string</code></a> then converts paths to strings using the platform's specific directory separator <a href="index.html#val-dir_sep"><code>dir_sep</code></a>.</li><li>Avoid platform specific <a href="index.html#val-split_volume"><span>volumes</span></a> or hard-coding file hierarchy conventions in your constants.</li><li>Do not assume there is a single root path and that it is <code>&quot;/&quot;</code>. On Windows each <a href="index.html#val-split_volume"><span>volume</span></a> can have a root path. Use <a href="index.html#val-is_root"><code>is_root</code></a> on <a href="index.html#val-normalize"><span>normalized</span></a> paths to detect roots.</li><li>Do not use <a href="index.html#val-to_string"><code>to_string</code></a> to construct URIs, <a href="index.html#val-to_string"><code>to_string</code></a> uses <a href="index.html#val-dir_sep"><code>dir_sep</code></a> to separate segments, on Windows this is <code>'\\'</code> which is not what URIs expect. Access path segments directly with <a href="index.html#segs"><span>Separators and segments</span></a>; note that you will need to percent encode these.</li></ul></header></section><section><header><h2 id="ex"><a href="#ex" class="anchor"></a>Examples</h2></header><section><header><h3 id="ex_add_seg"><a href="#ex_add_seg" class="anchor"></a><em></em></h3><ul><li><code>equal (add_seg (v &quot;/a&quot;) &quot;b&quot;) (v &quot;/a/b&quot;)</code></li><li><code>equal (add_seg (v &quot;/a/&quot;) &quot;b&quot;) (v &quot;/a/b&quot;)</code></li><li><code>equal (add_seg (v &quot;/a/b&quot;) &quot;&quot;) (v &quot;/a/b/&quot;)</code></li><li><code>equal (add_seg (v &quot;/a/b/&quot;) &quot;&quot;) (v &quot;/a/b/&quot;)</code></li><li><code>equal (add_seg (v &quot;/&quot;) &quot;&quot;) (v &quot;/&quot;)</code></li><li><code>equal (add_seg (v &quot;/&quot;) &quot;a&quot;) (v &quot;/a&quot;)</code></li><li><code>equal (add_seg (v &quot;.&quot;) &quot;&quot;) (v &quot;./&quot;)</code></li><li><code>equal (add_seg (v &quot;.&quot;) &quot;a&quot;) (v &quot;./a&quot;)</code></li><li><code>equal (add_seg (v &quot;..&quot;) &quot;&quot;) (v &quot;../&quot;)</code></li><li><code>equal (add_seg (v &quot;..&quot;) &quot;a&quot;) (v &quot;../a&quot;)</code></li></ul></header></section><section><header><h3 id="ex_append"><a href="#ex_append" class="anchor"></a><em></em></h3><ul><li><code>equal (append (v &quot;/a/b/&quot;) (v &quot;e/f&quot;)) (v &quot;/a/b/e/f&quot;)</code></li><li><code>equal (append (v &quot;/a/b&quot;) (v &quot;e/f&quot;)) (v &quot;/a/b/e/f&quot;)</code></li><li><code>equal (append (v &quot;/a/b/&quot;) (v &quot;/e/f&quot;)) (v &quot;/e/f&quot;)</code></li><li><code>equal (append (v &quot;a/b/&quot;) (v &quot;e/f&quot;)) (v &quot;a/b/e/f&quot;)</code></li><li><code>equal (append (v &quot;a/b&quot;) (v &quot;C:e&quot;)) (v &quot;C:e&quot;)</code> (Windows)</li></ul></header></section><section><header><h3 id="ex_segs"><a href="#ex_segs" class="anchor"></a><em></em></h3><ul><li><code>segs (v &quot;/a/b/&quot;) = [&quot;&quot;; &quot;a&quot;; &quot;b&quot;; &quot;&quot;]</code></li><li><code>segs (v &quot;/a/b&quot;) = [&quot;&quot;; &quot;a&quot;; &quot;b&quot;]</code></li><li><code>segs (v &quot;a/b/&quot;) = [&quot;a&quot;; &quot;b&quot;; &quot;&quot;]</code></li><li><code>segs (v &quot;a/b&quot;) = [&quot;a&quot;; &quot;b&quot;]</code></li><li><code>segs (v &quot;a&quot;) = [&quot;a&quot;]</code></li><li><code>segs (v &quot;/&quot;) = [&quot;&quot;; &quot;&quot;]</code></li><li><code>segs (v &quot;\\\\.\\dev\\&quot;) = [&quot;&quot;;&quot;&quot;]</code> (Windows)</li><li><code>segs (v &quot;\\\\server\\share\\a&quot;) = [&quot;&quot;;&quot;a&quot;]</code> (Windows)</li><li><code>segs (v &quot;C:a&quot;) = [&quot;a&quot;]</code> (Windows)</li><li><code>segs (v &quot;C:\\a&quot;) = [&quot;&quot;;&quot;a&quot;]</code> (Windows)</li></ul></header></section><section><header><h3 id="ex_is_dir_path"><a href="#ex_is_dir_path" class="anchor"></a><em></em></h3><ul><li><code>is_dir_path (v &quot;.&quot;) = true</code></li><li><code>is_dir_path (v &quot;..&quot;) = true</code></li><li><code>is_dir_path (v &quot;../&quot;) = true</code></li><li><code>is_dir_path (v &quot;/&quot;) = true</code></li><li><code>is_dir_path (v &quot;/a/b/&quot;) = true</code></li><li><code>is_dir_path (v &quot;/a/b&quot;) = false</code></li><li><code>is_dir_path (v &quot;a/&quot;) = true</code></li><li><code>is_dir_path (v &quot;a&quot;) = false</code></li><li><code>is_dir_path (v &quot;a/.&quot;) = true</code></li><li><code>is_dir_path (v &quot;a/..&quot;) = true</code></li><li><code>is_dir_path (v &quot;a/..b&quot;) = false</code></li><li><code>is_dir_path (v &quot;C:\\&quot;) = true</code> (Windows)</li><li><code>is_dir_path (v &quot;C:a&quot;) = false</code> (Windows)</li></ul></header></section><section><header><h3 id="ex_is_file_path"><a href="#ex_is_file_path" class="anchor"></a><em></em></h3><ul><li><code>is_file_path (v &quot;.&quot;) = false</code></li><li><code>is_file_path (v &quot;..&quot;) = false</code></li><li><code>is_file_path (v &quot;../&quot;) = false</code></li><li><code>is_file_path (v &quot;/&quot;) = false</code></li><li><code>is_file_path (v &quot;/a/b/&quot;) = false</code></li><li><code>is_file_path (v &quot;/a/b&quot;) = true</code></li><li><code>is_file_path (v &quot;a/&quot;) = false</code></li><li><code>is_file_path (v &quot;a&quot;) = true</code></li><li><code>is_file_path (v &quot;a/.&quot;) = false</code></li><li><code>is_file_path (v &quot;a/..&quot;) = false</code></li><li><code>is_file_path (v &quot;a/..b&quot;) = true</code></li><li><code>is_file_path (v &quot;C:\\&quot;) = false</code> (Windows)</li><li><code>is_file_path (v &quot;C:a&quot;) = true</code> (Windows)</li></ul></header></section><section><header><h3 id="ex_to_dir_path"><a href="#ex_to_dir_path" class="anchor"></a><em></em></h3><ul><li><code>equal (to_dir_path @@ v &quot;.&quot;) (v &quot;./&quot;)</code></li><li><code>equal (to_dir_path @@ v &quot;..&quot;) (v &quot;../&quot;)</code></li><li><code>equal (to_dir_path @@ v &quot;../&quot;) (v &quot;../&quot;)</code></li><li><code>equal (to_dir_path @@ v &quot;/&quot;) (v &quot;/&quot;)</code></li><li><code>equal (to_dir_path @@ v &quot;/a/b/&quot;) (v &quot;/a/b/&quot;)</code></li><li><code>equal (to_dir_path @@ v &quot;/a/b&quot;) (v &quot;/a/b/&quot;)</code></li><li><code>equal (to_dir_path @@ v &quot;a/&quot;) (v &quot;a/&quot;)</code></li><li><code>equal (to_dir_path @@ v &quot;a&quot;) (v &quot;a/&quot;)</code></li><li><code>equal (to_dir_path @@ v &quot;a/.&quot;) (v &quot;a/./&quot;)</code></li><li><code>equal (to_dir_path @@ v &quot;a/..&quot;) (v &quot;a/../&quot;)</code></li><li><code>equal (to_dir_path @@ v &quot;a/..b&quot;) (v &quot;a/..b/&quot;)</code></li><li><code>equal (to_dir_path @@ v &quot;\\\\server\\share\\&quot;)
       (v &quot;\\\\server\\share\\&quot;)</code> (Windows)</li><li><code>equal (to_dir_path @@ v &quot;C:a&quot;) (v &quot;C:a\\&quot;)</code> (Windows)</li><li><code>equal (to_dir_path @@ v &quot;C:\\&quot;) (v &quot;C:\\&quot;)</code> (Windows)</li></ul></header></section><section><header><h3 id="ex_filename"><a href="#ex_filename" class="anchor"></a><em></em></h3><ul><li><code>filename (v &quot;.&quot;) = &quot;&quot;</code></li><li><code>filename (v &quot;./&quot;) = &quot;&quot;</code></li><li><code>filename (v &quot;..&quot;) = &quot;&quot;</code></li><li><code>filename (v &quot;../&quot;) = &quot;&quot;</code></li><li><code>filename (v &quot;../..&quot;) = &quot;&quot;</code></li><li><code>filename (v &quot;/&quot;) = &quot;&quot;</code></li><li><code>filename (v &quot;/a/b/&quot;) = &quot;&quot;</code></li><li><code>filename (v &quot;/a/b&quot;) = &quot;b&quot;</code></li><li><code>filename (v &quot;a/&quot;) = &quot;&quot;</code></li><li><code>filename (v &quot;a&quot;) = &quot;a&quot;</code></li><li><code>filename (v &quot;a/.&quot;) = &quot;&quot;</code></li><li><code>filename (v &quot;a/..&quot;) = &quot;&quot;</code></li><li><code>filename (v &quot;a/..b&quot;) = &quot;..b&quot;</code></li><li><code>filename (v &quot;C:\\&quot;) = &quot;&quot;</code> (Windows)</li><li><code>filename (v &quot;C:a&quot;) = &quot;a&quot;</code> (Windows)</li></ul></header></section><section><header><h3 id="ex_split_base"><a href="#ex_split_base" class="anchor"></a><em></em></h3><ul><li><code>(split_base @@ v &quot;.&quot;) = (v &quot;./&quot;), (v &quot;.&quot;)</code></li><li><code>(split_base @@ v &quot;./&quot;) = (v &quot;./&quot;), (v &quot;./&quot;)</code></li><li><code>(split_base @@ v &quot;..&quot;) = (v &quot;./&quot;), (v &quot;..&quot;)</code></li><li><code>(split_base @@ v &quot;../&quot;) = (v &quot;./&quot;), (v &quot;../&quot;)</code></li><li><code>(split_base @@ v &quot;../../&quot;) = (v &quot;../&quot;), (v &quot;../&quot;)</code></li><li><code>(split_base @@ v &quot;.././&quot;) = (v &quot;../&quot;), (v &quot;./&quot;)</code></li><li><code>(split_base @@ v &quot;../../../&quot;) = (v &quot;../../&quot;), (v &quot;../&quot;)</code></li><li><code>(split_base @@ v &quot;/&quot;) = (v &quot;/&quot;), (v &quot;./&quot;)</code></li><li><code>(split_base @@ v &quot;/a/b/&quot;) = (v &quot;/a/&quot;), (v &quot;b/&quot;)</code></li><li><code>(split_base @@ v &quot;/a/b&quot;) = (v &quot;/a/&quot;), (v &quot;b&quot;)</code></li><li><code>(split_base @@ v &quot;a/&quot;) = (v &quot;./&quot;), (v &quot;a/&quot;)</code></li><li><code>(split_base @@ v &quot;a&quot;) = (v &quot;./&quot;), (v &quot;a&quot;)</code></li><li><code>(split_base @@ v &quot;a/b&quot;) = (v &quot;a/&quot;), (v &quot;b&quot;)</code></li><li><code>(split_base @@ v &quot;a/b/&quot;) = (v &quot;a/b/&quot;), (v &quot;b/&quot;)</code></li><li><code>(split_base @@ v &quot;a/.&quot;) = (v &quot;a/&quot;), (v &quot;.&quot;)</code></li><li><code>(split_base @@ v &quot;a/..&quot;) = (v &quot;a/&quot;), (v &quot;..&quot;)</code></li><li><code>(split_base @@ v &quot;a/../..&quot;) = (v &quot;a/../&quot;), (v &quot;..&quot;)</code></li><li><code>(split_base @@ v &quot;a/..b&quot;) = (v &quot;a/&quot;), (v &quot;..b&quot;)</code></li><li><code>(split_base @@ v &quot;./a&quot;) = (v &quot;./&quot;), (v &quot;a&quot;)</code></li><li><code>(split_base @@ v &quot;./a/&quot;) = (v &quot;./&quot;), (v &quot;a/&quot;)</code></li><li><code>(split_base @@ v &quot;../a&quot;) = (v &quot;../&quot;), (v &quot;a&quot;)</code></li><li><code>(split_base @@ v &quot;../a/&quot;) = (v &quot;../&quot;), (v &quot;a/&quot;)</code></li></ul></header></section><section><header><h3 id="ex_basename"><a href="#ex_basename" class="anchor"></a><em></em></h3><ul><li><code>basename (v &quot;.&quot;) = &quot;&quot;</code></li><li><code>basename (v &quot;..&quot;) = &quot;&quot;</code></li><li><code>basename (v &quot;../&quot;) = &quot;&quot;</code></li><li><code>basename (v &quot;../../&quot;) = &quot;&quot;</code></li><li><code>basename (v &quot;/&quot;) = &quot;&quot;</code></li><li><code>basename (v &quot;/a/b/&quot;) = &quot;b&quot;</code></li><li><code>basename (v &quot;/a/b&quot;) = &quot;b&quot;</code></li><li><code>basename (v &quot;a/&quot;) = &quot;a&quot;</code></li><li><code>basename (v &quot;a&quot;) = &quot;a&quot;</code></li><li><code>basename (v &quot;a/.&quot;) = &quot;&quot;</code></li><li><code>basename (v &quot;a/./&quot;) = &quot;&quot;</code></li><li><code>basename (v &quot;a/..&quot;) = &quot;&quot;</code></li><li><code>basename (v &quot;a/..b&quot;) = &quot;..b&quot;</code></li><li><code>basename (v &quot;./a&quot;) = &quot;a&quot;</code></li><li><code>basename (v &quot;../a&quot;) = &quot;a&quot;</code></li><li><code>basename (v &quot;C:\\&quot;) = &quot;&quot;</code> (Windows)</li><li><code>basename (v &quot;C:a&quot;) = &quot;a&quot;</code> (Windows)</li></ul></header></section><section><header><h3 id="ex_parent"><a href="#ex_parent" class="anchor"></a><em></em></h3><ul><li><code>equal (parent @@ v &quot;.&quot;) (v &quot;./../&quot;)</code></li><li><code>equal (parent @@ v &quot;..&quot;) (v &quot;../../&quot;)</code></li><li><code>equal (parent @@ v &quot;../&quot;) (v &quot;../../&quot;)</code></li><li><code>equal (parent @@ v &quot;../../&quot;) (v &quot;../../../&quot;)</code></li><li><code>equal (parent @@ v &quot;/&quot;) (v &quot;/&quot;)</code></li><li><code>equal (parent @@ v &quot;/a/b/&quot;) (v &quot;/a/&quot;)</code></li><li><code>equal (parent @@ v &quot;/a/b&quot;) (v &quot;/a/&quot;)</code></li><li><code>equal (parent @@ v &quot;a/&quot;) (v &quot;./&quot;)</code></li><li><code>equal (parent @@ v &quot;a&quot;) (v &quot;./&quot;)</code></li><li><code>equal (parent @@ v &quot;a/.&quot;) (v &quot;a/./../&quot;)</code></li><li><code>equal (parent @@ v &quot;a/./&quot;) (v &quot;a/./../&quot;)</code></li><li><code>equal (parent @@ v &quot;a/..&quot;) (v &quot;a/../../&quot;)</code></li><li><code>equal (parent @@ v &quot;a/../&quot;) (v &quot;a/../../&quot;)</code></li><li><code>equal (parent @@ v &quot;a/..b&quot;) (v &quot;a/&quot;)</code></li><li><code>equal (parent @@ v &quot;./a&quot;) (v &quot;./&quot;)</code></li><li><code>equal (parent @@ v &quot;../a&quot;) (v &quot;../&quot;)</code></li><li><code>equal (parent @@ v &quot;../../a&quot;) (v &quot;../../&quot;)</code></li><li><code>equal (parent @@ v &quot;\\\\server\\share\\&quot;) (v &quot;\\\\server\\share\\&quot;)</code> (Windows)</li><li><code>equal (parent @@ v &quot;C:\\&quot;) (v &quot;C:\\&quot;)</code> (Windows)</li><li><code>equal (parent @@ v &quot;C:a&quot;) (v &quot;C:.\\&quot;)</code> (Windows)</li></ul></header></section><section><header><h3 id="ex_rem_empty_seg"><a href="#ex_rem_empty_seg" class="anchor"></a><em></em></h3><ul><li><code>equal (rem_empty_seg @@ v &quot;.&quot;) (v &quot;.&quot;)</code></li><li><code>equal (rem_empty_seg @@ v &quot;..&quot;) (v &quot;..&quot;)</code></li><li><code>equal (rem_empty_seg @@ v &quot;../&quot;) (v &quot;..&quot;)</code></li><li><code>equal (rem_empty_seg @@ v &quot;../../&quot;) (v &quot;../..&quot;)</code></li><li><code>equal (rem_empty_seg @@ v &quot;/&quot;) (v &quot;/&quot;)</code></li><li><code>equal (rem_empty_seg @@ v &quot;/a/b/&quot;) (v &quot;/a/b&quot;)</code></li><li><code>equal (rem_empty_seg @@ v &quot;/a/b&quot;) (v &quot;/a/b&quot;)</code></li><li><code>equal (rem_empty_seg @@ v &quot;a/&quot;) (v &quot;a&quot;)</code></li><li><code>equal (rem_empty_seg @@ v &quot;a&quot;) (v &quot;a&quot;)</code></li><li><code>equal (rem_empty_seg @@ v &quot;a/.&quot;) (v &quot;a/.&quot;)</code></li><li><code>equal (rem_empty_seg @@ v &quot;a/./&quot;) (v &quot;a/.&quot;)</code></li><li><code>equal (rem_empty_seg @@ v &quot;a/..&quot;) (v &quot;a/..&quot;)</code></li><li><code>equal (rem_empty_seg @@ v &quot;a/../&quot;) (v &quot;a/..&quot;)</code></li><li><code>equal (rem_empty_seg @@ v &quot;a/..b&quot;) (v &quot;a/..b&quot;)</code></li><li><code>equal (rem_empty_seg @@ v &quot;./a&quot;) (v &quot;./a&quot;)</code></li><li><code>equal (rem_empty_seg @@ v &quot;../a&quot;) (v &quot;../a&quot;)</code></li><li><code>equal (rem_empty_seg @@ v &quot;../../a&quot;) (v &quot;../../a&quot;)</code></li><li><code>equal (rem_empty_seg @@ v &quot;\\\\server\\share\\&quot;)
    (v &quot;\\\\server\\share\\&quot;)</code> (Windows)</li><li><code>equal (rem_empty_seg @@ v &quot;C:\\&quot;) (v &quot;C:\\&quot;)</code> (Windows)</li><li><code>equal (rem_empty_seg @@ v &quot;C:a\\&quot;) (v &quot;C:a&quot;)</code> (Windows)</li></ul></header></section><section><header><h3 id="ex_normalize"><a href="#ex_normalize" class="anchor"></a><em></em></h3><ul><li><code>equal (normalize @@ v &quot;.&quot;) (v &quot;./&quot;)</code></li><li><code>equal (normalize @@ v &quot;..&quot;) (v &quot;../&quot;)</code></li><li><code>equal (normalize @@ v &quot;../&quot;) (v &quot;../&quot;)</code></li><li><code>equal (normalize @@ v &quot;../../&quot;) (v &quot;../../&quot;)</code></li><li><code>equal (normalize @@ v &quot;/&quot;) (v &quot;/&quot;)</code></li><li><code>equal (normalize @@ v &quot;/a/b/&quot;) (v &quot;/a/b/&quot;)</code></li><li><code>equal (normalize @@ v &quot;/a/b&quot;) (v &quot;/a/b&quot;)</code></li><li><code>equal (normalize @@ v &quot;a/&quot;) (v &quot;a/&quot;)</code></li><li><code>equal (normalize @@ v &quot;a&quot;) (v &quot;a&quot;)</code></li><li><code>equal (normalize @@ v &quot;a/.&quot;) (v &quot;a/&quot;)</code></li><li><code>equal (normalize @@ v &quot;a/./&quot;) (v &quot;a/&quot;)</code></li><li><code>equal (normalize @@ v &quot;a/..&quot;) (v &quot;./&quot;)</code></li><li><code>equal (normalize @@ v &quot;a/../&quot;) (v &quot;./&quot;)</code></li><li><code>equal (normalize @@ v &quot;a/..b&quot;) (v &quot;a/..b&quot;)</code></li><li><code>equal (normalize @@ v &quot;./a&quot;) (v &quot;a&quot;)</code></li><li><code>equal (normalize @@ v &quot;../a&quot;) (v &quot;../a&quot;)</code></li><li><code>equal (normalize @@ v &quot;../../a&quot;) (v &quot;../../a&quot;)</code></li><li><code>equal (normalize @@ v &quot;./a/..&quot;) (v &quot;./&quot;)</code></li><li><code>equal (normalize @@ v &quot;/a/b/./..&quot;) (v &quot;/a/&quot;)</code></li><li><code>equal (normalize @@ v &quot;/../..&quot;) (v &quot;/&quot;)</code></li><li><code>equal (normalize @@ v &quot;/a/../..&quot;) (v &quot;/&quot;)</code></li><li><code>equal (normalize @@ v &quot;./../..&quot;) (v &quot;../../&quot;)</code></li><li><code>equal (normalize @@ v &quot;../../a/&quot;) (v &quot;../../a/&quot;)</code></li><li><code>equal (normalize @@ v &quot;/a/b/c/./../../g&quot;) (v &quot;/a/g&quot;)</code></li><li><code>equal (normalize @@ v &quot;/a/b/c/./../../g/&quot;) (v &quot;/a/g/&quot;)</code></li><li><code>equal (normalize @@ v &quot;\\\\?\\UNC\\server\\share\\..&quot;)
       (v &quot;\\\\?\\UNC\\server\\share\\&quot;)</code> (Windows)</li><li><code>equal (normalize @@ v &quot;\\\\server\\share\\&quot;)
    (v &quot;\\\\server\\share\\&quot;)</code> (Windows)</li><li><code>equal (normalize @@ v &quot;C:\\&quot;) (v &quot;C:\\&quot;)</code> (Windows)</li><li><code>equal (normalize @@ v &quot;C:a\\&quot;) (v &quot;C:a\\&quot;)</code> (Windows)</li></ul></header></section><section><header><h3 id="ex_is_prefix"><a href="#ex_is_prefix" class="anchor"></a><em></em></h3><ul><li><code>is_prefix (v &quot;/a/b&quot;) (v &quot;/a/b&quot;) = true</code></li><li><code>is_prefix (v &quot;/a/b&quot;) (v &quot;/a/bc&quot;) = false</code></li><li><code>is_prefix (v &quot;/a/b&quot;) (v &quot;/a/b/&quot;) = true</code></li><li><code>is_prefix (v &quot;a/b/&quot;) (v &quot;a/b&quot;) = false</code></li><li><code>is_prefix (v &quot;a/b/&quot;) (v &quot;a/b/&quot;) = true</code></li><li><code>is_prefix (v &quot;a/b/&quot;) (v &quot;a/b/c&quot;) = true</code></li><li><code>is_prefix (v &quot;.&quot;) (v &quot;./&quot;) = true</code></li><li><code>is_prefix (v &quot;..&quot;) (v &quot;.&quot;) = false</code></li><li><code>is_prefix (v &quot;C:a&quot;) (v &quot;a&quot;) = false</code> (Windows)</li></ul></header></section><section><header><h3 id="ex_find_prefix"><a href="#ex_find_prefix" class="anchor"></a><em></em></h3><ul><li><code>find_prefix (v &quot;a/b/c&quot;) (v &quot;a/b/d&quot;)</code> is <code>Some (v &quot;a/b/&quot;)</code></li><li><code>find_prefix (v &quot;a/b/c&quot;) (v &quot;a/b/cd&quot;)</code> is <code>Some (v &quot;a/b/&quot;)</code></li><li><code>find_prefix (v &quot;a/b&quot;) (v &quot;a/b&quot;)</code> is <code>Some (v &quot;a/b&quot;)</code></li><li><code>find_prefix (v &quot;a/b&quot;) (v &quot;a/b/&quot;)</code> is <code>Some (v &quot;a/b&quot;)</code></li><li><code>find_prefix (v &quot;a/b&quot;) (v &quot;e/f&quot;)</code> is <code>None</code></li><li><code>find_prefix (v &quot;/a/b&quot;) (v &quot;/e/f&quot;)</code> is <code>Some (v &quot;/&quot;)</code></li><li><code>find_prefix (v &quot;/a/b&quot;) (v &quot;e/f&quot;)</code> is <code>None</code></li><li><code>find_prefix (v &quot;C:\\a&quot;) (v &quot;\\a&quot;)</code> is <code>None</code> (Windows)</li></ul></header></section><section><header><h3 id="ex_rem_prefix"><a href="#ex_rem_prefix" class="anchor"></a><em></em></h3><ul><li><code>rem_prefix (v &quot;a/b/&quot;) (v &quot;a/b&quot;)</code> is <code>None</code></li><li><code>rem_prefix (v &quot;a/b/&quot;) (v &quot;a/b/&quot;)</code> is <code>None</code></li><li><code>rem_prefix (v &quot;a/b&quot;) (v &quot;a/b&quot;)</code> is <code>None</code></li><li><code>rem_prefix (v &quot;a/b&quot;) (v &quot;a/b/&quot;)</code> is <code>Some &quot;./&quot;</code></li><li><code>rem_prefix (v &quot;a/b&quot;) (v &quot;a/b/c&quot;)</code> is <code>Some (v &quot;c&quot;)</code></li><li><code>rem_prefix (v &quot;a/b/&quot;) (v &quot;a/b/c&quot;)</code> is <code>Some (v &quot;c&quot;)</code></li><li><code>rem_prefix (v &quot;a/b&quot;) (v &quot;a/b/c/&quot;)</code> is <code>Some (v &quot;c/&quot;)</code></li><li><code>rem_prefix (v &quot;a/b/&quot;) (v &quot;a/b/c/&quot;)</code> is <code>Some (v &quot;c/&quot;)</code></li><li><code>rem_prefix (v &quot;C:\\a&quot;) (v &quot;C:\\a\\b&quot;)</code> is <code>Some (v &quot;b&quot;)</code> (Windows)</li></ul></header></section><section><header><h3 id="ex_relativize"><a href="#ex_relativize" class="anchor"></a><em></em></h3><ul><li><code>relativize ~root:(v &quot;/a/b&quot;) (v &quot;c&quot;)</code> is <code>None</code></li><li><code>relativize ~root:(v &quot;/a/b&quot;) (v &quot;/c&quot;)</code> is <code>Some (v &quot;../../c&quot;)</code></li><li><code>relativize ~root:(v &quot;/a/b&quot;) (v &quot;/c/&quot;)</code> is <code>Some (v &quot;../../c/&quot;)</code></li><li><code>relativize ~root:(v &quot;/a/b&quot;) (v &quot;/c&quot;)</code> is <code>Some (v &quot;../../c&quot;)</code></li><li><code>relativize ~root:(v &quot;/a/b&quot;) (v &quot;/c/&quot;)</code> is <code>Some (v &quot;../../c/&quot;)</code></li><li><code>relativize ~root:(v &quot;/a/b&quot;) (v &quot;/a/b/c&quot;)</code> is <code>Some (v &quot;c&quot;)</code></li><li><code>relativize ~root:(v &quot;/a/b&quot;) (v &quot;/a/b/c/&quot;)</code> is <code>Some (v &quot;c/&quot;)</code></li><li><code>relativize ~root:(v &quot;/a/b&quot;) (v &quot;/a/b&quot;)</code> is <code>None</code></li><li><code>relativize ~root:(v &quot;/a/b&quot;) (v &quot;/a/b/&quot;)</code> is <code>Some (v &quot;.&quot;)</code></li><li><code>relativize ~root:(v &quot;a/b&quot;) (v &quot;/c&quot;)</code> is <code>None</code>.</li><li><code>relativize ~root:(v &quot;a/b&quot;) (v &quot;c&quot;)</code> is <code>Some (v &quot;../../c&quot;)</code></li><li><code>relativize ~root:(v &quot;a/b&quot;) (v &quot;c/&quot;)</code> is <code>Some (v &quot;../../c/&quot;)</code></li><li><code>relativize ~root:(v &quot;a/b&quot;) (v &quot;a/b/c&quot;)</code> is <code>Some (v &quot;c&quot;)</code></li><li><code>relativize ~root:(v &quot;a/b&quot;) (v &quot;a/b&quot;)</code> is <code>Some (v &quot;.&quot;)</code></li><li><code>relativize ~root:(v &quot;a/b&quot;) (v &quot;a/b/&quot;)</code> is <code>Some (v &quot;.&quot;)</code></li><li><code>relativize ~root:(v &quot;../&quot;) (v &quot;./&quot;)</code> is <code>None</code></li><li><code>relativize ~root:(v &quot;../a&quot;) (v &quot;b&quot;)</code> is <code>None</code></li><li><code>relativize ~root:(v &quot;../a&quot;) (v &quot;../b/c&quot;)</code> is <code>Some (v &quot;../b/c&quot;)</code></li><li><code>relativize ~root:(v &quot;../../a&quot;) (v &quot;../b&quot;)</code> is <code>None</code></li><li><code>relativize ~root:(v &quot;../a&quot;) (v &quot;../../b&quot;)</code> is <code>(Some &quot;../../b&quot;)</code></li></ul></header></section><section><header><h3 id="ex_is_rooted"><a href="#ex_is_rooted" class="anchor"></a><em></em></h3><ul><li><code>is_rooted ~root:(v &quot;a/b&quot;) (v &quot;a/b&quot;) = false</code></li><li><code>is_rooted ~root:(v &quot;a/b&quot;) (v &quot;a/b/&quot;) = true</code></li><li><code>is_rooted ~root:(v &quot;a/b/&quot;) (v &quot;a/b&quot;) = false</code></li><li><code>is_rooted ~root:(v &quot;a/b/&quot;) (v &quot;a/b/&quot;) = true</code></li><li><code>is_rooted ~root:(v &quot;./&quot;) (v &quot;a&quot;) = true</code></li><li><code>is_rooted ~root:(v &quot;./&quot;) (v &quot;a/&quot;) = true</code></li><li><code>is_rooted ~root:(v &quot;./&quot;) (v &quot;a/../&quot;) = true</code></li><li><code>is_rooted ~root:(v &quot;./&quot;) (v &quot;..&quot;) = false</code></li><li><code>is_rooted ~root:(v &quot;../&quot;) (v &quot;./&quot;) = false</code></li><li><code>is_rooted ~root:(v &quot;../&quot;) (v &quot;a&quot;) = false</code></li><li><code>is_rooted ~root:(v &quot;../&quot;) (v &quot;../&quot;) = true</code></li><li><code>is_rooted ~root:(v &quot;../&quot;) (v &quot;../a&quot;) = true</code></li><li><code>is_rooted ~root:(v &quot;../a&quot;) (v &quot;./&quot;) = false</code></li><li><code>is_rooted ~root:(v &quot;/a&quot;) (v &quot;/a/..&quot;) = true</code></li><li><code>is_rooted ~root:(v &quot;/a&quot;) (v &quot;/a/../&quot;) = true</code></li><li><code>is_rooted ~root:(v &quot;/a&quot;) (v &quot;/..&quot;) = true</code></li></ul></header></section><section><header><h3 id="ex_is_root"><a href="#ex_is_root" class="anchor"></a><em></em></h3><ul><li><code>is_root (v &quot;/&quot;) = true</code></li><li><code>is_root (v &quot;/a&quot;) = false</code></li><li><code>is_root (v &quot;/a/..&quot;) = false</code></li><li><code>is_root (v &quot;//&quot;) = true</code> (POSIX)</li><li><code>is_root (v &quot;\\\\.\\dev\\&quot;) = true</code> (Windows)</li><li><code>is_root (v &quot;\\\\.\\dev\\a&quot;) = false</code> (Windows)</li><li><code>is_root (v &quot;\\\\server\\share\\&quot;) = true</code> (Windows)</li><li><code>is_root (v &quot;\\\\server\\share\\a&quot;) = false</code> (Windows)</li><li><code>is_root (v &quot;C:\\&quot;) = true</code> (Windows)</li><li><code>is_root (v &quot;C:a&quot;) = false</code> (Windows)</li><li><code>is_root (v &quot;C:\\a&quot;) = false</code> (Windows)</li></ul></header></section><section><header><h3 id="ex_get_ext"><a href="#ex_get_ext" class="anchor"></a><em></em></h3><ul><li><code>get_ext (v &quot;/&quot;) = &quot;&quot;</code></li><li><code>get_ext (v &quot;a/b&quot;) = &quot;&quot;</code></li><li><code>get_ext (v &quot;a/b.mli/..&quot;) = &quot;&quot;</code></li><li><code>get_ext (v &quot;a/b.mli/...&quot;) = &quot;&quot;</code></li><li><code>get_ext (v &quot;a/b.&quot;) = &quot;.&quot;</code></li><li><code>get_ext (v &quot;a/b.mli&quot;) = &quot;.mli&quot;</code></li><li><code>get_ext ~multi:true (v &quot;a/b.mli&quot;) = &quot;.mli&quot;</code></li><li><code>get_ext (v &quot;a/b.mli/&quot;) = &quot;.mli&quot;</code></li><li><code>get_ext (v &quot;a/.ocamlinit&quot;) = &quot;&quot;</code></li><li><code>get_ext (v &quot;a/.emacs.d&quot;) = &quot;.d&quot;</code></li><li><code>get_ext (v &quot;a/.emacs.d/&quot;) = &quot;.d&quot;</code></li><li><code>get_ext ~multi:true (v &quot;a/.emacs.d&quot;) = &quot;.d&quot;</code></li><li><code>get_ext (v &quot;a.tar.gz&quot;) = &quot;.gz&quot;</code></li><li><code>get_ext ~multi:true  (v &quot;a.tar.gz&quot;) = &quot;.tar.gz&quot;</code></li></ul></header></section><section><header><h3 id="ex_has_ext"><a href="#ex_has_ext" class="anchor"></a><em></em></h3><ul><li><code>has_ext &quot;mli&quot; (v &quot;a/b.mli&quot;) = true</code></li><li><code>has_ext &quot;.mli&quot; (v &quot;a/b.mli&quot;) = true</code></li><li><code>has_ext &quot;.mli&quot; (v &quot;a/b.mli/&quot;) = true</code></li><li><code>has_ext &quot;.mli&quot; (v &quot;a/bmli&quot;) = false</code></li><li><code>has_ext &quot;mli&quot; (v &quot;a/bmli&quot;) = false</code></li><li><code>has_ext &quot;.tar.gz&quot; (v &quot;a/f.tar.gz&quot;) = true</code></li><li><code>has_ext &quot;tar.gz&quot; (v &quot;a/f.tar.gz&quot;) = true</code></li><li><code>has_ext &quot;.gz&quot; (v &quot;a/f.tar.gz&quot;) = true</code></li><li><code>has_ext &quot;.tar&quot; (v &quot;a/f.tar.gz&quot;) = false</code></li><li><code>has_ext &quot;.cache&quot; (v &quot;a/.cache&quot;) = false</code></li><li><code>has_ext &quot;&quot; (v &quot;a/b&quot;) = false</code></li><li><code>has_ext &quot;&quot; (v &quot;a/b.&quot;) = true</code></li><li><code>has_ext &quot;.&quot; (v &quot;a/b.&quot;) = true</code></li></ul></header></section><section><header><h3 id="ex_exists_ext"><a href="#ex_exists_ext" class="anchor"></a><em></em></h3><ul><li><code>exists_ext (v &quot;a/f&quot;) = false</code></li><li><code>exists_ext (v &quot;a/f.&quot;) = true</code></li><li><code>exists_ext (v &quot;a/f.gz&quot;) = true</code></li><li><code>exists_ext ~multi:true (v &quot;a/f.gz&quot;) = false</code></li><li><code>exists_ext (v &quot;a/f.tar.gz&quot;) = true</code></li><li><code>exists_ext ~multi:true (v &quot;a/f.tar.gz&quot;) = true</code></li><li><code>exists_ext (v &quot;a/f.tar.gz/&quot;) = true</code></li><li><code>exists_ext (v &quot;.emacs.d&quot;) = true</code></li><li><code>exists_ext (v &quot;.emacs.d/&quot;) = true</code></li><li><code>exists_ext (v &quot;.ocamlinit&quot;) = false</code></li></ul></header></section><section><header><h3 id="ex_add_ext"><a href="#ex_add_ext" class="anchor"></a><em></em></h3><ul><li><code>equal (add_ext &quot;mli&quot; (v &quot;a/b&quot;)) (v &quot;a/b.mli&quot;)</code></li><li><code>equal (add_ext &quot;.mli&quot; (v &quot;a/b&quot;)) (v &quot;a/b.mli&quot;)</code></li><li><code>equal (add_ext &quot;.mli&quot; (v &quot;a/b/&quot;)) (v &quot;a/b.mli/&quot;)</code></li><li><code>equal (add_ext &quot;.mli&quot; (v &quot;/&quot;)) (v &quot;/&quot;)</code></li><li><code>equal (add_ext &quot;.mli&quot; (v &quot;a/b/..&quot;)) (v &quot;a/b/..&quot;)</code></li><li><code>equal (add_ext &quot;.&quot; (v &quot;a/b&quot;)) (v &quot;a/b.&quot;)</code></li><li><code>equal (add_ext &quot;&quot; (v &quot;a/b&quot;)) (v &quot;a/b&quot;)</code></li><li><code>equal (add_ext &quot;tar.gz&quot; (v &quot;a/f&quot;)) (v &quot;a/f.tar.gz&quot;)</code></li><li><code>equal (add_ext &quot;.tar.gz&quot; (v &quot;a/f&quot;)) (v &quot;a/f.tar.gz&quot;)</code></li><li><code>equal (add_ext &quot;gz&quot; (v &quot;a/f.tar&quot;) ) (v &quot;a/f.tar.gz&quot;)</code></li><li><code>equal (add_ext &quot;.gz&quot; (v &quot;a/f.tar&quot;) ) (v &quot;a/f.tar.gz&quot;)</code></li></ul></header></section><section><header><h3 id="ex_rem_ext"><a href="#ex_rem_ext" class="anchor"></a><em></em></h3><ul><li><code>equal (rem_ext @@ v &quot;/&quot;) (v &quot;/&quot;)</code></li><li><code>equal (rem_ext @@ v &quot;/a/b&quot;) (v &quot;/a/b&quot;)</code></li><li><code>equal (rem_ext @@ v &quot;/a/b.mli&quot;) (v &quot;/a/b&quot;)</code></li><li><code>equal (rem_ext @@ v &quot;/a/b.mli/&quot;) (v &quot;/a/b/&quot;)</code></li><li><code>equal (rem_ext @@ v &quot;/a/b.mli/..&quot;) (v &quot;/a/b.mli/..&quot;)</code></li><li><code>equal (rem_ext @@ v &quot;/a/b.mli/.&quot;) (v &quot;/a/b.mli/.&quot;)</code></li><li><code>equal (rem_ext @@ v &quot;a/.ocamlinit&quot;) (v &quot;a/.ocamlinit&quot;)</code></li><li><code>equal (rem_ext @@ v &quot;a/.emacs.d&quot;) (v &quot;a/.emacs&quot;)</code></li><li><code>equal (rem_ext @@ v &quot;a/.emacs.d/&quot;) (v &quot;a/.emacs/&quot;)</code></li><li><code>equal (rem_ext @@ v &quot;f.tar.gz&quot;) (v &quot;f.tar&quot;)</code></li><li><code>equal (rem_ext ~multi:true @@ v &quot;f.tar.gz&quot;) (v &quot;f&quot;)</code></li><li><code>equal (rem_ext ~multi:true @@ v &quot;f.tar.gz/&quot;) (v &quot;f/&quot;)</code></li></ul></header></section></section></div></body></html>