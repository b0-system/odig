<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>String (astring.Astring.String)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">astring</a> &#x00BB; <a href="../index.html">Astring</a> &#x00BB; String</nav><h1>Module <code>Astring.String</code></h1><p>Strings, <a href="Sub/index.html"><span>substrings</span></a>, string <a href="Set/index.html"><span>sets</span></a> and <a href="Map/index.html"><span>maps</span></a>.</p><p>A string <code>s</code> of length <code>l</code> is a zero-based indexed sequence of <code>l</code> bytes. An index <code>i</code> of <code>s</code> is an integer in the range [<code>0</code>;<code>l-1</code>], it represents the <code>i</code>th byte of <code>s</code> which can be accessed using the string indexing operator <code>s.[i]</code>.</p><p><b>Important.</b> OCaml's <code>string</code>s became immutable since 4.02. Whenever possible compile your code with the <code>-safe-string</code> option. This module does not expose any mutable operation on strings and <b>assumes</b> strings are immutable. See the <a href="../index.html#port"><span>porting guide</span></a>.</p><p><em>v0.8.3 - <a href="http://erratique.ch/software/astring">homepage</a></em></p><nav class="toc"><ul><li><a href="#string">String</a></li><li><a href="#append">Appending strings</a></li><li><a href="#predicates">Predicates</a></li><li><a href="#extract">Extracting substrings</a></li><li><a href="#subs">Substrings</a></li><li><a href="#traverse">Traversing strings</a></li><li><a href="#unique">Uniqueness</a></li><li><a href="#ascii">Strings as US-ASCII character sequences</a></li><li><a href="#pp">Pretty printing</a></li><li><a href="#string-sets-and-maps">String sets and maps</a></li><li><a href="#convert">OCaml base type conversions</a></li></ul></nav></header><section><header><h2 id="string"><a href="#string" class="anchor"></a>String</h2></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code><code> = string</code></dt><dd><p>The type for strings. Finite sequences of immutable bytes.</p></dd></dl><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val</span> empty : string</code></dt><dd><p><code>empty</code> is an empty string.</p></dd></dl><dl><dt class="spec value" id="val-v"><a href="#val-v" class="anchor"></a><code><span class="keyword">val</span> v : len:int <span>&#45;&gt;</span> (int <span>&#45;&gt;</span> char) <span>&#45;&gt;</span> string</code></dt><dd><p><code>v len f</code> is a string <code>s</code> of length <code>len</code> with <code>s.[i] = f
      i</code> for all indices <code>i</code> of <code>s</code>. <code>f</code> is invoked in increasing index order.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>len</code> is not in the range [<code>0</code>; <span class="xref-unresolved" title="unresolved reference to &quot;Sys.max_string_length&quot;"><code>Sys</code>.max_string_length</span>].</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-length"><a href="#val-length" class="anchor"></a><code><span class="keyword">val</span> length : string <span>&#45;&gt;</span> int</code></dt><dd><p><code>length s</code> is the number of bytes in <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-get"><a href="#val-get" class="anchor"></a><code><span class="keyword">val</span> get : string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> char</code></dt><dd><p><code>get s i</code> is the byte of <code>s</code>' at index <code>i</code>. This is equivalent to the <code>s.[i]</code> notation.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>i</code> is not an index of <code>s</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-get_byte"><a href="#val-get_byte" class="anchor"></a><code><span class="keyword">val</span> get_byte : string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dd><p><code>get_byte s i</code> is <code>Char.to_int (get s i)</code></p></dd></dl><dl><dt class="spec value" id="val-head"><a href="#val-head" class="anchor"></a><code><span class="keyword">val</span> head : ?&#8288;rev:bool <span>&#45;&gt;</span> string <span>&#45;&gt;</span> char option</code></dt><dd><p><code>head s</code> is <code>Some (get s h)</code> with <code>h = 0</code> if <code>rev = false</code> (default) or <code>h = length s - 1</code> if <code>rev = true</code>. <code>None</code> is returned if <code>s</code> is empty.</p></dd></dl><dl><dt class="spec value" id="val-get_head"><a href="#val-get_head" class="anchor"></a><code><span class="keyword">val</span> get_head : ?&#8288;rev:bool <span>&#45;&gt;</span> string <span>&#45;&gt;</span> char</code></dt><dd><p><code>get_head s</code> is like <a href="index.html#val-head"><code>head</code></a> but </p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>s</code> is empty.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-hash"><a href="#val-hash" class="anchor"></a><code><span class="keyword">val</span> hash : string <span>&#45;&gt;</span> int</code></dt><dd><p><code>hash s</code> is <span class="xref-unresolved" title="unresolved reference to &quot;Hashtbl.hash&quot;"><code>Hashtbl</code>.hash</span><code> s</code>.</p></dd></dl></section><section><header><h2 id="append"><a href="#append" class="anchor"></a>Appending strings</h2></header><dl><dt class="spec value" id="val-append"><a href="#val-append" class="anchor"></a><code><span class="keyword">val</span> append : string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt><dd><p><code>append s s'</code> appends <code>s'</code> to <code>s</code>. This is equivalent to <code>s ^ s'</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if the result is longer than <span class="xref-unresolved" title="unresolved reference to &quot;Sys.max_string_length&quot;"><code>Sys</code>.max_string_length</span>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-concat"><a href="#val-concat" class="anchor"></a><code><span class="keyword">val</span> concat : ?&#8288;sep:string <span>&#45;&gt;</span> string list <span>&#45;&gt;</span> string</code></dt><dd><p><code>concat ~sep ss</code> concatenates the list of strings <code>ss</code>, separating each consecutive elements in the list <code>ss</code> with <code>sep</code> (defaults to <a href="index.html#val-empty"><code>empty</code></a>).</p><dl><dt>raises Invalid_argument</dt><dd><p>if the result is longer than <span class="xref-unresolved" title="unresolved reference to &quot;Sys.max_string_length&quot;"><code>Sys</code>.max_string_length</span>.</p></dd></dl></dd></dl></section><section><header><h2 id="predicates"><a href="#predicates" class="anchor"></a>Predicates</h2></header><dl><dt class="spec value" id="val-is_empty"><a href="#val-is_empty" class="anchor"></a><code><span class="keyword">val</span> is_empty : string <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_empty s</code> is <code>length s = 0</code>.</p></dd></dl><dl><dt class="spec value" id="val-is_prefix"><a href="#val-is_prefix" class="anchor"></a><code><span class="keyword">val</span> is_prefix : affix:string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_prefix ~affix s</code> is <code>true</code> iff <code>affix.[i] = s.[i]</code> for all indices <code>i</code> of <code>affix</code>.</p></dd></dl><dl><dt class="spec value" id="val-is_infix"><a href="#val-is_infix" class="anchor"></a><code><span class="keyword">val</span> is_infix : affix:string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_infix ~affix s</code> is <code>true</code> iff there exists an index <code>j</code> in <code>s</code> such that for all indices <code>i</code> of <code>affix</code> we have <code>affix.[i] = s.[j + i]</code>.</p></dd></dl><dl><dt class="spec value" id="val-is_suffix"><a href="#val-is_suffix" class="anchor"></a><code><span class="keyword">val</span> is_suffix : affix:string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_suffix ~affix s</code> is true iff <code>affix.[n - i] = s.[m - i]</code> for all indices <code>i</code> of <code>affix</code> with <code>n = String.length affix - 1</code> and <code>m =
      String.length s - 1</code>.</p></dd></dl><dl><dt class="spec value" id="val-for_all"><a href="#val-for_all" class="anchor"></a><code><span class="keyword">val</span> for_all : (char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> string <span>&#45;&gt;</span> bool</code></dt><dd><p><code>for_all p s</code> is <code>true</code> iff for all indices <code>i</code> of <code>s</code>, <code>p s.[i]
      = true</code>.</p></dd></dl><dl><dt class="spec value" id="val-exists"><a href="#val-exists" class="anchor"></a><code><span class="keyword">val</span> exists : (char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> string <span>&#45;&gt;</span> bool</code></dt><dd><p><code>exists p s</code> is <code>true</code> iff there exists an index <code>i</code> of <code>s</code> with <code>p s.[i] = true</code>.</p></dd></dl><dl><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val</span> equal : string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> bool</code></dt><dd><p><code>equal s s'</code> is <code>s = s'</code>.</p></dd></dl><dl><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val</span> compare : string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> int</code></dt><dd><p><code>compare s s'</code> is <code>Pervasives.compare s s'</code>, it compares the byte sequences of <code>s</code> and <code>s'</code> in lexicographical order.</p></dd></dl></section><section><header><h2 id="extract"><a href="#extract" class="anchor"></a>Extracting substrings</h2><p><b>Tip.</b> These functions extract substrings as new strings. Using <a href="Sub/index.html"><span>substrings</span></a> may be less wasteful and more flexible.</p></header><dl><dt class="spec value" id="val-with_range"><a href="#val-with_range" class="anchor"></a><code><span class="keyword">val</span> with_range : ?&#8288;first:int <span>&#45;&gt;</span> ?&#8288;len:int <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt><dd><p><code>with_range ~first ~len s</code> are the consecutive bytes of <code>s</code> whose indices exist in the range [<code>first</code>;<code>first + len - 1</code>].</p><p><code>first</code> defaults to <code>0</code> and <code>len</code> to <code>max_int</code>. Note that <code>first</code> can be any integer and <code>len</code> any positive integer.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>len</code> is negative.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-with_index_range"><a href="#val-with_index_range" class="anchor"></a><code><span class="keyword">val</span> with_index_range : ?&#8288;first:int <span>&#45;&gt;</span> ?&#8288;last:int <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt><dd><p><code>with_index_range ~first ~last s</code> are the consecutive bytes of <code>s</code> whose indices exist in the range [<code>first</code>;<code>last</code>].</p><p><code>first</code> defaults to <code>0</code> and <code>last</code> to <code>String.length s - 1</code>.</p><p>Note that both <code>first</code> and <code>last</code> can be any integer. If <code>first &gt; last</code> the interval is empty and the empty string is returned.</p></dd></dl><dl><dt class="spec value" id="val-trim"><a href="#val-trim" class="anchor"></a><code><span class="keyword">val</span> trim : ?&#8288;drop:(char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt><dd><p><code>trim ~drop s</code> is <code>s</code> with prefix and suffix bytes satisfying <code>drop</code> in <code>s</code> removed. <code>drop</code> defaults to <a href="../Char/Ascii/index.html#val-is_white"><code>Char.Ascii.is_white</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-span"><a href="#val-span" class="anchor"></a><code><span class="keyword">val</span> span : ?&#8288;rev:bool <span>&#45;&gt;</span> ?&#8288;min:int <span>&#45;&gt;</span> ?&#8288;max:int <span>&#45;&gt;</span> ?&#8288;sat:(char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string * string</code></dt><dd><p><code>span ~rev ~min ~max ~sat s</code> is <code>(l, r)</code> where:</p><ul><li>if <code>rev</code> is <code>false</code> (default), <code>l</code> is at least <code>min</code> and at most <code>max</code> consecutive <code>sat</code> satisfying initial bytes of <code>s</code> or <a href="index.html#val-empty"><code>empty</code></a> if there are no such bytes. <code>r</code> are the remaining bytes of <code>s</code>.</li><li>if <code>rev</code> is <code>true</code>, <code>r</code> is at least <code>min</code> and at most <code>max</code> consecutive <code>sat</code> satisfying final bytes of <code>s</code> or <a href="index.html#val-empty"><code>empty</code></a> if there are no such bytes. <code>l</code> are the remaining the bytes of <code>s</code>.</li></ul><p>If <code>max</code> is unspecified the span is unlimited. If <code>min</code> is unspecified it defaults to <code>0</code>. If <code>min &gt; max</code> the condition can't be satisfied and the left or right span, depending on <code>rev</code>, is always empty. <code>sat</code> defaults to <code>(fun _ -&gt; true)</code>.</p><p>The invariant <code>l ^ r = s</code> holds.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>max</code> or <code>min</code> is negative.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-take"><a href="#val-take" class="anchor"></a><code><span class="keyword">val</span> take : ?&#8288;rev:bool <span>&#45;&gt;</span> ?&#8288;min:int <span>&#45;&gt;</span> ?&#8288;max:int <span>&#45;&gt;</span> ?&#8288;sat:(char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt><dd><p><code>take ~rev ~min ~max ~sat s</code> is the matching span of <a href="index.html#val-span"><code>span</code></a> without the remaining one. In other words:</p><pre><code class="ml">(if rev then snd else fst) @@ span ~rev ~min ~max ~sat s</code></pre></dd></dl><dl><dt class="spec value" id="val-drop"><a href="#val-drop" class="anchor"></a><code><span class="keyword">val</span> drop : ?&#8288;rev:bool <span>&#45;&gt;</span> ?&#8288;min:int <span>&#45;&gt;</span> ?&#8288;max:int <span>&#45;&gt;</span> ?&#8288;sat:(char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt><dd><p><code>drop ~rev ~min ~max ~sat s</code> is the remaining span of <a href="index.html#val-span"><code>span</code></a> without the matching span. In other words:</p><pre><code class="ml">(if rev then fst else snd) @@ span ~rev ~min ~max ~sat s</code></pre></dd></dl><dl><dt class="spec value" id="val-cut"><a href="#val-cut" class="anchor"></a><code><span class="keyword">val</span> cut : ?&#8288;rev:bool <span>&#45;&gt;</span> sep:string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> (string * string) option</code></dt><dd><p><code>cut ~sep s</code> is either the pair <code>Some (l,r)</code> of the two (possibly empty) substrings of <code>s</code> that are delimited by the first match of the non empty separator string <code>sep</code> or <code>None</code> if <code>sep</code> can't be matched in <code>s</code>. Matching starts from the beginning of <code>s</code> (<code>rev</code> is <code>false</code>, default) or the end (<code>rev</code> is <code>true</code>).</p><p>The invariant <code>l ^ sep ^ r = s</code> holds.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>sep</code> is the empty string.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-cuts"><a href="#val-cuts" class="anchor"></a><code><span class="keyword">val</span> cuts : ?&#8288;rev:bool <span>&#45;&gt;</span> ?&#8288;empty:bool <span>&#45;&gt;</span> sep:string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string list</code></dt><dd><p><code>cuts sep s</code> is the list of all substrings of <code>s</code> that are delimited by matches of the non empty separator string <code>sep</code>. Empty substrings are omitted in the list if <code>empty</code> is <code>false</code> (defaults to <code>true</code>).</p><p>Matching separators in <code>s</code> starts from the beginning of <code>s</code> (<code>rev</code> is <code>false</code>, default) or the end (<code>rev</code> is <code>true</code>). Once one is found, the separator is skipped and matching starts again, that is separator matches can't overlap. If there is no separator match in <code>s</code>, the list <code>[s]</code> is returned.</p><p>The following invariants hold:</p><ul><li><code>concat ~sep (cuts ~empty:true ~sep s) = s</code></li><li><code>cuts ~empty:true ~sep s &lt;&gt; []</code></li></ul><dl><dt>raises Invalid_argument</dt><dd><p>if <code>sep</code> is the empty string.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-fields"><a href="#val-fields" class="anchor"></a><code><span class="keyword">val</span> fields : ?&#8288;empty:bool <span>&#45;&gt;</span> ?&#8288;is_sep:(char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string list</code></dt><dd><p><code>fields ~empty ~is_sep s</code> is the list of (possibly empty) substrings that are delimited by bytes for which <code>is_sep</code> is <code>true</code>. Empty substrings are omitted in the list if <code>empty</code> is <code>false</code> (defaults to <code>true</code>). <code>is_sep</code> defaults to <a href="../Char/Ascii/index.html#val-is_white"><code>Char.Ascii.is_white</code></a>.</p></dd></dl></section><section><header><h2 id="subs"><a href="#subs" class="anchor"></a>Substrings</h2></header><dl><dt class="spec type" id="type-sub"><a href="#type-sub" class="anchor"></a><code><span class="keyword">type</span> sub</code></dt><dd><p>The type for <a href="Sub/index.html"><span>substrings</span></a>.</p></dd></dl><dl><dt class="spec value" id="val-sub"><a href="#val-sub" class="anchor"></a><code><span class="keyword">val</span> sub : ?&#8288;start:int <span>&#45;&gt;</span> ?&#8288;stop:int <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-sub">sub</a></code></dt><dd><p><code>sub</code> is <a href="Sub/index.html#val-v"><code>Sub.v</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-sub_with_range"><a href="#val-sub_with_range" class="anchor"></a><code><span class="keyword">val</span> sub_with_range : ?&#8288;first:int <span>&#45;&gt;</span> ?&#8288;len:int <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-sub">sub</a></code></dt><dd><p><code>sub_with_range</code> is like <a href="index.html#val-with_range"><code>with_range</code></a> but returns a substring value. If <code>first</code> is smaller than <code>0</code> the empty string at the start of <code>s</code> is returned. If <code>first</code> is greater than the last index of <code>s</code> the empty string at the end of <code>s</code> is returned.</p></dd></dl><dl><dt class="spec value" id="val-sub_with_index_range"><a href="#val-sub_with_index_range" class="anchor"></a><code><span class="keyword">val</span> sub_with_index_range : ?&#8288;first:int <span>&#45;&gt;</span> ?&#8288;last:int <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-sub">sub</a></code></dt><dd><p><code>sub_with_index_range</code> is like <a href="index.html#val-with_index_range"><code>with_index_range</code></a> but returns a substring value. If <code>first</code> and <code>last</code> are smaller than <code>0</code> the empty string at the start of <code>s</code> is returned. If <code>first</code> and is greater than the last index of <code>s</code> the empty string at the end of <code>s</code> is returned. If <code>first &gt; last</code> and <code>first</code> is an index of <code>s</code> the empty string at <code>first</code> is returned.</p></dd></dl><dl><dt class="spec module" id="module-Sub"><a href="#module-Sub" class="anchor"></a><code><span class="keyword">module</span> <a href="Sub/index.html">Sub</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Substrings.</p></dd></dl></section><section><header><h2 id="traverse"><a href="#traverse" class="anchor"></a>Traversing strings</h2></header><dl><dt class="spec value" id="val-find"><a href="#val-find" class="anchor"></a><code><span class="keyword">val</span> find : ?&#8288;rev:bool <span>&#45;&gt;</span> ?&#8288;start:int <span>&#45;&gt;</span> (char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> string <span>&#45;&gt;</span> int option</code></dt><dd><p><code>find ~rev ~start sat s</code> is:</p><ul><li>If <code>rev</code> is <code>false</code> (default). The smallest index <code>i</code>, if any, greater or equal to <code>start</code> such that <code>sat s.[i]</code> is <code>true</code>. <code>start</code> defaults to <code>0</code>.</li><li>If <code>rev</code> is <code>true</code>. The greatest index <code>i</code>, if any, smaller or equal to <code>start</code> such that <code>sat s.[i]</code> is <code>true</code>. <code>start</code> defaults to <code>String.length s - 1</code>.</li></ul><p>Note that <code>start</code> can be any integer.</p></dd></dl><dl><dt class="spec value" id="val-find_sub"><a href="#val-find_sub" class="anchor"></a><code><span class="keyword">val</span> find_sub : ?&#8288;rev:bool <span>&#45;&gt;</span> ?&#8288;start:int <span>&#45;&gt;</span> sub:string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> int option</code></dt><dd><p><code>find_sub ~rev ~start ~sub s</code> is:</p><ul><li>If <code>rev</code> is <code>false</code> (default). The smallest index <code>i</code>, if any, greater or equal to <code>start</code> such that <code>sub</code> can be found starting at <code>i</code> in <code>s</code> that is <code>s.[i] = sub.[0]</code>, <code>s.[i+1] = sub.[1]</code>, ... <code>start</code> defaults to <code>0</code>.</li><li>If <code>rev</code> is <code>true</code>. The greatest index <code>i</code>, if any, smaller or equal to <code>start</code> such that <code>sub</code> can be found starting at <code>i</code> in <code>s</code> that is <code>s.[i] = sub.[0]</code>, <code>s.[i+1] = sub.[1]</code>, ... <code>start</code> defaults to <code>String.length s - 1</code>.</li></ul><p>Note that <code>start</code> can be any integer.</p></dd></dl><dl><dt class="spec value" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span class="keyword">val</span> filter : (char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt><dd><p><code>filter sat s</code> is the string made of the bytes of <code>s</code> that satisfy <code>sat</code>, in the same order.</p></dd></dl><dl><dt class="spec value" id="val-filter_map"><a href="#val-filter_map" class="anchor"></a><code><span class="keyword">val</span> filter_map : (char <span>&#45;&gt;</span> char option) <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt><dd><p><code>filter_map f s</code> is the string made of the bytes of <code>s</code> as mapped by <code>f</code>, in the same order.</p></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : (char <span>&#45;&gt;</span> char) <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt><dd><p><code>map f s</code> is <code>s'</code> with <code>s'.[i] = f s.[i]</code> for all indices <code>i</code> of <code>s</code>. <code>f</code> is invoked in increasing index order.</p></dd></dl><dl><dt class="spec value" id="val-mapi"><a href="#val-mapi" class="anchor"></a><code><span class="keyword">val</span> mapi : (int <span>&#45;&gt;</span> char <span>&#45;&gt;</span> char) <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt><dd><p><code>mapi f s</code> is <code>s'</code> with <code>s'.[i] = f i s.[i]</code> for all indices <code>i</code> of <code>s</code>. <code>f</code> is invoked in increasing index order.</p></dd></dl><dl><dt class="spec value" id="val-fold_left"><a href="#val-fold_left" class="anchor"></a><code><span class="keyword">val</span> fold_left : (<span class="type-var">'a</span> <span>&#45;&gt;</span> char <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>fold_left f acc s</code> is <code>f (</code>...<code>(f (f acc s.[0]) s.[1])</code>...<code>) s.[m]</code> with <code>m = String.length s - 1</code>.</p></dd></dl><dl><dt class="spec value" id="val-fold_right"><a href="#val-fold_right" class="anchor"></a><code><span class="keyword">val</span> fold_right : (char <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>fold_right f s acc</code> is <code>f s.[0] (f s.[1] (</code>...<code>(f s.[m] acc) )</code>...<code>)</code> with <code>m = String.length s - 1</code>.</p></dd></dl><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : (char <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> string <span>&#45;&gt;</span> unit</code></dt><dd><p><code>iter f s</code> is <code>f s.[0]; f s.[1];</code> ... <code>f s.[m]</code> with <code>m = String.length s - 1</code>.</p></dd></dl><dl><dt class="spec value" id="val-iteri"><a href="#val-iteri" class="anchor"></a><code><span class="keyword">val</span> iteri : (int <span>&#45;&gt;</span> char <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> string <span>&#45;&gt;</span> unit</code></dt><dd><p><code>iteri f s</code> is <code>f 0 s.[0]; f 1 s.[1];</code> ... <code>f m s.[m]</code> with <code>m = String.length s - 1</code>.</p></dd></dl></section><section><header><h2 id="unique"><a href="#unique" class="anchor"></a>Uniqueness</h2></header><dl><dt class="spec value" id="val-uniquify"><a href="#val-uniquify" class="anchor"></a><code><span class="keyword">val</span> uniquify : string list <span>&#45;&gt;</span> string list</code></dt><dd><p><code>uniquify ss</code> is <code>ss</code> without duplicates, the list order is preserved.</p></dd></dl></section><section><header><h2 id="ascii"><a href="#ascii" class="anchor"></a>Strings as US-ASCII character sequences</h2></header><dl><dt class="spec module" id="module-Ascii"><a href="#module-Ascii" class="anchor"></a><code><span class="keyword">module</span> <a href="Ascii/index.html">Ascii</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>US-ASCII string support.</p></dd></dl></section><section><header><h2 id="pp"><a href="#pp" class="anchor"></a>Pretty printing</h2></header><dl><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val</span> pp : <a href="../../../ocaml/Stdlib/Format/index.html#type-formatter">Stdlib.Format.formatter</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp ppf s</code> prints <code>s</code>'s bytes on <code>ppf</code>.</p></dd></dl><dl><dt class="spec value" id="val-dump"><a href="#val-dump" class="anchor"></a><code><span class="keyword">val</span> dump : <a href="../../../ocaml/Stdlib/Format/index.html#type-formatter">Stdlib.Format.formatter</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> unit</code></dt><dd><p><code>dump ppf s</code> prints <code>s</code> as a syntactically valid OCaml string on <code>ppf</code> using <a href="Ascii/index.html#val-escape_string"><code>Ascii.escape_string</code></a>.</p></dd></dl></section><section><header><h2 id="string-sets-and-maps"><a href="#string-sets-and-maps" class="anchor"></a>String sets and maps</h2></header><dl><dt class="spec type" id="type-set"><a href="#type-set" class="anchor"></a><code><span class="keyword">type</span> set</code></dt><dd><p>The type for string sets.</p></dd></dl><dl><dt class="spec module" id="module-Set"><a href="#module-Set" class="anchor"></a><code><span class="keyword">module</span> <a href="Set/index.html">Set</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>String sets.</p></dd></dl><dl><dt class="spec type" id="type-map"><a href="#type-map" class="anchor"></a><code><span class="keyword">type</span> +'a map</code></dt><dd><p>The type for maps from strings to values of type 'a.</p></dd></dl><dl><dt class="spec module" id="module-Map"><a href="#module-Map" class="anchor"></a><code><span class="keyword">module</span> <a href="Map/index.html">Map</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>String maps.</p></dd></dl></section><section><header><h2 id="convert"><a href="#convert" class="anchor"></a>OCaml base type conversions</h2></header><dl><dt class="spec value" id="val-of_char"><a href="#val-of_char" class="anchor"></a><code><span class="keyword">val</span> of_char : char <span>&#45;&gt;</span> string</code></dt><dd><p><code>of_char c</code> is a string that contains the byte <code>c</code>.</p></dd></dl><dl><dt class="spec value" id="val-to_char"><a href="#val-to_char" class="anchor"></a><code><span class="keyword">val</span> to_char : string <span>&#45;&gt;</span> char option</code></dt><dd><p><code>to_char s</code> is the single byte in <code>s</code> or <code>None</code> if there is no byte or more than one in <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-of_bool"><a href="#val-of_bool" class="anchor"></a><code><span class="keyword">val</span> of_bool : bool <span>&#45;&gt;</span> string</code></dt><dd><p><code>of_bool b</code> is a string representation for <code>b</code>. Relies on <span class="xref-unresolved" title="unresolved reference to &quot;Pervasives.string_of_bool&quot;"><code>Pervasives</code>.string_of_bool</span>.</p></dd></dl><dl><dt class="spec value" id="val-to_bool"><a href="#val-to_bool" class="anchor"></a><code><span class="keyword">val</span> to_bool : string <span>&#45;&gt;</span> bool option</code></dt><dd><p><code>to_bool s</code> is a <code>bool</code> from <code>s</code>, if any. Relies on <span class="xref-unresolved" title="unresolved reference to &quot;Pervasives.bool_of_string&quot;"><code>Pervasives</code>.bool_of_string</span>.</p></dd></dl><dl><dt class="spec value" id="val-of_int"><a href="#val-of_int" class="anchor"></a><code><span class="keyword">val</span> of_int : int <span>&#45;&gt;</span> string</code></dt><dd><p><code>of_int i</code> is a string representation for <code>i</code>. Relies on <span class="xref-unresolved" title="unresolved reference to &quot;Pervasives.string_of_int&quot;"><code>Pervasives</code>.string_of_int</span>.</p></dd></dl><dl><dt class="spec value" id="val-to_int"><a href="#val-to_int" class="anchor"></a><code><span class="keyword">val</span> to_int : string <span>&#45;&gt;</span> int option</code></dt><dd><p><code>to_int</code> is an <code>int</code> from <code>s</code>, if any. Relies on <span class="xref-unresolved" title="unresolved reference to &quot;Pervasives.int_of_string&quot;"><code>Pervasives</code>.int_of_string</span>.</p></dd></dl><dl><dt class="spec value" id="val-of_nativeint"><a href="#val-of_nativeint" class="anchor"></a><code><span class="keyword">val</span> of_nativeint : nativeint <span>&#45;&gt;</span> string</code></dt><dd><p><code>of_nativeint i</code> is a string representation for <code>i</code>. Relies on <span class="xref-unresolved" title="unresolved reference to &quot;Nativeint.of_string&quot;"><code>Nativeint</code>.of_string</span>.</p></dd></dl><dl><dt class="spec value" id="val-to_nativeint"><a href="#val-to_nativeint" class="anchor"></a><code><span class="keyword">val</span> to_nativeint : string <span>&#45;&gt;</span> nativeint option</code></dt><dd><p><code>to_nativeint</code> is an <code>nativeint</code> from <code>s</code>, if any. Relies on <span class="xref-unresolved" title="unresolved reference to &quot;Nativeint.to_string&quot;"><code>Nativeint</code>.to_string</span>.</p></dd></dl><dl><dt class="spec value" id="val-of_int32"><a href="#val-of_int32" class="anchor"></a><code><span class="keyword">val</span> of_int32 : int32 <span>&#45;&gt;</span> string</code></dt><dd><p><code>of_int32 i</code> is a string representation for <code>i</code>. Relies on <span class="xref-unresolved" title="unresolved reference to &quot;Int32.of_string&quot;"><code>Int32</code>.of_string</span>.</p></dd></dl><dl><dt class="spec value" id="val-to_int32"><a href="#val-to_int32" class="anchor"></a><code><span class="keyword">val</span> to_int32 : string <span>&#45;&gt;</span> int32 option</code></dt><dd><p><code>to_int32</code> is an <code>int32</code> from <code>s</code>, if any. Relies on <span class="xref-unresolved" title="unresolved reference to &quot;Int32.to_string&quot;"><code>Int32</code>.to_string</span>.</p></dd></dl><dl><dt class="spec value" id="val-of_int64"><a href="#val-of_int64" class="anchor"></a><code><span class="keyword">val</span> of_int64 : int64 <span>&#45;&gt;</span> string</code></dt><dd><p><code>of_int64 i</code> is a string representation for <code>i</code>. Relies on <span class="xref-unresolved" title="unresolved reference to &quot;Int64.of_string&quot;"><code>Int64</code>.of_string</span>.</p></dd></dl><dl><dt class="spec value" id="val-to_int64"><a href="#val-to_int64" class="anchor"></a><code><span class="keyword">val</span> to_int64 : string <span>&#45;&gt;</span> int64 option</code></dt><dd><p><code>to_int64</code> is an <code>int64</code> from <code>s</code>, if any. Relies on <span class="xref-unresolved" title="unresolved reference to &quot;Int64.to_string&quot;"><code>Int64</code>.to_string</span>.</p></dd></dl><dl><dt class="spec value" id="val-of_float"><a href="#val-of_float" class="anchor"></a><code><span class="keyword">val</span> of_float : float <span>&#45;&gt;</span> string</code></dt><dd><p><code>of_float f</code> is a string representation for <code>f</code>. Relies on <span class="xref-unresolved" title="unresolved reference to &quot;Pervasives.string_of_float&quot;"><code>Pervasives</code>.string_of_float</span>.</p></dd></dl><dl><dt class="spec value" id="val-to_float"><a href="#val-to_float" class="anchor"></a><code><span class="keyword">val</span> to_float : string <span>&#45;&gt;</span> float option</code></dt><dd><p><code>to_float s</code> is a <code>float</code> from <code>s</code>, if any. Relies on <span class="xref-unresolved" title="unresolved reference to &quot;Pervasives.float_of_string&quot;"><code>Pervasives</code>.float_of_string</span>.</p></dd></dl></section></div></body></html>