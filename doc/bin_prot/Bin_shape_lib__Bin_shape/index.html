<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Bin_shape_lib__Bin_shape (bin_prot.Bin_shape_lib__Bin_shape)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">bin_prot</a> &#x00BB; Bin_shape_lib__Bin_shape</nav><h1>Module <code>Bin_shape_lib__Bin_shape</code></h1></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><p><code>Shape.t</code> are constructed by the <code>bin_shape</code> syntax extension from Ocaml type definitions &amp; expressions.</p><p>There is a direct mapping from ocaml type definition syntax to the corresponding <code>Shape.group</code> and from ocaml type expression syntax to the corresponding <code>Shape.t</code>.</p></dd></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></span></summary><dl><dt class="spec value" id="val-sexp_of_t"><a href="#val-sexp_of_t" class="anchor"></a><code><span class="keyword">val</span> sexp_of_t : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a></code></dt></dl></details></div></div></div><aside><p><code>Tid.t</code> &amp; <code>Vid.t</code> are identifiers for type-constructors &amp; type-vars. i.e. Given <code>type 'a t = ... </code></p></aside><div class="spec module" id="module-Tid"><a href="#module-Tid" class="anchor"></a><code><span class="keyword">module</span> <a href="Tid/index.html">Tid</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Vid"><a href="#module-Vid" class="anchor"></a><code><span class="keyword">module</span> <a href="Vid/index.html">Vid</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec module" id="module-Location"><a href="#module-Location" class="anchor"></a><code><span class="keyword">module</span> <a href="Location/index.html">Location</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p><code>Location.t</code> is required when constructing shapes for which evaluation might fail.</p></dd></dl><dl><dt class="spec module" id="module-Uuid"><a href="#module-Uuid" class="anchor"></a><code><span class="keyword">module</span> <a href="Uuid/index.html">Uuid</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p><code>Uuid.t</code> is used by <code>basetype</code> and <code>annotate</code>.</p></dd></dl><dl><dt class="spec type" id="type-group"><a href="#type-group" class="anchor"></a><code><span class="keyword">type</span> group</code></dt><dd><p>group of mutually recursive type definitions</p></dd></dl><dl><dt class="spec value" id="val-group"><a href="#val-group" class="anchor"></a><code><span class="keyword">val</span> group : <a href="Location/index.html#type-t">Location.t</a> <span>&#45;&gt;</span> (<a href="Tid/index.html#type-t">Tid.t</a> * <a href="Vid/index.html#type-t">Vid.t</a> list * <a href="index.html#type-t">t</a>) list <span>&#45;&gt;</span> <a href="index.html#type-group">group</a></code></dt><dd><p>This function is generative; repeated calls create distinct groups</p></dd></dl><dl><dt class="spec value" id="val-tuple"><a href="#val-tuple" class="anchor"></a><code><span class="keyword">val</span> tuple : <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-record"><a href="#val-record" class="anchor"></a><code><span class="keyword">val</span> record : (string * <a href="index.html#type-t">t</a>) list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-variant"><a href="#val-variant" class="anchor"></a><code><span class="keyword">val</span> variant : (string * <a href="index.html#type-t">t</a> list) list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt></dl><dl><dt class="spec type" id="type-poly_variant_row"><a href="#type-poly_variant_row" class="anchor"></a><code><span class="keyword">type</span> poly_variant_row</code></dt></dl><dl><dt class="spec value" id="val-constr"><a href="#val-constr" class="anchor"></a><code><span class="keyword">val</span> constr : string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> option <span>&#45;&gt;</span> <a href="index.html#type-poly_variant_row">poly_variant_row</a></code></dt><dt class="spec value" id="val-inherit_"><a href="#val-inherit_" class="anchor"></a><code><span class="keyword">val</span> inherit_ : <a href="Location/index.html#type-t">Location.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-poly_variant_row">poly_variant_row</a></code></dt><dt class="spec value" id="val-poly_variant"><a href="#val-poly_variant" class="anchor"></a><code><span class="keyword">val</span> poly_variant : <a href="Location/index.html#type-t">Location.t</a> <span>&#45;&gt;</span> <a href="index.html#type-poly_variant_row">poly_variant_row</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-rec_app"><a href="#val-rec_app" class="anchor"></a><code><span class="keyword">val</span> rec_app : <a href="Tid/index.html#type-t">Tid.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>recursive apps within the current group</p></dd></dl><dl><dt class="spec value" id="val-top_app"><a href="#val-top_app" class="anchor"></a><code><span class="keyword">val</span> top_app : <a href="index.html#type-group">group</a> <span>&#45;&gt;</span> <a href="Tid/index.html#type-t">Tid.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>recursive apps within the current group</p><p>apps from outside the group</p></dd></dl><dl><dt class="spec value" id="val-var"><a href="#val-var" class="anchor"></a><code><span class="keyword">val</span> var : <a href="Location/index.html#type-t">Location.t</a> <span>&#45;&gt;</span> <a href="Vid/index.html#type-t">Vid.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-basetype"><a href="#val-basetype" class="anchor"></a><code><span class="keyword">val</span> basetype : <a href="Uuid/index.html#type-t">Uuid.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Built-in types and types with custom serialization: i.e. int,list,... To avoid accidental protocol compatibility, pass a UUID as the <code>string</code> argument</p></dd></dl><aside><p><code>a = annotate s t</code> creates a shape <code>a</code> distinguished, but dependent on shape <code>t</code>. Very much as <code>record [(s,t)]</code> does. But with <code>annotate</code> the ocaml record type does not exist.</p></aside><dl><dt class="spec value" id="val-annotate_provisionally"><a href="#val-annotate_provisionally" class="anchor"></a><code><span class="keyword">val</span> annotate_provisionally : <a href="Uuid/index.html#type-t">Uuid.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt></dl><aside><p><code>Shape.Canonical.t</code> is the result of <code>eval</code>uating a shape to a canonical form, and represents the shape of Ocaml types w.r.t. bin_io serialization.</p><p>The idea is that de-serialization is safe if the canonical-shape for the type produced by de-serialization is equivalent to the canonical-shape of the serialized type.</p><p>The representation is canonical, so equivalence is structural equality.</p><p><code>Canonical.t</code> also provides a useful human level description of a type.</p><p>A <code>Canonical.t</code> can be `digested' to a <code>Digest.t</code>, and except for nearly impossible hash collisions, equality of the digests implies equality of canonical-shapes and hence equivalence at the Shape.t level.</p><p><code>Canonical.t</code> may also be constructed with various functions: <code>annotate, basetype, tuple, record, variant, poly_variant, fix, recurse, ..</code> which might be used when setting up unit tests or expected shapes.</p></aside><div class="spec module" id="module-Digest"><a href="#module-Digest" class="anchor"></a><code><span class="keyword">module</span> <a href="Digest/index.html">Digest</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Canonical"><a href="#module-Canonical" class="anchor"></a><code><span class="keyword">module</span> <a href="Canonical/index.html">Canonical</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-eval"><a href="#val-eval" class="anchor"></a><code><span class="keyword">val</span> eval : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="Canonical/index.html#type-t">Canonical.t</a></code></dt><dd><p><code>eval t</code> returns the canonical-shape for a shape-expression <code>Shape.t</code>. Type aliases are expanded, so that no <code>Tid.t</code> or <code>Vid.t</code> have significance in the resulting canonical-shape. Type-recursion, including non-regular recursion, is translated to the de-bruijn representation used in canonical-shapes.</p></dd></dl><dl><dt class="spec value" id="val-eval_to_digest"><a href="#val-eval_to_digest" class="anchor"></a><code><span class="keyword">val</span> eval_to_digest : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="Digest/index.html#type-t">Digest.t</a></code></dt><dd><p><code>eval_to_digest t</code> returns a hash-value direct from the <code>Shape.t</code>, potentially avoiding the intermediate <code>Canonical.t</code> from being constructed. This is important as the size of a canonical-shape might be exponential in terms of the size of the shape expression. The following holds: <code> Digest.(eval_to_digest exp = Canonical.to_digest (eval exp)) </code></p></dd></dl><dl><dt class="spec value" id="val-eval_to_digest_string"><a href="#val-eval_to_digest_string" class="anchor"></a><code><span class="keyword">val</span> eval_to_digest_string : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p><code>eval_to_digest_string t</code> == <code>Digest.to_hex (eval_to_digest t)</code> Convenience function useful for writing unit tests.</p></dd></dl><div class="spec module" id="module-For_typerep"><a href="#module-For_typerep" class="anchor"></a><code><span class="keyword">module</span> <a href="For_typerep/index.html">For_typerep</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></div></body></html>