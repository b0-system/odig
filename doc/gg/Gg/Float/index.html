<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Float (gg.Gg.Float)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">gg</a> &#x00BB; <a href="../index.html">Gg</a> &#x00BB; Float</nav><header class="odoc-preamble"><h1>Module <code><span>Gg.Float</span></code></h1><p>Floating point number utilities.</p><p>This module defines a few useful <span class="xref-unresolved">constants</span>, <span class="xref-unresolved">functions</span>, <span class="xref-unresolved">predicates and comparisons</span> on floating point numbers. The <span class="xref-unresolved">printers</span> output a lossless textual representation of floats.</p><p><span class="xref-unresolved">Quick recall</span> on OCaml's floating point representation.</p></header><nav class="odoc-toc"><ul><li><a href="#constants">Constants</a></li><li><a href="#functions">Functions</a></li><li><a href="#preds">Predicates and comparisons</a></li><li><a href="#printers">Printers</a></li><li><a href="#floatrecall">Quick recall on OCaml's <code>float</code>s</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span><span> = float</span></code></div><div class="spec-doc"><p>The type for floating point numbers.</p></div></div><h2 id="constants"><a href="#constants" class="anchor"></a>Constants</h2><div class="odoc-spec"><div class="spec value" id="val-e" class="anchored"><a href="#val-e" class="anchor"></a><code><span><span class="keyword">val</span> e : float</span></code></div><div class="spec-doc"><p>The constant <a href="http://mathworld.wolfram.com/e.html">e</a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pi" class="anchored"><a href="#val-pi" class="anchor"></a><code><span><span class="keyword">val</span> pi : float</span></code></div><div class="spec-doc"><p>The constant <a href="http://mathworld.wolfram.com/Pi.html">pi</a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-two_pi" class="anchored"><a href="#val-two_pi" class="anchor"></a><code><span><span class="keyword">val</span> two_pi : float</span></code></div><div class="spec-doc"><p><code>2 *. pi</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-pi_div_2" class="anchored"><a href="#val-pi_div_2" class="anchor"></a><code><span><span class="keyword">val</span> pi_div_2 : float</span></code></div><div class="spec-doc"><p><code>pi /. 2</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pi_div_4" class="anchored"><a href="#val-pi_div_4" class="anchor"></a><code><span><span class="keyword">val</span> pi_div_4 : float</span></code></div><div class="spec-doc"><p><code>pi /. 4</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-inv_pi" class="anchored"><a href="#val-inv_pi" class="anchor"></a><code><span><span class="keyword">val</span> inv_pi : float</span></code></div><div class="spec-doc"><p><code>1 /. pi</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-max_sub_float" class="anchored"><a href="#val-max_sub_float" class="anchor"></a><code><span><span class="keyword">val</span> max_sub_float : float</span></code></div><div class="spec-doc"><p>The greatest positive subnormal floating point number.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-min_sub_float" class="anchored"><a href="#val-min_sub_float" class="anchor"></a><code><span><span class="keyword">val</span> min_sub_float : float</span></code></div><div class="spec-doc"><p>The smallest positive subnormal floating point number.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-max_frac_float" class="anchored"><a href="#val-max_frac_float" class="anchor"></a><code><span><span class="keyword">val</span> max_frac_float : float</span></code></div><div class="spec-doc"><p>The greatest positive floating point number with a fractional part (the <code>float</code> before 2<sup>52</sup>). Any number outside [<code>-max_frac_float;max_frac_float</code>] is an integer.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-max_int_arith" class="anchored"><a href="#val-max_int_arith" class="anchor"></a><code><span><span class="keyword">val</span> max_int_arith : float</span></code></div><div class="spec-doc"><p>The greatest positive floating point number (2<sup>53</sup>) such that any <em>integer</em> in the range [<code>-max_int_arith;max_int_arith</code>] is represented exactly. Integer arithmetic can be performed exactly in this interval.</p></div></div><h2 id="functions"><a href="#functions" class="anchor"></a>Functions</h2><p><b>Note.</b> If applicable, a function taking NaNs returns a NaN unless otherwise specified.</p><div class="odoc-spec"><div class="spec value" id="val-deg_of_rad" class="anchored"><a href="#val-deg_of_rad" class="anchor"></a><code><span><span class="keyword">val</span> deg_of_rad : <span>float <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p><code>deg_of_rad r</code> is <code>r</code> <a href="http://mathworld.wolfram.com/Radian.html">radians</a> in <a href="http://mathworld.wolfram.com/Degree.html">degrees</a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-rad_of_deg" class="anchored"><a href="#val-rad_of_deg" class="anchor"></a><code><span><span class="keyword">val</span> rad_of_deg : <span>float <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p><code>rad_of_deg d</code> is <code>d</code> <a href="http://mathworld.wolfram.com/Degree.html">degrees</a> in <a href="http://mathworld.wolfram.com/Radian.html">radians</a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-wrap_angle" class="anchored"><a href="#val-wrap_angle" class="anchor"></a><code><span><span class="keyword">val</span> wrap_angle : <span>float <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p><code>wrap_angle r</code> is the angle <code>r</code> in the interval [<code>-pi;pi</code>[.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-random" class="anchored"><a href="#val-random" class="anchor"></a><code><span><span class="keyword">val</span> random : <span>?min:float <span class="arrow">&#45;&gt;</span></span> <span>len:float <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p><code>random min len ()</code> is a random float in the interval [<code>min;min+len</code>] (<code>min</code> defaults to 0.). Uses the standard library's default <code>Random</code> state for the generation.</p><p><b>Warning.</b> The float generated by a given state may change in future versions of the library.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-srandom" class="anchored"><a href="#val-srandom" class="anchor"></a><code><span><span class="keyword">val</span> srandom : <span><a href="../../../ocaml/Stdlib/Random/State/index.html#type-t">Random.State.t</a> <span class="arrow">&#45;&gt;</span></span> <span>?min:float <span class="arrow">&#45;&gt;</span></span> <span>len:float <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p><code>srandom state min len ()</code> is like <a href="#val-random"><code>random</code></a> but uses <code>state</code> for the generation.</p><p><b>Warning.</b> The float generated by a given <code>state</code> may change in future versions of the library.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mix" class="anchored"><a href="#val-mix" class="anchor"></a><code><span><span class="keyword">val</span> mix : <span>float <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p><code>mix x y t</code> is the linear interpolation <code>x +. t *. (y -. x)</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-step" class="anchored"><a href="#val-step" class="anchor"></a><code><span><span class="keyword">val</span> step : <span>float <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p><code>step edge x</code> is <code>0.</code> if <code>x &lt; edge</code> and <code>1.</code> otherwise. The result is undefined on NaNs.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-smooth_step" class="anchored"><a href="#val-smooth_step" class="anchor"></a><code><span><span class="keyword">val</span> smooth_step : <span>float <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p><code>smooth_step e0 e1 x</code> is <code>0.</code> if <code>x &lt;= e0</code>, <code>1.</code> if <code>x &gt;= e1</code> and cubic hermite interpolation between 0. and 1. otherwise. The result is undefined on NaNs.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fmax" class="anchored"><a href="#val-fmax" class="anchor"></a><code><span><span class="keyword">val</span> fmax : <span>float <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p><code>fmax x y</code> is <code>y</code> if <code>x &lt; y</code> and <code>x</code> otherwise. If <code>x</code> or <code>y</code> is NaN returns the other argument. If both are NaNs returns NaN.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fmin" class="anchored"><a href="#val-fmin" class="anchor"></a><code><span><span class="keyword">val</span> fmin : <span>float <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p><code>fmin x y</code> is <code>x</code> if <code>x &lt; y</code> and <code>y</code> otherwise. If <code>x</code> or <code>y</code> is NaN returns the other argument. If both are NaNs returns NaN.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-clamp" class="anchored"><a href="#val-clamp" class="anchor"></a><code><span><span class="keyword">val</span> clamp : <span>min:float <span class="arrow">&#45;&gt;</span></span> <span>max:float <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p><code>clamp min max x</code> is <code>min</code> if <code>x &lt; min</code>, <code>max</code> if <code>x &gt; max</code> and <code>x</code> otherwise. The result is undefined on NaNs and if <code>min &gt;
      max</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-remap" class="anchored"><a href="#val-remap" class="anchor"></a><code><span><span class="keyword">val</span> remap : <span>x0:float <span class="arrow">&#45;&gt;</span></span> <span>x1:float <span class="arrow">&#45;&gt;</span></span> <span>y0:float <span class="arrow">&#45;&gt;</span></span> <span>y1:float <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p><code>remap x0 x1 y0 y1 v</code> applies to <code>v</code> the <a href="http://mathworld.wolfram.com/AffineTransformation.html">affine transform</a> that maps <code>x0</code> to <code>y0</code> and <code>x1</code> to <code>y1</code>. If the transform is undefined (<code>x0 = x1</code> and <code>y0 &lt;&gt; y1</code>) the function returns <code>y0</code> for any <code>v</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-round" class="anchored"><a href="#val-round" class="anchor"></a><code><span><span class="keyword">val</span> round : <span>float <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p><code>round x</code> is the integer nearest to <code>x</code>. Ties are rounded towards positive infinity. If <code>x</code> is an infinity, returns <code>x</code>.</p><p><b>Note.</b> If the absolute magnitude of <code>x</code> is an integer strictly greater than <a href="#val-max_frac_float"><code>max_frac_float</code></a>, <code>round x = x</code> may be <code>false</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-int_of_round" class="anchored"><a href="#val-int_of_round" class="anchor"></a><code><span><span class="keyword">val</span> int_of_round : <span>float <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>int_of_round x</code> is <code>truncate (round v)</code>. The result is undefined on NaNs and infinities.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-round_dfrac" class="anchored"><a href="#val-round_dfrac" class="anchor"></a><code><span><span class="keyword">val</span> round_dfrac : <span>int <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p><code>round_dfrac d x</code> rounds <code>x</code> to the <code>d</code>th <em>decimal</em> fractional digit. Ties are rounded towards positive infinity. If <code>x</code> is an infinity, returns <code>x</code>. The result is only defined for <code>0 &lt;= d &lt;=
      16</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-round_dsig" class="anchored"><a href="#val-round_dsig" class="anchor"></a><code><span><span class="keyword">val</span> round_dsig : <span>int <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p><code>round_dsig d x</code> rounds the normalized <em>decimal</em> significand of <code>x</code> to the <code>d</code>th decimal fractional digit. Ties are rounded towards positive infinity. The result is NaN on infinities. The result only defined for <code>0 &lt;= d &lt;= 16</code>.</p><p><b>Warning.</b> The current implementation overflows on large <code>x</code> and <code>d</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-round_zero" class="anchored"><a href="#val-round_zero" class="anchor"></a><code><span><span class="keyword">val</span> round_zero : <span>eps:float <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p><code>round_zero eps x</code> is <code>0.</code> if <code>abs_float x &lt; eps</code> and <code>x</code> otherwise. The result is undefined if <code>eps</code> is NaN.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-chop" class="anchored"><a href="#val-chop" class="anchor"></a><code><span><span class="keyword">val</span> chop : <span>eps:float <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p><code>chop eps x</code> is <code>round x</code> if <code>abs_float (x -. round x) &lt; eps</code> and <code>x</code> otherwise. The result is undefined if <code>eps</code> is NaN.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sign" class="anchored"><a href="#val-sign" class="anchor"></a><code><span><span class="keyword">val</span> sign : <span>float <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p><code>sign x</code> is <code>1.</code> if <code>x &gt; 0.</code>, <code>0.</code> if <code>x = 0.</code>, <code>-1.</code> if <code>x &lt; 0.</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-sign_bit" class="anchored"><a href="#val-sign_bit" class="anchor"></a><code><span><span class="keyword">val</span> sign_bit : <span>float <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>sign_bit x</code> is <code>true</code> iff the sign bit is set in <code>x</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-succ" class="anchored"><a href="#val-succ" class="anchor"></a><code><span><span class="keyword">val</span> succ : <span>float <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p><code>succ x</code> is the floating point value just after <code>x</code> towards positive infinity. Returns in particular :</p><ul><li>NaN on NaNs.</li><li><code>infinity</code> on <code>infinity</code>.</li><li><code>-max_float</code> on <code>neg_infinity</code>.</li><li><code>min_sub_float</code> on <code>0.</code> <b>or</b> <code>-0.</code>.</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-pred" class="anchored"><a href="#val-pred" class="anchor"></a><code><span><span class="keyword">val</span> pred : <span>float <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p><code>pred x</code> is <code>-. succ (-.x)</code>, i.e. the floating point value before <code>x</code> towards negative infinity.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-nan" class="anchored"><a href="#val-nan" class="anchor"></a><code><span><span class="keyword">val</span> nan : <span>int <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p><code>nan payload</code> is a NaN whose 51 lower significand bits are defined by the 51 lower (or less, as <code>int</code> allows) bits of <code>payload</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-nan_payload" class="anchored"><a href="#val-nan_payload" class="anchor"></a><code><span><span class="keyword">val</span> nan_payload : <span>float <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>nan_payload x</code> is the 51 lower significand bits (or less, as <code>int</code> allows) of the NaN <code>x</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if <code>x</code> is not a NaN.</p></li></ul></div></div><h2 id="preds"><a href="#preds" class="anchor"></a>Predicates and comparisons</h2><div class="odoc-spec"><div class="spec value" id="val-is_zero" class="anchored"><a href="#val-is_zero" class="anchor"></a><code><span><span class="keyword">val</span> is_zero : <span>eps:float <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_zero eps x</code> is <code>true</code> if <code>abs_float x &lt; eps</code> and <code>false</code> otherwise. The result is undefined if <code>eps</code> is NaN.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_nan" class="anchored"><a href="#val-is_nan" class="anchor"></a><code><span><span class="keyword">val</span> is_nan : <span>float <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_nan x</code> is <code>true</code> iff <code>x</code> is a NaN.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_inf" class="anchored"><a href="#val-is_inf" class="anchor"></a><code><span><span class="keyword">val</span> is_inf : <span>float <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_inf x</code> is <code>true</code> iff <code>x</code> is <code>infinity</code> or <code>neg_infinity</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_int" class="anchored"><a href="#val-is_int" class="anchor"></a><code><span><span class="keyword">val</span> is_int : <span>float <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_int x</code> is <code>true</code> iff <code>x</code> is an integer.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-equal" class="anchored"><a href="#val-equal" class="anchor"></a><code><span><span class="keyword">val</span> equal : <span>float <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>equal x y</code> is <code>x = y</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-equal_tol" class="anchored"><a href="#val-equal_tol" class="anchor"></a><code><span><span class="keyword">val</span> equal_tol : <span>eps:float <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>equal_tol eps x y</code> is <code>true</code> iff |<code>x - y</code>| &lt;= <code>eps</code> * max (1,|<code>x</code>|,|<code>y</code>|). On special values the function behaves like <code>compare x y = 0</code>. The condition turns into an absolute tolerance test for small magnitudes and a relative tolerance test for large magnitudes.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-compare" class="anchored"><a href="#val-compare" class="anchor"></a><code><span><span class="keyword">val</span> compare : <span>float <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>compare x y</code> is <code>Pervasives.compare x y</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-compare_tol" class="anchored"><a href="#val-compare_tol" class="anchor"></a><code><span><span class="keyword">val</span> compare_tol : <span>eps:float <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>compare_tol ~eps x y</code> is <code>0</code> iff <code>equal_tol ~eps x y</code> is <code>true</code> and <code>Pervasives.compare x y</code> otherwise.</p></div></div><h2 id="printers"><a href="#printers" class="anchor"></a>Printers</h2><div class="odoc-spec"><div class="spec value" id="val-pp" class="anchored"><a href="#val-pp" class="anchor"></a><code><span><span class="keyword">val</span> pp : <span><a href="../../../ocaml/Stdlib/Format/index.html#type-formatter">Format.formatter</a> <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>pp ppf x</code> prints a lossless textual representation of <code>x</code> on <code>ppf</code>.</p><ul><li>Normals are represented by <code>&quot;[-]0x1.&lt;f&gt;p&lt;e&gt;&quot;</code> where <code>&lt;f&gt;</code> is the significand bits in hexadecimal and <code>&lt;e&gt;</code> the unbiased exponent in decimal.</li><li>Subnormals are represented by <code>&quot;[-]0x0.&lt;f&gt;p-1022&quot;</code> where <code>&lt;f&gt;</code> is the significand bits in hexadecimal.</li><li>NaNs are represented by <code>&quot;[-]nan(0x&lt;p&gt;)&quot;</code> where <code>&lt;p&gt;</code> is the payload in hexadecimal.</li><li>Infinities and zeroes are represented by <code>&quot;[-]inf&quot;</code> and <code>&quot;[-]0.&quot;</code>.</li></ul><p>This format should be compatible with recent implementations of <a href="http://www.opengroup.org/onlinepubs/000095399/functions/strtod.html">strtod</a> and hence with <code>float_of_string</code> (but negative NaNs seem to be problematic to get back).</p></div></div><h2 id="floatrecall"><a href="#floatrecall" class="anchor"></a>Quick recall on OCaml's <code>float</code>s</h2><p>An OCaml <code>float</code> is an <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE-754</a> 64 bit double precision binary floating point number. The 64 bits are laid out as follows :</p><pre>+----------------+-----------------------+-------------------------+
| sign s (1 bit) | exponent e (11 bits)  | significand t (52 bits) |
+----------------+-----------------------+-------------------------+
               63|62                   52|51                      0|</pre><p>The value represented depends on s, e and t :</p><pre>sign   exponent       significand   value represented           meaning
-------------------------------------------------------------------------
s      0              0             -1^s * 0                    zero
s      0              t &lt;&gt; 0        -1^s * 0.t * 2^-1022        subnormal
s      0 &lt; e &lt; 2047   f             -1^s * 1.t * 2^(e - 1023)   normal
s      2047           0             -1^s * infinity             infinity
s      2047           t &lt;&gt; 0        NaN                         not a number</pre><p>There are two zeros, a positive and a negative one but both are deemed equal by <code>=</code> and <code>Pervasives.compare</code>. A NaN is never equal (=) to <em>itself</em> or to another NaN however <code>Pervasives.compare</code> asserts any NaN to be equal to itself and to any other NaN.</p><p>The bit layout of a <code>float</code> can be converted to an <code>int64</code> and back using <code>Int64.bits_of_float</code> and <code>Int64.float_of_bits</code>.</p><p>The bit 51 of a NaN is used to distinguish between quiet (bit set) and signaling NaNs (bit cleared); the remaining 51 lower bits of the significand are the NaN's <em>payload</em> which can be used to store diagnostic information. These features don't seem to used in OCaml.</p><p>The significand of a floating point number is made of 53 binary digits (don't forget the implicit digit), this corresponds to log<sub>10</sub>(2<sup>53</sup>) ~ 16 <em>decimal</em> digits.</p><p>Only <code>float</code> values in the interval ]<code>-2</code><sup>52</sup>;2<sup>52</sup>[ may have a fractional part. <a href="#val-max_frac_float"><code>Float.max_frac_float</code></a> is the greatest positive <code>float</code> with a fractional part.</p><p>Any integer value in the interval [<code>-2</code><sup>53</sup>;2<sup>53</sup>] can be represented exactly by a <code>float</code> value. <em>Integer</em> arithmetic performed in this interval is exact. <a href="#val-max_int_arith"><code>Float.max_int_arith</code></a> is 2<sup>53</sup>.</p></div></body></html>