<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Writer (async_unix.Async_unix__.Writer)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">async_unix</a> &#x00BB; <a href="../index.html">Async_unix__</a> &#x00BB; Writer</nav><h1>Module <code>Async_unix__.Writer</code></h1></header><aside><p><code>Writer</code> is Async's main API for output to a file descriptor. It is the analog of <code>Core.Out_channel</code>.</p><p>Each writer has an internal buffer, to which <code>Writer.write*</code> adds data. Each writer uses an Async cooperative thread that makes <code>write()</code> system calls to move the data from the writer's buffer to an OS buffer via the file descriptor.</p><p>There is no guarantee that the data sync on the other side of the writer can keep up with the rate at which you are writing. If it cannot, the OS buffer will fill up and the writer's cooperative thread will be unable to send any bytes. In that case, calls to <code>Writer.write*</code> will grow the writer's buffer without bound, as long as your program produces data. One solution to this problem is to call <code>Writer.flushed</code> and not continue until that becomes determined, which will only happen once the bytes in the writer's buffer have been successfully transferred to the OS buffer. Another solution is to check <code>Writer.bytes_to_write</code> and not produce any more data if that is beyond some bound.</p><p>There are two kinds of errors that one can handle with writers. First, a writer can be <code>close</code>d, which will cause future <code>write</code>s (and other operations) to synchronously raise an exception. Second, the writer's cooperative thread can fail due to a <code>write()</code> system call failing. This will cause an exception to be sent to the writer's monitor, which will be a child of the monitor in effect when the writer is created. One can deal with such asynchronous exceptions in the usual way, by handling the stream returned by <code>Monitor.detach_and_get_error_stream (Writer.monitor writer)</code>.</p></aside><div class="spec module" id="module-Id"><a href="#module-Id" class="anchor"></a><code><span class="keyword">module</span> <a href="Id/index.html">Id</a> : <a href="../../../core/Core/index.html#module-type-Unique_id">Core.Unique_id</a></code></div><div class="spec module" id="module-Line_ending"><a href="#module-Line_ending" class="anchor"></a><code><span class="keyword">module</span> <a href="Line_ending/index.html">Line_ending</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></span></summary><dl><dt class="spec value" id="val-sexp_of_t"><a href="#val-sexp_of_t" class="anchor"></a><code><span class="keyword">val</span> sexp_of_t : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a></code></dt></dl></details></div></div></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../../../async_kernel/Async_kernel__/Async_invariant/index.html#module-type-S">Async_unix__.Import.Invariant.S</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../../../async_kernel/Async_kernel__/Async_invariant/module-type-S/index.html#type-t">t</a> := <a href="index.html#type-t">t</a></code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt></dl><dl><dt class="spec value" id="val-invariant"><a href="#val-invariant" class="anchor"></a><code><span class="keyword">val</span> invariant : <a href="index.html#type-t">t</a> <a href="../../../base/Base__/Invariant_intf/index.html#type-inv">Base__.Invariant_intf.inv</a></code></dt></dl></details></div></div></div><dl><dt class="spec value" id="val-io_stats"><a href="#val-io_stats" class="anchor"></a><code><span class="keyword">val</span> io_stats : <a href="../../Async_unix/Io_stats/index.html#type-t">Async_unix.Io_stats.t</a></code></dt><dd><p>Overall IO statistics for all writers.</p></dd></dl><dl><dt class="spec value" id="val-stdout"><a href="#val-stdout" class="anchor"></a><code><span class="keyword">val</span> stdout : <a href="index.html#type-t">t</a> <a href="../../../core_kernel/Core_kernel/Lazy/index.html#type-t">Core.Lazy.t</a></code></dt><dd><p><code>stdout</code> and <code>stderr</code> are writers for file descriptors 1 and 2. They are lazy because we don't want to create them in all programs that happen to link with Async.</p><p>When either <code>stdout</code> or <code>stderr</code> is created, they both are created. Furthermore, if they point to the same inode, then they will be the same writer to <code>Fd.stdout</code>. This can be confusing, because <code>fd (force stderr)</code> will be <code>Fd.stdout</code>, not <code>Fd.stderr</code>. And subsequent modifications of <code>Fd.stderr</code> will have no effect on <code>Writer.stderr</code>.</p><p>Unfortunately, the sharing is necessary because Async uses OS threads to do <code>write()</code> syscalls using the writer buffer. When calling a program that redirects stdout and stderr to the same file, as in:</p><pre>      foo.exe &gt;/tmp/z.file 2&gt;&amp;1</pre><p>if <code>Writer.stdout</code> and <code>Writer.stderr</code> weren't the same writer, then they could have threads simultaneously writing to the same file, which could easily cause data loss.</p></dd></dl><dl><dt class="spec value" id="val-stderr"><a href="#val-stderr" class="anchor"></a><code><span class="keyword">val</span> stderr : <a href="index.html#type-t">t</a> <a href="../../../core_kernel/Core_kernel/Lazy/index.html#type-t">Core.Lazy.t</a></code></dt></dl><dl><dt class="spec type" id="type-buffer_age_limit"><a href="#type-buffer_age_limit" class="anchor"></a><code><span class="keyword">type</span> buffer_age_limit</code> = <code>[ </code><table class="variant"><tr id="type-buffer_age_limit.At_most" class="anchored"><td class="def constructor"><a href="#type-buffer_age_limit.At_most" class="anchor"></a><code>| </code><code>`At_most <span class="keyword">of</span> <a href="../../../core_kernel/Core_kernel__Time_intf/module-type-S/Time/Span/index.html#type-t">Core.Time.Span.t</a></code></td></tr><tr id="type-buffer_age_limit.Unlimited" class="anchored"><td class="def constructor"><a href="#type-buffer_age_limit.Unlimited" class="anchor"></a><code>| </code><code>`Unlimited</code></td></tr></table><code> ]</code></dt></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></span></summary><dl><dt class="spec value" id="val-bin_buffer_age_limit"><a href="#val-bin_buffer_age_limit" class="anchor"></a><code><span class="keyword">val</span> bin_buffer_age_limit : <a href="index.html#type-buffer_age_limit">buffer_age_limit</a> <a href="../../../bin_prot/Bin_prot/Type_class/index.html#type-t">Bin_prot.Type_class.t</a></code></dt><dt class="spec value" id="val-bin_read_buffer_age_limit"><a href="#val-bin_read_buffer_age_limit" class="anchor"></a><code><span class="keyword">val</span> bin_read_buffer_age_limit : <a href="index.html#type-buffer_age_limit">buffer_age_limit</a> <a href="../../../bin_prot/Bin_prot/Read/index.html#type-reader">Bin_prot.Read.reader</a></code></dt><dt class="spec value" id="val-__bin_read_buffer_age_limit__"><a href="#val-__bin_read_buffer_age_limit__" class="anchor"></a><code><span class="keyword">val</span> __bin_read_buffer_age_limit__ : (int <span>&#45;&gt;</span> <a href="index.html#type-buffer_age_limit">buffer_age_limit</a>) <a href="../../../bin_prot/Bin_prot/Read/index.html#type-reader">Bin_prot.Read.reader</a></code></dt><dt class="spec value" id="val-bin_reader_buffer_age_limit"><a href="#val-bin_reader_buffer_age_limit" class="anchor"></a><code><span class="keyword">val</span> bin_reader_buffer_age_limit : <a href="index.html#type-buffer_age_limit">buffer_age_limit</a> <a href="../../../bin_prot/Bin_prot/Type_class/index.html#type-reader">Bin_prot.Type_class.reader</a></code></dt><dt class="spec value" id="val-bin_size_buffer_age_limit"><a href="#val-bin_size_buffer_age_limit" class="anchor"></a><code><span class="keyword">val</span> bin_size_buffer_age_limit : <a href="index.html#type-buffer_age_limit">buffer_age_limit</a> <a href="../../../bin_prot/Bin_prot/Size/index.html#type-sizer">Bin_prot.Size.sizer</a></code></dt><dt class="spec value" id="val-bin_write_buffer_age_limit"><a href="#val-bin_write_buffer_age_limit" class="anchor"></a><code><span class="keyword">val</span> bin_write_buffer_age_limit : <a href="index.html#type-buffer_age_limit">buffer_age_limit</a> <a href="../../../bin_prot/Bin_prot/Write/index.html#type-writer">Bin_prot.Write.writer</a></code></dt><dt class="spec value" id="val-bin_writer_buffer_age_limit"><a href="#val-bin_writer_buffer_age_limit" class="anchor"></a><code><span class="keyword">val</span> bin_writer_buffer_age_limit : <a href="index.html#type-buffer_age_limit">buffer_age_limit</a> <a href="../../../bin_prot/Bin_prot/Type_class/index.html#type-writer">Bin_prot.Type_class.writer</a></code></dt><dt class="spec value" id="val-bin_shape_buffer_age_limit"><a href="#val-bin_shape_buffer_age_limit" class="anchor"></a><code><span class="keyword">val</span> bin_shape_buffer_age_limit : <a href="../../../bin_prot/Bin_prot/Shape/index.html#type-t">Bin_prot.Shape.t</a></code></dt><dt class="spec value" id="val-buffer_age_limit_of_sexp"><a href="#val-buffer_age_limit_of_sexp" class="anchor"></a><code><span class="keyword">val</span> buffer_age_limit_of_sexp : <a href="../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a> <span>&#45;&gt;</span> <a href="index.html#type-buffer_age_limit">buffer_age_limit</a></code></dt><dt class="spec value" id="val-__buffer_age_limit_of_sexp__"><a href="#val-__buffer_age_limit_of_sexp__" class="anchor"></a><code><span class="keyword">val</span> __buffer_age_limit_of_sexp__ : <a href="../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a> <span>&#45;&gt;</span> <a href="index.html#type-buffer_age_limit">buffer_age_limit</a></code></dt><dt class="spec value" id="val-sexp_of_buffer_age_limit"><a href="#val-sexp_of_buffer_age_limit" class="anchor"></a><code><span class="keyword">val</span> sexp_of_buffer_age_limit : <a href="index.html#type-buffer_age_limit">buffer_age_limit</a> <span>&#45;&gt;</span> <a href="../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a></code></dt></dl></details></div></div></div><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : ?&#8288;buf_len:int <span>&#45;&gt;</span> ?&#8288;syscall:[ `Per_cycle | `Periodic of <a href="../../../core_kernel/Core_kernel__Time_intf/module-type-S/Time/Span/index.html#type-t">Core.Time.Span.t</a> ] <span>&#45;&gt;</span> ?&#8288;buffer_age_limit:<a href="index.html#type-buffer_age_limit">buffer_age_limit</a> <span>&#45;&gt;</span> ?&#8288;raise_when_consumer_leaves:bool <span>&#45;&gt;</span> ?&#8288;line_ending:<a href="Line_ending/index.html#type-t">Line_ending.t</a> <span>&#45;&gt;</span> <a href="../../Async_unix/Fd/index.html#type-t">Async_unix.Fd.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>create ?buf_len ?syscall ?buffer_age_limit fd</code> creates a new writer. The file descriptor <code>fd</code> should not be in use for writing by anything else.</p><p>By default, a write system call occurs at the end of a cycle in which bytes were written. One can supply <code>~syscall:(`Periodic span)</code> to get better performance. This batches writes together, doing the write system call periodically according to the supplied span.</p><p>A writer can asynchronously fail if the underlying write syscall returns an error, e.g., <code>EBADF</code>, <code>EPIPE</code>, <code>ECONNRESET</code>, ....</p><p><code>buffer_age_limit</code> specifies how backed up you can get before raising an exception. The default is <code>`Unlimited</code> for files, and 2 minutes for other kinds of file descriptors. You can supply <code>`Unlimited</code> to turn off buffer-age checks.</p><p><code>raise_when_consumer_leaves</code> specifies whether the writer should raise an exception when the consumer receiving bytes from the writer leaves, i.e., in Unix, the write syscall returns <code>EPIPE</code> or <code>ECONNRESET</code>. If <code>not raise_when_consumer_leaves</code>, then the writer will silently drop all writes after the consumer leaves, and the writer will eventually fail with a writer-buffer-older-than error if the application remains open long enough.</p><p><code>line_ending</code> determines how <code>newline</code> and <code>write_line</code> terminate lines by default. If <code>line_ending = Unix</code> then end of line is <code>&quot;\n&quot;</code>; if <code>line_ending = Dos</code> then end of line is <code>&quot;\r\n&quot;</code>. Note that <code>line_ending = Dos</code> is not equivalent to opening the file in text mode because any &quot;\n&quot; characters being printed by other means (e.g., <code>write
    &quot;\n&quot;</code>) are still written verbatim (in Unix style).</p></dd></dl><dl><dt class="spec value" id="val-raise_when_consumer_leaves"><a href="#val-raise_when_consumer_leaves" class="anchor"></a><code><span class="keyword">val</span> raise_when_consumer_leaves : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-set_raise_when_consumer_leaves"><a href="#val-set_raise_when_consumer_leaves" class="anchor"></a><code><span class="keyword">val</span> set_raise_when_consumer_leaves : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool <span>&#45;&gt;</span> unit</code></dt><dd><p><code>set_raise_when_consumer_leaves t bool</code> sets the <code>raise_when_consumer_leaves</code> flag of <code>t</code>, which determies how <code>t</code> responds to a write system call raising <code>EPIPE</code> and <code>ECONNRESET</code> (see <code>create</code>).</p></dd></dl><dl><dt class="spec value" id="val-set_buffer_age_limit"><a href="#val-set_buffer_age_limit" class="anchor"></a><code><span class="keyword">val</span> set_buffer_age_limit : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-buffer_age_limit">buffer_age_limit</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>set_buffer_age_limit t buffer_age_limit</code> replaces the existing buffer age limit with the new one. This is useful for stdout and stderr, which are lazily created in a context that does not allow applications to specify <code>buffer_age_limit</code>.</p></dd></dl><dl><dt class="spec value" id="val-consumer_left"><a href="#val-consumer_left" class="anchor"></a><code><span class="keyword">val</span> consumer_left : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>consumer_left t</code> returns a deferred that becomes determined when <code>t</code> attempts to write to a pipe that broke because the consumer on the other side left.</p></dd></dl><dl><dt class="spec value" id="val-of_out_channel"><a href="#val-of_out_channel" class="anchor"></a><code><span class="keyword">val</span> of_out_channel : <a href="../../../stdio/Stdio/Out_channel/index.html#type-t">Core.Out_channel.t</a> <span>&#45;&gt;</span> <a href="../../Async_unix/Fd/Kind/index.html#type-t">Async_unix.Fd.Kind.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-open_file"><a href="#val-open_file" class="anchor"></a><code><span class="keyword">val</span> open_file : ?&#8288;append:bool <span>&#45;&gt;</span> ?&#8288;buf_len:int <span>&#45;&gt;</span> ?&#8288;syscall:[ `Per_cycle | `Periodic of <a href="../../../core_kernel/Core_kernel__Time_intf/module-type-S/Time/Span/index.html#type-t">Core.Time.Span.t</a> ] <span>&#45;&gt;</span> ?&#8288;perm:int <span>&#45;&gt;</span> ?&#8288;line_ending:<a href="Line_ending/index.html#type-t">Line_ending.t</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>open_file file</code> opens <code>file</code> for writing and returns a writer for it. It uses <code>Unix_syscalls.openfile</code> to open the file.</p></dd></dl><dl><dt class="spec value" id="val-with_file"><a href="#val-with_file" class="anchor"></a><code><span class="keyword">val</span> with_file : ?&#8288;perm:int <span>&#45;&gt;</span> ?&#8288;append:bool <span>&#45;&gt;</span> ?&#8288;exclusive:bool <span>&#45;&gt;</span> ?&#8288;line_ending:<a href="Line_ending/index.html#type-t">Line_ending.t</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> f:(<a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>with_file ~file f</code> opens <code>file</code> for writing, creates a writer <code>t</code>, and runs <code>f t</code> to obtain a deferred <code>d</code>. When <code>d</code> becomes determined, the writer is closed. When the close completes, the result of <code>with_file</code> becomes determined with the value of <code>d</code>.</p><p>There is no need to call <code>Writer.flushed</code> to ensure that <code>with_file</code> waits for the writer to be flushed before closing it. <code>Writer.close</code> will already wait for the flush.</p></dd></dl><dl><dt class="spec value" id="val-id"><a href="#val-id" class="anchor"></a><code><span class="keyword">val</span> id : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="Id/index.html#type-t">Id.t</a></code></dt><dd><p><code>id</code> returns an id for this writer that is unique among all other writers.</p></dd></dl><dl><dt class="spec value" id="val-fd"><a href="#val-fd" class="anchor"></a><code><span class="keyword">val</span> fd : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../Async_unix/Fd/index.html#type-t">Async_unix.Fd.t</a></code></dt><dd><p><code>fd</code> returns the <code>Fd.t</code> used to create this writer.</p></dd></dl><dl><dt class="spec value" id="val-set_fd"><a href="#val-set_fd" class="anchor"></a><code><span class="keyword">val</span> set_fd : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../Async_unix/Fd/index.html#type-t">Async_unix.Fd.t</a> <span>&#45;&gt;</span> unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>set_fd t fd</code> sets the <code>fd</code> used by <code>t</code> for its underlying system calls. It first waits until everything being sent to the current <code>fd</code> is flushed. Of course, one must understand how the writer works and what one is doing to use this.</p></dd></dl><dl><dt class="spec value" id="val-write_gen"><a href="#val-write_gen" class="anchor"></a><code><span class="keyword">val</span> write_gen : ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;len:int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> blit_to_bigstring:(<span class="type-var">'a</span>, <a href="../../../core/Core/Bigstring/index.html#type-t">Core.Bigstring.t</a>) <a href="../../../core_kernel/Core_kernel/Blit/index.html#type-blit">Core.Blit.blit</a> <span>&#45;&gt;</span> length:(<span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> unit</code></dt><dd><p><code>write_gen t a</code> writes <code>a</code> to writer <code>t</code>, with <code>length</code> specifying the number of bytes needed and <code>blit_to_bigstring</code> blitting <code>a</code> directly into the <code>t</code>'s buffer. If one has a type that has <code>length</code> and <code>blit_to_bigstring</code> functions, like:</p><pre><code class="ml">module A : sig
  type t
  val length : t -&gt; int
  val blit_to_bigstring : (t, Bigstring.t) Blit.blit
end </code></pre><p>then one can use <code>write_gen</code> to implement a custom analog of <code>Writer.write</code>, like:</p><pre><code class="ml">module Write_a : sig
  val write : ?pos:int -&gt; ?len:int -&gt; A.t -&gt; Writer.t -&gt; unit
end = struct
  let write ?pos ?len a writer =
    Writer.write_gen
      ~length:A.length
      ~blit_to_bigstring:A.blit_to_bigstring
      ?pos ?len writer a
end </code></pre><p>In some cases it may be difficult to write only part of a value:</p><pre><code class="ml">module B : sig
  type t
  val length : t -&gt; int
  val blit_to_bigstring : t -&gt; Bigstring.t -&gt; pos:int -&gt; unit
end </code></pre><p>In these cases, use <code>write_gen_whole</code> instead. It never requires writing only part of a value, although it is potentially less space-efficient. It may waste portions of previously-allocated write buffers if they are too small.</p><pre><code class="ml">module Write_b : sig
  val write : B.t -&gt; Writer.t -&gt; unit
end = struct
  let write b writer =
    Writer.write_gen_whole
      ~length:B.length
      ~blit_to_bigstring:B.blit_to_bigstring
      writer b
end </code></pre><p>Note: <code>write_gen</code> and <code>write_gen_whole</code> give you access to the writer's internal buffer. You should not capture it; doing so might lead to errors of the segfault kind.</p></dd></dl><dl><dt class="spec value" id="val-write_gen_whole"><a href="#val-write_gen_whole" class="anchor"></a><code><span class="keyword">val</span> write_gen_whole : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> blit_to_bigstring:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../../../core/Core/Bigstring/index.html#type-t">Core.Bigstring.t</a> <span>&#45;&gt;</span> pos:int <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> length:(<span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-write_direct"><a href="#val-write_direct" class="anchor"></a><code><span class="keyword">val</span> write_direct : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<a href="../../../core/Core/Bigstring/index.html#type-t">Core.Bigstring.t</a> <span>&#45;&gt;</span> pos:int <span>&#45;&gt;</span> len:int <span>&#45;&gt;</span> <span class="type-var">'a</span> * int) <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt><dd><p><code>write_direct t ~f</code> gives <code>t</code>'s internal buffer to <code>f</code>. <code>pos</code> and <code>len</code> define the portion of the buffer that can be filled. <code>f</code> must return a pair <code>(x, written)</code> where <code>written</code> is the number of bytes written to the buffer at <code>pos</code>. <code>write_direct</code> raises if <code>written &lt; 0 || written &gt; len</code>. <code>write_direct</code> returns <code>Some x</code>, or <code>None</code> if the writer is stopped. By using <code>write_direct</code> only, one can ensure that the writer's internal buffer never grows. Look at the <code>write_direct</code> expect tests for an example of how this can be used to construct a <code>write_string</code> like function that never grows the internal buffer.</p></dd></dl><dl><dt class="spec value" id="val-write_bytes"><a href="#val-write_bytes" class="anchor"></a><code><span class="keyword">val</span> write_bytes : ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;len:int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../core_kernel/Core_kernel/Bytes/index.html#type-t">Core.Bytes.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>write ?pos ?len t s</code> adds a job to the writer's queue of pending writes. The contents of the string are copied to an internal buffer before <code>write</code> returns, so clients can do whatever they want with <code>s</code> after that.</p></dd></dl><dl><dt class="spec value" id="val-write"><a href="#val-write" class="anchor"></a><code><span class="keyword">val</span> write : ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;len:int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-write_bigstring"><a href="#val-write_bigstring" class="anchor"></a><code><span class="keyword">val</span> write_bigstring : ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;len:int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../core/Core/Bigstring/index.html#type-t">Core.Bigstring.t</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-write_iobuf"><a href="#val-write_iobuf" class="anchor"></a><code><span class="keyword">val</span> write_iobuf : ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;len:int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> ([&gt; <a href="../../../core/Core/index.html#type-read">Core.read</a> ], <span class="type-var">_</span>) <a href="../../../core/Core/Iobuf/index.html#type-t">Core.Iobuf.t</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-write_substring"><a href="#val-write_substring" class="anchor"></a><code><span class="keyword">val</span> write_substring : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../core_kernel/Core_kernel/Substring/index.html#type-t">Core.Substring.t</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-write_bigsubstring"><a href="#val-write_bigsubstring" class="anchor"></a><code><span class="keyword">val</span> write_bigsubstring : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../core_kernel/Core_kernel/Bigsubstring/index.html#type-t">Core.Bigsubstring.t</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-writef"><a href="#val-writef" class="anchor"></a><code><span class="keyword">val</span> writef : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, unit, string, unit) <a href="../../../core/Core/index.html#type-format4">Core.format4</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dt class="spec value" id="val-to_formatter"><a href="#val-to_formatter" class="anchor"></a><code><span class="keyword">val</span> to_formatter : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../ocaml/Stdlib/Format/index.html#type-formatter">Stdlib.Format.formatter</a></code></dt><dd><p><code>to_formatter</code> returns an OCaml-formatter that one can print to using <span class="xref-unresolved" title="unresolved reference to &quot;Format.fprintf&quot;"><code>Format</code>.fprintf</span>. Note that flushing the formatter will only submit all buffered data to the writer, but does <em>not</em> guarantee flushing to the operating system.</p></dd></dl><dl><dt class="spec value" id="val-write_char"><a href="#val-write_char" class="anchor"></a><code><span class="keyword">val</span> write_char : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> char <span>&#45;&gt;</span> unit</code></dt><dd><p><code>write_char t c</code> writes the character.</p></dd></dl><dl><dt class="spec value" id="val-newline"><a href="#val-newline" class="anchor"></a><code><span class="keyword">val</span> newline : ?&#8288;line_ending:<a href="Line_ending/index.html#type-t">Line_ending.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>newline t</code> writes the end-of-line terminator. <code>line_ending</code> can override <code>t</code>'s <code>line_ending</code>.</p></dd></dl><dl><dt class="spec value" id="val-write_line"><a href="#val-write_line" class="anchor"></a><code><span class="keyword">val</span> write_line : ?&#8288;line_ending:<a href="Line_ending/index.html#type-t">Line_ending.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> unit</code></dt><dd><p><code>write_line t s ?line_ending</code> is <code>write t s; newline t ?line_ending</code>.</p></dd></dl><dl><dt class="spec value" id="val-write_byte"><a href="#val-write_byte" class="anchor"></a><code><span class="keyword">val</span> write_byte : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p><code>write_byte t i</code> writes one 8-bit integer (as the single character with that code). The given integer is taken modulo 256.</p></dd></dl><div class="spec module" id="module-Terminate_with"><a href="#module-Terminate_with" class="anchor"></a><code><span class="keyword">module</span> <a href="Terminate_with/index.html">Terminate_with</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-write_sexp"><a href="#val-write_sexp" class="anchor"></a><code><span class="keyword">val</span> write_sexp : ?&#8288;hum:bool <span>&#45;&gt;</span> ?&#8288;terminate_with:<a href="Terminate_with/index.html#type-t">Terminate_with.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../core_kernel/Core_kernel/Sexp/index.html#type-t">Core.Sexp.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>write_sexp t sexp</code> writes to <code>t</code> the string representation of <code>sexp</code>, possibly followed by a terminating character as per <code>Terminate_with</code>. With <code>~terminate_with:Newline</code>, the terminating character is a newline. With <code>~terminate_with:Space_if_needed</code>, if a space is needed to ensure that the sexp reader knows that it has reached the end of the sexp, then the terminating character will be a space; otherwise, no terminating character is added. A terminating space is needed if the string representation doesn't end in <code>')'</code> or <code>'&quot;'</code>.</p></dd></dl><dl><dt class="spec value" id="val-write_bin_prot"><a href="#val-write_bin_prot" class="anchor"></a><code><span class="keyword">val</span> write_bin_prot : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../../bin_prot/Bin_prot/Type_class/index.html#type-writer">Bin_prot.Type_class.writer</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>write_bin_prot</code> writes out a value using its bin_prot sizer/writer pair. The format is the &quot;size-prefixed binary protocol&quot;, in which the length of the data is written before the data itself. This is the format that <code>Reader.read_bin_prot</code> reads.</p></dd></dl><dl><dt class="spec value" id="val-write_bin_prot_no_size_header"><a href="#val-write_bin_prot_no_size_header" class="anchor"></a><code><span class="keyword">val</span> write_bin_prot_no_size_header : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> size:int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../../bin_prot/Bin_prot/Write/index.html#type-writer">Bin_prot.Write.writer</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Writes out a value using its bin_prot writer. Unlike <code>write_bin_prot</code>, this doesn't prefix the output with the size of the bin_prot blob. <code>size</code> is the expected size. This function will raise if the bin_prot writer writes an amount other than <code>size</code> bytes.</p></dd></dl><dl><dt class="spec value" id="val-write_marshal"><a href="#val-write_marshal" class="anchor"></a><code><span class="keyword">val</span> write_marshal : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> flags:<a href="../../../ocaml/Stdlib/Marshal/index.html#type-extern_flags">Stdlib.Marshal.extern_flags</a> list <span>&#45;&gt;</span> <span class="type-var">_</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>write_marshal</code> serializes data using <code>marshal</code> and writes it to the writer.</p></dd></dl><aside><p>Unlike the <code>write_</code> functions, all functions starting with <code>schedule_</code> require flushing or closing of the writer after returning before it is safe to modify the bigstrings which were directly or indirectly passed to these functions. The reason is that these bigstrings will be read from directly when writing; their contents is not copied to internal buffers.</p><p>This is important if users need to send the same large data string to a huge number of clients simultaneously (e.g., on a cluster), because these functions then avoid needlessly exhausting memory by sharing the data.</p></aside><dl><dt class="spec value" id="val-schedule_bigstring"><a href="#val-schedule_bigstring" class="anchor"></a><code><span class="keyword">val</span> schedule_bigstring : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;len:int <span>&#45;&gt;</span> <a href="../../../core/Core/Bigstring/index.html#type-t">Core.Bigstring.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>schedule_bigstring t bstr</code> schedules a write of bigstring <code>bstr</code>. It is not safe to change the bigstring until the writer has been successfully flushed or closed after this operation.</p></dd></dl><dl><dt class="spec value" id="val-schedule_bigsubstring"><a href="#val-schedule_bigsubstring" class="anchor"></a><code><span class="keyword">val</span> schedule_bigsubstring : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../core_kernel/Core_kernel/Bigsubstring/index.html#type-t">Core.Bigsubstring.t</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-schedule_iobuf_peek"><a href="#val-schedule_iobuf_peek" class="anchor"></a><code><span class="keyword">val</span> schedule_iobuf_peek : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;len:int <span>&#45;&gt;</span> ([&gt; <a href="../../../core/Core/index.html#type-read">Core.read</a> ], <span class="type-var">_</span>) <a href="../../../core/Core/Iobuf/index.html#type-t">Core.Iobuf.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>schedule_iobuf_peek</code> is like <code>schedule_bigstring</code>, but for an iobuf. It is not safe to change the iobuf until the writer has been successfully flushed or closed after this operation.</p></dd></dl><dl><dt class="spec value" id="val-schedule_iobuf_consume"><a href="#val-schedule_iobuf_consume" class="anchor"></a><code><span class="keyword">val</span> schedule_iobuf_consume : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> ?&#8288;len:int <span>&#45;&gt;</span> ([&gt; <a href="../../../core/Core/index.html#type-read">Core.read</a> ], <a href="../../../core/Core/Iobuf/index.html#type-seek">Core.Iobuf.seek</a>) <a href="../../../core/Core/Iobuf/index.html#type-t">Core.Iobuf.t</a> <span>&#45;&gt;</span> unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>schedule_iobuf_consume</code> is like <code>schedule_iobuf_peek</code>, and additionally advances the iobuf beyond the portion that has been written. Until the result is determined, it is not safe to assume whether the iobuf has been advanced yet or not.</p></dd></dl><dl><dt class="spec value" id="val-schedule_iovec"><a href="#val-schedule_iovec" class="anchor"></a><code><span class="keyword">val</span> schedule_iovec : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../core/Core/Bigstring/index.html#type-t">Core.Bigstring.t</a> <a href="../../../core/Core__Core_unix/IOVec/index.html#type-t">Core.Unix.IOVec.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>schedule_iovec t iovec</code> schedules a write of I/O-vector <code>iovec</code>. It is not safe to change the bigstrings underlying the I/O-vector until the writer has been successfully flushed or closed after this operation.</p></dd></dl><dl><dt class="spec value" id="val-schedule_iovecs"><a href="#val-schedule_iovecs" class="anchor"></a><code><span class="keyword">val</span> schedule_iovecs : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../core/Core/Bigstring/index.html#type-t">Core.Bigstring.t</a> <a href="../../../core/Core__Core_unix/IOVec/index.html#type-t">Core.Unix.IOVec.t</a> <a href="../../../core_kernel/Core_kernel/Queue/index.html#type-t">Core.Queue.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>schedule_iovecs t iovecs</code> like <a href="index.html#val-schedule_iovec"><code>schedule_iovec</code></a>, but takes a whole queue <code>iovecs</code> of I/O-vectors as argument. The queue is guaranteed to be empty when this function returns and can be modified. It is not safe to change the bigstrings underlying the I/O-vectors until the writer has been successfully flushed or closed after this operation.</p></dd></dl><dl><dt class="spec value" id="val-flushed"><a href="#val-flushed" class="anchor"></a><code><span class="keyword">val</span> flushed : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>flushed t</code> returns a deferred that will become determined when all prior writes complete (i.e. the <code>write()</code> system call returns). If a prior write fails, then the deferred will never become determined.</p><p>It is OK to call <code>flushed t</code> after <code>t</code> has been closed.</p></dd></dl><dl><dt class="spec value" id="val-flushed_time"><a href="#val-flushed_time" class="anchor"></a><code><span class="keyword">val</span> flushed_time : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../core/Core__/Core_time_float/index.html#type-t">Core.Time.t</a> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dt class="spec value" id="val-flushed_time_ns"><a href="#val-flushed_time_ns" class="anchor"></a><code><span class="keyword">val</span> flushed_time_ns : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../core/Core__/Core_time_ns/index.html#type-t">Core.Time_ns.t</a> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dt class="spec value" id="val-fsync"><a href="#val-fsync" class="anchor"></a><code><span class="keyword">val</span> fsync : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dt class="spec value" id="val-fdatasync"><a href="#val-fdatasync" class="anchor"></a><code><span class="keyword">val</span> fdatasync : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dt class="spec value" id="val-send"><a href="#val-send" class="anchor"></a><code><span class="keyword">val</span> send : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> unit</code></dt><dd><p><code>send</code> writes a string to the writer that can be read back using <code>Reader.recv</code>.</p></dd></dl><dl><dt class="spec value" id="val-monitor"><a href="#val-monitor" class="anchor"></a><code><span class="keyword">val</span> monitor : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../async_kernel/Async_kernel/Monitor/index.html#type-t">Async_unix__.Import.Monitor.t</a></code></dt><dd><p><code>monitor t</code> returns the writer's monitor.</p></dd></dl><dl><dt class="spec value" id="val-close"><a href="#val-close" class="anchor"></a><code><span class="keyword">val</span> close : ?&#8288;force_close:unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>close ?force_close t</code> waits for the writer to be flushed, and then calls <code>Unix.close</code> on the underlying file descriptor. <code>force_close</code> causes the <code>Unix.close</code> to happen even if the flush hangs. By default <code>force_close</code> is <code>Deferred.never ()</code> for files and <code>after (sec 5)</code> for other types of file descriptors (e.g., sockets). If the close is forced, data in the writer's buffer may not be written to the file descriptor. You can check this by calling <code>bytes_to_write</code> after <code>close</code> finishes.</p><p>WARNING: <code>force_close</code> will not reliably stop any write that is in progress. If there are any in-flight system calls, it will wait for them to finish, which includes <code>writev</code>, which can legitimately block forever.</p><p><code>close</code> will raise an exception if the <code>Unix.close</code> on the underlying file descriptor fails.</p><p>You must call <code>close</code> on a writer in order to close the underlying file descriptor. Not doing so will cause a file descriptor leak. It also will cause a space leak, because until the writer is closed, it is held on to in order to flush the writer on shutdown.</p><p>It is an error to call other operations on <code>t</code> after <code>close t</code> has been called, except that calls of <code>close</code> subsequent to the original call to <code>close</code> will return the same deferred as the original call.</p><p><code>close_started  t</code> becomes determined as soon as <code>close</code> is called.</p><p><code>close_finished t</code> becomes determined after <code>t</code>'s underlying file descriptor has been closed, i.e., it is the same as the result of <code>close</code>. <code>close_finished</code> differs from <code>close</code> in that it does not have the side effect of initiating a close.</p><p><code>is_closed t</code> returns <code>true</code> iff <code>close t</code> has been called.</p><p><code>is_open t</code> is <code>not (is_closed t)</code></p><p><code>with_close t ~f</code> runs <code>f ()</code>, and closes <code>t</code> after <code>f</code> finishes or raises.</p></dd></dl><dl><dt class="spec value" id="val-close_started"><a href="#val-close_started" class="anchor"></a><code><span class="keyword">val</span> close_started : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dt class="spec value" id="val-close_finished"><a href="#val-close_finished" class="anchor"></a><code><span class="keyword">val</span> close_finished : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dt class="spec value" id="val-is_closed"><a href="#val-is_closed" class="anchor"></a><code><span class="keyword">val</span> is_closed : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-is_open"><a href="#val-is_open" class="anchor"></a><code><span class="keyword">val</span> is_open : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-with_close"><a href="#val-with_close" class="anchor"></a><code><span class="keyword">val</span> with_close : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(unit <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dt class="spec value" id="val-can_write"><a href="#val-can_write" class="anchor"></a><code><span class="keyword">val</span> can_write : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>can_write t</code> returns <code>true</code> if calls to <code>write*</code> functions on <code>t</code> are allowed. If <code>is_open t</code> then <code>can_write t</code>. But one can have <code>is_closed t</code> and <code>can_write t</code>, during the time after <code>close t</code> before closing has finished.</p></dd></dl><dl><dt class="spec value" id="val-is_stopped_permanently"><a href="#val-is_stopped_permanently" class="anchor"></a><code><span class="keyword">val</span> is_stopped_permanently : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Errors raised within the writer can stop the background job that flushes out the writer's buffers. <code>is_stopped_permanently</code> returns <code>true</code> when the background job has stopped. <code>stopped_permanently</code> becomes determined when the background job has stopped.</p></dd></dl><dl><dt class="spec value" id="val-stopped_permanently"><a href="#val-stopped_permanently" class="anchor"></a><code><span class="keyword">val</span> stopped_permanently : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dt class="spec value" id="val-with_flushed_at_close"><a href="#val-with_flushed_at_close" class="anchor"></a><code><span class="keyword">val</span> with_flushed_at_close : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> flushed:(unit <span>&#45;&gt;</span> unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a>) <span>&#45;&gt;</span> f:(unit <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p>In addition to flushing its internal buffer prior to closing, a writer keeps track of producers that are feeding it data, so that when <code>Writer.close</code> is called, it does the following:</p><ol><li>requests that the writer's producers flush their data to it</li><li>flushes the writer's internal buffer</li><li>calls <code>Unix.close</code> on the writer's underlying file descriptor</li></ol><p><code>with_flushed_at_close t ~flushed ~f</code> calls <code>f</code> and adds <code>flushed</code> to the set of producers that should be flushed-at-close, for the duration of <code>f</code>.</p></dd></dl><dl><dt class="spec value" id="val-bytes_to_write"><a href="#val-bytes_to_write" class="anchor"></a><code><span class="keyword">val</span> bytes_to_write : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>bytes_to_write t</code> returns how many bytes have been requested to write but have not yet been written.</p></dd></dl><dl><dt class="spec value" id="val-bytes_written"><a href="#val-bytes_written" class="anchor"></a><code><span class="keyword">val</span> bytes_written : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../core_kernel/Core_kernel/Int63/index.html#type-t">Core.Int63.t</a></code></dt><dd><p><code>bytes_written t</code> returns how many bytes have been written.</p></dd></dl><dl><dt class="spec value" id="val-bytes_received"><a href="#val-bytes_received" class="anchor"></a><code><span class="keyword">val</span> bytes_received : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../core_kernel/Core_kernel/Int63/index.html#type-t">Core.Int63.t</a></code></dt><dd><p><code>bytes_received t</code> returns how many bytes have been received by the writer. As long as the writer is running, <code>bytes_received = bytes_written + bytes_to_write</code>.</p></dd></dl><aside><p><code>with_file_atomic ?temp_file ?perm ?fsync file ~f</code> creates a writer to a temp file, feeds that writer to <code>f</code>, and when the result of <code>f</code> becomes determined, atomically moves (using <code>Unix.rename</code>) the temp file to <code>file</code>. If <code>file</code> currently exists, it will be replaced, even if it is read-only. The temp file will be <code>file</code> (or <code>temp_file</code> if supplied) suffixed by a unique random sequence of six characters. The temp file may need to be removed in case of a crash so it may be prudent to choose a temp file that can be easily found by cleanup tools.</p><p>If <code>fsync</code> is <code>true</code>, the temp file will be flushed to disk before it takes the place of the target file, thus guaranteeing that the target file will always be in a sound state, even after a machine crash. Since synchronization is extremely slow, this is not the default. Think carefully about the event of machine crashes and whether you may need this option!</p><p>We intend for <code>with_file_atomic</code> to preserve the behavior of the <code>open</code> system call, so if <code>file</code> does not exist, we will apply the umask to <code>perm</code>. If <code>file</code> does exist, <code>perm</code> will default to the file's current permissions rather than 0o666.</p><p><code>save</code> is a special case of <code>with_file_atomic</code> that atomically writes the given string to the specified file.</p><p><code>save_sexp</code> is a special case of <code>with_file_atomic</code> that atomically writes the given sexp to the specified file.</p></aside><dl><dt class="spec value" id="val-with_file_atomic"><a href="#val-with_file_atomic" class="anchor"></a><code><span class="keyword">val</span> with_file_atomic : ?&#8288;temp_file:string <span>&#45;&gt;</span> ?&#8288;perm:<a href="../../../core/Core__/Core_unix/index.html#type-file_perm">Core.Unix.file_perm</a> <span>&#45;&gt;</span> ?&#8288;fsync:bool <span>&#45;&gt;</span> string <span>&#45;&gt;</span> f:(<a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dt class="spec value" id="val-save"><a href="#val-save" class="anchor"></a><code><span class="keyword">val</span> save : ?&#8288;temp_file:string <span>&#45;&gt;</span> ?&#8288;perm:<a href="../../../core/Core__/Core_unix/index.html#type-file_perm">Core.Unix.file_perm</a> <span>&#45;&gt;</span> ?&#8288;fsync:bool <span>&#45;&gt;</span> string <span>&#45;&gt;</span> contents:string <span>&#45;&gt;</span> unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dt class="spec value" id="val-save_lines"><a href="#val-save_lines" class="anchor"></a><code><span class="keyword">val</span> save_lines : ?&#8288;temp_file:string <span>&#45;&gt;</span> ?&#8288;perm:<a href="../../../core/Core__/Core_unix/index.html#type-file_perm">Core.Unix.file_perm</a> <span>&#45;&gt;</span> ?&#8288;fsync:bool <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string list <span>&#45;&gt;</span> unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>save_lines file lines</code> writes all lines in <code>lines</code> to <code>file</code>, with each line followed by a newline.</p></dd></dl><dl><dt class="spec value" id="val-save_sexp"><a href="#val-save_sexp" class="anchor"></a><code><span class="keyword">val</span> save_sexp : ?&#8288;temp_file:string <span>&#45;&gt;</span> ?&#8288;perm:<a href="../../../core/Core__/Core_unix/index.html#type-file_perm">Core.Unix.file_perm</a> <span>&#45;&gt;</span> ?&#8288;fsync:bool <span>&#45;&gt;</span> ?&#8288;hum:bool <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="../../../core_kernel/Core_kernel/Sexp/index.html#type-t">Core.Sexp.t</a> <span>&#45;&gt;</span> unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>save_sexp t sexp</code> writes <code>sexp</code> to <code>t</code>, followed by a newline. To read a file produced using <code>save_sexp</code>, one would typically use <code>Reader.load_sexp</code>, which deals with the additional whitespace and works nicely with converting the sexp to a value.</p></dd></dl><dl><dt class="spec value" id="val-save_sexps"><a href="#val-save_sexps" class="anchor"></a><code><span class="keyword">val</span> save_sexps : ?&#8288;temp_file:string <span>&#45;&gt;</span> ?&#8288;perm:<a href="../../../core/Core__/Core_unix/index.html#type-file_perm">Core.Unix.file_perm</a> <span>&#45;&gt;</span> ?&#8288;fsync:bool <span>&#45;&gt;</span> ?&#8288;hum:bool <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="../../../core_kernel/Core_kernel/Sexp/index.html#type-t">Core.Sexp.t</a> list <span>&#45;&gt;</span> unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>save_sexps</code> works similarly to <code>save_sexp</code>, but saves a sequence of sexps instead, separated by newlines. There is a corresponding <code>Reader.load_sexps</code> for reading back in.</p></dd></dl><dl><dt class="spec value" id="val-save_bin_prot"><a href="#val-save_bin_prot" class="anchor"></a><code><span class="keyword">val</span> save_bin_prot : ?&#8288;temp_file:string <span>&#45;&gt;</span> ?&#8288;perm:<a href="../../../core/Core__/Core_unix/index.html#type-file_perm">Core.Unix.file_perm</a> <span>&#45;&gt;</span> ?&#8288;fsync:bool <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../../bin_prot/Bin_prot/Type_class/index.html#type-writer">Bin_prot.Type_class.writer</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>save_bin_prot t bin_writer 'a</code> writes <code>'a</code> to <code>t</code> using its bin_writer, in the size-prefixed format, like <code>write_bin_prot</code>. To read a file produced using <code>save_bin_prot</code>, one would typically use <code>Reader.load_bin_prot</code>.</p></dd></dl><dl><dt class="spec value" id="val-transfer'"><a href="#val-transfer'" class="anchor"></a><code><span class="keyword">val</span> transfer' : ?&#8288;stop:unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a> <span>&#45;&gt;</span> ?&#8288;max_num_values_per_read:int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel__Pipe/Reader/index.html#type-t">Async_unix__.Import.Pipe.Reader.t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <a href="../../../core_kernel/Core_kernel/Queue/index.html#type-t">Core.Queue.t</a> <span>&#45;&gt;</span> unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a>) <span>&#45;&gt;</span> unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>transfer' t pipe_r f</code> repeatedly reads values from <code>pipe_r</code> and feeds them to <code>f</code>, which should in turn write them to <code>t</code>. It provides pushback to <code>pipe_r</code> by not reading when <code>t</code> cannot keep up with the data being pushed in.</p><p>By default, each read from <code>pipe_r</code> reads all the values in <code>pipe_r</code>. One can supply <code>max_num_values_per_read</code> to limit the number of values per read.</p><p>The <code>transfer'</code> stops and the result becomes determined when <code>stop</code> becomes determined, when <code>pipe_r</code> reaches its EOF, when <code>t</code> is closed, or when <code>t</code>'s consumer leaves. In the latter two cases, <code>transfer'</code> closes <code>pipe_r</code>.</p><p><code>transfer'</code> causes <code>Pipe.flushed</code> on <code>pipe_r</code>'s writer to ensure that the bytes have been flushed to <code>t</code> before returning. It also waits on <code>Pipe.upstream_flushed</code> at shutdown.</p><p><code>transfer t pipe_r f</code> is equivalent to:</p><pre><code class="ml">transfer' t pipe_r (fun q -&gt; Queue.iter q ~f; return ()) </code></pre></dd></dl><dl><dt class="spec value" id="val-transfer"><a href="#val-transfer" class="anchor"></a><code><span class="keyword">val</span> transfer : ?&#8288;stop:unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a> <span>&#45;&gt;</span> ?&#8288;max_num_values_per_read:int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel__Pipe/Reader/index.html#type-t">Async_unix__.Import.Pipe.Reader.t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dt class="spec value" id="val-pipe"><a href="#val-pipe" class="anchor"></a><code><span class="keyword">val</span> pipe : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string <a href="../../../async_kernel/Async_kernel__Pipe/Writer/index.html#type-t">Async_unix__.Import.Pipe.Writer.t</a></code></dt><dd><p><code>pipe t</code> returns the writing end of a pipe attached to <code>t</code> that pushes back when <code>t</code> cannot keep up with the data being pushed in. Closing the pipe does not close <code>t</code>.</p></dd></dl><dl><dt class="spec value" id="val-of_pipe"><a href="#val-of_pipe" class="anchor"></a><code><span class="keyword">val</span> of_pipe : <a href="../../../core_kernel/Core_kernel/Info/index.html#type-t">Core.Info.t</a> <span>&#45;&gt;</span> string <a href="../../../async_kernel/Async_kernel__Pipe/Writer/index.html#type-t">Async_unix__.Import.Pipe.Writer.t</a> <span>&#45;&gt;</span> (<a href="index.html#type-t">t</a> * [ `Closed_and_flushed_downstream of unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a> ]) <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>of_pipe info pipe_w</code> returns a writer <code>t</code> such that data written to <code>t</code> will appear on <code>pipe_w</code>. If either <code>t</code> or <code>pipe_w</code> are closed, the other is closed as well.</p><p><code>of_pipe</code> is implemented by attaching <code>t</code> to the write-end of a Unix pipe, and shuttling bytes from the read-end of the Unix pipe to <code>pipe_w</code>.</p></dd></dl><dl><dt class="spec value" id="val-behave_nicely_in_pipeline"><a href="#val-behave_nicely_in_pipeline" class="anchor"></a><code><span class="keyword">val</span> behave_nicely_in_pipeline : ?&#8288;writers:<a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> unit</code></dt><dd><p><code>behave_nicely_in_pipeline ~writers ()</code> causes the program to silently exit with status 0 if any of the consumers of <code>writers</code> go away. It also sets the buffer age to unlimited, in case there is a human (e.g., using <code>less</code>) on the other side of the pipeline.</p></dd></dl><dl><dt class="spec value" id="val-set_synchronous_out_channel"><a href="#val-set_synchronous_out_channel" class="anchor"></a><code><span class="keyword">val</span> set_synchronous_out_channel : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../stdio/Stdio/Out_channel/index.html#type-t">Core.Out_channel.t</a> <span>&#45;&gt;</span> unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>set_synchronous_out_channel t out_channel</code> causes all future writes to <code>t</code> to synchronously call <code>Out_channel.output*</code> functions to send data to the OS immediately. Any writes that were called prior to setting the <code>out_channel</code> will be <code>flushed</code>. <code>clear_synchronous_out_channel t</code> makes writes buffered and asynchronous again.</p><p><code>set_synchronous_out_channel</code> is used by expect tests to ensure that the interleaving between calls to <code>Core.printf</code> (and similar IO functions) and <code>Async.printf</code> generates output with the same interleaving. <code>{set,clear}_synchronous_out_channel</code> are idempotent.</p></dd></dl><dl><dt class="spec value" id="val-clear_synchronous_out_channel"><a href="#val-clear_synchronous_out_channel" class="anchor"></a><code><span class="keyword">val</span> clear_synchronous_out_channel : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>clear_synchronous_out_channel t</code> restores <code>t</code> to its normal state, with the background writer asynchronously feeding data to the OS.</p></dd></dl><dl><dt class="spec value" id="val-with_synchronous_out_channel"><a href="#val-with_synchronous_out_channel" class="anchor"></a><code><span class="keyword">val</span> with_synchronous_out_channel : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../stdio/Stdio/Out_channel/index.html#type-t">Core.Out_channel.t</a> <span>&#45;&gt;</span> f:(unit <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt></dl></div></body></html>