<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Lwt_io (lwt.Lwt_io)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">lwt</a> &#x00BB; Lwt_io</nav><header class="odoc-preamble"><h1>Module <code><span>Lwt_io</span></code></h1><p>Buffered byte channels</p></header><nav class="odoc-toc"><ul><li><a href="#types">Types</a></li><li><a href="#well-known-instances">Well-known instances</a></li><li><a href="#channels-creation/manipulation">Channels creation/manipulation</a></li><li><a href="#random-access">Random access</a></li><li><a href="#reading">Reading</a></li><li><a href="#writing">Writing</a></li><li><a href="#printing">Printing</a></li><li><a href="#utilities">Utilities</a></li><li><a href="#file-utilities">File utilities</a></li><li><a href="#input/output-of-integers">Input/output of integers</a></li><li><a href="#low-level-access-to-the-internal-buffer">Low-level access to the internal buffer</a></li><li><a href="#misc">Misc</a></li><li><a href="#deprecated">Deprecated</a></li></ul></nav><div class="odoc-content"><p>A <b>channel</b> is a high-level object for performing input/output (IO). It allows to read/write from/to the outside world in an efficient way, by minimising the number of system calls.</p><p>An <b>output channel</b> is used to send data and an <b>input channel</b> is used to receive data.</p><p>If you are familiar with buffered channels you may be familiar too with the <b>flush</b> operation. Note that byte channels of this module are automatically flushed when there is nothing else to do (i.e. before the program becomes idle), so this means that you no longer have to write:</p><pre><code>eprintf &quot;log message\n&quot;;
flush stderr;</code></pre><p>to have your messages displayed.</p><p>Note about errors: input functions of this module raise <code>End_of_file</code> when the end-of-file is reached (i.e. when the read function returns <code>0</code>). Other exceptions are ones caused by the backend read/write functions, such as <code>Unix.Unix_error</code>.</p><div class="odoc-spec"><div class="spec exception" id="exception-Channel_closed" class="anchored"><a href="#exception-Channel_closed" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Channel_closed</span> <span class="keyword">of</span> string</span></code></div><div class="spec-doc"><p>Exception raised when a channel is closed. The parameter is a description of the channel.</p></div></div><h3 id="types"><a href="#types" class="anchor"></a>Types</h3><div class="odoc-spec"><div class="spec type" id="type-channel" class="anchored"><a href="#type-channel" class="anchor"></a><code><span><span class="keyword">type</span> <span>'mode channel</span></span></code></div><div class="spec-doc"><p>Type of buffered byte channels</p></div></div><div class="odoc-spec"><div class="spec type" id="type-input" class="anchored"><a href="#type-input" class="anchor"></a><code><span><span class="keyword">type</span> input</span></code></div><div class="spec-doc"><p>Input mode</p></div></div><div class="odoc-spec"><div class="spec type" id="type-output" class="anchored"><a href="#type-output" class="anchor"></a><code><span><span class="keyword">type</span> output</span></code></div><div class="spec-doc"><p>Output mode</p></div></div><div class="odoc-spec"><div class="spec type" id="type-mode" class="anchored"><a href="#type-mode" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a mode</span></span><span> = </span></code><table><tr id="type-mode.Input" class="anchored"><td class="def variant constructor"><a href="#type-mode.Input" class="anchor"></a><code><span>| </span><span><span class="constructor">Input</span> : <span><a href="#type-input">input</a> <a href="#type-mode">mode</a></span></span></code></td></tr><tr id="type-mode.Output" class="anchored"><td class="def variant constructor"><a href="#type-mode.Output" class="anchor"></a><code><span>| </span><span><span class="constructor">Output</span> : <span><a href="#type-output">output</a> <a href="#type-mode">mode</a></span></span></code></td></tr></table></div><div class="spec-doc"><p>Channel mode</p></div></div><div class="odoc-spec"><div class="spec value" id="val-input" class="anchored"><a href="#val-input" class="anchor"></a><code><span><span class="keyword">val</span> input : <span><a href="#type-input">input</a> <a href="#type-mode">mode</a></span></span></code></div><div class="spec-doc"><p><code>input</code> input mode representation</p></div></div><div class="odoc-spec"><div class="spec value" id="val-output" class="anchored"><a href="#val-output" class="anchor"></a><code><span><span class="keyword">val</span> output : <span><a href="#type-output">output</a> <a href="#type-mode">mode</a></span></span></code></div><div class="spec-doc"><p><code>output</code> output mode representation</p></div></div><div class="odoc-spec"><div class="spec type" id="type-input_channel" class="anchored"><a href="#type-input_channel" class="anchor"></a><code><span><span class="keyword">type</span> input_channel</span><span> = <span><a href="#type-input">input</a> <a href="#type-channel">channel</a></span></span></code></div><div class="spec-doc"><p>Type of input channels</p></div></div><div class="odoc-spec"><div class="spec type" id="type-output_channel" class="anchored"><a href="#type-output_channel" class="anchor"></a><code><span><span class="keyword">type</span> output_channel</span><span> = <span><a href="#type-output">output</a> <a href="#type-channel">channel</a></span></span></code></div><div class="spec-doc"><p>Type of output channels</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mode" class="anchored"><a href="#val-mode" class="anchor"></a><code><span><span class="keyword">val</span> mode : <span><span><span class="type-var">'a</span> <a href="#type-channel">channel</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-mode">mode</a></span></span></code></div><div class="spec-doc"><p><code>mode ch</code> returns the mode of a channel</p></div></div><h3 id="well-known-instances"><a href="#well-known-instances" class="anchor"></a>Well-known instances</h3><div class="odoc-spec"><div class="spec value" id="val-stdin" class="anchored"><a href="#val-stdin" class="anchor"></a><code><span><span class="keyword">val</span> stdin : <a href="#type-input_channel">input_channel</a></span></code></div><div class="spec-doc"><p>The standard input, it reads data from <a href="../Lwt_unix/index.html#val-stdin"><code>Lwt_unix.stdin</code></a></p></div></div><div class="odoc-spec"><div class="spec value" id="val-stdout" class="anchored"><a href="#val-stdout" class="anchor"></a><code><span><span class="keyword">val</span> stdout : <a href="#type-output_channel">output_channel</a></span></code></div><div class="spec-doc"><p>The standard output, it writes data to <a href="../Lwt_unix/index.html#val-stdout"><code>Lwt_unix.stdout</code></a></p></div></div><div class="odoc-spec"><div class="spec value" id="val-stderr" class="anchored"><a href="#val-stderr" class="anchor"></a><code><span><span class="keyword">val</span> stderr : <a href="#type-output_channel">output_channel</a></span></code></div><div class="spec-doc"><p>The standard output for error messages, it writes data to <a href="../Lwt_unix/index.html#val-stderr"><code>Lwt_unix.stderr</code></a></p></div></div><div class="odoc-spec"><div class="spec value" id="val-zero" class="anchored"><a href="#val-zero" class="anchor"></a><code><span><span class="keyword">val</span> zero : <a href="#type-input_channel">input_channel</a></span></code></div><div class="spec-doc"><p>Inputs which returns always <code>'\x00'</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-null" class="anchored"><a href="#val-null" class="anchor"></a><code><span><span class="keyword">val</span> null : <a href="#type-output_channel">output_channel</a></span></code></div><div class="spec-doc"><p>Output which drops everything</p></div></div><h3 id="channels-creation/manipulation"><a href="#channels-creation/manipulation" class="anchor"></a>Channels creation/manipulation</h3><div class="odoc-spec"><div class="spec value" id="val-pipe" class="anchored"><a href="#val-pipe" class="anchor"></a><code><span><span class="keyword">val</span> pipe : <span>?in_buffer:<a href="../Lwt_bytes/index.html#type-t">Lwt_bytes.t</a> <span class="arrow">&#45;&gt;</span></span> <span>?out_buffer:<a href="../Lwt_bytes/index.html#type-t">Lwt_bytes.t</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-input_channel">input_channel</a> * <a href="#type-output_channel">output_channel</a></span></code></div><div class="spec-doc"><p><code>pipe ?in_buffer ?out_buffer ()</code> creates a pipe using <a href="../Lwt_unix/index.html#val-pipe"><code>Lwt_unix.pipe</code></a> and makes two channels from the two returned file descriptors</p></div></div><div class="odoc-spec"><div class="spec value" id="val-make" class="anchored"><a href="#val-make" class="anchor"></a><code><span><span class="keyword">val</span> make : <span>?buffer:<a href="../Lwt_bytes/index.html#type-t">Lwt_bytes.t</a> <span class="arrow">&#45;&gt;</span></span> <span>?close:<span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>?seek:<span>(<span>int64 <span class="arrow">&#45;&gt;</span></span> <span><a href="../../ocaml/Unix/index.html#type-seek_command">Unix.seek_command</a> <span class="arrow">&#45;&gt;</span></span> <span>int64 <a href="../Lwt/index.html#type-t">Lwt.t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span>
<span>mode:<span><span class="type-var">'mode</span> <a href="#type-mode">mode</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><a href="../Lwt_bytes/index.html#type-t">Lwt_bytes.t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <a href="../Lwt/index.html#type-t">Lwt.t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'mode</span> <a href="#type-channel">channel</a></span></span></code></div><div class="spec-doc"><p><code>make ?buffer ?close ~mode perform_io</code> is the main function for creating new channels.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">buffer</span> <p>user-supplied buffer. When this argument is present, its value will be used as the buffer for the created channel. The size of buffer must conform to the limitations described in <code>set_default_buffer_size</code>. When this argument is not present, a new internal buffer of default size will be allocated for this channel.</p><p>Warning: do not use the same buffer for simultaneous work with more than one channel.</p><p>There are other functions in this module that take a <code>buffer</code> argument, sharing the same semantics.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">close</span> <p>close function of the channel. It defaults to <code>Lwt.return</code></p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">seek</span> <p>same meaning as <code>Unix.lseek</code></p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">mode</span> <p>either <code>input</code> or <code>output</code></p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">perform_io</span> <p>is the read or write function. It is called when more input is needed or when the buffer need to be flushed.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-of_bytes" class="anchored"><a href="#val-of_bytes" class="anchor"></a><code><span><span class="keyword">val</span> of_bytes : <span>mode:<span><span class="type-var">'mode</span> <a href="#type-mode">mode</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Lwt_bytes/index.html#type-t">Lwt_bytes.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'mode</span> <a href="#type-channel">channel</a></span></span></code></div><div class="spec-doc"><p>Create a channel from a byte array. Reading/writing is done directly on the provided array.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_fd" class="anchored"><a href="#val-of_fd" class="anchor"></a><code><span><span class="keyword">val</span> of_fd : <span>?buffer:<a href="../Lwt_bytes/index.html#type-t">Lwt_bytes.t</a> <span class="arrow">&#45;&gt;</span></span> <span>?close:<span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>mode:<span><span class="type-var">'mode</span> <a href="#type-mode">mode</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Lwt_unix/index.html#type-file_descr">Lwt_unix.file_descr</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'mode</span> <a href="#type-channel">channel</a></span></span></code></div><div class="spec-doc"><p><code>of_fd ?buffer ?close ~mode fd</code> creates a channel from a file descriptor.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">close</span> <p>defaults to closing the file descriptor.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-of_unix_fd" class="anchored"><a href="#val-of_unix_fd" class="anchor"></a><code><span><span class="keyword">val</span> of_unix_fd : <span>?buffer:<a href="../Lwt_bytes/index.html#type-t">Lwt_bytes.t</a> <span class="arrow">&#45;&gt;</span></span> <span>?close:<span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>mode:<span><span class="type-var">'mode</span> <a href="#type-mode">mode</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../ocaml/Unix/index.html#type-file_descr">Unix.file_descr</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'mode</span> <a href="#type-channel">channel</a></span></span></code></div><div class="spec-doc"><p><code>of_unix_fd ?buffer ?close ~mode fd</code> is a short-hand for:</p><p><code>of_fd ?buffer ?close (Lwt_unix.of_unix_file_descr fd)</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-close" class="anchored"><a href="#val-close" class="anchor"></a><code><span><span class="keyword">val</span> close : <span><span><span class="type-var">'a</span> <a href="#type-channel">channel</a></span> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>close ch</code> closes the given channel. If <code>ch</code> is an output channel, it performs all pending actions, flushes it and closes it. If <code>ch</code> is an input channel, it just closes it immediately.</p><p><code>close</code> returns the result of the close function of the channel. Multiple calls to <code>close</code> will return exactly the same value.</p><p>Note: you cannot use <code>close</code> on channels obtained with <a href="#val-atomic"><code>atomic</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-abort" class="anchored"><a href="#val-abort" class="anchor"></a><code><span><span class="keyword">val</span> abort : <span><span><span class="type-var">'a</span> <a href="#type-channel">channel</a></span> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>abort ch</code> abort current operations and close the channel immediately.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-atomic" class="anchored"><a href="#val-atomic" class="anchor"></a><code><span><span class="keyword">val</span> atomic : <span><span>(<span><span><span class="type-var">'a</span> <a href="#type-channel">channel</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="../Lwt/index.html#type-t">Lwt.t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-channel">channel</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>atomic f</code> transforms a sequence of io operations into one single atomic io operation.</p><p>Note:</p><ul><li>the channel passed to <code>f</code> is invalid after <code>f</code> terminates</li><li><code>atomic</code> can be called inside another <code>atomic</code></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-file_length" class="anchored"><a href="#val-file_length" class="anchor"></a><code><span><span class="keyword">val</span> file_length : <span>string <span class="arrow">&#45;&gt;</span></span> <span>int64 <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p>Retrieves the length of the file at the given path. If the path refers to a directory, the returned promise is rejected with <code>Unix.(Unix_error (EISDIR, _, _))</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-buffered" class="anchored"><a href="#val-buffered" class="anchor"></a><code><span><span class="keyword">val</span> buffered : <span><span><span class="type-var">'a</span> <a href="#type-channel">channel</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>buffered oc</code> returns the number of bytes in the buffer</p></div></div><div class="odoc-spec"><div class="spec value" id="val-flush" class="anchored"><a href="#val-flush" class="anchor"></a><code><span><span class="keyword">val</span> flush : <span><a href="#type-output_channel">output_channel</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>flush oc</code> performs all pending writes on <code>oc</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-flush_all" class="anchored"><a href="#val-flush_all" class="anchor"></a><code><span><span class="keyword">val</span> flush_all : <span>unit <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>flush_all ()</code> flushes all open output channels</p></div></div><div class="odoc-spec"><div class="spec value" id="val-buffer_size" class="anchored"><a href="#val-buffer_size" class="anchor"></a><code><span><span class="keyword">val</span> buffer_size : <span><span><span class="type-var">'a</span> <a href="#type-channel">channel</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Returns the size of the internal buffer.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-resize_buffer" class="anchored"><a href="#val-resize_buffer" class="anchor"></a><code><span><span class="keyword">val</span> resize_buffer : <span><span><span class="type-var">'a</span> <a href="#type-channel">channel</a></span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p>Resize the internal buffer to the given size</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_busy" class="anchored"><a href="#val-is_busy" class="anchor"></a><code><span><span class="keyword">val</span> is_busy : <span><span><span class="type-var">'a</span> <a href="#type-channel">channel</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_busy channel</code> returns whether the given channel is currently busy. A channel is busy when there is at least one job using it that has not yet terminated.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_closed" class="anchored"><a href="#val-is_closed" class="anchor"></a><code><span><span class="keyword">val</span> is_closed : <span><span><span class="type-var">'a</span> <a href="#type-channel">channel</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_closed channel</code> returns whether the given channel is currently closed.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.2.0</li></ul></div></div><h3 id="random-access"><a href="#random-access" class="anchor"></a>Random access</h3><div class="odoc-spec"><div class="spec value" id="val-position" class="anchored"><a href="#val-position" class="anchor"></a><code><span><span class="keyword">val</span> position : <span><span><span class="type-var">'a</span> <a href="#type-channel">channel</a></span> <span class="arrow">&#45;&gt;</span></span> int64</span></code></div><div class="spec-doc"><p><code>position ch</code> Returns the current position in the channel.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_position" class="anchored"><a href="#val-set_position" class="anchor"></a><code><span><span class="keyword">val</span> set_position : <span><span><span class="type-var">'a</span> <a href="#type-channel">channel</a></span> <span class="arrow">&#45;&gt;</span></span> <span>int64 <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>set_position ch pos</code> Sets the position in the output channel. This does not work if the channel does not support random access.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-length" class="anchored"><a href="#val-length" class="anchor"></a><code><span><span class="keyword">val</span> length : <span><span><span class="type-var">'a</span> <a href="#type-channel">channel</a></span> <span class="arrow">&#45;&gt;</span></span> <span>int64 <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p>Returns the length of the channel in bytes</p></div></div><h3 id="reading"><a href="#reading" class="anchor"></a>Reading</h3><p>Note: except for functions dealing with streams (<a href="#val-read_chars"><code>read_chars</code></a> and <a href="#val-read_lines"><code>read_lines</code></a>) all functions are <b>atomic</b>.</p><div class="odoc-spec"><div class="spec value" id="val-read_char" class="anchored"><a href="#val-read_char" class="anchor"></a><code><span><span class="keyword">val</span> read_char : <span><a href="#type-input_channel">input_channel</a> <span class="arrow">&#45;&gt;</span></span> <span>char <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>read_char ic</code> reads the next character of <code>ic</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">End_of_file</span> <p>if the end of the file is reached</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-read_char_opt" class="anchored"><a href="#val-read_char_opt" class="anchor"></a><code><span><span class="keyword">val</span> read_char_opt : <span><a href="#type-input_channel">input_channel</a> <span class="arrow">&#45;&gt;</span></span> <span><span>char option</span> <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p>Same as <a href="#val-read_char"><code>Lwt_io.read_char</code></a>, but does not raise <code>End_of_file</code> on end of input</p></div></div><div class="odoc-spec"><div class="spec value" id="val-read_chars" class="anchored"><a href="#val-read_chars" class="anchor"></a><code><span><span class="keyword">val</span> read_chars : <span><a href="#type-input_channel">input_channel</a> <span class="arrow">&#45;&gt;</span></span> <span>char <a href="../Lwt_stream/index.html#type-t">Lwt_stream.t</a></span></span></code></div><div class="spec-doc"><p><code>read_chars ic</code> returns a stream holding all characters of <code>ic</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-read_line" class="anchored"><a href="#val-read_line" class="anchor"></a><code><span><span class="keyword">val</span> read_line : <span><a href="#type-input_channel">input_channel</a> <span class="arrow">&#45;&gt;</span></span> <span>string <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>read_line ic</code> reads one complete line from <code>ic</code> and returns it without the end of line. End of line is either <code>&quot;\n&quot;</code> or <code>&quot;\r\n&quot;</code>.</p><p>If the end of input is reached before reading any character, <code>End_of_file</code> is raised. If it is reached before reading an end of line but characters have already been read, they are returned.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-read_line_opt" class="anchored"><a href="#val-read_line_opt" class="anchor"></a><code><span><span class="keyword">val</span> read_line_opt : <span><a href="#type-input_channel">input_channel</a> <span class="arrow">&#45;&gt;</span></span> <span><span>string option</span> <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p>Same as <a href="#val-read_line"><code>read_line</code></a> but do not raise <code>End_of_file</code> on end of input.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-read_lines" class="anchored"><a href="#val-read_lines" class="anchor"></a><code><span><span class="keyword">val</span> read_lines : <span><a href="#type-input_channel">input_channel</a> <span class="arrow">&#45;&gt;</span></span> <span>string <a href="../Lwt_stream/index.html#type-t">Lwt_stream.t</a></span></span></code></div><div class="spec-doc"><p><code>read_lines ic</code> returns a stream holding all lines of <code>ic</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-read" class="anchored"><a href="#val-read" class="anchor"></a><code><span><span class="keyword">val</span> read : <span>?count:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-input_channel">input_channel</a> <span class="arrow">&#45;&gt;</span></span> <span>string <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p>If <code>~count</code> is specified, <code>read ~count ic</code> reads at most <code>~count</code> bytes from <code>ic</code> in one read operation. Note that fewer than <code>~count</code> bytes can be read. This can happen for multiple reasons, including end of input, or no more data currently available. Check the size of the resulting string. <code>read</code> resolves with <code>&quot;&quot;</code> if the input channel is already at the end of input.</p><p>If <code>~count</code> is not specified, <code>read ic</code> reads all bytes until the end of input.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-read_into" class="anchored"><a href="#val-read_into" class="anchor"></a><code><span><span class="keyword">val</span> read_into : <span><a href="#type-input_channel">input_channel</a> <span class="arrow">&#45;&gt;</span></span> <span>bytes <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>read_into ic buffer offset length</code> reads up to <code>length</code> bytes, stores them in <code>buffer</code> at offset <code>offset</code>, and returns the number of bytes read.</p><p>Note: <code>read_into</code> does not raise <code>End_of_file</code>, it returns a length of <code>0</code> instead.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-read_into_exactly" class="anchored"><a href="#val-read_into_exactly" class="anchor"></a><code><span><span class="keyword">val</span> read_into_exactly : <span><a href="#type-input_channel">input_channel</a> <span class="arrow">&#45;&gt;</span></span> <span>bytes <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>read_into_exactly ic buffer offset length</code> reads exactly <code>length</code> bytes and stores them in <code>buffer</code> at offset <code>offset</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">End_of_file</span> <p>on end of input</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-read_into_bigstring" class="anchored"><a href="#val-read_into_bigstring" class="anchor"></a><code><span><span class="keyword">val</span> read_into_bigstring : <span><a href="#type-input_channel">input_channel</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Lwt_bytes/index.html#type-t">Lwt_bytes.t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-read_into_exactly_bigstring" class="anchored"><a href="#val-read_into_exactly_bigstring" class="anchor"></a><code><span><span class="keyword">val</span> read_into_exactly_bigstring : <span><a href="#type-input_channel">input_channel</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Lwt_bytes/index.html#type-t">Lwt_bytes.t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-read_value" class="anchored"><a href="#val-read_value" class="anchor"></a><code><span><span class="keyword">val</span> read_value : <span><a href="#type-input_channel">input_channel</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>read_value channel</code> reads a marshaled value from <code>channel</code>; it corresponds to the standard library's <a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/Marshal.html#VALfrom_channel"><code>Marshal.from_channel</code></a>. The corresponding writing function is <a href="#val-write_value"><code>write_value</code></a>.</p><p>Note that reading marshaled values is <em>not</em>, in general, type-safe. See the warning in the description of module <a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/Marshal.html"><code>Marshal</code></a> for details. The short version is: if you read a value of one type, such as <code>string</code>, when a value of another type, such as <code>int</code> has actually been marshaled to <code>channel</code>, you may get arbitrary behavior, including segmentation faults, access violations, security bugs, etc.</p></div></div><h3 id="writing"><a href="#writing" class="anchor"></a>Writing</h3><p>Note: as for reading functions, all functions except <a href="#val-write_chars"><code>write_chars</code></a> and <a href="#val-write_lines"><code>write_lines</code></a> are <b>atomic</b>.</p><p>For example if you use <a href="#val-write_line"><code>write_line</code></a> in two different threads, the two operations will be serialized, and lines cannot be mixed.</p><div class="odoc-spec"><div class="spec value" id="val-write_char" class="anchored"><a href="#val-write_char" class="anchor"></a><code><span><span class="keyword">val</span> write_char : <span><a href="#type-output_channel">output_channel</a> <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>write_char oc char</code> writes <code>char</code> on <code>oc</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-write_chars" class="anchored"><a href="#val-write_chars" class="anchor"></a><code><span><span class="keyword">val</span> write_chars : <span><a href="#type-output_channel">output_channel</a> <span class="arrow">&#45;&gt;</span></span> <span><span>char <a href="../Lwt_stream/index.html#type-t">Lwt_stream.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>write_chars oc chars</code> writes all characters of <code>chars</code> on <code>oc</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-write" class="anchored"><a href="#val-write" class="anchor"></a><code><span><span class="keyword">val</span> write : <span><a href="#type-output_channel">output_channel</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>write oc str</code> writes all characters of <code>str</code> on <code>oc</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-write_line" class="anchored"><a href="#val-write_line" class="anchor"></a><code><span><span class="keyword">val</span> write_line : <span><a href="#type-output_channel">output_channel</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>write_line oc str</code> writes <code>str</code> on <code>oc</code> followed by a new-line.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-write_lines" class="anchored"><a href="#val-write_lines" class="anchor"></a><code><span><span class="keyword">val</span> write_lines : <span><a href="#type-output_channel">output_channel</a> <span class="arrow">&#45;&gt;</span></span> <span><span>string <a href="../Lwt_stream/index.html#type-t">Lwt_stream.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>write_lines oc lines</code> writes all lines of <code>lines</code> to <code>oc</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-write_from" class="anchored"><a href="#val-write_from" class="anchor"></a><code><span><span class="keyword">val</span> write_from : <span><a href="#type-output_channel">output_channel</a> <span class="arrow">&#45;&gt;</span></span> <span>bytes <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>write_from oc buffer offset length</code> writes up to <code>length</code> bytes to <code>oc</code>, from <code>buffer</code> at offset <code>offset</code> and returns the number of bytes actually written</p></div></div><div class="odoc-spec"><div class="spec value" id="val-write_from_bigstring" class="anchored"><a href="#val-write_from_bigstring" class="anchor"></a><code><span><span class="keyword">val</span> write_from_bigstring : <span><a href="#type-output_channel">output_channel</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Lwt_bytes/index.html#type-t">Lwt_bytes.t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-write_from_string" class="anchored"><a href="#val-write_from_string" class="anchor"></a><code><span><span class="keyword">val</span> write_from_string : <span><a href="#type-output_channel">output_channel</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p>See <a href="#val-write"><code>write</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-write_from_exactly" class="anchored"><a href="#val-write_from_exactly" class="anchor"></a><code><span><span class="keyword">val</span> write_from_exactly : <span><a href="#type-output_channel">output_channel</a> <span class="arrow">&#45;&gt;</span></span> <span>bytes <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>write_from_exactly oc buffer offset length</code> writes all <code>length</code> bytes from <code>buffer</code> at offset <code>offset</code> to <code>oc</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-write_from_exactly_bigstring" class="anchored"><a href="#val-write_from_exactly_bigstring" class="anchor"></a><code><span><span class="keyword">val</span> write_from_exactly_bigstring : <span><a href="#type-output_channel">output_channel</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Lwt_bytes/index.html#type-t">Lwt_bytes.t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-write_from_string_exactly" class="anchored"><a href="#val-write_from_string_exactly" class="anchor"></a><code><span><span class="keyword">val</span> write_from_string_exactly : <span><a href="#type-output_channel">output_channel</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p>See <a href="#val-write_from_exactly"><code>write_from_exactly</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-write_value" class="anchored"><a href="#val-write_value" class="anchor"></a><code><span><span class="keyword">val</span> write_value : <span><a href="#type-output_channel">output_channel</a> <span class="arrow">&#45;&gt;</span></span> <span>?flags:<span><a href="../../ocaml/Stdlib/Marshal/index.html#type-extern_flags">Marshal.extern_flags</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>write_value channel ?flags v</code> writes <code>v</code> to <code>channel</code> using the <code>Marshal</code> module of the standard library. See <a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/Marshal.html#VALto_channel"><code>Marshal.to_channel</code></a> for an explanation of <code>?flags</code>.</p><p>The corresponding reading function is <a href="#val-read_value"><code>read_value</code></a>. See warnings about type safety in the description of <a href="#val-read_value"><code>read_value</code></a>.</p></div></div><h3 id="printing"><a href="#printing" class="anchor"></a>Printing</h3><p>These functions are basically helpers. Also you may prefer using the name <a href="#val-printl"><code>printl</code></a> rather than <a href="#val-write_line"><code>write_line</code></a> because it is shorter.</p><p>The general name of a printing function is <code>&lt;prefix&gt;print&lt;suffixes&gt;</code>,</p><p>where <code>&lt;prefix&gt;</code> is one of:</p><ul><li><code>'f'</code>, which means that the function takes as argument a channel</li><li>nothing, which means that the function prints on <a href="#val-stdout"><code>stdout</code></a></li><li><code>'e'</code>, which means that the function prints on <a href="#val-stderr"><code>stderr</code></a></li></ul><p>and <code>&lt;suffixes&gt;</code> is a combination of:</p><ul><li><code>'l'</code> which means that a new-line character is printed after the message</li><li><code>'f'</code> which means that the function takes as argument a <b>format</b> instead of a string</li></ul><div class="odoc-spec"><div class="spec value" id="val-fprint" class="anchored"><a href="#val-fprint" class="anchor"></a><code><span><span class="keyword">val</span> fprint : <span><a href="#type-output_channel">output_channel</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-fprintl" class="anchored"><a href="#val-fprintl" class="anchor"></a><code><span><span class="keyword">val</span> fprintl : <span><a href="#type-output_channel">output_channel</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-fprintf" class="anchored"><a href="#val-fprintf" class="anchor"></a><code><span><span class="keyword">val</span> fprintf : <span><a href="#type-output_channel">output_channel</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>,Â unit,Â string,Â <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span>)</span> <a href="../../ocaml/Stdlib/index.html#type-format4">format4</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>%!</code> does nothing here. To flush the channel, use <code>Lwt_io.flush channel</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fprintlf" class="anchored"><a href="#val-fprintlf" class="anchor"></a><code><span><span class="keyword">val</span> fprintlf : <span><a href="#type-output_channel">output_channel</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>,Â unit,Â string,Â <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span>)</span> <a href="../../ocaml/Stdlib/index.html#type-format4">format4</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>%!</code> does nothing here. To flush the channel, use <code>Lwt_io.flush channel</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-print" class="anchored"><a href="#val-print" class="anchor"></a><code><span><span class="keyword">val</span> print : <span>string <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-printl" class="anchored"><a href="#val-printl" class="anchor"></a><code><span><span class="keyword">val</span> printl : <span>string <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-printf" class="anchored"><a href="#val-printf" class="anchor"></a><code><span><span class="keyword">val</span> printf : <span><span><span>(<span class="type-var">'a</span>,Â unit,Â string,Â <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span>)</span> <a href="../../ocaml/Stdlib/index.html#type-format4">format4</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>%!</code> does nothing here. To flush the channel, use <code>Lwt_io.(flush stdout)</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-printlf" class="anchored"><a href="#val-printlf" class="anchor"></a><code><span><span class="keyword">val</span> printlf : <span><span><span>(<span class="type-var">'a</span>,Â unit,Â string,Â <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span>)</span> <a href="../../ocaml/Stdlib/index.html#type-format4">format4</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>%!</code> does nothing here. To flush the channel, use <code>Lwt_io.(flush stdout)</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-eprint" class="anchored"><a href="#val-eprint" class="anchor"></a><code><span><span class="keyword">val</span> eprint : <span>string <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-eprintl" class="anchored"><a href="#val-eprintl" class="anchor"></a><code><span><span class="keyword">val</span> eprintl : <span>string <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-eprintf" class="anchored"><a href="#val-eprintf" class="anchor"></a><code><span><span class="keyword">val</span> eprintf : <span><span><span>(<span class="type-var">'a</span>,Â unit,Â string,Â <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span>)</span> <a href="../../ocaml/Stdlib/index.html#type-format4">format4</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>%!</code> does nothing here. To flush the channel, use <code>Lwt_io.(flush stderr)</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-eprintlf" class="anchored"><a href="#val-eprintlf" class="anchor"></a><code><span><span class="keyword">val</span> eprintlf : <span><span><span>(<span class="type-var">'a</span>,Â unit,Â string,Â <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span>)</span> <a href="../../ocaml/Stdlib/index.html#type-format4">format4</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>%!</code> does nothing here. To flush the channel, use <code>Lwt_io.(flush stderr)</code>.</p></div></div><h3 id="utilities"><a href="#utilities" class="anchor"></a>Utilities</h3><div class="odoc-spec"><div class="spec value" id="val-hexdump_stream" class="anchored"><a href="#val-hexdump_stream" class="anchor"></a><code><span><span class="keyword">val</span> hexdump_stream : <span><a href="#type-output_channel">output_channel</a> <span class="arrow">&#45;&gt;</span></span> <span><span>char <a href="../Lwt_stream/index.html#type-t">Lwt_stream.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>hexdump_stream oc byte_stream</code> produces the same output as the command <code>hexdump -C</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-hexdump" class="anchored"><a href="#val-hexdump" class="anchor"></a><code><span><span class="keyword">val</span> hexdump : <span><a href="#type-output_channel">output_channel</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>hexdump oc str = hexdump_stream oc (Lwt_stream.of_string str)</code></p></div></div><h3 id="file-utilities"><a href="#file-utilities" class="anchor"></a>File utilities</h3><div class="odoc-spec"><div class="spec type" id="type-file_name" class="anchored"><a href="#type-file_name" class="anchor"></a><code><span><span class="keyword">type</span> file_name</span><span> = string</span></code></div><div class="spec-doc"><p>Type of file names</p></div></div><div class="odoc-spec"><div class="spec value" id="val-open_file" class="anchored"><a href="#val-open_file" class="anchor"></a><code><span><span class="keyword">val</span> open_file : <span>?buffer:<a href="../Lwt_bytes/index.html#type-t">Lwt_bytes.t</a> <span class="arrow">&#45;&gt;</span></span> <span>?flags:<span><a href="../../ocaml/Unix/index.html#type-open_flag">Unix.open_flag</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span>?perm:<a href="../../ocaml/Unix/index.html#type-file_perm">Unix.file_perm</a> <span class="arrow">&#45;&gt;</span></span> <span>mode:<span><span class="type-var">'a</span> <a href="#type-mode">mode</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-file_name">file_name</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-channel">channel</a></span> <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>Lwt_io.open_file ~mode file</code> opens the given file, either for reading (with <code>~mode:Input</code>) or for writing (with <code>~mode:Output</code>). The returned channel provides buffered I/O on the file.</p><p>If <code>~buffer</code> is supplied, it is used as the I/O buffer.</p><p>If <code>~flags</code> is supplied, the file is opened with the given flags (see <a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEopen_flag"><code>Unix.open_flag</code></a>). Note that <code>~flags</code> is used <em>exactly</em> as given. For example, opening a file with <code>~flags</code> and <code>~mode:Input</code> does <em>not</em> implicitly add <code>O_RDONLY</code>. So, you should include <code>O_RDONLY</code> when opening for reading (<code>~mode:Input</code>), and <code>O_WRONLY</code> when opening for writing (<code>~mode:Input</code>). It is also recommended to include <code>O_NONBLOCK</code>, unless you are sure that the file cannot be a socket or a named pipe.</p><p>The default permissions used for creating new files are <code>0o666</code>, i.e. reading and writing are allowed for the file owner, group, and everyone. These default permissions can be overridden by supplying <code>~perm</code>.</p><p>Note: if opening for writing (<code>~mode:Output</code>), and the file already exists, <code>open_file</code> truncates (clears) the file by default. If you would like to keep the pre-existing contents of the file, use the <code>~flags</code> parameter to pass a custom flags list that does not include <code>Unix.O_TRUNC</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Unix.Unix_error</span> <p>on error.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-with_file" class="anchored"><a href="#val-with_file" class="anchor"></a><code><span><span class="keyword">val</span> with_file : <span>?buffer:<a href="../Lwt_bytes/index.html#type-t">Lwt_bytes.t</a> <span class="arrow">&#45;&gt;</span></span> <span>?flags:<span><a href="../../ocaml/Unix/index.html#type-open_flag">Unix.open_flag</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span>?perm:<a href="../../ocaml/Unix/index.html#type-file_perm">Unix.file_perm</a> <span class="arrow">&#45;&gt;</span></span> <span>mode:<span><span class="type-var">'a</span> <a href="#type-mode">mode</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-file_name">file_name</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span><span class="type-var">'a</span> <a href="#type-channel">channel</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="../Lwt/index.html#type-t">Lwt.t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>Lwt_io.with_file ~mode filename f</code> opens the given using <a href="#val-open_file"><code>Lwt_io.open_file</code></a>, and passes the resulting channel to <code>f</code>. <code>Lwt_io.with_file</code> ensures that the channel is closed when the promise returned by <code>f</code> resolves, or if <code>f</code> raises an exception.</p><p>See <a href="#val-open_file"><code>Lwt_io.open_file</code></a> for a description of the arguments, warnings, and other notes.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-open_temp_file" class="anchored"><a href="#val-open_temp_file" class="anchor"></a><code><span><span class="keyword">val</span> open_temp_file : <span>?buffer:<a href="../Lwt_bytes/index.html#type-t">Lwt_bytes.t</a> <span class="arrow">&#45;&gt;</span></span> <span>?flags:<span><a href="../../ocaml/Unix/index.html#type-open_flag">Unix.open_flag</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span>?perm:<a href="../../ocaml/Unix/index.html#type-file_perm">Unix.file_perm</a> <span class="arrow">&#45;&gt;</span></span> <span>?temp_dir:string <span class="arrow">&#45;&gt;</span></span>
<span>?prefix:string <span class="arrow">&#45;&gt;</span></span> <span>?suffix:string <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span>(string * <a href="#type-output_channel">output_channel</a>)</span> <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>open_temp_file ()</code> starts creating a new temporary file, and evaluates to a promise for the pair of the file's name, and an output channel for writing to the file.</p><p>The caller should take care to delete the file later. Alternatively, see <a href="#val-with_temp_file"><code>Lwt_io.with_temp_file</code></a>.</p><p>The <code>?buffer</code> and <code>?perm</code> arguments are passed directly to an internal call to <a href="#val-open_file"><code>Lwt_io.open_file</code></a>.</p><p>If not specified, <code>?flags</code> defaults to <code>[O_CREATE; O_EXCL; O_WRONLY; O_CLOEXEC]</code>. If specified, the specified flags are used exactly. Note that these should typically contain at least <code>O_CREAT</code> and <code>O_EXCL</code>, otherwise <code>open_temp_file</code> may open an existing file.</p><p><code>?temp_dir</code> can be used to choose the directory in which the file is created. For the current directory, use <a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/Filename.html#VALcurrent_dir_name"><code>Filename.current_dir_name</code></a>. If not specified, the directory is taken from <a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/Filename.html#VALget_temp_dir_name"><code>Filename.get_temp_dir_name</code></a>, which is typically set to your system temporary file directory.</p><p><code>?prefix</code> helps determine the name of the file. It will be the prefix concatenated with a random sequence of characters. If not specified, <code>open_temp_file</code> uses some default prefix.</p><p><code>?suffix</code> is like <code>prefix</code>, but it is appended at the end of the filename. In particular, it can be used to set the extension. This argument is supported since Lwt 4.4.0.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.2.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-with_temp_file" class="anchored"><a href="#val-with_temp_file" class="anchor"></a><code><span><span class="keyword">val</span> with_temp_file : <span>?buffer:<a href="../Lwt_bytes/index.html#type-t">Lwt_bytes.t</a> <span class="arrow">&#45;&gt;</span></span> <span>?flags:<span><a href="../../ocaml/Unix/index.html#type-open_flag">Unix.open_flag</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span>?perm:<a href="../../ocaml/Unix/index.html#type-file_perm">Unix.file_perm</a> <span class="arrow">&#45;&gt;</span></span> <span>?temp_dir:string <span class="arrow">&#45;&gt;</span></span>
<span>?prefix:string <span class="arrow">&#45;&gt;</span></span> <span>?suffix:string <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span>(string * <a href="#type-output_channel">output_channel</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="../Lwt/index.html#type-t">Lwt.t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>with_temp_file f</code> calls <a href="#val-open_temp_file"><code>open_temp_file</code></a><code> ()</code>, passing all optional arguments directly to it. It then attaches <code>f</code> to run after the file is created, passing the filename and output channel to <code>f</code>. When the promise returned by <code>f</code> is resolved, <code>with_temp_file</code> closes the channel and deletes the temporary file by calling <a href="../Lwt_unix/index.html#val-unlink"><code>Lwt_unix.unlink</code></a>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.2.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-create_temp_dir" class="anchored"><a href="#val-create_temp_dir" class="anchor"></a><code><span><span class="keyword">val</span> create_temp_dir : <span>?perm:<a href="../../ocaml/Unix/index.html#type-file_perm">Unix.file_perm</a> <span class="arrow">&#45;&gt;</span></span> <span>?parent:string <span class="arrow">&#45;&gt;</span></span> <span>?prefix:string <span class="arrow">&#45;&gt;</span></span> <span>?suffix:string <span class="arrow">&#45;&gt;</span></span>
<span>unit <span class="arrow">&#45;&gt;</span></span> <span>string <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p>Creates a temporary directory, and returns a promise that resolves to its path. The caller must take care to remove the directory. Alternatively, see <a href="#val-with_temp_dir"><code>Lwt_io.with_temp_dir</code></a>.</p><p>If <code>~perm</code> is specified, the directory is created with the given permissions. The default permissions are <code>0755</code>.</p><p><code>~parent</code> is the directory in which the temporary directory is created. If not specified, the default value is the result of <code>Filename.get_temp_dir_name ()</code>.</p><p><code>~prefix</code> is prepended to the directory name, and <code>~suffix</code> is appended to it.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.4.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-with_temp_dir" class="anchored"><a href="#val-with_temp_dir" class="anchor"></a><code><span><span class="keyword">val</span> with_temp_dir : <span>?perm:<a href="../../ocaml/Unix/index.html#type-file_perm">Unix.file_perm</a> <span class="arrow">&#45;&gt;</span></span> <span>?parent:string <span class="arrow">&#45;&gt;</span></span> <span>?prefix:string <span class="arrow">&#45;&gt;</span></span> <span>?suffix:string <span class="arrow">&#45;&gt;</span></span>
<span><span>(<span>string <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../Lwt/index.html#type-t">Lwt.t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>with_temp_dir f</code> first calls <a href="#val-create_temp_dir"><code>create_temp_dir</code></a>, forwarding all optional arguments to it. Once the temporary directory is created at <code>path</code>, <code>with_temp_dir f</code> calls <code>f path</code>. When the promise returned by <code>f path</code> is resolved, <code>with_temp_dir f</code> recursively deletes the temporary directory and all its contents.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.4.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-open_connection" class="anchored"><a href="#val-open_connection" class="anchor"></a><code><span><span class="keyword">val</span> open_connection : <span>?fd:<a href="../Lwt_unix/index.html#type-file_descr">Lwt_unix.file_descr</a> <span class="arrow">&#45;&gt;</span></span> <span>?in_buffer:<a href="../Lwt_bytes/index.html#type-t">Lwt_bytes.t</a> <span class="arrow">&#45;&gt;</span></span> <span>?out_buffer:<a href="../Lwt_bytes/index.html#type-t">Lwt_bytes.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../ocaml/Unix/index.html#type-sockaddr">Unix.sockaddr</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-input_channel">input_channel</a> * <a href="#type-output_channel">output_channel</a>)</span> <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>open_connection ?fd ?in_buffer ?out_buffer addr</code> opens a connection to the given address and returns two channels for using it. If <code>fd</code> is not specified, a fresh one will be used.</p><p>The connection is completely closed when you close both channels.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Unix.Unix_error</span> <p>on error.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-with_connection" class="anchored"><a href="#val-with_connection" class="anchor"></a><code><span><span class="keyword">val</span> with_connection : <span>?fd:<a href="../Lwt_unix/index.html#type-file_descr">Lwt_unix.file_descr</a> <span class="arrow">&#45;&gt;</span></span> <span>?in_buffer:<a href="../Lwt_bytes/index.html#type-t">Lwt_bytes.t</a> <span class="arrow">&#45;&gt;</span></span> <span>?out_buffer:<a href="../Lwt_bytes/index.html#type-t">Lwt_bytes.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../ocaml/Unix/index.html#type-sockaddr">Unix.sockaddr</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span>(<a href="#type-input_channel">input_channel</a> * <a href="#type-output_channel">output_channel</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../Lwt/index.html#type-t">Lwt.t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>with_connection ?fd ?in_buffer ?out_buffer addr f</code> opens a connection to the given address and passes the channels to <code>f</code></p></div></div><div class="odoc-spec"><div class="spec type" id="type-server" class="anchored"><a href="#type-server" class="anchor"></a><code><span><span class="keyword">type</span> server</span></code></div><div class="spec-doc"><p>Type of a server</p></div></div><div class="odoc-spec"><div class="spec value" id="val-establish_server_with_client_socket" class="anchored"><a href="#val-establish_server_with_client_socket" class="anchor"></a><code><span><span class="keyword">val</span> establish_server_with_client_socket : <span>?server_fd:<a href="../Lwt_unix/index.html#type-file_descr">Lwt_unix.file_descr</a> <span class="arrow">&#45;&gt;</span></span> <span>?backlog:int <span class="arrow">&#45;&gt;</span></span>
<span>?no_close:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="../../ocaml/Unix/index.html#type-sockaddr">Unix.sockaddr</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><a href="../Lwt_unix/index.html#type-sockaddr">Lwt_unix.sockaddr</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Lwt_unix/index.html#type-file_descr">Lwt_unix.file_descr</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-server">server</a> <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>establish_server_with_client_socket listen_address f</code> creates a server which listens for incoming connections on <code>listen_address</code>. When a client makes a new connection, it is passed to <code>f</code>: more precisely, the server calls</p><pre><code>f client_address client_socket</code></pre><p>where <code>client_address</code> is the address (peer name) of the new client, and <code>client_socket</code> is the socket connected to the client.</p><p>The server does not block waiting for <code>f</code> to complete: it concurrently tries to accept more client connections while <code>f</code> is handling the client.</p><p>When the promise returned by <code>f</code> completes (i.e., <code>f</code> is done handling the client), <code>establish_server_with_client_socket</code> automatically closes <code>client_socket</code>. This is a default behavior that is useful for simple cases, but for a robust application you should explicitly close these channels yourself, and handle any exceptions as appropriate. If the channels are still open when <code>f</code> completes, and their automatic closing raises an exception, <code>establish_server_with_client_socket</code> treats it as an unhandled exception reaching the top level of the application: it passes that exception to <a href="../Lwt/index.html#val-async_exception_hook"><code>Lwt.async_exception_hook</code></a>, the default behavior of which is to print the exception and <em>terminate your process</em>.</p><p>Automatic closing can be completely disabled by passing <code>~no_close:true</code>.</p><p>Similarly, if <code>f</code> raises an exception (or the promise it returns fails with an exception), <code>establish_server_with_client_socket</code> can do nothing with that exception, except pass it to <a href="../Lwt/index.html#val-async_exception_hook"><code>Lwt.async_exception_hook</code></a>.</p><p><code>~server_fd</code> can be specified to use an existing file descriptor for listening. Otherwise, a fresh socket is created internally. In either case, <code>establish_server_with_client_socket</code> will internally assign <code>listen_address</code> to the server socket.</p><p><code>~backlog</code> is the argument passed to <a href="../Lwt_unix/index.html#val-listen"><code>Lwt_unix.listen</code></a>. Its default value is <code>SOMAXCONN</code>, which varies by platform and socket kind.</p><p>The returned promise (a <code>server Lwt.t</code>) resolves when the server has just started listening on <code>listen_address</code>: right after the internal call to <code>listen</code>, and right before the first internal call to <code>accept</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.1.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-establish_server_with_client_address" class="anchored"><a href="#val-establish_server_with_client_address" class="anchor"></a><code><span><span class="keyword">val</span> establish_server_with_client_address : <span>?fd:<a href="../Lwt_unix/index.html#type-file_descr">Lwt_unix.file_descr</a> <span class="arrow">&#45;&gt;</span></span> <span>?buffer_size:int <span class="arrow">&#45;&gt;</span></span>
<span>?backlog:int <span class="arrow">&#45;&gt;</span></span> <span>?no_close:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="../../ocaml/Unix/index.html#type-sockaddr">Unix.sockaddr</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><a href="../Lwt_unix/index.html#type-sockaddr">Lwt_unix.sockaddr</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-input_channel">input_channel</a> * <a href="#type-output_channel">output_channel</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-server">server</a> <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p>Like <a href="#val-establish_server_with_client_socket"><code>Lwt_io.establish_server_with_client_socket</code></a>, but passes two buffered channels to the connection handler <code>f</code>. These channels wrap the client socket.</p><p>The channels are closed automatically when the promise returned by <code>f</code> resolves. To avoid this behavior, pass <code>~no_close:true</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.1.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-shutdown_server" class="anchored"><a href="#val-shutdown_server" class="anchor"></a><code><span><span class="keyword">val</span> shutdown_server : <span><a href="#type-server">server</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p>Closes the given server's listening socket. The returned promise resolves when the <code>close(2)</code> system call completes. This function does not affect the sockets of connections that have already been accepted, i.e. passed to <code>f</code> by <a href="#val-establish_server"><code>establish_server</code></a>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.0.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-lines_of_file" class="anchored"><a href="#val-lines_of_file" class="anchor"></a><code><span><span class="keyword">val</span> lines_of_file : <span><a href="#type-file_name">file_name</a> <span class="arrow">&#45;&gt;</span></span> <span>string <a href="../Lwt_stream/index.html#type-t">Lwt_stream.t</a></span></span></code></div><div class="spec-doc"><p><code>lines_of_file name</code> returns a stream of all lines of the file with name <code>name</code>. The file is automatically closed when all lines have been read.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-lines_to_file" class="anchored"><a href="#val-lines_to_file" class="anchor"></a><code><span><span class="keyword">val</span> lines_to_file : <span><a href="#type-file_name">file_name</a> <span class="arrow">&#45;&gt;</span></span> <span><span>string <a href="../Lwt_stream/index.html#type-t">Lwt_stream.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>lines_to_file name lines</code> writes all lines of <code>lines</code> to file with name <code>name</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-chars_of_file" class="anchored"><a href="#val-chars_of_file" class="anchor"></a><code><span><span class="keyword">val</span> chars_of_file : <span><a href="#type-file_name">file_name</a> <span class="arrow">&#45;&gt;</span></span> <span>char <a href="../Lwt_stream/index.html#type-t">Lwt_stream.t</a></span></span></code></div><div class="spec-doc"><p><code>chars_of_file name</code> returns a stream of all characters of the file with name <code>name</code>. As for <a href="#val-lines_of_file"><code>lines_of_file</code></a> the file is closed when all characters have been read.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-chars_to_file" class="anchored"><a href="#val-chars_to_file" class="anchor"></a><code><span><span class="keyword">val</span> chars_to_file : <span><a href="#type-file_name">file_name</a> <span class="arrow">&#45;&gt;</span></span> <span><span>char <a href="../Lwt_stream/index.html#type-t">Lwt_stream.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>chars_to_file name chars</code> writes all characters of <code>chars</code> to <code>name</code></p></div></div><h3 id="input/output-of-integers"><a href="#input/output-of-integers" class="anchor"></a>Input/output of integers</h3><div class="odoc-spec"><div class="spec module-type" id="module-type-NumberIO" class="anchored"><a href="#module-type-NumberIO" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span><a href="module-type-NumberIO/index.html">NumberIO</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Common interface for reading/writing integers in binary</p></div></div><div class="odoc-spec"><div class="spec module" id="module-LE" class="anchored"><a href="#module-LE" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="LE/index.html">LE</a></span><span> : <a href="module-type-NumberIO/index.html">NumberIO</a></span></code></div><div class="spec-doc"><p>Reading/writing of numbers in little-endian</p></div></div><div class="odoc-spec"><div class="spec module" id="module-BE" class="anchored"><a href="#module-BE" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="BE/index.html">BE</a></span><span> : <a href="module-type-NumberIO/index.html">NumberIO</a></span></code></div><div class="spec-doc"><p>Reading/writing of numbers in big-endian</p></div></div><div class="odoc-include"><div class="spec-doc"><p>Reading/writing of numbers in the system endianness.</p></div><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="module-type-NumberIO/index.html">NumberIO</a></span></code></summary><div class="odoc-spec"><div class="spec value" id="val-read_int" class="anchored"><a href="#val-read_int" class="anchor"></a><code><span><span class="keyword">val</span> read_int : <span><a href="#type-input_channel">input_channel</a> <span class="arrow">&#45;&gt;</span></span> <span>int <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p>Reads a 32-bits integer as an ocaml int</p></div></div><div class="odoc-spec"><div class="spec value" id="val-read_int16" class="anchored"><a href="#val-read_int16" class="anchor"></a><code><span><span class="keyword">val</span> read_int16 : <span><a href="#type-input_channel">input_channel</a> <span class="arrow">&#45;&gt;</span></span> <span>int <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-read_int32" class="anchored"><a href="#val-read_int32" class="anchor"></a><code><span><span class="keyword">val</span> read_int32 : <span><a href="#type-input_channel">input_channel</a> <span class="arrow">&#45;&gt;</span></span> <span>int32 <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-read_int64" class="anchored"><a href="#val-read_int64" class="anchor"></a><code><span><span class="keyword">val</span> read_int64 : <span><a href="#type-input_channel">input_channel</a> <span class="arrow">&#45;&gt;</span></span> <span>int64 <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-read_float32" class="anchored"><a href="#val-read_float32" class="anchor"></a><code><span><span class="keyword">val</span> read_float32 : <span><a href="#type-input_channel">input_channel</a> <span class="arrow">&#45;&gt;</span></span> <span>float <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p>Reads an IEEE single precision floating point value</p></div></div><div class="odoc-spec"><div class="spec value" id="val-read_float64" class="anchored"><a href="#val-read_float64" class="anchor"></a><code><span><span class="keyword">val</span> read_float64 : <span><a href="#type-input_channel">input_channel</a> <span class="arrow">&#45;&gt;</span></span> <span>float <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p>Reads an IEEE double precision floating point value</p></div></div><h4 id="writing_5"><a href="#writing_5" class="anchor"></a>Writing</h4><div class="odoc-spec"><div class="spec value" id="val-write_int" class="anchored"><a href="#val-write_int" class="anchor"></a><code><span><span class="keyword">val</span> write_int : <span><a href="#type-output_channel">output_channel</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p>Writes an ocaml int as a 32-bits integer</p></div></div><div class="odoc-spec"><div class="spec value" id="val-write_int16" class="anchored"><a href="#val-write_int16" class="anchor"></a><code><span><span class="keyword">val</span> write_int16 : <span><a href="#type-output_channel">output_channel</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-write_int32" class="anchored"><a href="#val-write_int32" class="anchor"></a><code><span><span class="keyword">val</span> write_int32 : <span><a href="#type-output_channel">output_channel</a> <span class="arrow">&#45;&gt;</span></span> <span>int32 <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-write_int64" class="anchored"><a href="#val-write_int64" class="anchor"></a><code><span><span class="keyword">val</span> write_int64 : <span><a href="#type-output_channel">output_channel</a> <span class="arrow">&#45;&gt;</span></span> <span>int64 <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-write_float32" class="anchored"><a href="#val-write_float32" class="anchor"></a><code><span><span class="keyword">val</span> write_float32 : <span><a href="#type-output_channel">output_channel</a> <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p>Writes an IEEE single precision floating point value</p></div></div><div class="odoc-spec"><div class="spec value" id="val-write_float64" class="anchored"><a href="#val-write_float64" class="anchor"></a><code><span><span class="keyword">val</span> write_float64 : <span><a href="#type-output_channel">output_channel</a> <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p>Writes an IEEE double precision floating point value</p></div></div></details></div><div class="odoc-spec"><div class="spec type" id="type-byte_order" class="anchored"><a href="#type-byte_order" class="anchor"></a><code><span><span class="keyword">type</span> byte_order</span><span> = <a href="../Lwt_sys/index.html#type-byte_order">Lwt_sys.byte_order</a></span><span> = </span></code><table><tr id="type-byte_order.Little_endian" class="anchored"><td class="def variant constructor"><a href="#type-byte_order.Little_endian" class="anchor"></a><code><span>| </span><span><span class="constructor">Little_endian</span></span></code></td></tr><tr id="type-byte_order.Big_endian" class="anchored"><td class="def variant constructor"><a href="#type-byte_order.Big_endian" class="anchor"></a><code><span>| </span><span><span class="constructor">Big_endian</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Type of byte order</p><span class="comment-delim">*)</span></td></tr></table></div></div><div class="odoc-spec"><div class="spec value" id="val-system_byte_order" class="anchored"><a href="#val-system_byte_order" class="anchor"></a><code><span><span class="keyword">val</span> system_byte_order : <a href="#type-byte_order">byte_order</a></span></code></div><div class="spec-doc"><p>Same as <a href="../Lwt_sys/index.html#type-byte_order"><code>Lwt_sys.byte_order</code></a>.</p></div></div><h3 id="low-level-access-to-the-internal-buffer"><a href="#low-level-access-to-the-internal-buffer" class="anchor"></a>Low-level access to the internal buffer</h3><div class="odoc-spec"><div class="spec value" id="val-block" class="anchored"><a href="#val-block" class="anchor"></a><code><span><span class="keyword">val</span> block : <span><span><span class="type-var">'a</span> <a href="#type-channel">channel</a></span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><a href="../Lwt_bytes/index.html#type-t">Lwt_bytes.t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="../Lwt/index.html#type-t">Lwt.t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>block ch size f</code> pass to <code>f</code> the internal buffer and an offset. The buffer contains <code>size</code> chars at <code>offset</code>. <code>f</code> may read or write these chars. <code>size</code> must satisfy <code>0 &lt;= size &lt;= 16</code></p></div></div><div class="odoc-spec"><div class="spec type" id="type-direct_access" class="anchored"><a href="#type-direct_access" class="anchor"></a><code><span><span class="keyword">type</span> direct_access</span><span> = </span><span>{</span></code><table><tr id="type-direct_access.da_buffer" class="anchored"><td class="def record field"><a href="#type-direct_access.da_buffer" class="anchor"></a><code><span>da_buffer : <a href="../Lwt_bytes/index.html#type-t">Lwt_bytes.t</a>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The internal buffer</p><span class="comment-delim">*)</span></td></tr><tr id="type-direct_access.da_ptr" class="anchored"><td class="def record field"><a href="#type-direct_access.da_ptr" class="anchor"></a><code><span><span class="keyword">mutable</span> da_ptr : int;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The pointer to:</p><ul><li>the beginning of free space for output channels</li><li>the beginning of data for input channels</li></ul><span class="comment-delim">*)</span></td></tr><tr id="type-direct_access.da_max" class="anchored"><td class="def record field"><a href="#type-direct_access.da_max" class="anchor"></a><code><span><span class="keyword">mutable</span> da_max : int;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The maximum offset</p><span class="comment-delim">*)</span></td></tr><tr id="type-direct_access.da_perform" class="anchored"><td class="def record field"><a href="#type-direct_access.da_perform" class="anchor"></a><code><span>da_perform : <span>unit <span class="arrow">&#45;&gt;</span></span> <span>int <a href="../Lwt/index.html#type-t">Lwt.t</a></span>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><ul><li>for input channels: refills the buffer and returns how many bytes have been read</li><li>for output channels: flush partially the buffer and returns how many bytes have been written</li></ul><span class="comment-delim">*)</span></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p>Information for directly accessing the internal buffer of a channel</p></div></div><div class="odoc-spec"><div class="spec value" id="val-direct_access" class="anchored"><a href="#val-direct_access" class="anchor"></a><code><span><span class="keyword">val</span> direct_access : <span><span><span class="type-var">'a</span> <a href="#type-channel">channel</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><a href="#type-direct_access">direct_access</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="../Lwt/index.html#type-t">Lwt.t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>direct_access ch f</code> passes to <code>f</code> a <a href="#val-direct_access"><code>direct_access</code></a> structure. <code>f</code> must use it and update <code>da_ptr</code> to reflect how many bytes have been read/written.</p></div></div><h3 id="misc"><a href="#misc" class="anchor"></a>Misc</h3><div class="odoc-spec"><div class="spec value" id="val-default_buffer_size" class="anchored"><a href="#val-default_buffer_size" class="anchor"></a><code><span><span class="keyword">val</span> default_buffer_size : <span>unit <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Return the default size for buffers. Channels that are created without a specific buffer use new buffer of this size.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_default_buffer_size" class="anchored"><a href="#val-set_default_buffer_size" class="anchor"></a><code><span><span class="keyword">val</span> set_default_buffer_size : <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Change the default buffer size.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if the given size is smaller than <code>16</code> or greater than <code>Sys.max_string_length</code></p></li></ul></div></div><h3 id="deprecated"><a href="#deprecated" class="anchor"></a>Deprecated</h3><div class="odoc-spec"><div class="spec value" id="val-establish_server" class="anchored"><a href="#val-establish_server" class="anchor"></a><code><span><span class="keyword">val</span> establish_server : <span>?fd:<a href="../Lwt_unix/index.html#type-file_descr">Lwt_unix.file_descr</a> <span class="arrow">&#45;&gt;</span></span> <span>?buffer_size:int <span class="arrow">&#45;&gt;</span></span> <span>?backlog:int <span class="arrow">&#45;&gt;</span></span> <span>?no_close:bool <span class="arrow">&#45;&gt;</span></span>
<span><a href="../../ocaml/Unix/index.html#type-sockaddr">Unix.sockaddr</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span>(<a href="#type-input_channel">input_channel</a> * <a href="#type-output_channel">output_channel</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../Lwt/index.html#type-t">Lwt.t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-server">server</a> <a href="../Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p>Like <code>establish_server_with_client_address</code>, but does not pass the client address or fd to the callback <code>f</code>.</p><ul class="at-tags"><li class="deprecated"><span class="at-tag">deprecated</span> <p>Use <code>establish_server_with_client_address</code>.</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.0.0</li></ul></div></div><div class="odoc-spec"><div class="spec module" id="module-Versioned" class="anchored"><a href="#module-Versioned" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Versioned/index.html">Versioned</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Versioned variants of APIs undergoing breaking changes.</p></div></div></div></body></html>