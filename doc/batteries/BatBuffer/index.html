<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>BatBuffer (batteries.BatBuffer)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">batteries</a> &#x00BB; BatBuffer</nav><header class="odoc-preamble"><h1>Module <code><span>BatBuffer</span></code></h1><p>Extensible string buffers.</p><p>This module implements string buffers that automatically expand as necessary. It provides accumulative concatenation of strings in quasi-linear time (instead of quadratic time when strings are concatenated pairwise).</p><ul class="at-tags"><li class="author"><span class="at-tag">author</span> Pierre Weis (Base module)</li></ul><ul class="at-tags"><li class="author"><span class="at-tag">author</span> Xavier Leroy (Base module)</li></ul><ul class="at-tags"><li class="author"><span class="at-tag">author</span> David Teller</li></ul><ul class="at-tags"><li class="author"><span class="at-tag">author</span> Dawid Toton</li></ul></header><nav class="odoc-toc"><ul><li><a href="#boilerplate-code">Boilerplate code</a></li><li><a href="#iterators">Iterators</a></li><li><a href="#binary-encoding-of-integers">Binary encoding of integers</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span><span> = <a href="../../ocaml/Stdlib/Buffer/index.html#type-t">Buffer.t</a></span></code></div><div class="spec-doc"><p>The abstract type of buffers.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-create" class="anchored"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>create n</code> returns a fresh buffer, initially empty. The <code>n</code> parameter is the initial size of the internal string that holds the buffer contents. That string is automatically reallocated when more than <code>n</code> characters are stored in the buffer, but shrinks back to <code>n</code> characters when <code>reset</code> is called. For best performance, <code>n</code> should be of the same order of magnitude as the number of characters that are expected to be stored in the buffer (for instance, 80 for a buffer that holds one output line). Nothing bad will happen if the buffer grows beyond that limit, however. In doubt, take <code>n = 16</code> for instance. If <code>n</code> is not between 1 and <code>Sys</code>.max_string_length, it will be clipped to that interval.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-contents" class="anchored"><a href="#val-contents" class="anchor"></a><code><span><span class="keyword">val</span> contents : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Return a copy of the current contents of the buffer. The buffer itself is unchanged.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_bytes" class="anchored"><a href="#val-to_bytes" class="anchor"></a><code><span><span class="keyword">val</span> to_bytes : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../ocaml/Stdlib/Bytes/index.html#type-t">Bytes.t</a></span></code></div><div class="spec-doc"><p>Return a copy of the current contents of the buffer. The buffer itself is unchanged.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.3.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-sub" class="anchored"><a href="#val-sub" class="anchor"></a><code><span><span class="keyword">val</span> sub : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>Buffer.sub b off len</code> returns a copy of <code>len</code> bytes from the current contents of the buffer <code>b</code>, starting at offset <code>off</code>.</p><p>Raise <code>Invalid_argument</code> if <code>srcoff</code> and <code>len</code> do not designate a valid range of <code>b</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-blit" class="anchored"><a href="#val-blit" class="anchor"></a><code><span><span class="keyword">val</span> blit : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="../../ocaml/Stdlib/Bytes/index.html#type-t">Bytes.t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>Buffer.blit src srcoff dst dstoff len</code> copies <code>len</code> characters from the current contents of the buffer <code>src</code>, starting at offset <code>srcoff</code> to string <code>dst</code>, starting at character <code>dstoff</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if <code>srcoff</code> and <code>len</code> do not designate a valid substring of <code>src</code>, or if <code>dstoff</code> and <code>len</code> do not designate a valid substring of <code>dst</code>.</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.11.2</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-nth" class="anchored"><a href="#val-nth" class="anchor"></a><code><span><span class="keyword">val</span> nth : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> char</span></code></div><div class="spec-doc"><p>get the n-th character of the buffer. </p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if index out of bounds</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-length" class="anchored"><a href="#val-length" class="anchor"></a><code><span><span class="keyword">val</span> length : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Return the number of characters currently contained in the buffer.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-clear" class="anchored"><a href="#val-clear" class="anchor"></a><code><span><span class="keyword">val</span> clear : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Empty the buffer.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-reset" class="anchored"><a href="#val-reset" class="anchor"></a><code><span><span class="keyword">val</span> reset : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Empty the buffer and deallocate the internal string holding the buffer contents, replacing it with the initial internal string of length <code>n</code> that was allocated by <code>Buffer</code>.create <code>n</code>. For long-lived buffers that may have grown a lot, <code>reset</code> allows faster reclamation of the space used by the buffer.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-add_char" class="anchored"><a href="#val-add_char" class="anchor"></a><code><span><span class="keyword">val</span> add_char : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>add_char b c</code> appends the character <code>c</code> at the end of the buffer <code>b</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-add_string" class="anchored"><a href="#val-add_string" class="anchor"></a><code><span><span class="keyword">val</span> add_string : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>add_string b s</code> appends the string <code>s</code> at the end of the buffer <code>b</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-add_bytes" class="anchored"><a href="#val-add_bytes" class="anchor"></a><code><span><span class="keyword">val</span> add_bytes : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../ocaml/Stdlib/Bytes/index.html#type-t">Bytes.t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>add_bytes b s</code> appends the string <code>s</code> at the end of the buffer <code>b</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.3.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-add_substring" class="anchored"><a href="#val-add_substring" class="anchor"></a><code><span><span class="keyword">val</span> add_substring : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>add_substring b s ofs len</code> takes <code>len</code> characters from offset <code>ofs</code> in string <code>s</code> and appends them at the end of the buffer <code>b</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-add_subbytes" class="anchored"><a href="#val-add_subbytes" class="anchor"></a><code><span><span class="keyword">val</span> add_subbytes : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../ocaml/Stdlib/Bytes/index.html#type-t">Bytes.t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>add_subbytes b s ofs len</code> takes <code>len</code> characters from offset <code>ofs</code> in byte sequence <code>s</code> and appends them at the end of the buffer <code>b</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.3.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-add_substitute" class="anchored"><a href="#val-add_substitute" class="anchor"></a><code><span><span class="keyword">val</span> add_substitute : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>string <span class="arrow">&#45;&gt;</span></span> string)</span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>add_substitute b f s</code> appends the string pattern <code>s</code> at the end of the buffer <code>b</code> with substitution. The substitution process looks for variables into the pattern and substitutes each variable name by its value, as obtained by applying the mapping <code>f</code> to the variable name. Inside the string pattern, a variable name immediately follows a non-escaped <code>$</code> character and is one of the following:</p><ul><li>a non empty sequence of alphanumeric or <code>_</code> characters,</li><li>an arbitrary sequence of characters enclosed by a pair of matching parentheses or curly brackets. An escaped <code>$</code> character is a <code>$</code> that immediately follows a backslash character; it then stands for a plain <code>$</code>.</li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Not_found</span> <p>if the closing character of a parenthesized variable cannot be found.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-add_buffer" class="anchored"><a href="#val-add_buffer" class="anchor"></a><code><span><span class="keyword">val</span> add_buffer : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>add_buffer b1 b2</code> appends the current contents of buffer <code>b2</code> at the end of buffer <code>b1</code>. <code>b2</code> is not modified.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-add_input" class="anchored"><a href="#val-add_input" class="anchor"></a><code><span><span class="keyword">val</span> add_input : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../BatInnerIO/index.html#type-input">BatInnerIO.input</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>add_input b ic n</code> reads exactly <code>n</code> character from the input <code>ic</code> and stores them at the end of buffer <code>b</code>. </p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">End_of_file</span> <p>if the channel contains fewer than <code>n</code> characters.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-add_channel" class="anchored"><a href="#val-add_channel" class="anchor"></a><code><span><span class="keyword">val</span> add_channel : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../BatInnerIO/index.html#type-input">BatInnerIO.input</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>@obsolete replaced by <a href="#val-add_input"><code>add_input</code></a></p></div></div><div class="odoc-spec"><div class="spec value" id="val-output_buffer" class="anchored"><a href="#val-output_buffer" class="anchor"></a><code><span><span class="keyword">val</span> output_buffer : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>string <a href="../BatInnerIO/index.html#type-output">BatInnerIO.output</a></span></span></code></div><div class="spec-doc"><p><code>output_buffer b</code> creates an output channel that writes to that buffer, and when closed, returns the contents of the buffer.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-truncate" class="anchored"><a href="#val-truncate" class="anchor"></a><code><span><span class="keyword">val</span> truncate : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>truncate b len</code> truncates the length of <code>b</code> to <code>len</code> Note: the internal byte sequence is not shortened. Raises <code>Invalid_argument</code> if <code>len &lt; 0</code> or <code>len &gt; length b</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.7.0 and OCaml 4.05.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-add_utf_8_uchar" class="anchored"><a href="#val-add_utf_8_uchar" class="anchor"></a><code><span><span class="keyword">val</span> add_utf_8_uchar : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../ocaml/Stdlib/Uchar/index.html#type-t">Uchar.t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>add_utf_8_uchar b u</code> appends the <a href="https://tools.ietf.org/html/rfc3629">UTF-8</a> encoding of <code>u</code> at the end of buffer <code>b</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.8.0 and OCaml 4.06.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-add_utf_16le_uchar" class="anchored"><a href="#val-add_utf_16le_uchar" class="anchor"></a><code><span><span class="keyword">val</span> add_utf_16le_uchar : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../ocaml/Stdlib/Uchar/index.html#type-t">Uchar.t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>add_utf_16le_uchar b u</code> appends the <a href="https://tools.ietf.org/html/rfc2781">UTF-16LE</a> encoding of <code>u</code> at the end of buffer <code>b</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.8.0 and OCaml 4.06.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-add_utf_16be_uchar" class="anchored"><a href="#val-add_utf_16be_uchar" class="anchor"></a><code><span><span class="keyword">val</span> add_utf_16be_uchar : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../ocaml/Stdlib/Uchar/index.html#type-t">Uchar.t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>add_utf_16be_uchar b u</code> appends the <a href="https://tools.ietf.org/html/rfc2781">UTF-16BE</a> encoding of <code>u</code> at the end of buffer <code>b</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.8.0 and OCaml 4.06.0</li></ul></div></div><h6 id="boilerplate-code"><a href="#boilerplate-code" class="anchor"></a>Boilerplate code</h6><div class="odoc-spec"><div class="spec value" id="val-enum" class="anchored"><a href="#val-enum" class="anchor"></a><code><span><span class="keyword">val</span> enum : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>char <a href="../BatEnum/index.html#type-t">BatEnum.t</a></span></span></code></div><div class="spec-doc"><p>Returns an enumeration of the characters of a buffer.</p><p>Contents of the enumeration is unspecified if the buffer is modified after the enumeration is returned.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_enum" class="anchored"><a href="#val-of_enum" class="anchor"></a><code><span><span class="keyword">val</span> of_enum : <span><span>char <a href="../BatEnum/index.html#type-t">BatEnum.t</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Creates a buffer from a character enumeration.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-print" class="anchored"><a href="#val-print" class="anchor"></a><code><span><span class="keyword">val</span> print : <span><span><span class="type-var">'a</span> <a href="../BatInnerIO/index.html#type-output">BatInnerIO.output</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><h2 id="iterators"><a href="#iterators" class="anchor"></a>Iterators</h2><div class="odoc-spec"><div class="spec value" id="val-to_seq" class="anchored"><a href="#val-to_seq" class="anchor"></a><code><span><span class="keyword">val</span> to_seq : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>char <a href="../../ocaml/Stdlib/Seq/index.html#type-t">Seq.t</a></span></span></code></div><div class="spec-doc"><p>Iterate on the buffer, in increasing order. Modification of the buffer during iteration is undefined behavior.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.10.0 and OCaml 4.07</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-to_seqi" class="anchored"><a href="#val-to_seqi" class="anchor"></a><code><span><span class="keyword">val</span> to_seqi : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(int * char)</span> <a href="../../ocaml/Stdlib/Seq/index.html#type-t">Seq.t</a></span></span></code></div><div class="spec-doc"><p>Iterate on the buffer, in increasing order, yielding indices along chars. Modification of the buffer during iteration is undefined behavior.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.10.0 and OCaml 4.07</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-add_seq" class="anchored"><a href="#val-add_seq" class="anchor"></a><code><span><span class="keyword">val</span> add_seq : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>char <a href="../../ocaml/Stdlib/Seq/index.html#type-t">Seq.t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Add chars to the buffer</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.10.0 and OCaml 4.07</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-of_seq" class="anchored"><a href="#val-of_seq" class="anchor"></a><code><span><span class="keyword">val</span> of_seq : <span><span>char <a href="../../ocaml/Stdlib/Seq/index.html#type-t">Seq.t</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Create a buffer from the generator</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.10.0 and OCaml 4.07</li></ul></div></div><h2 id="binary-encoding-of-integers"><a href="#binary-encoding-of-integers" class="anchor"></a>Binary encoding of integers</h2><p>The functions in this section append binary encodings of integers to buffers.</p><p>Little-endian (resp. big-endian) encoding means that least (resp. most) significant bytes are stored first. Big-endian is also known as network byte order. Native-endian encoding is either little-endian or big-endian depending on <code>Sys</code>.big_endian.</p><p>32-bit and 64-bit integers are represented by the <code>int32</code> and <code>int64</code> types, which can be interpreted either as signed or unsigned numbers.</p><p>8-bit and 16-bit integers are represented by the <code>int</code> type, which has more bits than the binary encoding. Functions that encode these values truncate their inputs to their least significant bytes.</p><div class="odoc-spec"><div class="spec value" id="val-add_uint8" class="anchored"><a href="#val-add_uint8" class="anchor"></a><code><span><span class="keyword">val</span> add_uint8 : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>add_uint8 b i</code> appends a binary unsigned 8-bit integer <code>i</code> to <code>b</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.10.0 and OCaml 4.08</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-add_int8" class="anchored"><a href="#val-add_int8" class="anchor"></a><code><span><span class="keyword">val</span> add_int8 : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>add_int8 b i</code> appends a binary signed 8-bit integer <code>i</code> to <code>b</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.10.0 and OCaml 4.08</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-add_uint16_ne" class="anchored"><a href="#val-add_uint16_ne" class="anchor"></a><code><span><span class="keyword">val</span> add_uint16_ne : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>add_uint16_ne b i</code> appends a binary native-endian unsigned 16-bit integer <code>i</code> to <code>b</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.10.0 and OCaml 4.08</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-add_uint16_be" class="anchored"><a href="#val-add_uint16_be" class="anchor"></a><code><span><span class="keyword">val</span> add_uint16_be : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>add_uint16_be b i</code> appends a binary big-endian unsigned 16-bit integer <code>i</code> to <code>b</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.10.0 and OCaml 4.08</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-add_uint16_le" class="anchored"><a href="#val-add_uint16_le" class="anchor"></a><code><span><span class="keyword">val</span> add_uint16_le : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>add_uint16_le b i</code> appends a binary little-endian unsigned 16-bit integer <code>i</code> to <code>b</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.10.0 and OCaml 4.08</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-add_int16_ne" class="anchored"><a href="#val-add_int16_ne" class="anchor"></a><code><span><span class="keyword">val</span> add_int16_ne : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>add_int16_ne b i</code> appends a binary native-endian signed 16-bit integer <code>i</code> to <code>b</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.10.0 and OCaml 4.08</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-add_int16_be" class="anchored"><a href="#val-add_int16_be" class="anchor"></a><code><span><span class="keyword">val</span> add_int16_be : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>add_int16_be b i</code> appends a binary big-endian signed 16-bit integer <code>i</code> to <code>b</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.10.0 and OCaml 4.08</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-add_int16_le" class="anchored"><a href="#val-add_int16_le" class="anchor"></a><code><span><span class="keyword">val</span> add_int16_le : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>add_int16_le b i</code> appends a binary little-endian signed 16-bit integer <code>i</code> to <code>b</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.10.0 and OCaml 4.08</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-add_int32_ne" class="anchored"><a href="#val-add_int32_ne" class="anchor"></a><code><span><span class="keyword">val</span> add_int32_ne : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int32 <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>add_int32_ne b i</code> appends a binary native-endian 32-bit integer <code>i</code> to <code>b</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.10.0 and OCaml 4.08</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-add_int32_be" class="anchored"><a href="#val-add_int32_be" class="anchor"></a><code><span><span class="keyword">val</span> add_int32_be : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int32 <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>add_int32_be b i</code> appends a binary big-endian 32-bit integer <code>i</code> to <code>b</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.10.0 and OCaml 4.08</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-add_int32_le" class="anchored"><a href="#val-add_int32_le" class="anchor"></a><code><span><span class="keyword">val</span> add_int32_le : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int32 <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>add_int32_le b i</code> appends a binary little-endian 32-bit integer <code>i</code> to <code>b</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.10.0 and OCaml 4.08</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-add_int64_ne" class="anchored"><a href="#val-add_int64_ne" class="anchor"></a><code><span><span class="keyword">val</span> add_int64_ne : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int64 <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>add_int64_ne b i</code> appends a binary native-endian 64-bit integer <code>i</code> to <code>b</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.10.0 and OCaml 4.08</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-add_int64_be" class="anchored"><a href="#val-add_int64_be" class="anchor"></a><code><span><span class="keyword">val</span> add_int64_be : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int64 <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>add_int64_be b i</code> appends a binary big-endian 64-bit integer <code>i</code> to <code>b</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.10.0 and OCaml 4.08</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-add_int64_le" class="anchored"><a href="#val-add_int64_le" class="anchor"></a><code><span><span class="keyword">val</span> add_int64_le : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int64 <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>add_int64_ne b i</code> appends a binary little-endian 64-bit integer <code>i</code> to <code>b</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.10.0 and OCaml 4.08</li></ul></div></div></div></body></html>