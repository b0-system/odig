<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>PathType (batteries.BatPathGen.PathType)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">batteries</a> &#x00BB; <a href="../index.html">BatPathGen</a> &#x00BB; PathType</nav><header class="odoc-preamble"><h1>Module type <code><span>BatPathGen.PathType</span></code></h1><p>All implementations of <code>Path</code> functionality have this module type.</p></header><nav class="odoc-toc"><ul><li><a href="#construction">Construction</a></li><li><a href="#validation">Validation</a></li><li><a href="#conversions">Conversions</a></li><li><a href="#convenience-aliases">Convenience aliases</a></li><li><a href="#name-related-functions">Name related functions</a></li><li><a href="#supplementary-functions">Supplementary functions</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-ustring" class="anchored"><a href="#type-ustring" class="anchor"></a><code><span><span class="keyword">type</span> ustring</span></code></div><div class="spec-doc"><p>Type of strings used. In case of <code>Path</code>.OfRope it is <code>Rope</code>.t and in <code>Path</code>.OfString module it is <code>string</code>.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-uchar" class="anchored"><a href="#type-uchar" class="anchor"></a><code><span><span class="keyword">type</span> uchar</span></code></div><div class="spec-doc"><p>Type of characters. It corresponds to <code>ustring</code> type.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-OperatorLift" class="anchored"><a href="#module-OperatorLift" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="OperatorLift/index.html">OperatorLift</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Convenience operator for lifting primitive strings to <code>ustring</code> type.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span><span> = <span><a href="#type-ustring">ustring</a> list</span></span></code></div><div class="spec-doc"><p>A type for storing paths. It is reversed list of names. In case of absolute path, the last element of the list is empty string (<em>Windows:</em> empty or letter-colon; details below). Empty list represents empty relative path.</p><p>Examples: <code>[&quot;a&quot;;&quot;b&quot;;&quot;c&quot;]</code> is c/b/a (relative path); <code>[&quot;d&quot;;&quot;e&quot;;&quot;&quot;]</code> stays for /e/d (absolute path).</p><p>All examples here and below are given for <code>ustring</code>=<code>string</code> case for clarity. To have the code working with other string types, one should prepend the <code>!!</code> operator (<a href="OperatorLift/index.html#val-(!!)"><code>OperatorLift.(!!)</code></a>) to all string literals.</p><p>There are two infix operators provided to allow to write expressions in natural order. For example, to build a path using <a href="Operators/index.html#val-(/:)"><code>PathType.Operators.(/:)</code></a> one can write:</p><p><code>base_dir/:&quot;bar&quot;</code> instead of <code>&quot;bar&quot;::base_dir</code></p><p>However it may be sometimes inevitable to write components in reverse, for example:</p><p><code>let whose_readme = function &quot;README&quot;::app::&quot;doc&quot;::&quot;share&quot;::_ -&gt; Some app | _ -&gt; None</code></p><p><em>Windows:</em> Windows absolute paths start with &quot;\\&quot; or with drive letter. Use following representation:</p><ul><li><code>Path.root/:&quot;.&quot;/:&quot;pipe&quot; = [&quot;pipe&quot;;&quot;.&quot;;&quot;&quot;]</code> for &quot;\\.\pipe&quot;</li><li><code>[&quot;C:&quot;]/:&quot;foo&quot; = [&quot;foo&quot;;&quot;C:&quot;]</code> for &quot;C:\foo&quot;</li></ul><p>In principle the first type of paths has broader range of allowed characters, but this implementation applies more strict rules to both (<a href="#val-default_validator"><code>default_validator</code></a>).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_relative" class="anchored"><a href="#val-is_relative" class="anchor"></a><code><span><span class="keyword">val</span> is_relative : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-is_absolute" class="anchored"><a href="#val-is_absolute" class="anchor"></a><code><span><span class="keyword">val</span> is_absolute : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><h6 id="construction"><a href="#construction" class="anchor"></a>Construction</h6><div class="odoc-spec"><div class="spec value" id="val-root" class="anchored"><a href="#val-root" class="anchor"></a><code><span><span class="keyword">val</span> root : <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Root of the filesystem (<code>[&quot;&quot;]</code>). It is minimal absolute path. Below it is called 'empty'. However it yields &quot;/&quot; or &quot;\\&quot; when converted to a string.</p><p><em>Windows:</em> This path (root and nothing more) is meaningless, but for simplicity it is considered valid here. To create absolute path starting with drive letter, construct the list explicitly (as in <code>[&quot;C:&quot;]/:&quot;foo&quot;</code>). A path consisting of drive letter only is also called 'empty' here.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-append" class="anchored"><a href="#val-append" class="anchor"></a><code><span><span class="keyword">val</span> append : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-ustring">ustring</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Alternative name for <a href="Operators/index.html#val-(/:)"><code>Operators.(/:)</code></a></p></div></div><div class="odoc-spec"><div class="spec value" id="val-concat" class="anchored"><a href="#val-concat" class="anchor"></a><code><span><span class="keyword">val</span> concat : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Alternative name for <a href="Operators/index.html#val-(//@)"><code>Operators.(//@)</code></a></p></div></div><div class="odoc-spec"><div class="spec module" id="module-Operators" class="anchored"><a href="#module-Operators" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Operators/index.html">Operators</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Infix operators for path construction. They are in separate module, so one can <code>open Path.Operators</code> to use them.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Infix" class="anchored"><a href="#module-Infix" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Infix/index.html">Infix</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>As other Operators modules in batteries are named &quot;Infix&quot; we provide Infix as well. This is a mere copy of Operators.</p></div></div><div class="odoc-spec"><div class="spec exception" id="exception-Malformed_path" class="anchored"><a href="#exception-Malformed_path" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Malformed_path</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-normalize_filepath" class="anchored"><a href="#val-normalize_filepath" class="anchor"></a><code><span><span class="keyword">val</span> normalize_filepath : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Consumes single dots where possible, e.g.:</p><p><code>normalize ([&quot;..&quot;]/:&quot;foo&quot;/:&quot;.&quot;/:&quot;bar&quot;/:&quot;sub1&quot;/:&quot;..&quot;/:&quot;sub2&quot;) = [&quot;..&quot;]/:&quot;foo&quot;/:&quot;bar&quot;/:&quot;sub1&quot;/:&quot;..&quot;/:&quot;sub2&quot;</code></p><p>When a directory structure contains links, it can be not pefectly pure tree. Then meaing of the &quot;..&quot; symbol depends on the real nature of parent of what is denoted by the name that preceded the &quot;..&quot; symbol. This symbol cannot be resolved for a graph traversal case when dealing with abstract paths only.</p><p><em>Windows:</em> If single dot is next to root, it is preserved.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-normalize_in_graph" class="anchored"><a href="#val-normalize_in_graph" class="anchor"></a><code><span><span class="keyword">val</span> normalize_in_graph : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Another name for <code>normalize_filepath</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-normalize_in_tree" class="anchored"><a href="#val-normalize_in_tree" class="anchor"></a><code><span><span class="keyword">val</span> normalize_in_tree : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Consumes single dots and applies double dots where possible, e.g.:</p><p><code>normalize ([&quot;..&quot;]/:&quot;foo&quot;/:&quot;.&quot;/:&quot;bar&quot;/:&quot;sub1&quot;/:&quot;..&quot;/:&quot;sub2&quot;) = [&quot;..&quot;]/:&quot;foo&quot;/:&quot;bar&quot;/:&quot;sub2&quot;</code></p><p>This normalization is useful when dealing with paths that describe locations in a tree and the &quot;..&quot; symbol always points to the only parent of what precedes this symbol.</p><p><em>Windows:</em> If single dot is next to root, it is preserved.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Malformed_path</span> <p>when absolute path is given that contains double dots that would be applied to the root.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-normalize" class="anchored"><a href="#val-normalize" class="anchor"></a><code><span><span class="keyword">val</span> normalize : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Deprecated name for <code>normalize_in_tree</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-parent" class="anchored"><a href="#val-parent" class="anchor"></a><code><span><span class="keyword">val</span> parent : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Returns parent path, i.e. immediate ancestor: <code>parent (foo/:bar) = foo</code></p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if empty path (relative <code>[]</code> or absolute <code>[&quot;&quot;]</code>) is given</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-belongs" class="anchored"><a href="#val-belongs" class="anchor"></a><code><span><span class="keyword">val</span> belongs : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>belongs base sub</code> is <code>true</code> when <code>sub</code> descends from <code>base</code>, i.e. <code>base</code> is a prefix of <code>sub</code>. If <code>base</code>=<code>sub</code> the function returns <code>true</code>. It is otherwise <code>false</code>. Both arguments must be absolute paths or both relative.</p><p>If both arguments have a root portion with drive letter and these letters are different, <code>belongs base sub</code> returns false.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if exactly one of given arguments is absolute path</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-relative_to_any" class="anchored"><a href="#val-relative_to_any" class="anchor"></a><code><span><span class="keyword">val</span> relative_to_any : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>relative_to_any base sub</code> returns relative path <code>rel</code> such that <code>normalize (base/:rel) = normalize sub</code>, i.e. common base is stripped and &quot;..&quot; are added if necessary. Both arguments must be absolute paths or both relative.</p><p>This function normalizes <code>base</code> and <code>sub</code> before calculation of the relative path.</p><p><em>Windows:</em> If <code>base</code> and <code>sub</code> are absolute, they must have the same root element: have the same drive letter or both starting with <a href="#val-root"><code>root</code></a> (i.e. <code>&quot;&quot;</code> is the last element of the list). Exceptionally it is possible to get an absolute path as a result if drive letter is in <code>sub</code> but not as a root element (e .g. <code>base = root/:&quot;bar&quot;</code> and <code>sub = root/:bar//@([&quot;C:&quot;]/:&quot;foo&quot;</code>).</p><ul class="at-tags"><li class="see"><span class="at-tag">see</span> <code class="value">relative_to_parent</code> <p>may be sometimes more suitable</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if exactly one of given arguments is an absolute path</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Malformed_path</span> <p>if normalization fails (see <code>PathType</code>.normalize)</p></li></ul></div></div><div class="odoc-spec"><div class="spec exception" id="exception-Not_parent" class="anchored"><a href="#exception-Not_parent" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Not_parent</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-relative_to_parent" class="anchored"><a href="#val-relative_to_parent" class="anchor"></a><code><span><span class="keyword">val</span> relative_to_parent : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>relative_to_parent parent sub</code> returns relative path <code>rel</code> such that <code>(normalize parent)/:rel = normalize sub</code>. It is checked if <code>sub</code> is really a descendant of <code>parent</code>. Both arguments must be absolute paths or both relative.</p><p>This function normalizes <code>base</code> and <code>sub</code> before calculation of the relative path.</p><p><em>Windows:</em> Exceptionally it is possible to get an absolute path as a result if drive letter is in <code>sub</code> but not as a root element (e .g. <code>base = root/:&quot;bar&quot;</code> and <code>sub = root/:bar//@([&quot;C:&quot;]/:&quot;foo&quot;)</code>).</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Not_parent</span> <p>if <code>sub</code> is not descendant of <code>parent</code></p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if exactly one of given arguments is absolute path</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Malformed_path</span> <p>if normalization fails (see <code>PathType</code>.normalize)</p></li></ul></div></div><h6 id="validation"><a href="#validation" class="anchor"></a>Validation</h6><div class="odoc-spec"><div class="spec exception" id="exception-Illegal_char" class="anchored"><a href="#exception-Illegal_char" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Illegal_char</span></span></code></div><div class="spec-doc"><p>Raised by <a href="#val-of_string"><code>PathType.of_string</code></a>, <a href="#val-append"><code>PathType.append</code></a> and <a href="Operators/index.html#val-(/:)"><code>PathType.Operators.(/:)</code></a> when used validator finds illegal character.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-validator" class="anchored"><a href="#type-validator" class="anchor"></a><code><span><span class="keyword">type</span> validator</span><span> = <span><a href="#type-ustring">ustring</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Validators should check if all characters of given string can be used in a name (path component). Return true if the name is valid. Return false if illegal character is found.</p><p>If a name should be rejected for some other reason, user defined validator may raise an exception.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-default_validator" class="anchored"><a href="#val-default_validator" class="anchor"></a><code><span><span class="keyword">val</span> default_validator : <span><a href="#type-validator">validator</a> <a href="../../../ocaml/Stdlib/index.html#type-ref">ref</a></span></span></code></div><div class="spec-doc"><p>Forward slash and code zero are considered invalid.</p><p><em>Windows:</em> Invalid characters are *?:\/&lt;&gt; and all with code &lt;32. Exception: the function <a href="#val-of_string"><code>PathType.of_string</code></a> doesn't use validator against drive letter with colon.</p></div></div><h6 id="conversions"><a href="#conversions" class="anchor"></a>Conversions</h6><div class="odoc-spec"><div class="spec value" id="val-to_ustring" class="anchored"><a href="#val-to_ustring" class="anchor"></a><code><span><span class="keyword">val</span> to_ustring : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ustring">ustring</a></span></code></div><div class="spec-doc"><p>Convert to the chosen <code>ustring</code> type. Empty relative path is converted to &quot;.&quot; (single dot).</p><p><em>Windows:</em> backslash is used as a separator and double backslash for root. If the path is only a drive letter (empty absolute path) trailing backslash is added (e.g. <code>to_string [&quot;C:&quot;] = &quot;C:\&quot;</code>).</p><ul class="at-tags"><li class="see"><span class="at-tag">see</span> <code class="value">to_string</code> <p>is likely to bo more useful &quot;</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-to_string" class="anchored"><a href="#val-to_string" class="anchor"></a><code><span><span class="keyword">val</span> to_string : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Convert to type primitive string with UTF-8 content. The string is built in the same way as by <code>to_ustring</code> function.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_string" class="anchored"><a href="#val-of_string" class="anchor"></a><code><span><span class="keyword">val</span> of_string : <span><a href="#type-ustring">ustring</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Parse path in a given string. Any number of consecutive separators collapse (&quot;a//b&quot; becomes &quot;a/b&quot;). <code>Path.default_validator</code> is applied to each resulting name.</p><p><em>Windows:</em> both slashes '\' and '/' are accepted as separators. Paths of the 'semi-relative' form &quot;C:foo\bar&quot; are not recognized. For example &quot;C:&quot; string is parsed as <code>[&quot;C:&quot;]</code> which has different meaning (see <a href="#val-to_string"><code>to_string</code></a>).</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Illegal_char</span> <p>when a character not allowed in paths is found.</p></li></ul></div></div><h6 id="convenience-aliases"><a href="#convenience-aliases" class="anchor"></a>Convenience aliases</h6><div class="odoc-spec"><div class="spec value" id="val-s" class="anchored"><a href="#val-s" class="anchor"></a><code><span><span class="keyword">val</span> s : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>= <a href="#val-to_string"><code>to_string</code></a></p></div></div><div class="odoc-spec"><div class="spec value" id="val-p" class="anchored"><a href="#val-p" class="anchor"></a><code><span><span class="keyword">val</span> p : <span><a href="#type-ustring">ustring</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>= <a href="#val-of_string"><code>of_string</code></a></p></div></div><h6 id="name-related-functions"><a href="#name-related-functions" class="anchor"></a>Name related functions</h6><p>These functions do not accept empty paths, i.e. <code>[]</code>, <code>[&quot;&quot;]</code> or <code>[&quot;C:&quot;]</code>.</p><div class="odoc-spec"><div class="spec value" id="val-name" class="anchored"><a href="#val-name" class="anchor"></a><code><span><span class="keyword">val</span> name : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ustring">ustring</a></span></code></div><div class="spec-doc"><p>Returns name of the object the pathname points to, i.e. <code>name (foo/:bar) = bar</code></p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if empty path (relative <code>[]</code> or absolute <code>[&quot;&quot;]</code>) is given</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-map_name" class="anchored"><a href="#val-map_name" class="anchor"></a><code><span><span class="keyword">val</span> map_name : <span><span>(<span><a href="#type-ustring">ustring</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ustring">ustring</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>map_name fu path</code> returns <code>path</code> with the name replaced by <code>fu (</code><a href="#val-name"><code>PathType.name</code></a><code> path)</code>.</p><p>Example: <code>map_name (fun nn -&gt; nn ^ &quot;.backup&quot;) ([&quot;foo&quot;]/:&quot;bar&quot;) = [&quot;foo&quot;]/:&quot;bar.backup&quot;</code></p><p><a href="#val-default_validator"><code>PathType.default_validator</code></a> is applied to new name.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Illegal_char</span> <p>(raised by validator if any bad character is found)</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-ext" class="anchored"><a href="#val-ext" class="anchor"></a><code><span><span class="keyword">val</span> ext : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-ustring">ustring</a> option</span></span></code></div><div class="spec-doc"><p>Returns extension of the name of the object the pathname points to. Examples:</p><p><code>ext [&quot;aa.bb&quot;] = Some &quot;bb&quot;</code></p><p><code>ext [&quot;aa.&quot;] = Some &quot;&quot;</code></p><p><code>ext [&quot;aa&quot;] = None</code></p><p><code>ext [&quot;.hidden&quot;] = Some &quot;hidden&quot;</code> <em>(!)</em></p><p>Extension begins where the rightmost dot in the name is found. If the name ends with a dot, the extension is empty and <code>Some &quot;&quot;</code> is returned. If there is no extension (no dot) the function returns <code>None</code>.</p><p>@example &quot;Count unfinished music downloads (files ending with '.ogg.part').&quot;</p><pre><code>let count_music_parts download_dir =
  let files = Directory.files download_dir in
  let check file =
    match Path.ext file with
    | Some &quot;part&quot; -&gt; ((Path.ext (Path.name_core file)) = &quot;ogg&quot;)
    | _ -&gt; false
  in
  let music_parts = List.filter check files in
  List.length music_parts</code></pre><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if empty path (relative <code>[]</code> or absolute <code>[&quot;&quot;]</code>) is given</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-map_ext" class="anchored"><a href="#val-map_ext" class="anchor"></a><code><span><span class="keyword">val</span> map_ext : <span><span>(<span><span><a href="#type-ustring">ustring</a> option</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-ustring">ustring</a> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>map_ext fu path</code> returns <code>path</code> but with the name with extension given by <code>fu (</code><a href="#val-ext"><code>PathType.ext</code></a><code> path)</code>. If <code>fu</code> returns <code>Some _</code>, the original extension may be replaced (when <code>Some ext</code> is passed to <code>fu</code>) or new added (when <code>fu</code> gets <code>None</code>). In case <code>fu</code> returns <code>None</code>, the extension is removed (if exists).</p><p>@example &quot;A name for file being encoded in a new format.&quot;</p><pre><code>let pngname file = map_ext (function Some _ | None -&gt; Some &quot;png&quot;) file
let new_bar = pngname ([&quot;foo&quot;]/:&quot;bar.jpeg&quot;) (* = [&quot;foo&quot;]/:&quot;bar.png&quot; *)</code></pre><p><a href="#val-default_validator"><code>PathType.default_validator</code></a> is applied to the resulting name.</p><p>The replacement string returned by the mapping function <code>fu</code> can contain dots. Consequently, this string doesn't need to be an extension as defined by the <a href="#val-ext"><code>ext</code></a> function. Consider for example:</p><pre><code>let before = foo/:&quot;bar.mli&quot;
let replacement = &quot;mli.off&quot;
let ext_before = Path.ext before (* = Some &quot;mli&quot; *)
let after = Path.map_ext (fun _ -&gt; Some replacement) before (* = foo/:&quot;bar.mli.off&quot; *)
let ext_after = Path.ext after (* = Some &quot;off&quot; *)</code></pre><p>Note the difference between <code>replacement</code> and <code>ext_after</code>! <code>(map_ext fu)</code> is idempotent only if <code>fu</code> always returns <code>Some _</code>. Otherwise it can remove the extension, possibly exposing part of the name that becomes the new extension.</p><p><em>Windows:</em> If <code>fu</code> returns <code>Some &quot;&quot;</code> (to make a name with trailing period) <code>map_ext</code> returns a path that shouldn't be passed to the operating system (it is invalid).</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Illegal_char</span> <p>(raised by validator if any bad character is found)</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if empty path (relative <code>[]</code> or absolute <code>[&quot;&quot;]</code>) is given</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-name_core" class="anchored"><a href="#val-name_core" class="anchor"></a><code><span><span class="keyword">val</span> name_core : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ustring">ustring</a></span></code></div><div class="spec-doc"><p>Returns part of the name to the left of rightmost dot. Returns empty string if the name starts with a dot.</p><p>@example &quot;Label for a piece of GUI in which a file is edited.&quot;</p><pre><code>let tab_label modified file =
  let text = (if modified then &quot;*&quot; else &quot;&quot;) ^ (Path.name_core file) in
  GMisc.label ~text ()</code></pre><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if empty path (relative <code>[]</code> or absolute <code>[&quot;&quot;]</code>) is given</p></li></ul></div></div><div class="odoc-spec"><div class="spec type" id="type-components" class="anchored"><a href="#type-components" class="anchor"></a><code><span><span class="keyword">type</span> components</span><span> = <a href="#type-t">t</a> * <a href="#type-ustring">ustring</a> * <span><a href="#type-ustring">ustring</a> option</span></span></code></div><div class="spec-doc"><p>A <code>path</code> can be represented by the following triple: <code>(Path.parent path, Path.name_core path, Path.ext path)</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-split" class="anchored"><a href="#val-split" class="anchor"></a><code><span><span class="keyword">val</span> split : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-components">components</a></span></code></div><div class="spec-doc"><p>Dissect the path to its components (parent path, core part of name and possibly an extension).</p><p>Resulting <code>name_core</code> string can be empty. For example, <code>Path.split (Path.root/:&quot;home&quot;/:&quot;user&quot;/:&quot;.bashrc&quot;)</code> equals <code>(Path.root/:&quot;home&quot;/:&quot;user&quot;, &quot;&quot;, Some &quot;bashrc&quot;)</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if empty path (relative <code>[]</code> or absolute <code>[&quot;&quot;]</code>) is given</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-join" class="anchored"><a href="#val-join" class="anchor"></a><code><span><span class="keyword">val</span> join : <span><a href="#type-components">components</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Create a path from given components.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Illegal_char</span> <p>(raised by validator on any bad character)</p><p>@example &quot;Creating paths for a series of numbered images.&quot;</p><pre><code>let get_animation_frames working_dir count =
  let frame_file num = Path.join
      (working_dir/:&quot;rendering&quot;
      ,&quot;frame&quot;^(stirng_of_int num)
      ,Some &quot;png&quot;
      )
  in
  BatEnum.map frame_file (1 -- count)</code></pre></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-map" class="anchored"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span><span>(<span><a href="#type-components">components</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-components">components</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Map a path through a function that operates on separate components.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Illegal_char</span> <p>(raised by validator on any bad character)</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if empty path (relative <code>[]</code> or absolute <code>[&quot;&quot;]</code>) is given</p><p>@example &quot;Insert a string just before file extension.&quot;</p><pre><code>let extract_first_page file =
  let insert (parent, name_core, ext) = (parent, name_core ^ &quot;_page1&quot;, ext) in
  let result_file = Path.map insert file in
  let code = Sys.command
      (String.concat ' '
         [&quot;psselect -p1 &lt;&quot;; P.s file
         ;&quot; &gt;&quot;; P.s result_file
         ]
      )
  in
  if code = 0 then result_file else failwith &quot;psselect&quot;</code></pre></li></ul></div></div><h6 id="supplementary-functions"><a href="#supplementary-functions" class="anchor"></a>Supplementary functions</h6><div class="odoc-spec"><div class="spec value" id="val-drive_letter" class="anchored"><a href="#val-drive_letter" class="anchor"></a><code><span><span class="keyword">val</span> drive_letter : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-uchar">uchar</a> option</span></span></code></div><div class="spec-doc"><p>Return drive letter of the given absolute path.</p><p><em>Windows:</em> <code>drive_letter abs</code> returns <code>None</code> if <code>abs</code> is simple absolute path (i.e. begins with a separator), otherwise the root element of <code>abs</code> consists of a letter <code>ch</code> with a colon - in this case <code>Some ch</code> is returned.</p><p><em>Other systems:</em> Returns <code>None</code> on all absolute paths.</p><p>@example &quot;(Windows only) Are the locations on the same partition?&quot;</p><pre><code>let can_move_quickly ~path_from ~path_to =
(drive_letter path_from) = (drive_letter path_to)</code></pre><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if relative path is given</p></li></ul></div></div></div></body></html>