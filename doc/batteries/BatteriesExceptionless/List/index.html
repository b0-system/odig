<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>List (batteries.BatteriesExceptionless.List)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">batteries</a> &#x00BB; <a href="../index.html">BatteriesExceptionless</a> &#x00BB; List</nav><header class="odoc-preamble"><h1>Module <code><span>BatteriesExceptionless.List</span></code></h1></header><div class="odoc-content"><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> <a href="../../BatList/index.html">BatList</a> <span class="keyword">with</span> <span><span class="keyword">module</span> <a href="../../BatList/Labels/index.html">Labels</a> := <a href="../../BatList/Labels/index.html">BatList.Labels</a></span></span></code></summary><p>List operations.</p><p>@documents List</p><ul class="at-tags"><li class="author"><span class="at-tag">author</span> Xavier Leroy (base module)</li></ul><ul class="at-tags"><li class="author"><span class="at-tag">author</span> Brian Hurt</li></ul><ul class="at-tags"><li class="author"><span class="at-tag">author</span> Nicolas Cannasse</li></ul><ul class="at-tags"><li class="author"><span class="at-tag">author</span> Richard W.M. Jones</li></ul><ul class="at-tags"><li class="author"><span class="at-tag">author</span> David Teller</li></ul><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a t</span></span><span> = <span><span class="type-var">'a</span> list</span></span><span> = </span></code><table><tr id="type-t.[]" class="anchored"><td class="def variant constructor"><a href="#type-t.[]" class="anchor"></a><code><span>| </span><span><span class="constructor">[]</span></span></code></td></tr><tr id="type-t.::" class="anchored"><td class="def variant constructor"><a href="#type-t.::" class="anchor"></a><code><span>| </span><span><span class="constructor">::</span> <span class="keyword">of</span> <span class="type-var">'a</span> * <span><span class="type-var">'a</span> list</span></span></code></td></tr></table></div></div><p>The type of lists</p><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../../BatEnum/module-type-Enumerable/index.html">BatEnum.Enumerable</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="../../BatEnum/module-type-Enumerable/index.html#type-enumerable">enumerable</a></span> = <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></span></code></summary><div class="odoc-spec"><div class="spec type" id="type-enumerable" class="anchored"><a href="#type-enumerable" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a enumerable</span></span><span> = <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>The data structure, e.g. <code>'a List.t</code></p></div></div></details></div><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../../BatInterfaces/module-type-Mappable/index.html">BatInterfaces.Mappable</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="../../BatInterfaces/module-type-Mappable/index.html#type-mappable">mappable</a></span> = <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></span></code></summary><div class="odoc-spec"><div class="spec type" id="type-mappable" class="anchored"><a href="#type-mappable" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a mappable</span></span><span> = <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>The data structure, e.g. <code>'a List.t</code></p></div></div></details></div><h6 id="base-operations"><a href="#base-operations" class="anchor"></a>Base operations</h6><div class="odoc-spec"><div class="spec value" id="val-is_empty" class="anchored"><a href="#val-is_empty" class="anchor"></a><code><span><span class="keyword">val</span> is_empty : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_empty e</code> returns true if <code>e</code> does not contains any element.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-cons" class="anchored"><a href="#val-cons" class="anchor"></a><code><span><span class="keyword">val</span> cons : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>cons h t</code> returns the list starting with <code>h</code> and continuing as <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-first" class="anchored"><a href="#val-first" class="anchor"></a><code><span><span class="keyword">val</span> first : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Alias to hd</p></div></div><div class="odoc-spec"><div class="spec value" id="val-length" class="anchored"><a href="#val-length" class="anchor"></a><code><span><span class="keyword">val</span> length : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Return the length (number of elements) of the given list.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-compare_lengths" class="anchored"><a href="#val-compare_lengths" class="anchor"></a><code><span><span class="keyword">val</span> compare_lengths : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Compare the lengths of two lists. <code>compare_lengths l1 l2</code> is equivalent to <code>compare (length l1) (length l2)</code>, except that the computation stops after itering on the shortest list.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.7.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-compare_length_with" class="anchored"><a href="#val-compare_length_with" class="anchor"></a><code><span><span class="keyword">val</span> compare_length_with : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Compare the length of a list to an integer. <code>compare_length_with l n</code> is equivalent to <code>compare (length l) n</code>, except that the computation stops after at most <code>n</code> iterations on the list.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.7.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-at_opt" class="anchored"><a href="#val-at_opt" class="anchor"></a><code><span><span class="keyword">val</span> at_opt : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div><div class="spec-doc"><p><code>at_opt</code> returns the n-th element of the list <code>l</code> or None if the index is beyond the length of <code>l</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.7.0</li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if the index is negative</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-rev" class="anchored"><a href="#val-rev" class="anchor"></a><code><span><span class="keyword">val</span> rev : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p>List reversal.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-shuffle" class="anchored"><a href="#val-shuffle" class="anchor"></a><code><span><span class="keyword">val</span> shuffle : <span>?state:<a href="../../../ocaml/Stdlib/Random/State/index.html#type-t">Random.State.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>shuffle ~state:rs l</code> randomly shuffles the elements of <code>l</code>. The optional random state <code>rs</code> allows to control the random numbers being used during shuffling (for reproducibility).</p><p>Shuffling is implemented using the Fisher-Yates algorithm on an array and works in O(n), where n is the number of elements of <code>l</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.6.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-append" class="anchored"><a href="#val-append" class="anchor"></a><code><span><span class="keyword">val</span> append : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>append l1 l2</code> is a concatenation of <code>l1</code> and <code>l2</code>. Same function as the infix operator <code>@</code>. Tail-recursive. This function takes O(<code>length l1</code>) time.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-rev_append" class="anchored"><a href="#val-rev_append" class="anchor"></a><code><span><span class="keyword">val</span> rev_append : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>List.rev_append l1 l2</code> reverses <code>l1</code> and concatenates it to <code>l2</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-concat" class="anchored"><a href="#val-concat" class="anchor"></a><code><span><span class="keyword">val</span> concat : <span><span><span><span class="type-var">'a</span> list</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p>Concatenate a list of lists. The elements of the argument are all concatenated together (in the same order) to give the result. Tail-recursive.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-flatten" class="anchored"><a href="#val-flatten" class="anchor"></a><code><span><span class="keyword">val</span> flatten : <span><span><span><span class="type-var">'a</span> list</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p>Same as <code>concat</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-singleton" class="anchored"><a href="#val-singleton" class="anchor"></a><code><span><span class="keyword">val</span> singleton : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p>Create a list consisting of exactly one element.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.1</li></ul></div></div><h6 id="constructors"><a href="#constructors" class="anchor"></a>Constructors</h6><div class="odoc-spec"><div class="spec value" id="val-make" class="anchored"><a href="#val-make" class="anchor"></a><code><span><span class="keyword">val</span> make : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p>Similar to <code>String.make</code>, <code>make n x</code> returns a list containing <code>n</code> elements <code>x</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-range" class="anchored"><a href="#val-range" class="anchor"></a><code><span><span class="keyword">val</span> range : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span>[&lt; `To <span>| `Downto</span> ]</span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int list</span></span></code></div><div class="spec-doc"><p><code>range 1 `To 3</code> = <code>[1; 2; 3]</code>. <code>range 3 `Downto 1</code> = <code>[3; 2; 1]</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>in (<code>range i `To j</code>) if (i &gt; j).</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>in (<code>range i `Downto j</code>) if (i &lt; j).</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.2.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-frange" class="anchored"><a href="#val-frange" class="anchor"></a><code><span><span class="keyword">val</span> frange : <span>float <span class="arrow">&#45;&gt;</span></span> <span><span>[&lt; `To <span>| `Downto</span> ]</span> <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>float list</span></span></code></div><div class="spec-doc"><p><code>frange start `To stop n</code> generates (without accumulating floating point errors) <code>n</code> floats in the range <code>[start..stop]</code>. <code>n</code> must be &gt;= 2. At each step, floats in an increasing (resp. decreasing) range increase (resp. decrease) by approximately (stop - start) / (n - 1).</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>in (<code>frange i _ j n</code>) if (n &lt; 2).</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>in (<code>frange i `To j _</code>) if (i &gt;= j).</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>in (<code>frange i `Downto j _</code>) if (i &lt;= j). Examples: <code>frange 1.0 `To 3.0 3</code> = <code>[1.0; 2.0; 3.0]</code>. <code>frange 3.0 `Downto 1.0 3</code> = <code>[3.0; 2.0; 1.0]</code>.</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.6.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-init" class="anchored"><a href="#val-init" class="anchor"></a><code><span><span class="keyword">val</span> init : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p>Similar to <code>Array.init</code>, <code>init n f</code> returns the list containing the results of (f 0),(f 1).... (f (n-1)).</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if n &lt; 0.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-unfold" class="anchored"><a href="#val-unfold" class="anchor"></a><code><span><span class="keyword">val</span> unfold : <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>unfold init f</code> creates a list by repeatedly applying <code>f</code> to the second element of its own result, starting from the initial value <code>init</code>. The first element of each result is accumulated in a list. The list is terminated and returned as soon as <code>f</code> returns <code>None</code>.</p><p>Example: <code>List.unfold 0 (fun x -&gt; if x = 3 then None else Some (string_of_int x, x+1))</code> will return <code>[&quot;0&quot;;&quot;1&quot;;&quot;2&quot;]</code></p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.1</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-unfold_exn" class="anchored"><a href="#val-unfold_exn" class="anchor"></a><code><span><span class="keyword">val</span> unfold_exn : <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span> * exn</span></code></div><div class="spec-doc"><p>Creates a list containing the results of sequential calls to <code>f()</code>. <code>f()</code> is called repeatedly until it throws an exception. Both the results list, as well as the exception thrown are returned in a <code>(results_list, exn)</code> pair. Warning: if calls to <code>f()</code> never throw an exception, unfold_exn is an infinite loop.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.2.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-unfold_exc" class="anchored"><a href="#val-unfold_exc" class="anchor"></a><code><span><span class="keyword">val</span> unfold_exc : <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span> * exn</span></code></div><div class="spec-doc"><p>Alias for <code>unfold_exn</code>.</p><ul class="at-tags"><li class="deprecated"><span class="at-tag">deprecated</span> <p>use <code>unfold_exn</code></p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.3.0</li></ul></div></div><h6 id="comparison"><a href="#comparison" class="anchor"></a>Comparison</h6><div class="odoc-spec"><div class="spec value" id="val-equal" class="anchored"><a href="#val-equal" class="anchor"></a><code><span><span class="keyword">val</span> equal : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>equal eq [a1; ...; an] [b1; ..; bm]</code> holds when the two input lists have the same length, and for each pair of elements <code>ai</code>, <code>bi</code> at the same position we have <code>eq ai bi</code>.</p><p>Note: the <code>eq</code> function may be called even if the lists have different length. If you know your equality function is costly, you may want to check <a href="#val-compare_lengths"><code>compare_lengths</code></a> first.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.3.0 and 4.12.0</li></ul></div></div><h6 id="iterators"><a href="#iterators" class="anchor"></a>Iterators</h6><div class="odoc-spec"><div class="spec value" id="val-iter" class="anchored"><a href="#val-iter" class="anchor"></a><code><span><span class="keyword">val</span> iter : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>List.iter f [a0; a1; ...; an]</code> applies function <code>f</code> in turn to <code>a0; a1; ...; an</code>. It is equivalent to <code>begin f a0; f a1; ...; f an; () end</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-iteri" class="anchored"><a href="#val-iteri" class="anchor"></a><code><span><span class="keyword">val</span> iteri : <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>iteri f l</code> will call <code>(f 0 a0); (f 1 a1) ... (f n an)</code> where <code>a0..an</code> are the elements of the list <code>l</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-map" class="anchored"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> list</span></span></code></div><div class="spec-doc"><p><code>map f [a0; a1; ...; an]</code> applies function <code>f</code> to <code>a0, a1, ..., an</code>, and builds the list <code>[f a0; f a1; ...; f an]</code> with the results returned by <code>f</code>. Tail-recursive.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-rev_map" class="anchored"><a href="#val-rev_map" class="anchor"></a><code><span><span class="keyword">val</span> rev_map : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> list</span></span></code></div><div class="spec-doc"><p><code>List.rev_map f l</code> gives the same result as <a href="#val-rev"><code>List.rev</code></a><code> (</code><a href="#val-map"><code>List.map</code></a><code> f l)</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mapi" class="anchored"><a href="#val-mapi" class="anchor"></a><code><span><span class="keyword">val</span> mapi : <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> list</span></span></code></div><div class="spec-doc"><p><code>mapi f l</code> will build the list containing <code>(f 0 a0); (f 1 a1) ... (f n an)</code> where <code>a0..an</code> are the elements of the list <code>l</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_left" class="anchored"><a href="#val-fold_left" class="anchor"></a><code><span><span class="keyword">val</span> fold_left : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>List.fold_left f a [b0; b1; ...; bn]</code> is <code>f (... (f (f a b0) b1) ...) bn</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold" class="anchored"><a href="#val-fold" class="anchor"></a><code><span><span class="keyword">val</span> fold : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Alias for <code>fold_left</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_lefti" class="anchored"><a href="#val-fold_lefti" class="anchor"></a><code><span><span class="keyword">val</span> fold_lefti : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>As <code>fold_left</code>, but with the index of the element, from <code>0</code> to <code>length li - 1</code>, as additional argument.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.3.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_right" class="anchored"><a href="#val-fold_right" class="anchor"></a><code><span><span class="keyword">val</span> fold_right : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span></span></code></div><div class="spec-doc"><p><code>List.fold_right f [a0; a1; ...; an] b</code> is <code>f a0 (f a1 (... (f an b) ...))</code>. Tail-recursive.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_righti" class="anchored"><a href="#val-fold_righti" class="anchor"></a><code><span><span class="keyword">val</span> fold_righti : <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>As <code>fold_right</code>, but with the index of the element, from <code>0</code> to <code>length li - 1</code>, as additional argument.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.3.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-reduce" class="anchored"><a href="#val-reduce" class="anchor"></a><code><span><span class="keyword">val</span> reduce : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>List.reduce f h::t</code> is <code>fold_left f h t</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>on empty list.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_left_map" class="anchored"><a href="#val-fold_left_map" class="anchor"></a><code><span><span class="keyword">val</span> fold_left_map : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> * <span class="type-var">'c</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> * <span><span class="type-var">'c</span> list</span></span></code></div><div class="spec-doc"><p>Combines <code>fold_left</code> and <code>map</code>. Tail-recursive.</p><p>More precisely :</p><pre><code>fold_left_map f acc [] = (acc, [])

fold_left_map f acc (x :: xs) =
  let (acc', y) = f acc x in
  let (res, ys) = fold_left_map acc' xs in
  (res, y :: ys)</code></pre><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.6.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-max" class="anchored"><a href="#val-max" class="anchor"></a><code><span><span class="keyword">val</span> max : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>max l</code> returns the largest value in <code>l</code> as judged by <code>Pervasives.compare</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>on an empty list.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-min" class="anchored"><a href="#val-min" class="anchor"></a><code><span><span class="keyword">val</span> min : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>min l</code> returns the smallest value in <code>l</code> as judged by <code>Pervasives.compare</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>on an empty list.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-sum" class="anchored"><a href="#val-sum" class="anchor"></a><code><span><span class="keyword">val</span> sum : <span><span>int list</span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>sum l</code> returns the sum of the integers of <code>l</code>. Returns <code>0</code> on the empty list. Note: prior to 2.11.0, used to raise Invalid_argument on the empty list.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fsum" class="anchored"><a href="#val-fsum" class="anchor"></a><code><span><span class="keyword">val</span> fsum : <span><span>float list</span> <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p><code>fsum l</code> returns the sum of the floats of <code>l</code>. Returns <code>0.</code> on the empty list. Note: prior to 2.11.0, used to raise Invalid_argument on the empty list.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-favg" class="anchored"><a href="#val-favg" class="anchor"></a><code><span><span class="keyword">val</span> favg : <span><span>float list</span> <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p><code>favg l</code> returns the average of the floats of <code>l</code></p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>on the empty list.</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.6.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-kahan_sum" class="anchored"><a href="#val-kahan_sum" class="anchor"></a><code><span><span class="keyword">val</span> kahan_sum : <span><span>float list</span> <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p><code>kahan_sum l</code> returns a numerically-accurate sum of the floats of <code>l</code>. See <a href="../../BatArray/index.html#val-fsum"><code>BatArray.fsum</code></a> for more details.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.2.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-min_max" class="anchored"><a href="#val-min_max" class="anchor"></a><code><span><span class="keyword">val</span> min_max : <span>?cmp:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> * <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>min_max l</code> returns the pair (smallest, largest) from <code>l</code> as judged by <code>Pervasives.compare</code> (by default). You can provide another comparison function via the optional <code>cmp</code> parameter.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>on an empty list.</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.1</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-to_seq" class="anchored"><a href="#val-to_seq" class="anchor"></a><code><span><span class="keyword">val</span> to_seq : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../../../ocaml/Stdlib/Seq/index.html#type-t">Seq.t</a></span></span></code></div><div class="spec-doc"><p>Iterate on the list</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.10.0 and OCaml 4.07</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-of_seq" class="anchored"><a href="#val-of_seq" class="anchor"></a><code><span><span class="keyword">val</span> of_seq : <span><span><span class="type-var">'a</span> <a href="../../../ocaml/Stdlib/Seq/index.html#type-t">Seq.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p>Create a list from the iterator</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.10.0 and OCaml 4.07</li></ul></div></div><h6 id="iterators-on-two-lists"><a href="#iterators-on-two-lists" class="anchor"></a>Iterators on two lists</h6><div class="odoc-spec"><div class="spec value" id="val-iter2" class="anchored"><a href="#val-iter2" class="anchor"></a><code><span><span class="keyword">val</span> iter2 : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>List.iter2 f [a0; a1; ...; an] [b0; b1; ...; bn]</code> calls in turn <code>f a0 b0; f a1 b1; ...; f an bn</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if two lists have different lengths.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-iter2i" class="anchored"><a href="#val-iter2i" class="anchor"></a><code><span><span class="keyword">val</span> iter2i : <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>List.iter2i f [a0; a1; ...; an] [b0; b1; ...; bn]</code> calls in turn <code>f 0 a0 b0; f 1 a1 b1; ...; f n an bn</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if two lists have different lengths.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-map2" class="anchored"><a href="#val-map2" class="anchor"></a><code><span><span class="keyword">val</span> map2 : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> list</span></span></code></div><div class="spec-doc"><p><code>List.map2 f [a0; a1; ...; an] [b0; b1; ...; bn]</code> is <code>[f a0 b0; f a1 b1; ...; f an bn]</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if two lists have different lengths. Tail-recursive.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-map2i" class="anchored"><a href="#val-map2i" class="anchor"></a><code><span><span class="keyword">val</span> map2i : <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> list</span></span></code></div><div class="spec-doc"><p><code>List.map2i f [a0; a1; ...; an] [b0; b1; ...; bn]</code> is <code>[f 0 a0 b0; f 1 a1 b1; ...; f n an bn]</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if two lists have different lengths. Tail-recursive.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-rev_map2" class="anchored"><a href="#val-rev_map2" class="anchor"></a><code><span><span class="keyword">val</span> rev_map2 : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> list</span></span></code></div><div class="spec-doc"><p><code>List.rev_map2 f l1 l2</code> gives the same result as <a href="#val-rev"><code>List.rev</code></a><code> (</code><a href="#val-map2"><code>List.map2</code></a><code> f l1 l2)</code>, but is tail-recursive and more efficient.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_left2" class="anchored"><a href="#val-fold_left2" class="anchor"></a><code><span><span class="keyword">val</span> fold_left2 : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'c</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>List.fold_left2 f a [b0; b1; ...; bn] [c0; c1; ...; cn]</code> is <code>f (... (f (f a b0 c0) b1 c1) ...) bn cn</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if two lists have different lengths.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_right2" class="anchored"><a href="#val-fold_right2" class="anchor"></a><code><span><span class="keyword">val</span> fold_right2 : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span></span></code></div><div class="spec-doc"><p><code>List.fold_right2 f [a0; a1; ...; an] [b0; b1; ...; bn] c</code> is <code>f a0 b0 (f a1 b1 (... (f an bn c) ...))</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if two lists have different lengths. Tail-recursive.</p></li></ul></div></div><h6 id="list-scanning"><a href="#list-scanning" class="anchor"></a>List scanning</h6><div class="odoc-spec"><div class="spec value" id="val-mem" class="anchored"><a href="#val-mem" class="anchor"></a><code><span><span class="keyword">val</span> mem : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>mem a l</code> is true if and only if <code>a</code> is equal to an element of <code>l</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mem_cmp" class="anchored"><a href="#val-mem_cmp" class="anchor"></a><code><span><span class="keyword">val</span> mem_cmp : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Same as <a href="#val-mem"><code>List.mem</code></a>, but the comparator function is explicitly provided.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.2.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-memq" class="anchored"><a href="#val-memq" class="anchor"></a><code><span><span class="keyword">val</span> memq : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Same as <a href="#val-mem"><code>List.mem</code></a>, but uses physical equality instead of structural equality to compare list elements.</p></div></div><h6 id="unary-predicate,-one-list"><a href="#unary-predicate,-one-list" class="anchor"></a>Unary predicate, One list</h6><div class="odoc-spec"><div class="spec value" id="val-for_all" class="anchored"><a href="#val-for_all" class="anchor"></a><code><span><span class="keyword">val</span> for_all : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>for_all p [a0; a1; ...; an]</code> checks if all elements of the list satisfy the predicate <code>p</code>. That is, it returns <code>(p a0) &amp;&amp; (p a1) &amp;&amp; ... &amp;&amp; (p an)</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-exists" class="anchored"><a href="#val-exists" class="anchor"></a><code><span><span class="keyword">val</span> exists : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>exists p [a0; a1; ...; an]</code> checks if at least one element of the list satisfies the predicate <code>p</code>. That is, it returns <code>(p a0) || (p a1) || ... || (p an)</code>.</p></div></div><h6 id="binary-predicate,-two-lists"><a href="#binary-predicate,-two-lists" class="anchor"></a>Binary predicate, Two lists</h6><div class="odoc-spec"><div class="spec value" id="val-for_all2" class="anchored"><a href="#val-for_all2" class="anchor"></a><code><span><span class="keyword">val</span> for_all2 : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Same as <a href="#val-for_all"><code>List.for_all</code></a>, but for a two-argument predicate.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if two lists have different lengths.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-exists2" class="anchored"><a href="#val-exists2" class="anchor"></a><code><span><span class="keyword">val</span> exists2 : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Same as <a href="#val-exists"><code>List.exists</code></a>, but for a two-argument predicate.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if two lists have different lengths.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-subset" class="anchored"><a href="#val-subset" class="anchor"></a><code><span><span class="keyword">val</span> subset : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>subset cmp l l'</code> check if all elements of the list <code>l</code> is contained in the list <code>l'</code> by applying <code>cmp</code> as comparator.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.2.0</li></ul></div></div><h6 id="list-searching"><a href="#list-searching" class="anchor"></a>List searching</h6><div class="odoc-spec"><div class="spec value" id="val-find_opt" class="anchored"><a href="#val-find_opt" class="anchor"></a><code><span><span class="keyword">val</span> find_opt : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div><div class="spec-doc"><p><code>find_opt p l</code> returns the first element of the list <code>l</code> that satisfies the predicate <code>p</code>, or <code>None</code> if there is no value that satisfies <code>p</code> in the list <code>l</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.7.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-find_map_opt" class="anchored"><a href="#val-find_map_opt" class="anchor"></a><code><span><span class="keyword">val</span> find_map_opt : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span></span></code></div><div class="spec-doc"><p><code>find_map_opt f l</code> applies <code>f</code> to the elements of <code>l</code> in order, and returns the first result of the form <code>Some v</code>, or <code>None</code> if none exist.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.12.0 and OCaml 4.10</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-find_exn" class="anchored"><a href="#val-find_exn" class="anchor"></a><code><span><span class="keyword">val</span> find_exn : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span>exn <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>find_exn p e l</code> returns the first element of <code>l</code> such as <code>p x</code> returns <code>true</code> or raises <code>e</code> if such an element has not been found.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-concat_map" class="anchored"><a href="#val-concat_map" class="anchor"></a><code><span><span class="keyword">val</span> concat_map : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> list</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> list</span></span></code></div><div class="spec-doc"><p><code>List.concat_map f l</code> gives the same result as <a href="#val-concat"><code>List.concat</code></a><code> (</code><a href="#val-map"><code>List.map</code></a><code> f l)</code>. Tail-recursive.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.12.0 and OCaml 4.10</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-filter" class="anchored"><a href="#val-filter" class="anchor"></a><code><span><span class="keyword">val</span> filter : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>filter p l</code> returns all the elements of the list <code>l</code> that satisfy the predicate <code>p</code>. The order of the elements in the input list is preserved.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-count_matching" class="anchored"><a href="#val-count_matching" class="anchor"></a><code><span><span class="keyword">val</span> count_matching : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>count_matching p l</code> returns the number of elements in <code>l</code> that satisfy <code>p</code>. Semantically equivalent but faster than <code>length (filter p l)</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-filteri" class="anchored"><a href="#val-filteri" class="anchor"></a><code><span><span class="keyword">val</span> filteri : <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>filteri p [a0; a1; ...; an]</code> returns all the elements <code>ai</code> of index <code>i</code> that satisfy the predicate <code>p i ai</code>. The order of the elements in the input list is preserved.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.2.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-filter_map" class="anchored"><a href="#val-filter_map" class="anchor"></a><code><span><span class="keyword">val</span> filter_map : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> list</span></span></code></div><div class="spec-doc"><p><code>filter_map f l</code> calls <code>(f a0) (f a1).... (f an)</code> where <code>a0,a1..an</code> are the elements of <code>l</code>. It returns the list of elements <code>bi</code> such as <code>f ai = Some bi</code> (when <code>f</code> returns <code>None</code>, the corresponding element of <code>l</code> is discarded).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-filteri_map" class="anchored"><a href="#val-filteri_map" class="anchor"></a><code><span><span class="keyword">val</span> filteri_map : <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> list</span></span></code></div><div class="spec-doc"><p><code>filteri_map f l</code> calls <code>(f 0 a0) (f 1 a1).... (f n an)</code> where <code>a0,a1..an</code> are the elements of <code>l</code>. It returns the list of elements <code>bi</code> such as <code>f ai = Some bi</code> (when <code>f</code> returns <code>None</code>, the corresponding element of <code>l</code> is discarded).</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.2.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-find_all" class="anchored"><a href="#val-find_all" class="anchor"></a><code><span><span class="keyword">val</span> find_all : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>find_all</code> is another name for <a href="#val-filter"><code>List.filter</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-partition" class="anchored"><a href="#val-partition" class="anchor"></a><code><span><span class="keyword">val</span> partition : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span> * <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>partition p l</code> returns a pair of lists <code>(l1, l2)</code>, where <code>l1</code> is the list of all the elements of <code>l</code> that satisfy the predicate <code>p</code>, and <code>l2</code> is the list of all the elements of <code>l</code> that do not satisfy <code>p</code>. The order of the elements in the input list is preserved.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-partition_map" class="anchored"><a href="#val-partition_map" class="anchor"></a><code><span><span class="keyword">val</span> partition_map : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'b</span>,Â <span class="type-var">'c</span>)</span> <a href="../../BatEither/index.html#type-t">BatEither.t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> list</span> * <span><span class="type-var">'c</span> list</span></span></code></div><div class="spec-doc"><p><code>partition_map f l</code> returns a pair of lists <code>(l1, l2)</code> such that, for each element <code>x</code> of the input list <code>l</code>:</p><ul><li>if <code>f x</code> is <code>Left y1</code>, then <code>y1</code> is in <code>l1</code>, and</li><li>if <code>f x</code> is <code>Right y2</code>, then <code>y2</code> is in <code>l2</code>. The output elements are included in <code>l1</code> and <code>l2</code> in the same relative order as the corresponding input elements in <code>l</code>. In particular, <code>partition_map (fun x -&gt; if f x then Left x else Right x) l</code> is equivalent to <code>partition f l</code>.</li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.3.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-index_of" class="anchored"><a href="#val-index_of" class="anchor"></a><code><span><span class="keyword">val</span> index_of : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span>int option</span></span></code></div><div class="spec-doc"><p><code>index_of e l</code> returns the index of the first occurrence of <code>e</code> in <code>l</code>, or <code>None</code> if there is no occurrence of <code>e</code> in <code>l</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-index_ofq" class="anchored"><a href="#val-index_ofq" class="anchor"></a><code><span><span class="keyword">val</span> index_ofq : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span>int option</span></span></code></div><div class="spec-doc"><p><code>index_ofq e l</code> behaves as <code>index_of e l</code> except it uses physical equality</p></div></div><div class="odoc-spec"><div class="spec value" id="val-rindex_of" class="anchored"><a href="#val-rindex_of" class="anchor"></a><code><span><span class="keyword">val</span> rindex_of : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span>int option</span></span></code></div><div class="spec-doc"><p><code>rindex_of e l</code> returns the index of the last occurrence of <code>e</code> in <code>l</code>, or <code>None</code> if there is no occurrence of <code>e</code> in <code>l</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-rindex_ofq" class="anchored"><a href="#val-rindex_ofq" class="anchor"></a><code><span><span class="keyword">val</span> rindex_ofq : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span>int option</span></span></code></div><div class="spec-doc"><p><code>rindex_ofq e l</code> behaves as <code>rindex_of e l</code> except it uses physical equality</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unique" class="anchored"><a href="#val-unique" class="anchor"></a><code><span><span class="keyword">val</span> unique : <span>?eq:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>unique cmp l</code> returns the list <code>l</code> without any duplicate element. The default comparator ( = ) is used if no comparison function specified.</p><p>Implementation Note: The current implementation removes any elements where the tail of the list contains an equal element, thus it keeps the *last* copy of each equal element.</p><p>This function takes O(n^2) time.</p><ul class="at-tags"><li class="see"><span class="at-tag">see</span> <code class="value">sort_unique</code> <p>to save time in cases when reordering the list is acceptable</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-unique_cmp" class="anchored"><a href="#val-unique_cmp" class="anchor"></a><code><span><span class="keyword">val</span> unique_cmp : <span>?cmp:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p>As <code>unique</code>, except comparator parameter returns an int. Default comparator is <code>Pervasives.compare</code>. This function takes O(n log n) time.</p><p>Implementation Note: The current implementation removes subsequent elements that compare as equal to earlier elements in the list, thus it keeps the *first* copy of each equal element.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.3.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-unique_hash" class="anchored"><a href="#val-unique_hash" class="anchor"></a><code><span><span class="keyword">val</span> unique_hash : <span>?hash:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span>?eq:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p>As <code>unique</code>, except uses a hash table to cut down the expected runtime to linear, assuming a good hash function. <code>?hash</code> defaults to <code>Hashtbl.hash</code> and <code>?eq</code> defaults to <code>(=)</code>.</p><p>Implementation Note: The current implementation removes subsequent elements that hash and compare as equal to earlier elements in the list, thus it keeps the *first* copy of each equal element.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.0.0</li></ul></div></div><h6 id="association-lists"><a href="#association-lists" class="anchor"></a>Association lists</h6><div class="odoc-spec"><div class="spec value" id="val-assoc_opt" class="anchored"><a href="#val-assoc_opt" class="anchor"></a><code><span><span class="keyword">val</span> assoc_opt : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span></span></code></div><div class="spec-doc"><p><code>assoc_opt a l</code> returns the value associated with key <code>a</code> in the list of pairs <code>l</code>. That is, <code>assoc_opt a [ ...; (a,b); ...] = b</code> if <code>(a,b)</code> is the leftmost binding of <code>a</code> in list <code>l</code>. Returns <code>None</code> if there is no value associated with <code>a</code> in the list <code>l</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.7.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-remove_assoc" class="anchored"><a href="#val-remove_assoc" class="anchor"></a><code><span><span class="keyword">val</span> remove_assoc : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span></span></code></div><div class="spec-doc"><p><code>remove_assoc a l</code> returns the list of pairs <code>l</code> without the first pair with key <code>a</code>, if any. Tail-recursive.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mem_assoc" class="anchored"><a href="#val-mem_assoc" class="anchor"></a><code><span><span class="keyword">val</span> mem_assoc : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Same as <a href="#val-assoc"><code>List.assoc</code></a>, but simply return true if a binding exists, and false if no bindings exist for the given key.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-assq_opt" class="anchored"><a href="#val-assq_opt" class="anchor"></a><code><span><span class="keyword">val</span> assq_opt : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span></span></code></div><div class="spec-doc"><p>Same as <a href="#val-assoc_opt"><code>List.assoc_opt</code></a>, but uses physical equality instead of structural equality to compare keys.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.7.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-assq_inv" class="anchored"><a href="#val-assq_inv" class="anchor"></a><code><span><span class="keyword">val</span> assq_inv : <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Same as <a href="#val-assoc_inv"><code>List.assoc_inv</code></a>, but uses physical equality instead of structural equality to compare keys.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-remove_assq" class="anchored"><a href="#val-remove_assq" class="anchor"></a><code><span><span class="keyword">val</span> remove_assq : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span></span></code></div><div class="spec-doc"><p>Same as <a href="#val-remove_assoc"><code>List.remove_assoc</code></a>, but uses physical equality instead of structural equality to compare keys. Tail-recursive.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mem_assq" class="anchored"><a href="#val-mem_assq" class="anchor"></a><code><span><span class="keyword">val</span> mem_assq : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Same as <a href="#val-mem_assoc"><code>List.mem_assoc</code></a>, but uses physical equality instead of structural equality to compare keys.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-modify" class="anchored"><a href="#val-modify" class="anchor"></a><code><span><span class="keyword">val</span> modify : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span></span></code></div><div class="spec-doc"><p><code>modify a f l</code> returns the same list as <code>l</code> but with value associated to key <code>a</code> replaced with <code>f a</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Not_found</span> <p>if no value is associated with <code>a</code> in <code>l</code></p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.1</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-modify_def" class="anchored"><a href="#val-modify_def" class="anchor"></a><code><span><span class="keyword">val</span> modify_def : <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span></span></code></div><div class="spec-doc"><p><code>modify_def dfl a f l</code> performs as <code>modify a f l</code> except that it add an association from <code>a</code> to <code>f dfl</code> instead of raising <code>Not_found</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.1</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-modify_opt" class="anchored"><a href="#val-modify_opt" class="anchor"></a><code><span><span class="keyword">val</span> modify_opt : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span><span class="type-var">'b</span> option</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span></span></code></div><div class="spec-doc"><p><code>modify_opt a f l</code> allows to modify the binding for <code>a</code> in <code>l</code> or absence thereof.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.1</li></ul></div></div><h6 id="list-transformations"><a href="#list-transformations" class="anchor"></a>List transformations</h6><div class="odoc-spec"><div class="spec value" id="val-modify_at" class="anchored"><a href="#val-modify_at" class="anchor"></a><code><span><span class="keyword">val</span> modify_at : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>modify_at n f l</code> returns the same list as <code>l</code> but with nth-value <code>a</code> replaced with <code>f a</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if the index is outside of <code>l</code> bounds</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.3.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-modify_opt_at" class="anchored"><a href="#val-modify_opt_at" class="anchor"></a><code><span><span class="keyword">val</span> modify_opt_at : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>modify_opt_at n f l</code> returns the same list as <code>l</code> but with nth-value <code>a</code> removed if <code>f a</code> is <code>None</code>, and replaced by <code>v</code> if it is <code>Some v</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if the index is outside of <code>l</code> bounds</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.3.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-split_nth" class="anchored"><a href="#val-split_nth" class="anchor"></a><code><span><span class="keyword">val</span> split_nth : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span> * <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p>Obsolete. As <code>split_at</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-remove" class="anchored"><a href="#val-remove" class="anchor"></a><code><span><span class="keyword">val</span> remove : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>remove l x</code> returns the list <code>l</code> without the first element <code>x</code> found or returns <code>l</code> if no element is equal to <code>x</code>. Elements are compared using ( = ).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-remove_if" class="anchored"><a href="#val-remove_if" class="anchor"></a><code><span><span class="keyword">val</span> remove_if : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>remove_if cmp l</code> is similar to <code>remove</code>, but with <code>cmp</code> used instead of ( = ).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-remove_at" class="anchored"><a href="#val-remove_at" class="anchor"></a><code><span><span class="keyword">val</span> remove_at : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>remove_at i l</code> returns the list <code>l</code> without the element at index <code>i</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if <code>i</code> is outside of <code>l</code> size bounds.</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.3.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-remove_all" class="anchored"><a href="#val-remove_all" class="anchor"></a><code><span><span class="keyword">val</span> remove_all : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>remove_all l x</code> is similar to <code>remove</code> but removes all elements that are equal to <code>x</code> and not only the first one.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-take" class="anchored"><a href="#val-take" class="anchor"></a><code><span><span class="keyword">val</span> take : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>take n l</code> returns up to the <code>n</code> first elements from list <code>l</code>, if available.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-ntake" class="anchored"><a href="#val-ntake" class="anchor"></a><code><span><span class="keyword">val</span> ntake : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> list</span></span></code></div><div class="spec-doc"><p><code>ntake n l</code> cuts <code>l</code> into lists of size at most <code>n</code>. <code>n</code> must be &gt; 0.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if <code>n</code> &lt;= 0. Each list in the result has size n, except the last one which may have fewer elements in case <code>l</code> was too short. Example: <code>ntake 2 [1; 2; 3; 4; 5] = [[1; 2]; [3; 4]; [5]]</code></p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.2.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-drop" class="anchored"><a href="#val-drop" class="anchor"></a><code><span><span class="keyword">val</span> drop : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>drop n l</code> returns <code>l</code> without the first <code>n</code> elements, or the empty list if <code>l</code> have less than <code>n</code> elements.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-takedrop" class="anchored"><a href="#val-takedrop" class="anchor"></a><code><span><span class="keyword">val</span> takedrop : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span> * <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>takedrop n l</code> is equivalent to <code>(take n l, drop n l)</code> but is done in one pass.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.2.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-take_while" class="anchored"><a href="#val-take_while" class="anchor"></a><code><span><span class="keyword">val</span> take_while : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>take_while p xs</code> returns the (possibly empty) longest prefix of elements of <code>xs</code> that satisfy the predicate <code>p</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-drop_while" class="anchored"><a href="#val-drop_while" class="anchor"></a><code><span><span class="keyword">val</span> drop_while : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>drop_while p xs</code> returns the suffix remaining after <code>take_while p xs</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-span" class="anchored"><a href="#val-span" class="anchor"></a><code><span><span class="keyword">val</span> span : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span> * <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>span</code>, applied to a predicate <code>p</code> and a list <code>xs</code>, returns a tuple where first element is longest prefix (possibly empty) of xs of elements that satisfy p and second element is the remainder of the list. This is equivalent to <code>(take_while p xs, drop_while p xs)</code>, but is done in one pass.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.1</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_while" class="anchored"><a href="#val-fold_while" class="anchor"></a><code><span><span class="keyword">val</span> fold_while : <span><span>(<span><span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'acc</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'acc</span> * <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>fold_while p f init l</code>, accumulates elements <code>x</code> of list <code>l</code> using function <code>f</code>, as long as predicate <code>p acc x</code> holds. At the end, the accumulated value along with the remaining part of the list are returned.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.10.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-nsplit" class="anchored"><a href="#val-nsplit" class="anchor"></a><code><span><span class="keyword">val</span> nsplit : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> list</span></span></code></div><div class="spec-doc"><p><code>nsplit</code>, applied to a predicate <code>p</code> and a list <code>xs</code>, returns a list of lists. <code>xs</code> is split when <code>p x</code> is true and <code>x</code> is excluded from the result.</p><p>If elements that satisfy <code>p</code> are consecutive, or at the beginning or end of the input list, the output list will contain empty lists marking their position. For example, <code>split (fun n -&gt; n&lt;0) [-1;2;-2;-3;4;-5]</code> is <code>[[];[2];[];[4];[]]</code>. This is consistent with the behavior of <code>String.nsplit</code>, where <code>String.nsplit &quot;;&quot; &quot;1;2;;3;&quot; = [&quot;1&quot;;&quot;2&quot;;&quot;&quot;;&quot;3&quot;;&quot;&quot;]</code>.</p><p>Note that for any <code>xss : 'a list list</code> and <code>sep : 'a</code>, we always have that <code>flatten (interleave [sep] (nsplit ((=) sep) xss))</code> is <code>xss</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.1</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-group_consecutive" class="anchored"><a href="#val-group_consecutive" class="anchor"></a><code><span><span class="keyword">val</span> group_consecutive : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> list</span></span></code></div><div class="spec-doc"><p>The <code>group_consecutive</code> function takes a list and returns a list of lists such that the concatenation of the result is equal to the argument. Moreover, each sublist in the result contains only equal elements. For example, <code>group_consecutive (=) [3;3;4;3;3] =  [[3;3];[4];[3;3]]</code>.</p><p><b>Note:</b> In the next major version, this function is intended to replace the current <code>group</code>, which also sorts its input before grouping, and which will therefore be renamed into something more pertinent, such as <code>classify</code>, <code>regroup</code>, or <code>group_sort</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.1</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-interleave" class="anchored"><a href="#val-interleave" class="anchor"></a><code><span><span class="keyword">val</span> interleave : <span>?first:<span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span>?last:<span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>interleave ~first ~last sep [a0;a1;a2;...;an]</code> returns <code>first; a0; sep; a1; sep; a2; sep; ...; sep; an; last</code>.</p></div></div><h6 id="batenum-functions"><a href="#batenum-functions" class="anchor"></a>BatEnum functions</h6><p>Abstraction layer.</p><div class="odoc-spec"><div class="spec value" id="val-enum" class="anchored"><a href="#val-enum" class="anchor"></a><code><span><span class="keyword">val</span> enum : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../../BatEnum/index.html#type-t">BatEnum.t</a></span></span></code></div><div class="spec-doc"><p>Returns an enumeration of the elements of a list. This enumeration may be used to visit elements of the list in forward order (i.e. from the first element to the last one).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_enum" class="anchored"><a href="#val-of_enum" class="anchor"></a><code><span><span class="keyword">val</span> of_enum : <span><span><span class="type-var">'a</span> <a href="../../BatEnum/index.html#type-t">BatEnum.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p>Build a list from an enumeration. In the result, elements appear in the same order as they did in the source enumeration.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-backwards" class="anchored"><a href="#val-backwards" class="anchor"></a><code><span><span class="keyword">val</span> backwards : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../../BatEnum/index.html#type-t">BatEnum.t</a></span></span></code></div><div class="spec-doc"><p>Returns an enumeration of the elements of a list. This enumeration may be used to visit elements of the list in backwards order (i.e. from the last element to the first one).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_backwards" class="anchored"><a href="#val-of_backwards" class="anchor"></a><code><span><span class="keyword">val</span> of_backwards : <span><span><span class="type-var">'a</span> <a href="../../BatEnum/index.html#type-t">BatEnum.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p>Build a list from an enumeration. The first element of the enumeration becomes the last element of the list, the second element of the enumeration becomes the second-to-last element of the list...</p></div></div><h6 id="list-of-pairs"><a href="#list-of-pairs" class="anchor"></a>List of pairs</h6><div class="odoc-spec"><div class="spec value" id="val-split" class="anchored"><a href="#val-split" class="anchor"></a><code><span><span class="keyword">val</span> split : <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span> * <span><span class="type-var">'b</span> list</span></span></code></div><div class="spec-doc"><p>Transform a list of pairs into a pair of lists: <code>split [(a0,b0); (a1,b1); ...; (an,bn)]</code> is <code>([a0; a1; ...; an], [b0;
    b1; ...; bn])</code>. Tail-recursive.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-combine" class="anchored"><a href="#val-combine" class="anchor"></a><code><span><span class="keyword">val</span> combine : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span></span></code></div><div class="spec-doc"><p>Transform a pair of lists into a list of pairs: <code>combine [a0; a1; ...; an] [b0; b1; ...; bn]</code> is <code>[(a0,b0); (a1,b1); ...; (an,bn)]</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if two lists have different lengths. Tail-recursive.</p></li></ul></div></div><h6 id="sorting"><a href="#sorting" class="anchor"></a>Sorting</h6><div class="odoc-spec"><div class="spec value" id="val-sort" class="anchored"><a href="#val-sort" class="anchor"></a><code><span><span class="keyword">val</span> sort : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p>Sort a list in increasing order according to a comparison function. The comparison function must return 0 if its arguments compare as equal, a positive integer if the first is greater, and a negative integer if the first is smaller (see Array.sort for a complete specification). For example, <code>Pervasives</code>.compare is a suitable comparison function. The resulting list is sorted in increasing order. <code>List.sort</code> is guaranteed to run in constant heap space (in addition to the size of the result list) and logarithmic stack space.</p><p>The current implementation uses Merge Sort. It runs in constant heap space and logarithmic stack space.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-stable_sort" class="anchored"><a href="#val-stable_sort" class="anchor"></a><code><span><span class="keyword">val</span> stable_sort : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p>Same as <a href="#val-sort"><code>List.sort</code></a>, but the sorting algorithm is guaranteed to be stable (i.e. elements that compare equal are kept in their original order) .</p><p>The current implementation uses Merge Sort. It runs in constant heap space and logarithmic stack space.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fast_sort" class="anchored"><a href="#val-fast_sort" class="anchor"></a><code><span><span class="keyword">val</span> fast_sort : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p>Same as <a href="#val-sort"><code>List.sort</code></a> or <a href="#val-stable_sort"><code>List.stable_sort</code></a>, whichever is faster on typical input.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-merge" class="anchored"><a href="#val-merge" class="anchor"></a><code><span><span class="keyword">val</span> merge : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p>Merge two lists: Assuming that <code>l1</code> and <code>l2</code> are sorted according to the comparison function <code>cmp</code>, <code>merge cmp l1 l2</code> will return a sorted list containing all the elements of <code>l1</code> and <code>l2</code>. If several elements compare equal, the elements of <code>l1</code> will be before the elements of <code>l2</code>. Not tail-recursive (sum of the lengths of the arguments).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sort_uniq" class="anchored"><a href="#val-sort_uniq" class="anchor"></a><code><span><span class="keyword">val</span> sort_uniq : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>sort_uniq cmp l</code> returns the list <code>l</code> sorted and without any duplicate element. <code>cmp</code> is a usual comparison function providing total order.</p><p>This function takes O(n log n) time.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.3.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-sort_unique" class="anchored"><a href="#val-sort_unique" class="anchor"></a><code><span><span class="keyword">val</span> sort_unique : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p>synonym for <code>sort_uniq</code></p></div></div><h6 id="utilities"><a href="#utilities" class="anchor"></a>Utilities</h6><div class="odoc-spec"><div class="spec value" id="val-group" class="anchored"><a href="#val-group" class="anchor"></a><code><span><span class="keyword">val</span> group : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> list</span></span></code></div><div class="spec-doc"><p><code>group cmp l</code> returns list of groups and each group consists of elements judged equal by comparison function <code>cmp</code>. Groups in the resulting list appear in order given by <code>cmp</code>. All groups are always nonempty. <code>group</code> returns <code>[]</code> only if <code>l</code> is empty.</p><p>For example <code>group cmp [f;c;b;e;d;a]</code> can give <code>[[a;b];[c];[d;e;f]]</code> if following conditions are met: <code>cmp a b = 0</code>, <code>cmp b c = -1</code>, <code>cmp c d = -1</code>, <code>cmp d e = 0</code>, ...</p><p>See the note on <code>group_consecutive</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-cartesian_product" class="anchored"><a href="#val-cartesian_product" class="anchor"></a><code><span><span class="keyword">val</span> cartesian_product : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span></span></code></div><div class="spec-doc"><p>Different from <code>List.combine</code>, this returns every pair of elements formed out of the two lists. <code>cartesian_product [a0; a1; ...; an] [b0; b1; ...; bn] =
    [(a0,b0);(a0,b1); ...; (a0,bn); (a1,b0); ..; (a1, bn);
    ...; (an,bn)]</code>. The lists can be of unequal size.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-n_cartesian_product" class="anchored"><a href="#val-n_cartesian_product" class="anchor"></a><code><span><span class="keyword">val</span> n_cartesian_product : <span><span><span><span class="type-var">'a</span> list</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> list</span></span></code></div><div class="spec-doc"><p>Given n lists, return the n-way cartesian product of these lists. Given <code>[a;b];[c];[d;e;f]</code>, returns <code>[a;c;d];[a;c;e];[a;c;f];[b;c;d];[b;c;e];[b;c;f]</code>, all ways of choosing one element from each input list.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-transpose" class="anchored"><a href="#val-transpose" class="anchor"></a><code><span><span class="keyword">val</span> transpose : <span><span><span><span class="type-var">'a</span> list</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> list</span></span></code></div><div class="spec-doc"><p>Transposes a list of lists, turning rows of the input into columns of the output and vice versa.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.0.0</li></ul></div></div><h6 id="boilerplate-code"><a href="#boilerplate-code" class="anchor"></a>Boilerplate code</h6><h6 id="printing"><a href="#printing" class="anchor"></a>Printing</h6><div class="odoc-spec"><div class="spec value" id="val-print" class="anchored"><a href="#val-print" class="anchor"></a><code><span><span class="keyword">val</span> print : <span>?first:string <span class="arrow">&#45;&gt;</span></span> <span>?last:string <span class="arrow">&#45;&gt;</span></span> <span>?sep:string <span class="arrow">&#45;&gt;</span></span>
<span><span>(<span><span><span class="type-var">'a</span> <a href="../../BatInnerIO/index.html#type-output">BatInnerIO.output</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="../../BatInnerIO/index.html#type-output">BatInnerIO.output</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Print the contents of a list</p></div></div><div class="odoc-spec"><div class="spec value" id="val-eq" class="anchored"><a href="#val-eq" class="anchor"></a><code><span><span class="keyword">val</span> eq : <span><span><span class="type-var">'a</span> <a href="../../BatOrd/index.html#type-eq">BatOrd.eq</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <a href="../../BatOrd/index.html#type-eq">BatOrd.eq</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-ord" class="anchored"><a href="#val-ord" class="anchor"></a><code><span><span class="keyword">val</span> ord : <span><span><span class="type-var">'a</span> <a href="../../BatOrd/index.html#type-ord">BatOrd.ord</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <a href="../../BatOrd/index.html#type-ord">BatOrd.ord</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-compare" class="anchored"><a href="#val-compare" class="anchor"></a><code><span><span class="keyword">val</span> compare : <span><span><span class="type-var">'a</span> <a href="../../BatOrd/index.html#type-comp">BatOrd.comp</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <a href="../../BatOrd/index.html#type-comp">BatOrd.comp</a></span></span></code></div></div><p>Comparison and equality for lists based on element comparison and equality</p><div class="odoc-spec"><div class="spec module" id="module-Eq" class="anchored"><a href="#module-Eq" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Eq/index.html">Eq</a></span><span> (<a href="Eq/argument-1-T/index.html">T</a> : <a href="../../BatOrd/module-type-Eq/index.html">BatOrd.Eq</a>) : <a href="../../BatOrd/module-type-Eq/index.html">BatOrd.Eq</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../../BatOrd/module-type-Eq/index.html#type-t">t</a> = <span><a href="Eq/argument-1-T/index.html#type-t">T.t</a> list</span></span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Ord" class="anchored"><a href="#module-Ord" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Ord/index.html">Ord</a></span><span> (<a href="Ord/argument-1-T/index.html">T</a> : <a href="../../BatOrd/module-type-Ord/index.html">BatOrd.Ord</a>) : <a href="../../BatOrd/module-type-Ord/index.html">BatOrd.Ord</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../../BatOrd/module-type-Ord/index.html#type-t">t</a> = <span><a href="Ord/argument-1-T/index.html#type-t">T.t</a> list</span></span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Comp" class="anchored"><a href="#module-Comp" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Comp/index.html">Comp</a></span><span> (<a href="Comp/argument-1-T/index.html">T</a> : <a href="../../BatOrd/module-type-Comp/index.html">BatOrd.Comp</a>) : <a href="../../BatOrd/module-type-Comp/index.html">BatOrd.Comp</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../../BatOrd/module-type-Comp/index.html#type-t">t</a> = <span><a href="Comp/argument-1-T/index.html#type-t">T.t</a> list</span></span></span></code></div></div><h6 id="obsolete-functions"><a href="#obsolete-functions" class="anchor"></a>Obsolete functions</h6><div class="odoc-spec"><div class="spec value" id="val-nth" class="anchored"><a href="#val-nth" class="anchor"></a><code><span><span class="keyword">val</span> nth : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Obsolete. As <code>at</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-nth_opt" class="anchored"><a href="#val-nth_opt" class="anchor"></a><code><span><span class="keyword">val</span> nth_opt : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div><div class="spec-doc"><p>Return the <code>n</code>-th element of the given list. The first element (head of the list) is at position 0. Return <code>None</code> if the list is too short. Raise <code>Invalid_argument &quot;List.nth&quot;</code> if <code>n</code> is negative.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.7.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-takewhile" class="anchored"><a href="#val-takewhile" class="anchor"></a><code><span><span class="keyword">val</span> takewhile : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p>obsolete, as <a href="#val-take_while"><code>take_while</code></a></p></div></div><div class="odoc-spec"><div class="spec value" id="val-dropwhile" class="anchored"><a href="#val-dropwhile" class="anchor"></a><code><span><span class="keyword">val</span> dropwhile : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p>obsolete, as <a href="#val-drop_while"><code>drop_while</code></a></p></div></div><h6 id="override-modules"><a href="#override-modules" class="anchor"></a>Override modules</h6><p>The following modules replace functions defined in <a href="#"><code>List</code></a> with functions behaving slightly differently but having the same name. This is by design: the functions are meant to override the corresponding functions of <a href="#"><code>List</code></a>.</p><div class="odoc-spec"><div class="spec module" id="module-Exceptionless" class="anchored"><a href="#module-Exceptionless" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Exceptionless/index.html">Exceptionless</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Exceptionless counterparts for error-raising operations</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Infix" class="anchored"><a href="#module-Infix" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Infix/index.html">Infix</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-(@)" class="anchored"><a href="#val-(@)" class="anchor"></a><code><span><span class="keyword">val</span> (@) : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p>Tail recursive <code>List.append</code>.</p></div></div></details></div><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> <span class="keyword">struct</span> <span class="keyword">include</span> <a href="../../BatList/Exceptionless/index.html">BatList.Exceptionless</a> <span class="keyword">end</span></span></code></summary><p>Exceptionless counterparts for error-raising operations</p><div class="odoc-spec"><div class="spec value" id="val-find" class="anchored"><a href="#val-find" class="anchor"></a><code><span><span class="keyword">val</span> find : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div><div class="spec-doc"><p><code>find p l</code> returns <code>Some x</code> where <code>x</code> is the first element of <code>l</code> such as <code>p x</code> returns <code>true</code> or <code>None</code> if such an element has not been found.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-rfind" class="anchored"><a href="#val-rfind" class="anchor"></a><code><span><span class="keyword">val</span> rfind : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div><div class="spec-doc"><p><code>rfind p l</code> returns <code>Some x</code> where <code>x</code> is the last element of <code>l</code> such that <code>p x</code> returns <code>true</code> or <code>None</code> if such element as not been found.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-findi" class="anchored"><a href="#val-findi" class="anchor"></a><code><span><span class="keyword">val</span> findi : <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(int * <span class="type-var">'a</span>)</span> option</span></span></code></div><div class="spec-doc"><p><code>findi p l</code> returns <code>Some (i, ai)</code> where <code>ai</code> and <code>i</code> are respectively the first element of <code>l</code> and its index, such that <code>p i ai</code> is true, or <code>None</code> if no such element has been found.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-split_at" class="anchored"><a href="#val-split_at" class="anchor"></a><code><span><span class="keyword">val</span> split_at : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span>[ <span>`Ok of <span><span class="type-var">'a</span> list</span> * <span><span class="type-var">'a</span> list</span></span> <span><span>| `Invalid_argument</span> of string</span> ]</span></span></code></div><div class="spec-doc"><p>Whenever <code>n</code> is inside of <code>l</code> size bounds, <code>split_at n l</code> returns <code>Ok(l1,l2)</code>, where <code>l1</code> contains the first <code>n</code> elements of <code>l</code> and <code>l2</code> contains the others. Otherwise, returns <code>`Invalid_argument n</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-at" class="anchored"><a href="#val-at" class="anchor"></a><code><span><span class="keyword">val</span> at : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>[ <span>`Ok of <span class="type-var">'a</span></span> <span><span>| `Invalid_argument</span> of string</span> ]</span></span></code></div><div class="spec-doc"><p>If <code>n</code> is inside the bounds of <code>l</code>, <code>at l n</code> returns <code>Ok x</code>, where <code>x</code> is the n-th element of the list <code>l</code>. Otherwise, returns <code>Error
      (`Invalid_argument(n))</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-assoc" class="anchored"><a href="#val-assoc" class="anchor"></a><code><span><span class="keyword">val</span> assoc : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span></span></code></div><div class="spec-doc"><p><code>assoc a l</code> returns <code>Some b</code> where <code>b</code> is the value associated with key <code>b</code> in the list of pairs <code>l</code>. That is, <code>assoc a [ ...; (a,b); ...] = Some b</code> if <code>(a,b)</code> is the leftmost binding of <code>a</code> in list <code>l</code>. Return <code>None</code> if there is no value associated with <code>a</code> in the list <code>l</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-assoc_inv" class="anchored"><a href="#val-assoc_inv" class="anchor"></a><code><span><span class="keyword">val</span> assoc_inv : <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div><div class="spec-doc"><p><code>assoc_inv b l</code> returns <code>Some a</code> where <code>a</code> is the key associated with value <code>b</code> in the list of pairs <code>l</code>. That is, <code>assoc b [ ...; (a,b); ...] = Some a</code> if <code>(a,b)</code> is the leftmost binding of <code>a</code> in list <code>l</code>. Return <code>None</code> if there is no key associated with <code>b</code> in the list <code>l</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-assq" class="anchored"><a href="#val-assq" class="anchor"></a><code><span><span class="keyword">val</span> assq : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span></span></code></div><div class="spec-doc"><p>As <a href="#val-assoc"><code>assoc</code></a> but with physical equality.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-find_map" class="anchored"><a href="#val-find_map" class="anchor"></a><code><span><span class="keyword">val</span> find_map : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span></span></code></div><div class="spec-doc"><p><code>find_map f xs</code> returns <code>Some y</code> such that <code>x</code> is the first element of the list where <code>f x</code> returns <code>Some y</code>. It returns <code>None</code> if no such element exists.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-hd" class="anchored"><a href="#val-hd" class="anchor"></a><code><span><span class="keyword">val</span> hd : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div><div class="spec-doc"><p><code>hd l</code> returns <code>Some x</code> such that <code>x</code> is the first element of the given list <code>l</code>. Returns <code>None</code> if list <code>l</code> is empty.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-tl" class="anchored"><a href="#val-tl" class="anchor"></a><code><span><span class="keyword">val</span> tl : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> option</span></span></code></div><div class="spec-doc"><p><code>tl l</code> returns <code>Some x</code> such that <code>x</code> is the given list <code>l</code> without its first element. Returns <code>None</code> if list <code>l</code> is empty.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-last" class="anchored"><a href="#val-last" class="anchor"></a><code><span><span class="keyword">val</span> last : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div><div class="spec-doc"><p><code>last l</code> returns either <code>Some x</code> where <code>x</code> is the last element of the list, or <code>None</code> if the list is empty. This function takes linear time.</p></div></div></details></div><div class="odoc-spec"><div class="spec module" id="module-Labels" class="anchored"><a href="#module-Labels" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Labels/index.html">Labels</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div></div></body></html>