<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Unsafe (angstrom.Angstrom.Unsafe)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">angstrom</a> &#x00BB; <a href="../index.html">Angstrom</a> &#x00BB; Unsafe</nav><header class="odoc-preamble"><h1>Module <code><span>Angstrom.Unsafe</span></code></h1><p>Unsafe Operations on Angstrom's Internal Buffer</p><p>These functions are considered <b>unsafe</b> as they expose the input buffer to client code without any protections against modification, or leaking references. They are exposed to support performance-sensitive parsers that want to avoid allocation at all costs. Client code should take care to write the input buffer callback functions such that they:</p><ul><li>do not modify the input buffer <i>outside</i> of the range <code>[off, off + len)</code>;</li><li>do not modify the input buffer <i>inside</i> of the range <code>[off, off + len)</code> if the parser might backtrack; and</li><li>do not return any direct or indirect references to the input buffer.</li></ul><p>If the input buffer callback functions do not do any of these things, then the client may consider their use safe.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec value" id="val-take" class="anchored"><a href="#val-take" class="anchor"></a><code><span><span class="keyword">val</span> take : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><a href="../index.html#type-bigstring">bigstring</a> <span class="arrow">&#45;&gt;</span></span> <span>off:int <span class="arrow">&#45;&gt;</span></span> <span>len:int <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../index.html#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>take n f</code> accepts exactly <code>n</code> characters of input into the parser's internal buffer then calls <code>f buffer ~off ~len</code>. <code>buffer</code> is the parser's internal buffer. <code>off</code> is the offset from the start of <code>buffer</code> containing the requested content. <code>len</code> is the length of the requested content. <code>len</code> is guaranteed to be equal to <code>n</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-take_while" class="anchored"><a href="#val-take_while" class="anchor"></a><code><span><span class="keyword">val</span> take_while : <span><span>(<span>char <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><a href="../index.html#type-bigstring">bigstring</a> <span class="arrow">&#45;&gt;</span></span> <span>off:int <span class="arrow">&#45;&gt;</span></span> <span>len:int <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../index.html#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>take_while check f</code> accepts input into the parser's interal buffer as long as <code>check</code> returns <code>true</code> then calls <code>f buffer ~off ~len</code>. <code>buffer</code> is the parser's internal buffer. <code>off</code> is the offset from the start of <code>buffer</code> containing the requested content. <code>len</code> is the length of the content matched by <code>check</code>.</p><p>This parser does not fail. If <code>check</code> returns <code>false</code> on the first character, <code>len</code> will be <code>0</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-take_while1" class="anchored"><a href="#val-take_while1" class="anchor"></a><code><span><span class="keyword">val</span> take_while1 : <span><span>(<span>char <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><a href="../index.html#type-bigstring">bigstring</a> <span class="arrow">&#45;&gt;</span></span> <span>off:int <span class="arrow">&#45;&gt;</span></span> <span>len:int <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../index.html#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>take_while1 check f</code> accepts input into the parser's interal buffer as long as <code>check</code> returns <code>true</code> then calls <code>f buffer ~off ~len</code>. <code>buffer</code> is the parser's internal buffer. <code>off</code> is the offset from the start of <code>buffer</code> containing the requested content. <code>len</code> is the length of the content matched by <code>check</code>.</p><p>This parser requires that <code>f</code> return <code>true</code> for at least one character of input, and will fail otherwise.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-take_till" class="anchored"><a href="#val-take_till" class="anchor"></a><code><span><span class="keyword">val</span> take_till : <span><span>(<span>char <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><a href="../index.html#type-bigstring">bigstring</a> <span class="arrow">&#45;&gt;</span></span> <span>off:int <span class="arrow">&#45;&gt;</span></span> <span>len:int <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../index.html#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>take_till check f</code> accepts input into the parser's interal buffer as long as <code>check</code> returns <code>false</code> then calls <code>f buffer ~off ~len</code>. <code>buffer</code> is the parser's internal buffer. <code>off</code> is the offset from the start of <code>buffer</code> containing the requested content. <code>len</code> is the length of the content matched by <code>check</code>.</p><p>This parser does not fail. If <code>check</code> returns <code>true</code> on the first character, <code>len</code> will be <code>0</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-peek" class="anchored"><a href="#val-peek" class="anchor"></a><code><span><span class="keyword">val</span> peek : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><a href="../index.html#type-bigstring">bigstring</a> <span class="arrow">&#45;&gt;</span></span> <span>off:int <span class="arrow">&#45;&gt;</span></span> <span>len:int <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../index.html#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>peek n ~f</code> accepts exactly <code>n</code> characters and calls <code>f buffer ~off ~len</code> with <code>len = n</code>. If there is not enough input, it will fail.</p><p>This parser does not advance the input. Use it for lookahead.</p></div></div></div></body></html>