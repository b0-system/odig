<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Bus (core_kernel.Core_kernel.Bus)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">core_kernel</a> &#x00BB; <a href="../index.html">Core_kernel</a> &#x00BB; Bus</nav><h1>Module <code>Core_kernel.Bus</code></h1><p>A <code>Bus</code> is a publisher/subscriber system within the memory space of the program. A bus has a mutable set of subscribers, which can be modified using <code>subscribe_exn</code> and <code>unsubscribe</code>.</p><p><code>create</code> returns a <code>Bus.Read_write.t</code>, which you can use to <code>write</code> values to the bus. <code>write</code> calls the callbacks of all current subscribers before returning.</p><p>In a <code>('callback, 'phantom) Bus.t</code>, <code>'phantom</code> is a read-write phantom type that controls whether one can read values from or write values to the bus. The phantom type states the capabilities one could ever have access to, not the capabilities that are immediately available. In particular, if one wants to subscribe to a <code>Bus.Read_write.t</code>, one must call <code>read_only</code> on it in order to get a <code>Bus.Read_only.t</code> that can be passed to <code>subscribe_exn</code>. This is deliberate, and is meant to avoid unintentional reads from code that should only be writing.</p></header><dl><dt class="spec module" id="module-Callback_arity"><a href="#module-Callback_arity" class="anchor"></a><code><span class="keyword">module</span> <a href="Callback_arity/index.html">Callback_arity</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p><code>Callback_arity</code> states the type of callbacks stored in a bus. Using <code>Callback_arity</code> is an implementation technique that allows callbacks to be defined as ordinary n-ary curried functions (e.g., <code>a1 -&gt; a2 -&gt; a3 -&gt; r</code>), instead of forcing n-ary-variadic callbacks to use tuples (e.g., <code>a1 * a2 * a3 -&gt; r</code>). This also avoids extra allocation.</p></dd></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> ('callback, 'phantom) t</code></dt></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></span></summary><dl><dt class="spec value" id="val-sexp_of_t"><a href="#val-sexp_of_t" class="anchor"></a><code><span class="keyword">val</span> sexp_of_t : (<span class="type-var">'callback</span> <span>&#45;&gt;</span> <a href="../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a>) <span>&#45;&gt;</span> (<span class="type-var">'phantom</span> <span>&#45;&gt;</span> <a href="../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a>) <span>&#45;&gt;</span> (<span class="type-var">'callback</span>, <span class="type-var">'phantom</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a></code></dt></dl></details></div></div></div><dl><dt class="spec type" id="type-bus"><a href="#type-bus" class="anchor"></a><code><span class="keyword">type</span> ('callback, 'phantom) bus</code><code> = (<span class="type-var">'callback</span>, <span class="type-var">'phantom</span>) <a href="index.html#type-t">t</a></code></dt></dl><div class="spec module" id="module-Read_write"><a href="#module-Read_write" class="anchor"></a><code><span class="keyword">module</span> <a href="Read_write/index.html">Read_write</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Read_only"><a href="#module-Read_only" class="anchor"></a><code><span class="keyword">module</span> <a href="Read_only/index.html">Read_only</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-On_subscription_after_first_write"><a href="#module-On_subscription_after_first_write" class="anchor"></a><code><span class="keyword">module</span> <a href="On_subscription_after_first_write/index.html">On_subscription_after_first_write</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-read_only"><a href="#val-read_only" class="anchor"></a><code><span class="keyword">val</span> read_only : (<span class="type-var">'callback</span>, <span class="type-var">_</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'callback</span> <a href="Read_only/index.html#type-t">Read_only.t</a></code></dt><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : ?&#8288;name:<a href="../Info/index.html#type-t">Info.t</a> <span>&#45;&gt;</span> <a href="../Source_code_position/index.html#type-t">Source_code_position.t</a> <span>&#45;&gt;</span> <span class="type-var">'callback</span> <a href="Callback_arity/index.html#type-t">Callback_arity.t</a> <span>&#45;&gt;</span> on_subscription_after_first_write:<a href="On_subscription_after_first_write/index.html#type-t">On_subscription_after_first_write.t</a> <span>&#45;&gt;</span> on_callback_raise:(<a href="../Error/index.html#type-t">Error.t</a> <span>&#45;&gt;</span> <a href="../../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a>) <span>&#45;&gt;</span> <span class="type-var">'callback</span> <a href="Read_write/index.html#type-t">Read_write.t</a></code></dt><dd><p>In <code>create [%here] ArityN ~on_subscription_after_first_write ~on_callback_raise</code>, <code>[%here]</code> is stored in the resulting bus, and contained in <code>%sexp_of: t</code>, which can help with debugging.</p><p>If <code>on_subscription_after_first_write</code> is <code>Raise</code>, then <code>subscribe_exn</code> will raise if it is called after <code>write</code> has been called the first time. If <code>on_subscription_after_first_write</code> is <code>Allow_and_send_last_value</code>, then the bus will remember the last value written and will send it to new subscribers.</p><p>If a callback raises, <code>on_callback_raise</code> is called with an error containing the exception.</p><p>If <code>on_callback_raise</code> raises, then the exception is raised to <code>write</code> and the bus is closed.</p></dd></dl><dl><dt class="spec value" id="val-callback_arity"><a href="#val-callback_arity" class="anchor"></a><code><span class="keyword">val</span> callback_arity : (<span class="type-var">'callback</span>, <span class="type-var">_</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'callback</span> <a href="Callback_arity/index.html#type-t">Callback_arity.t</a></code></dt><dt class="spec value" id="val-num_subscribers"><a href="#val-num_subscribers" class="anchor"></a><code><span class="keyword">val</span> num_subscribers : (<span class="type-var">_</span>, <span class="type-var">_</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../Core_kernel__/Import/index.html#type-int">Core_kernel__.Import.int</a></code></dt><dt class="spec value" id="val-is_closed"><a href="#val-is_closed" class="anchor"></a><code><span class="keyword">val</span> is_closed : (<span class="type-var">_</span>, <span class="type-var">_</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../Core_kernel__/Import/index.html#type-bool">Core_kernel__.Import.bool</a></code></dt><dt class="spec value" id="val-close"><a href="#val-close" class="anchor"></a><code><span class="keyword">val</span> close : <span class="type-var">'callback</span> <a href="Read_write/index.html#type-t">Read_write.t</a> <span>&#45;&gt;</span> <a href="../../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a></code></dt><dd><p><code>close</code> disallows future <code>write</code>s -- once <code>close t</code> is called, all further calls to <code>write t</code> will raise. <code>close</code> is idempotent. If <code>close</code> is called from within a callback, the current message will still be sent to all subscribed callbacks that have not yet seen it before the close takes effect.</p></dd></dl><aside><p><code>write</code> ... <code>write4</code> call all callbacks currently subscribed to the bus, with no guarantee on the order in which they will be called. <code>write</code> is non-allocating, though the callbacks themselves may allocate. Calling <code>writeN t</code> from within a callback on <code>t</code> if <code>is_closed t</code> will raise.</p></aside><dl><dt class="spec value" id="val-write"><a href="#val-write" class="anchor"></a><code><span class="keyword">val</span> write : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a>) <a href="Read_write/index.html#type-t">Read_write.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a></code></dt><dt class="spec value" id="val-write2"><a href="#val-write2" class="anchor"></a><code><span class="keyword">val</span> write2 : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <a href="../../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a>) <a href="Read_write/index.html#type-t">Read_write.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <a href="../../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a></code></dt><dt class="spec value" id="val-write3"><a href="#val-write3" class="anchor"></a><code><span class="keyword">val</span> write3 : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <a href="../../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a>) <a href="Read_write/index.html#type-t">Read_write.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <a href="../../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a></code></dt><dt class="spec value" id="val-write4"><a href="#val-write4" class="anchor"></a><code><span class="keyword">val</span> write4 : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'d</span> <span>&#45;&gt;</span> <a href="../../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a>) <a href="Read_write/index.html#type-t">Read_write.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'d</span> <span>&#45;&gt;</span> <a href="../../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a></code></dt></dl><div class="spec module" id="module-Subscriber"><a href="#module-Subscriber" class="anchor"></a><code><span class="keyword">module</span> <a href="Subscriber/index.html">Subscriber</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-subscribe_exn"><a href="#val-subscribe_exn" class="anchor"></a><code><span class="keyword">val</span> subscribe_exn : ?&#8288;extract_exn:<a href="../../Core_kernel__/Import/index.html#type-bool">Core_kernel__.Import.bool</a> <span>&#45;&gt;</span> ?&#8288;on_callback_raise:(<a href="../Error/index.html#type-t">Error.t</a> <span>&#45;&gt;</span> <a href="../../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a>) <span>&#45;&gt;</span> ?&#8288;on_close:(<a href="../../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a> <span>&#45;&gt;</span> <a href="../../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a>) <span>&#45;&gt;</span> <span class="type-var">'callback</span> <a href="Read_only/index.html#type-t">Read_only.t</a> <span>&#45;&gt;</span> <a href="../Source_code_position/index.html#type-t">Source_code_position.t</a> <span>&#45;&gt;</span> f:<span class="type-var">'callback</span> <span>&#45;&gt;</span> <span class="type-var">'callback</span> <a href="Subscriber/index.html#type-t">Subscriber.t</a></code></dt><dd><p><code>subscribe_exn t [%here] ~f</code> adds the callback <code>f</code> to the set of <code>t</code>'s subscribers, and returns a <code>Subscriber.t</code> that can later be used to <code>unsubscribe</code>. <code>[%here]</code> is stored in the <code>Subscriber.t</code>, and contained in <code>%sexp_of: Subscriber.t</code>, which can help with debugging. If <code>subscribe_exn t</code> is called by a callback in <code>t</code>, i.e., during <code>write t</code>, the subscription takes effect for the next <code>write</code>, but does not affect the current <code>write</code>. <code>subscribe_exn</code> takes time proportional to the number of callbacks.</p><p>If <code>on_callback_raise</code> is supplied, then it will be called by <code>write</code> whenever <code>f</code> raises; only if that subsequently raises will <code>t</code>'s <code>on_callback_raise</code> be called. If <code>on_callback_raise</code> is not supplied, then <code>t</code>'s <code>on_callback_raise</code> will be called whenever <code>f</code> raises.</p><p>If <code>on_callback_raise</code> is supplied and <code>extract_exn</code> is set to true, then the error passed to the <code>on_callback_raise</code> method will contain only the exception raised by <code>f</code> without any additional information about the bus subscription or backtrace.</p><p><code>on_close</code> is called if you are still subscribed when <code>Bus.close</code> is called.</p></dd></dl><dl><dt class="spec value" id="val-iter_exn"><a href="#val-iter_exn" class="anchor"></a><code><span class="keyword">val</span> iter_exn : <span class="type-var">'callback</span> <a href="Read_only/index.html#type-t">Read_only.t</a> <span>&#45;&gt;</span> <a href="../Source_code_position/index.html#type-t">Source_code_position.t</a> <span>&#45;&gt;</span> f:<span class="type-var">'callback</span> <span>&#45;&gt;</span> <a href="../../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a></code></dt><dd><p><code>iter_exn t [%here] ~f</code> is <code>ignore (subscribe_exn t [%here] ~callback:f)</code>. This captures the common usage in which one never wants to unsubscribe from a bus.</p></dd></dl><div class="spec module" id="module-Fold_arity"><a href="#module-Fold_arity" class="anchor"></a><code><span class="keyword">module</span> <a href="Fold_arity/index.html">Fold_arity</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-fold_exn"><a href="#val-fold_exn" class="anchor"></a><code><span class="keyword">val</span> fold_exn : <span class="type-var">'callback</span> <a href="Read_only/index.html#type-t">Read_only.t</a> <span>&#45;&gt;</span> <a href="../Source_code_position/index.html#type-t">Source_code_position.t</a> <span>&#45;&gt;</span> (<span class="type-var">'callback</span>, <span class="type-var">'f</span>, <span class="type-var">'s</span>) <a href="Fold_arity/index.html#type-t">Fold_arity.t</a> <span>&#45;&gt;</span> init:<span class="type-var">'s</span> <span>&#45;&gt;</span> f:<span class="type-var">'f</span> <span>&#45;&gt;</span> <a href="../../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a></code></dt><dd><p><code>fold_exn t [%here] arity ~init ~f</code> folds over the bus events, threading a state value to every call. It is otherwise similar to <code>iter_exn</code>.</p></dd></dl><dl><dt class="spec value" id="val-unsubscribe"><a href="#val-unsubscribe" class="anchor"></a><code><span class="keyword">val</span> unsubscribe : <span class="type-var">'callback</span> <a href="Read_only/index.html#type-t">Read_only.t</a> <span>&#45;&gt;</span> <span class="type-var">'callback</span> <a href="Subscriber/index.html#type-t">Subscriber.t</a> <span>&#45;&gt;</span> <a href="../../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a></code></dt><dd><p><code>unsubscribe t subscriber</code> removes the callback corresponding to <code>subscriber</code> from <code>t</code>. <code>unsubscribe</code> never raises and is idempotent. As with <code>subscribe_exn</code>, <code>unsubscribe t</code> during <code>write t</code> takes effect after the current <code>write</code> finishes. Also like <code>subscribe_exn</code>, <code>unsubscribe</code> takes time proportional to the number of callbacks.</p></dd></dl></div></body></html>