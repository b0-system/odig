<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>File_cache (b0.B00.File_cache)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">b0</a> &#x00BB; <a href="../index.html">B00</a> &#x00BB; File_cache</nav><h1>Module <code>B00.File_cache</code></h1><p>File caches.</p><p>A file cache maps a key to a metadata hunk and an ordered list of file <em>contents</em> (filenames are irrelevant).</p><p><code>B0</code> uses file caches to capture the contents of files written by build operations, it also stores their exit code and standard outputs in the metadata. This allows to recreate the effect of a build operation without having to rerun it.</p><p><b>FIXME.</b> The following notions use the file system information and can be inaccurate. It's a bit unclear whether it's a good idea to rely on them. They are only used for cache <a href="index.html#val-trim_size"><span>trimming</span></a>.</p><ul><li>The <em>access time</em> of a key is the greatest access time to the file contents or metadata hunk it maps to.</li><li>A key is <em>unused</em> if all its file contents are not referenced outside the cache. Key usage cannot be determined if the key file contents and their references do not live on the same file system device or if the file system does not support hard links, see <a href="index.html#val-need_copy"><code>need_copy</code></a>. <b>FIXME.</b> Now that we allow keys to map to empty list of file contents, unused might not make much sense for trimming. Maybe refine the notion to <em>unused content</em>.</li></ul><nav class="toc"><ul><li><a href="#file_cache">File caches</a></li><li><a href="#ops">Cache operations</a></li><li><a href="#stats">Cache statistics</a></li></ul></nav></header><section><header><h2 id="file_cache"><a href="#file_cache" class="anchor"></a>File caches</h2></header><dl><dt class="spec type" id="type-feedback"><a href="#type-feedback" class="anchor"></a><code><span class="keyword">type</span> feedback</code> = <code>[ </code><table class="variant"><tr id="type-feedback.File_cache_need_copy" class="anchored"><td class="def constructor"><a href="#type-feedback.File_cache_need_copy" class="anchor"></a><code>| </code><code>`File_cache_need_copy <span class="keyword">of</span> <a href="../../B0_std/Fpath/index.html#type-t">B0_std.Fpath.t</a></code></td></tr></table><code> ]</code></dt><dd><p>The type for file cache feedback. See <a href="index.html#val-create"><code>create</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-pp_feedback"><a href="#val-pp_feedback" class="anchor"></a><code><span class="keyword">val</span> pp_feedback : <a href="index.html#type-feedback">feedback</a> <a href="../../B0_std/Fmt/index.html#type-t">B0_std.Fmt.t</a></code></dt><dd><p><code>pp_feedback</code> formats file caches feedback.</p></dd></dl><dl><dt class="spec type" id="type-key"><a href="#type-key" class="anchor"></a><code><span class="keyword">type</span> key</code><code> = string</code></dt><dd><p>The type for keys. A key maps to a metadata hunk and an ordered list of file contents. The module treats keys as sequence of bytes however since they are used as file names they should satisfy the <a href="../../B0_std/Fpath/index.html#val-is_seg"><code>B0_std.Fpath.is_seg</code></a> predicate; this is not checked by the module.</p></dd></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><p>The type for file caches.</p></dd></dl><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : ?&#8288;feedback:(<a href="index.html#type-feedback">feedback</a> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <a href="../../B0_std/Fpath/index.html#type-t">B0_std.Fpath.t</a> <span>&#45;&gt;</span> (<a href="index.html#type-t">t</a>, string) <a href="../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></code></dt><dd><p><code>create ~feedback dir</code> is a file cache using directory <code>dir</code> for data storage. The full path to <code>dir</code> is created by the call if it doesn't exist. <code>feedback</code> is invoked <em>once</em> if the cache switches to copying mode, see <a href="index.html#val-need_copy"><code>need_copy</code></a> for details (defaults is a nop).</p></dd></dl><dl><dt class="spec value" id="val-dir"><a href="#val-dir" class="anchor"></a><code><span class="keyword">val</span> dir : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../B0_std/Fpath/index.html#type-t">B0_std.Fpath.t</a></code></dt><dd><p><code>dir c</code> is <code>c</code>'s storage directory.</p></dd></dl><dl><dt class="spec value" id="val-need_copy"><a href="#val-need_copy" class="anchor"></a><code><span class="keyword">val</span> need_copy : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../B0_std/Fpath/index.html#type-t">B0_std.Fpath.t</a> option</code></dt><dd><p><code>need_copy c</code> is <code>Some file</code> iff the cache switched to copying mode because of an operation that involved the file path <code>file</code>, external to the cache. This can happen due to one of the following conditions:</p><ul><li>The cache directory <a href="index.html#val-dir"><code>dir</code></a> and <code>file</code> live on different file system devices.</li><li>The underlying file system does not support hard links.</li><li>Too many hard links exist on a file.</li></ul><p><code>file</code> is also given to the <code>notify_need_copy</code> callback provided on <a href="index.html#val-create"><code>create</code></a> as soon as the condition is detected (and before the actual copy occurs). Note that once a file did copy, all the remaining transfers from or to the cache do copy aswell, which may be slow.</p></dd></dl></section><section><header><h2 id="ops"><a href="#ops" class="anchor"></a>Cache operations</h2><p><b>Note.</b> In general, whenever a cache operation modifies the file system and errors with <code>Error _</code> the resulting file system state is undefined.</p></header><dl><dt class="spec value" id="val-mem"><a href="#val-mem" class="anchor"></a><code><span class="keyword">val</span> mem : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-key">key</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>mem c k</code> is <code>true</code> iff <code>k</code> is bound in <code>c</code>.</p></dd></dl><dl><dt class="spec value" id="val-add"><a href="#val-add" class="anchor"></a><code><span class="keyword">val</span> add : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-key">key</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="../../B0_std/Fpath/index.html#type-t">B0_std.Fpath.t</a> list <span>&#45;&gt;</span> (bool, string) <a href="../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></code></dt><dd><p><code>add c k m fs</code>, binds the metadata <code>m</code> and the <em>contents</em> of the ordered list of files <code>fs</code> to <code>k</code> in <code>c</code>. The function returns:</p><ul><li><code>Ok true</code> if the operation succeeds.</li><li><code>Ok false</code> if a file of <code>fs</code> could not be accessed. In this case <code>k</code> is guaranteed to be unbound in <code>c</code>.</li><li><code>Error _</code> if an unexpected error occurs. In that case the resulting state of the cache for key <code>k</code> is undefined.</li></ul></dd></dl><dl><dt class="spec value" id="val-rem"><a href="#val-rem" class="anchor"></a><code><span class="keyword">val</span> rem : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-key">key</a> <span>&#45;&gt;</span> (bool, string) <a href="../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></code></dt><dd><p><code>rem c k</code> removes the binding of <code>k</code> in <code>c</code>. <code>Ok true</code> is returned if <code>k</code> was bound in <code>c</code> and <code>Ok false</code> otherwise.</p></dd></dl><dl><dt class="spec value" id="val-find"><a href="#val-find" class="anchor"></a><code><span class="keyword">val</span> find : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-key">key</a> <span>&#45;&gt;</span> ((<a href="../../B0_std/Fpath/index.html#type-t">B0_std.Fpath.t</a> * <a href="../../B0_std/Fpath/index.html#type-t">B0_std.Fpath.t</a> list) option, string) <a href="../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></code></dt><dd><p><code>find c k</code> is <code>Some (mf, fs)</code> if <code>k</code> is bound in <code>c</code> with <code>mf</code> the file that holds the key metadata and <code>fs</code> the files that hold the file contents of the key in the order given on <a href="index.html#val-add"><code>add</code></a>. The result is <code>None</code> if <code>k</code> is unbound in <code>c</code>.</p></dd></dl><dl><dt class="spec value" id="val-revive"><a href="#val-revive" class="anchor"></a><code><span class="keyword">val</span> revive : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-key">key</a> <span>&#45;&gt;</span> <a href="../../B0_std/Fpath/index.html#type-t">B0_std.Fpath.t</a> list <span>&#45;&gt;</span> ((string * <a href="../../B0_std/Fpath/index.html#type-t">B0_std.Fpath.t</a> list) option, string) <a href="../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></code></dt><dd><p><code>revive c k fs</code> binds the file contents of key <code>k</code> to the inexistent file <em>path</em>s (directories are created) of <code>fs</code>. The function returns:</p><ul><li><code>Ok (Some (m, existed)</code> in case of success, with <code>m</code> the metadata of the key and <code>existed</code> the files that already existed and were left untouched by the operation. Assuming no other process fiddles with <code>fs</code> all these file paths now exist (but those of <code>existed</code> might differ from the corresponding one in the cache).</li><li><code>Ok None</code> if the length of <code>fs</code> does not match the sequence of files of <code>k</code> or if <code>k</code> is unbound in <code>c</code>. In this case the file paths <code>fs</code> are left untouched.</li><li><code>Error _</code> if an unexpected error occurs. In that case the resulting state of the file system for paths <code>fs</code> is undefined.</li></ul></dd></dl><dl><dt class="spec value" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span class="keyword">val</span> fold : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<a href="index.html#type-key">key</a> <span>&#45;&gt;</span> <a href="../../B0_std/Fpath/index.html#type-t">B0_std.Fpath.t</a> <span>&#45;&gt;</span> <a href="../../B0_std/Fpath/index.html#type-t">B0_std.Fpath.t</a> list <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, string) <a href="../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></code></dt><dd><p><code>fold c f acc</code> folds <code>f</code> over the contents of each key of <code>c</code> starting with <code>acc</code>.</p></dd></dl><dl><dt class="spec value" id="val-keys"><a href="#val-keys" class="anchor"></a><code><span class="keyword">val</span> keys : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<a href="index.html#type-key">key</a> list, string) <a href="../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></code></dt><dd><p><code>keys c</code> are the keys of cache <code>c</code>.</p></dd></dl><dl><dt class="spec value" id="val-is_unused"><a href="#val-is_unused" class="anchor"></a><code><span class="keyword">val</span> is_unused : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-key">key</a> <span>&#45;&gt;</span> (bool, string) <a href="../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></code></dt><dd><p><code>is_unused c k</code> is <code>true</code> iff <code>k</code> is bound in <code>c</code> and its content is being unused. <b>Warning</b> For caches which are referenced across file system device or on file systems that do not support hard links this may return <code>true</code> even though the key is actually in use.</p></dd></dl><dl><dt class="spec value" id="val-delete_unused"><a href="#val-delete_unused" class="anchor"></a><code><span class="keyword">val</span> delete_unused : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (unit, string) <a href="../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></code></dt><dd><p><code>delete_unused c</code> deletes <a href="index.html#val-is_unused"><span>unused</span></a> keys of <code>c</code>.</p></dd></dl><dl><dt class="spec value" id="val-trim_size"><a href="#val-trim_size" class="anchor"></a><code><span class="keyword">val</span> trim_size : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> max_byte_size:int <span>&#45;&gt;</span> pct:int <span>&#45;&gt;</span> (unit, string) <a href="../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></code></dt><dd><p><code>trim_size c max_byte_size ~pct</code> delete keys of <code>c</code> until they either weight at most <code>max_byte_size</code> or are <code>pct</code> of their current size; whichever is the smaller. The function deletes by order of increasing access time but unused keys are deleted first.</p></dd></dl></section><section><header><h2 id="stats"><a href="#stats" class="anchor"></a>Cache statistics</h2></header><dl><dt class="spec module" id="module-Stats"><a href="#module-Stats" class="anchor"></a><code><span class="keyword">module</span> <a href="Stats/index.html">Stats</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Cache statistics.</p></dd></dl></section></div></body></html>