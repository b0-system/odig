<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Result (sugar.Sugar__S.Result)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">sugar</a> &#x00BB; <a href="../index.html">Sugar__S</a> &#x00BB; Result</nav><h1>Module type <code>Sugar__S.Result</code></h1><p>The signature for the default result monad.</p></header><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../index.html#module-type-Result_partials">Result_partials</a></code></span></summary><dl><dt class="spec type" id="type-error"><a href="#type-error" class="anchor"></a><code><span class="keyword">type</span> error</code></dt><dd><p>Error definition from your project</p></dd></dl><dl><dt class="spec type" id="type-result"><a href="#type-result" class="anchor"></a><code><span class="keyword">type</span> 'a result</code><code> = (<span class="type-var">'a</span>, <a href="index.html#type-error">error</a>) <a href="../../../result/Result/index.html#type-result">Result.result</a></code></dt><dd><p>An alias for the result type in the stdlib</p></dd></dl><dl><dt class="spec value" id="val-bind"><a href="#val-bind" class="anchor"></a><code><span class="keyword">val</span> bind : <span class="type-var">'a</span> <a href="index.html#type-result">result</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-result">result</a>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-result">result</a></code></dt><dd><p>Apply the binding only if the computation was successful. You can use the operator <a href="index.html#val-(&gt;&gt;=)"><span>&gt;&gt;=</span></a> instead of this function for syntatic sugar</p></dd></dl><dl><dt class="spec value" id="val-bind_unless"><a href="#val-bind_unless" class="anchor"></a><code><span class="keyword">val</span> bind_unless : <span class="type-var">'a</span> <a href="index.html#type-result">result</a> <span>&#45;&gt;</span> (<a href="index.html#type-error">error</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-result">result</a>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-result">result</a></code></dt><dd><p>Apply the binding only if the computation failed.</p><p>Notice that an error handler must be provided, and this handler must throw an error or provide an equivalent for the result type of the previous computation.</p><p>You can use the operator <a href="Infix/index.html#val-(&gt;---------)"><span>&gt;---------</span></a> instead of this function for syntatic sugar</p></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : <span class="type-var">'a</span> <a href="index.html#type-result">result</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-result">result</a></code></dt><dd><p>Apply a function to the result of a successful computation. This function makes it ease to work with non error aware functions.</p><p>Example:</p><pre><code class="ml">open Sugar.Option

let twenty =
 map (Some 10) (fun n -&gt; n + n)</code></pre><p>You could also use the combinator <a href="Infix/index.html#val-(&gt;&gt;|)"><span>&gt;&gt;|</span></a> for syntatic sugar.</p></dd></dl><dl><dt class="spec value" id="val-return"><a href="#val-return" class="anchor"></a><code><span class="keyword">val</span> return : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-result">result</a></code></dt><dd><p>Return a value in a successful computation. This function should be used with its counterpart, <code>throw</code></p></dd></dl><dl><dt class="spec value" id="val-throw"><a href="#val-throw" class="anchor"></a><code><span class="keyword">val</span> throw : <a href="index.html#type-error">error</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-result">result</a></code></dt><dd><p>Return an error as the result of a computation.</p><p>Like the <code>return</code> function, <code>throw</code> helps you hide the internals of your result type and keep a clean code.</p><p>If you are still at the beginning of your project, and don't have your errors defined yet, this function still is a great help. For example, the code bellow have the same usage as the function <code>failwith</code>, but is a lot safer.</p><pre><code class="ml">module MyResult = Sugar.MakeResult (struct error = string end)
open MyResult
let run (): int result =
  if true then
    return 10
  else
    throw &quot;something bad happend&quot;</code></pre><p>You could also not describe your errors at all for some time, and use the <a href="../../Sugar/Option/index.html"><code>Sugar.Option</code></a> module to create error aware computations, like:</p><pre><code class="ml">open Sugar.Option
let run (): string result =
  if true then
    return &quot;hello world&quot;
  else
    throw ()</code></pre></dd></dl><div class="spec module" id="module-Infix"><a href="#module-Infix" class="anchor"></a><code><span class="keyword">module</span> <a href="Infix/index.html">Infix</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-(&gt;&gt;=)"><a href="#val-(&gt;&gt;=)" class="anchor"></a><code><span class="keyword">val</span> (&gt;&gt;=) : <span class="type-var">'a</span> <a href="index.html#type-result">result</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-result">result</a>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-result">result</a></code></dt><dd><p>Bind combinator</p><p>If the computation in the left is successful, the operator will Take the inner value and feed it to the function in the right. This is an alias for the function <code>bind</code>.</p><p>If the computation in the left failed, the operator will propagate the error, skipping the function completely.</p></dd></dl><dl><dt class="spec value" id="val-unwrap"><a href="#val-unwrap" class="anchor"></a><code><span class="keyword">val</span> unwrap : <span class="type-var">'a</span> <a href="index.html#type-result">result</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Unwraps the successful result as a normal value in the threading monad. If the value is not successful, it will raise an Invalid_arg exception.</p></dd></dl><dl><dt class="spec value" id="val-unwrap_or"><a href="#val-unwrap_or" class="anchor"></a><code><span class="keyword">val</span> unwrap_or : (<a href="index.html#type-error">error</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-result">result</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Unwraps the successful result as a value in the threading monad. Different from <code>unwrap</code>, you can assign an error handler to be executed if the computation failed. Example:</p><pre><code class="ml">let run () =
  get_data ()
  |&gt; unwrap_or (fun _ -&gt; &quot;default&quot;)</code></pre></dd></dl><dl><dt class="spec value" id="val-expect"><a href="#val-expect" class="anchor"></a><code><span class="keyword">val</span> expect : <span class="type-var">'a</span> <a href="index.html#type-result">result</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Extracts a successful value from an computation, or raises and Invalid_arg exception with the defined parameter.</p></dd></dl></details></div></div></div><dl><dt class="spec module" id="module-For"><a href="#module-For" class="anchor"></a><code><span class="keyword">module</span> <a href="For/index.html">For</a> : <span class="keyword">functor</span> (<a href="For/argument-1-UserMonad/index.html">UserMonad</a> : <a href="../Params/index.html#module-type-Monad">Params.Monad</a>) <span>&#45;&gt;</span> <a href="../index.html#module-type-Promise">Promise</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="For/index.html#type-error">error</a> := <a href="index.html#type-error">error</a> <span class="keyword">and</span> <span class="keyword">type</span> 'a <a href="For/index.html#type-monad">monad</a> := <span class="type-var">'a</span> <a href="For/argument-1-UserMonad/index.html#type-t">UserMonad.t</a></code></dt><dd><p>Create a new result module based on the current one, but wrapped around a monad.</p></dd></dl></div></body></html>