<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Decoder (dune.Dune_lang.Decoder)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">dune</a> &#x00BB; <a href="../index.html">Dune_lang</a> &#x00BB; Decoder</nav><h1>Module <code>Dune_lang.Decoder</code></h1><nav class="toc"><ul><li><a href="#parsing-record-fields">Parsing record fields</a></li></ul></nav></header><dl><dt class="spec type" id="type-ast"><a href="#type-ast" class="anchor"></a><code><span class="keyword">type</span> ast</code><code> = <a href="../Ast/index.html#type-t">Ast.t</a></code><code> = </code><table class="variant"><tr id="type-ast.Atom" class="anchored"><td class="def constructor"><a href="#type-ast.Atom" class="anchor"></a><code>| </code><code><span class="constructor">Atom</span> <span class="keyword">of</span> <a href="../../Stdune/Loc/index.html#type-t">Stdune.Loc.t</a> * <a href="../Atom/index.html#type-t">Atom.t</a></code></td></tr><tr id="type-ast.Quoted_string" class="anchored"><td class="def constructor"><a href="#type-ast.Quoted_string" class="anchor"></a><code>| </code><code><span class="constructor">Quoted_string</span> <span class="keyword">of</span> <a href="../../Stdune/Loc/index.html#type-t">Stdune.Loc.t</a> * string</code></td></tr><tr id="type-ast.Template" class="anchored"><td class="def constructor"><a href="#type-ast.Template" class="anchor"></a><code>| </code><code><span class="constructor">Template</span> <span class="keyword">of</span> <a href="../Template/index.html#type-t">Template.t</a></code></td></tr><tr id="type-ast.List" class="anchored"><td class="def constructor"><a href="#type-ast.List" class="anchor"></a><code>| </code><code><span class="constructor">List</span> <span class="keyword">of</span> <a href="../../Stdune/Loc/index.html#type-t">Stdune.Loc.t</a> * <a href="index.html#type-ast">ast</a> list</code></td></tr></table></dt><dt class="spec type" id="type-hint"><a href="#type-hint" class="anchor"></a><code><span class="keyword">type</span> hint</code><code> = </code><code>{</code><table class="record"><tr id="type-hint.on" class="anchored"><td class="def field"><a href="#type-hint.on" class="anchor"></a><code>on : string;</code></td></tr><tr id="type-hint.candidates" class="anchored"><td class="def field"><a href="#type-hint.candidates" class="anchor"></a><code>candidates : string list;</code></td></tr></table><code>}</code></dt></dl><dl><dt class="spec exception" id="exception-Decoder"><a href="#exception-Decoder" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Decoder</span> <span class="keyword">of</span> <a href="../../Stdune/Loc/index.html#type-t">Stdune.Loc.t</a> * string * <a href="index.html#type-hint">hint</a> option</code></dt></dl><dl><dt class="spec type" id="type-parser"><a href="#type-parser" class="anchor"></a><code><span class="keyword">type</span> ('a, 'kind) parser</code></dt><dd><p>Monad producing a value of type <code>'a</code> by parsing an input composed of a sequence of S-expressions.</p><p>The input can be seen either as a plain sequence of S-expressions or a list of fields. The <code>'kind</code> parameter indicates how the input is seen:</p><ul><li><p>with </p><pre><code class="ml">'kind = [values]</code></pre><p>, the input is seen as an ordered sequence of S-expressions</p></li></ul><ul><li><p>with </p><pre><code class="ml">'kind = [fields]</code></pre><p>, the input is seen as an unordered sequence of fields</p></li></ul><p>A field is a S-expression of the form: <code>(&lt;atom&gt; &lt;values&gt;...)</code> where <code>atom</code> is a plain atom, i.e. not a quoted string and not containing variables. <code>values</code> is a sequence of zero, one or more S-expressions.</p><p>It is possible to switch between the two mode at any time using the appropriate combinator. Some primitives can be used in both mode while some are specific to one mode.</p></dd></dl><dl><dt class="spec type" id="type-values"><a href="#type-values" class="anchor"></a><code><span class="keyword">type</span> values</code></dt><dt class="spec type" id="type-fields"><a href="#type-fields" class="anchor"></a><code><span class="keyword">type</span> fields</code></dt><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> 'a t</code><code> = (<span class="type-var">'a</span>, <a href="index.html#type-values">values</a>) <a href="index.html#type-parser">parser</a></code></dt><dt class="spec type" id="type-fields_parser"><a href="#type-fields_parser" class="anchor"></a><code><span class="keyword">type</span> 'a fields_parser</code><code> = (<span class="type-var">'a</span>, <a href="index.html#type-fields">fields</a>) <a href="index.html#type-parser">parser</a></code></dt></dl><dl><dt class="spec value" id="val-parse"><a href="#val-parse" class="anchor"></a><code><span class="keyword">val</span> parse : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../Stdune/Univ_map/index.html#type-t">Stdune.Univ_map.t</a> <span>&#45;&gt;</span> <a href="index.html#type-ast">ast</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>parse parser context sexp</code> parse a S-expression using the following parser. The input consist of a single S-expression. <code>context</code> allows to pass extra information such as versions to individual parsers.</p></dd></dl><dl><dt class="spec value" id="val-return"><a href="#val-return" class="anchor"></a><code><span class="keyword">val</span> return : <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">_</span>) <a href="index.html#type-parser">parser</a></code></dt><dt class="spec value" id="val-(&gt;&gt;=)"><a href="#val-(&gt;&gt;=)" class="anchor"></a><code><span class="keyword">val</span> (&gt;&gt;=) : (<span class="type-var">'a</span>, <span class="type-var">'k</span>) <a href="index.html#type-parser">parser</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'b</span>, <span class="type-var">'k</span>) <a href="index.html#type-parser">parser</a>) <span>&#45;&gt;</span> (<span class="type-var">'b</span>, <span class="type-var">'k</span>) <a href="index.html#type-parser">parser</a></code></dt><dt class="spec value" id="val-(&gt;&gt;|)"><a href="#val-(&gt;&gt;|)" class="anchor"></a><code><span class="keyword">val</span> (&gt;&gt;|) : (<span class="type-var">'a</span>, <span class="type-var">'k</span>) <a href="index.html#type-parser">parser</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> (<span class="type-var">'b</span>, <span class="type-var">'k</span>) <a href="index.html#type-parser">parser</a></code></dt><dt class="spec value" id="val-(&gt;&gt;&gt;)"><a href="#val-(&gt;&gt;&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&gt;&gt;&gt;) : (unit, <span class="type-var">'k</span>) <a href="index.html#type-parser">parser</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'k</span>) <a href="index.html#type-parser">parser</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'k</span>) <a href="index.html#type-parser">parser</a></code></dt><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : (<span class="type-var">'a</span>, <span class="type-var">'k</span>) <a href="index.html#type-parser">parser</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> (<span class="type-var">'b</span>, <span class="type-var">'k</span>) <a href="index.html#type-parser">parser</a></code></dt><dt class="spec value" id="val-try_"><a href="#val-try_" class="anchor"></a><code><span class="keyword">val</span> try_ : (<span class="type-var">'a</span>, <span class="type-var">'k</span>) <a href="index.html#type-parser">parser</a> <span>&#45;&gt;</span> (exn <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'k</span>) <a href="index.html#type-parser">parser</a>) <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'k</span>) <a href="index.html#type-parser">parser</a></code></dt><dt class="spec value" id="val-get"><a href="#val-get" class="anchor"></a><code><span class="keyword">val</span> get : <span class="type-var">'a</span> <a href="../../Stdune__Univ_map/Key/index.html#type-t">Stdune.Univ_map.Key.t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> option, <span class="type-var">_</span>) <a href="index.html#type-parser">parser</a></code></dt><dd><p>Access to the context</p></dd></dl><dl><dt class="spec value" id="val-set"><a href="#val-set" class="anchor"></a><code><span class="keyword">val</span> set : <span class="type-var">'a</span> <a href="../../Stdune__Univ_map/Key/index.html#type-t">Stdune.Univ_map.Key.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'b</span>, <span class="type-var">'k</span>) <a href="index.html#type-parser">parser</a> <span>&#45;&gt;</span> (<span class="type-var">'b</span>, <span class="type-var">'k</span>) <a href="index.html#type-parser">parser</a></code></dt><dt class="spec value" id="val-get_all"><a href="#val-get_all" class="anchor"></a><code><span class="keyword">val</span> get_all : (<a href="../../Stdune/Univ_map/index.html#type-t">Stdune.Univ_map.t</a>, <span class="type-var">_</span>) <a href="index.html#type-parser">parser</a></code></dt><dt class="spec value" id="val-set_many"><a href="#val-set_many" class="anchor"></a><code><span class="keyword">val</span> set_many : <a href="../../Stdune/Univ_map/index.html#type-t">Stdune.Univ_map.t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'k</span>) <a href="index.html#type-parser">parser</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'k</span>) <a href="index.html#type-parser">parser</a></code></dt><dt class="spec value" id="val-loc"><a href="#val-loc" class="anchor"></a><code><span class="keyword">val</span> loc : (<a href="../../Stdune/Loc/index.html#type-t">Stdune.Loc.t</a>, <span class="type-var">_</span>) <a href="index.html#type-parser">parser</a></code></dt><dd><p>Return the location of the list currently being parsed.</p></dd></dl><dl><dt class="spec value" id="val-if_eos"><a href="#val-if_eos" class="anchor"></a><code><span class="keyword">val</span> if_eos : then_:(<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-parser">parser</a> <span>&#45;&gt;</span> else_:(<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-parser">parser</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-parser">parser</a></code></dt><dd><p>End of sequence condition. Uses <code>then_</code> if there are no more S-expressions to parse, <code>else_</code> otherwise.</p></dd></dl><dl><dt class="spec value" id="val-if_list"><a href="#val-if_list" class="anchor"></a><code><span class="keyword">val</span> if_list : then_:<span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> else_:<span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>If the next element of the sequence is a list, parse it with <code>then_</code>, otherwise parse it with <code>else_</code>.</p></dd></dl><dl><dt class="spec value" id="val-if_paren_colon_form"><a href="#val-if_paren_colon_form" class="anchor"></a><code><span class="keyword">val</span> if_paren_colon_form : then_:((<a href="../../Stdune/Loc/index.html#type-t">Stdune.Loc.t</a> * string) <span>&#45;&gt;</span> <span class="type-var">'a</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> else_:<span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>If the next element of the sequence is of the form <code>(:&lt;name&gt;
      ...)</code>, use <code>then_</code> to parse <code>...</code>. Otherwise use <code>else_</code>.</p></dd></dl><dl><dt class="spec value" id="val-keyword"><a href="#val-keyword" class="anchor"></a><code><span class="keyword">val</span> keyword : string <span>&#45;&gt;</span> unit <a href="index.html#type-t">t</a></code></dt><dd><p>Expect the next element to be the following atom.</p></dd></dl><dl><dt class="spec value" id="val-match_keyword"><a href="#val-match_keyword" class="anchor"></a><code><span class="keyword">val</span> match_keyword : (string * <span class="type-var">'a</span> <a href="index.html#type-t">t</a>) list <span>&#45;&gt;</span> fallback:<span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><pre><code class="ml">match_keyword [(k1, t1); (k2, t2); ...] ~fallback</code></pre><p>inspects the next element of the input sequence. If it is an atom equal to one of <code>k1</code>, <code>k2</code>, ... then the corresponding parser is used to parse the rest of the sequence. Other <code>fallback</code> is used.</p></dd></dl><dl><dt class="spec value" id="val-until_keyword"><a href="#val-until_keyword" class="anchor"></a><code><span class="keyword">val</span> until_keyword : string <span>&#45;&gt;</span> before:<span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> after:<span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> list * <span class="type-var">'b</span> option) <a href="index.html#type-t">t</a></code></dt><dd><p>Use <code>before</code> to parse elements until the keyword is reached. Then use <code>after</code> to parse the rest.</p></dd></dl><dl><dt class="spec type" id="type-kind"><a href="#type-kind" class="anchor"></a><code><span class="keyword">type</span> kind</code><code> = </code><table class="variant"><tr id="type-kind.Values" class="anchored"><td class="def constructor"><a href="#type-kind.Values" class="anchor"></a><code>| </code><code><span class="constructor">Values</span> <span class="keyword">of</span> <a href="../../Stdune/Loc/index.html#type-t">Stdune.Loc.t</a> * string option</code></td></tr><tr id="type-kind.Fields" class="anchored"><td class="def constructor"><a href="#type-kind.Fields" class="anchor"></a><code>| </code><code><span class="constructor">Fields</span> <span class="keyword">of</span> <a href="../../Stdune/Loc/index.html#type-t">Stdune.Loc.t</a> * string option</code></td></tr></table></dt><dd><p>What is currently being parsed. The second argument is the atom at the beginnig of the list when inside a <code>sum ...</code> or <code>field
      ...</code>.</p></dd></dl><dl><dt class="spec value" id="val-kind"><a href="#val-kind" class="anchor"></a><code><span class="keyword">val</span> kind : (<a href="index.html#type-kind">kind</a>, <span class="type-var">_</span>) <a href="index.html#type-parser">parser</a></code></dt><dt class="spec value" id="val-repeat"><a href="#val-repeat" class="anchor"></a><code><span class="keyword">val</span> repeat : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <a href="index.html#type-t">t</a></code></dt><dd><p><code>repeat t</code> use <code>t</code> to consume all remaning elements of the input until the end of sequence is reached.</p></dd></dl><dl><dt class="spec value" id="val-capture"><a href="#val-capture" class="anchor"></a><code><span class="keyword">val</span> capture : (<span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>Capture the rest of the input for later parsing</p></dd></dl><dl><dt class="spec value" id="val-enter"><a href="#val-enter" class="anchor"></a><code><span class="keyword">val</span> enter : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>enter t</code> expect the next element of the input to be a list and parse its contents with <code>t</code>.</p></dd></dl><dl><dt class="spec value" id="val-fields"><a href="#val-fields" class="anchor"></a><code><span class="keyword">val</span> fields : <span class="type-var">'a</span> <a href="index.html#type-fields_parser">fields_parser</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>fields fp</code> converts the rest of the current input to a list of fields and parse them with <code>fp</code>. This operation fails if one the S-expression in the input is not of the form <code>(&lt;atom&gt;
      &lt;values&gt;...)</code></p></dd></dl><dl><dt class="spec value" id="val-record"><a href="#val-record" class="anchor"></a><code><span class="keyword">val</span> record : <span class="type-var">'a</span> <a href="index.html#type-fields_parser">fields_parser</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>record fp = enter (fields fp)</code></p></dd></dl><div><div class="spec include"><div class="doc"><p>Consume the next element of the input as a string, int, char, ...</p><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../../Stdune/Sexp_intf/index.html#module-type-Combinators">Stdune.Sexp_intf.Combinators</a> <span class="keyword">with</span> <span class="keyword">type</span> 'a <a href="../../Stdune/Sexp_intf/module-type-Combinators/index.html#type-t">t</a> := <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> 'a t</code></dt></dl><dl><dt class="spec value" id="val-unit"><a href="#val-unit" class="anchor"></a><code><span class="keyword">val</span> unit : unit <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-char"><a href="#val-char" class="anchor"></a><code><span class="keyword">val</span> char : char <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-string"><a href="#val-string" class="anchor"></a><code><span class="keyword">val</span> string : string <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-int"><a href="#val-int" class="anchor"></a><code><span class="keyword">val</span> int : int <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-float"><a href="#val-float" class="anchor"></a><code><span class="keyword">val</span> float : float <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-bool"><a href="#val-bool" class="anchor"></a><code><span class="keyword">val</span> bool : bool <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-pair"><a href="#val-pair" class="anchor"></a><code><span class="keyword">val</span> pair : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-triple"><a href="#val-triple" class="anchor"></a><code><span class="keyword">val</span> triple : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span> * <span class="type-var">'c</span>) <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-list"><a href="#val-list" class="anchor"></a><code><span class="keyword">val</span> list : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-array"><a href="#val-array" class="anchor"></a><code><span class="keyword">val</span> array : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> array <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-option"><a href="#val-option" class="anchor"></a><code><span class="keyword">val</span> option : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> option <a href="index.html#type-t">t</a></code></dt></dl></details></div></div></div><dl><dt class="spec value" id="val-raw"><a href="#val-raw" class="anchor"></a><code><span class="keyword">val</span> raw : <a href="index.html#type-ast">ast</a> <a href="index.html#type-t">t</a></code></dt><dd><p>Unparsed next element of the input</p></dd></dl><dl><dt class="spec value" id="val-peek"><a href="#val-peek" class="anchor"></a><code><span class="keyword">val</span> peek : <a href="index.html#type-ast">ast</a> option <a href="index.html#type-t">t</a></code></dt><dd><p>Inspect the next element of the input without consuming it</p></dd></dl><dl><dt class="spec value" id="val-peek_exn"><a href="#val-peek_exn" class="anchor"></a><code><span class="keyword">val</span> peek_exn : <a href="index.html#type-ast">ast</a> <a href="index.html#type-t">t</a></code></dt><dd><p>Same as <code>peek</code> but fail if the end of input is reached</p></dd></dl><dl><dt class="spec value" id="val-junk"><a href="#val-junk" class="anchor"></a><code><span class="keyword">val</span> junk : unit <a href="index.html#type-t">t</a></code></dt><dd><p>Consume and ignore the next element of the input</p></dd></dl><dl><dt class="spec value" id="val-junk_everything"><a href="#val-junk_everything" class="anchor"></a><code><span class="keyword">val</span> junk_everything : (unit, <span class="type-var">_</span>) <a href="index.html#type-parser">parser</a></code></dt><dd><p>Ignore all the rest of the input</p></dd></dl><dl><dt class="spec value" id="val-plain_string"><a href="#val-plain_string" class="anchor"></a><code><span class="keyword">val</span> plain_string : (loc:<a href="../../Stdune/Loc/index.html#type-t">Stdune.Loc.t</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>plain_string f</code> expects the next element of the input to be a plain string, i.e. either an atom or a quoted string, but not a template nor a list.</p></dd></dl><dl><dt class="spec value" id="val-fix"><a href="#val-fix" class="anchor"></a><code><span class="keyword">val</span> fix : (<span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-of_sexp_error"><a href="#val-of_sexp_error" class="anchor"></a><code><span class="keyword">val</span> of_sexp_error : ?&#8288;hint:<a href="index.html#type-hint">hint</a> <span>&#45;&gt;</span> <a href="../../Stdune/Loc/index.html#type-t">Stdune.Loc.t</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">_</span></code></dt><dt class="spec value" id="val-of_sexp_errorf"><a href="#val-of_sexp_errorf" class="anchor"></a><code><span class="keyword">val</span> of_sexp_errorf : ?&#8288;hint:<a href="index.html#type-hint">hint</a> <span>&#45;&gt;</span> <a href="../../Stdune/Loc/index.html#type-t">Stdune.Loc.t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, unit, string, <span class="type-var">'b</span>) <a href="../../../ocaml/Stdlib/index.html#type-format4">Stdlib.format4</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dt class="spec value" id="val-no_templates"><a href="#val-no_templates" class="anchor"></a><code><span class="keyword">val</span> no_templates : ?&#8288;hint:<a href="index.html#type-hint">hint</a> <span>&#45;&gt;</span> <a href="../../Stdune/Loc/index.html#type-t">Stdune.Loc.t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, unit, string, <span class="type-var">'b</span>) <a href="../../../ocaml/Stdlib/index.html#type-format4">Stdlib.format4</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dt class="spec value" id="val-located"><a href="#val-located" class="anchor"></a><code><span class="keyword">val</span> located : (<span class="type-var">'a</span>, <span class="type-var">'k</span>) <a href="index.html#type-parser">parser</a> <span>&#45;&gt;</span> (<a href="../../Stdune/Loc/index.html#type-t">Stdune.Loc.t</a> * <span class="type-var">'a</span>, <span class="type-var">'k</span>) <a href="index.html#type-parser">parser</a></code></dt><dt class="spec value" id="val-enum"><a href="#val-enum" class="anchor"></a><code><span class="keyword">val</span> enum : (string * <span class="type-var">'a</span>) list <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-sum"><a href="#val-sum" class="anchor"></a><code><span class="keyword">val</span> sum : (string * <span class="type-var">'a</span> <a href="index.html#type-t">t</a>) list <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Parser that parse a S-expression of the form <code>(&lt;atom&gt; &lt;s-exp1&gt;
      &lt;s-exp2&gt; ...)</code> or <code>&lt;atom&gt;</code>. <code>&lt;atom&gt;</code> is looked up in the list and the remaining s-expressions are parsed using the corresponding list parser.</p></dd></dl><dl><dt class="spec value" id="val-map_validate"><a href="#val-map_validate" class="anchor"></a><code><span class="keyword">val</span> map_validate : <span class="type-var">'a</span> <a href="index.html#type-fields_parser">fields_parser</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'b</span>, string) <a href="../../Stdune/Result/index.html#type-t">Stdune.Result.t</a>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-fields_parser">fields_parser</a></code></dt><dd><p>Check the result of a list parser, and raise a properly located error in case of failure.</p></dd></dl><section><header><h4 id="parsing-record-fields"><a href="#parsing-record-fields" class="anchor"></a>Parsing record fields</h4></header><dl><dt class="spec value" id="val-field"><a href="#val-field" class="anchor"></a><code><span class="keyword">val</span> field : string <span>&#45;&gt;</span> ?&#8288;default:<span class="type-var">'a</span> <span>&#45;&gt;</span> ?&#8288;on_dup:(<a href="../../Stdune/Univ_map/index.html#type-t">Stdune.Univ_map.t</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="../Ast/index.html#type-t">Ast.t</a> list <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-fields_parser">fields_parser</a></code></dt><dt class="spec value" id="val-field_o"><a href="#val-field_o" class="anchor"></a><code><span class="keyword">val</span> field_o : string <span>&#45;&gt;</span> ?&#8288;on_dup:(<a href="../../Stdune/Univ_map/index.html#type-t">Stdune.Univ_map.t</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="../Ast/index.html#type-t">Ast.t</a> list <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> option <a href="index.html#type-fields_parser">fields_parser</a></code></dt><dt class="spec value" id="val-field_b"><a href="#val-field_b" class="anchor"></a><code><span class="keyword">val</span> field_b : ?&#8288;check:unit <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> ?&#8288;on_dup:(<a href="../../Stdune/Univ_map/index.html#type-t">Stdune.Univ_map.t</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="../Ast/index.html#type-t">Ast.t</a> list <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> string <span>&#45;&gt;</span> bool <a href="index.html#type-fields_parser">fields_parser</a></code></dt><dt class="spec value" id="val-field_o_b"><a href="#val-field_o_b" class="anchor"></a><code><span class="keyword">val</span> field_o_b : ?&#8288;check:unit <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> ?&#8288;on_dup:(<a href="../../Stdune/Univ_map/index.html#type-t">Stdune.Univ_map.t</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="../Ast/index.html#type-t">Ast.t</a> list <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> string <span>&#45;&gt;</span> bool option <a href="index.html#type-fields_parser">fields_parser</a></code></dt><dt class="spec value" id="val-multi_field"><a href="#val-multi_field" class="anchor"></a><code><span class="keyword">val</span> multi_field : string <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <a href="index.html#type-fields_parser">fields_parser</a></code></dt><dd><p>A field that can appear multiple times</p></dd></dl><dl><dt class="spec value" id="val-field_present_too_many_times"><a href="#val-field_present_too_many_times" class="anchor"></a><code><span class="keyword">val</span> field_present_too_many_times : <a href="../../Stdune/Univ_map/index.html#type-t">Stdune.Univ_map.t</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="../Ast/index.html#type-t">Ast.t</a> list <span>&#45;&gt;</span> <span class="type-var">_</span></code></dt><dd><p>Default value for <code>on_dup</code>. It fails with an appropriate error message.</p></dd></dl><dl><dt class="spec value" id="val-leftover_fields"><a href="#val-leftover_fields" class="anchor"></a><code><span class="keyword">val</span> leftover_fields : <a href="../Ast/index.html#type-t">Ast.t</a> list <a href="index.html#type-fields_parser">fields_parser</a></code></dt></dl><div class="spec module" id="module-Let_syntax"><a href="#module-Let_syntax" class="anchor"></a><code><span class="keyword">module</span> <a href="Let_syntax/index.html">Let_syntax</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section></div></body></html>