<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>BatEnum (batteries.BatEnum)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">batteries</a> &#x00BB; BatEnum</nav><header class="odoc-preamble"><h1>Module <code><span>BatEnum</span></code></h1><p>Enumeration over abstract collection of elements.</p><p>Enumerations are a representation of finite or infinite sequences of elements. In Batteries Included, enumerations are used pervasively, both as a uniform manner of reading and manipulating the contents of a data structure, or as a simple manner of reading or writing sequences of characters, numbers, strings, etc. from/to files, network connections or other inputs/outputs.</p><p>Enumerations are typically computed as needed, which allows the definition and manipulation of huge (possibly infinite) sequences. Manipulating an enumeration is a uniform and often comfortable way of extracting subsequences (function <a href="#val-filter"><code>filter</code></a> or operator <code>//</code> et al), converting sequences into other sequences (function <a href="#val-map"><code>map</code></a> or operators <code>/@</code> and <code>@/</code> et al), gathering information (function <a href="#val-scanl"><code>scanl</code></a> et al) or performing loops (functions <a href="#val-iter"><code>iter</code></a> and <a href="#val-map"><code>map</code></a>).</p><p>For instance, function <a href="../BatRandom/index.html#val-enum_int"><code>BatRandom.enum_int</code></a> creates an infinite enumeration of random numbers. Combined with <code>//</code> and <a href="#val-map"><code>map</code></a>, we may turn this into an infinite enumeration of squares of random even numbers: <code>map (fun x -&gt; x * x) ( (Random.enum_int 100) // even )</code></p><p>Similarly, to obtain an enumeration of 50 random integers, we may use <a href="#val-take"><code>take</code></a>, as follows: <code>take 50 (Random.enum_int 100)</code></p><p>As most data structures in Batteries can be enumerated and built from enumerations, these operations may be used also on lists, arrays, hashtables, etc. When designing a new data structure, it is usually a good idea to allow enumeration and construction from an enumeration.</p><p><b>Note</b> Enumerations are not thread-safe. You should not attempt to access one enumeration from different threads.</p><ul class="at-tags"><li class="author"><span class="at-tag">author</span> Nicolas Cannasse</li></ul><ul class="at-tags"><li class="author"><span class="at-tag">author</span> David Rajchenbach-Teller</li></ul></header><nav class="odoc-toc"><ul><li><a href="#final-functions">Final functions</a></li><li><a href="#useful-functions">Useful functions</a></li><li><a href="#lazy-constructors">Lazy constructors</a></li><li><a href="#constructors">Constructors</a></li><li><a href="#counting">Counting</a></li><li><a href="#utilities">Utilities</a></li><li><a href="#trampolining">Trampolining</a></li><li><a href="#infix-operators">Infix operators</a></li><li><a href="#monad-related-modules">Monad related modules</a></li><li><a href="#boilerplate-code">Boilerplate code</a></li><li><a href="#override-modules">Override modules</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a t</span></span></code></div></div><div class="odoc-spec"><div class="spec module-type" id="module-type-Enumerable" class="anchored"><a href="#module-type-Enumerable" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span><a href="module-type-Enumerable/index.html">Enumerable</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>A signature for data structures which may be converted to and from <code>enum</code>.</p></div></div><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="module-type-Enumerable/index.html">Enumerable</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="module-type-Enumerable/index.html#type-enumerable">enumerable</a></span> = <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></span></code></summary><div class="odoc-spec"><div class="spec type" id="type-enumerable" class="anchored"><a href="#type-enumerable" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a enumerable</span></span><span> = <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>The data structure, e.g. <code>'a List.t</code></p></div></div></details></div><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../BatInterfaces/module-type-Mappable/index.html">BatInterfaces.Mappable</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="../BatInterfaces/module-type-Mappable/index.html#type-mappable">mappable</a></span> = <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></span></code></summary><div class="odoc-spec"><div class="spec type" id="type-mappable" class="anchored"><a href="#type-mappable" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a mappable</span></span><span> = <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>The data structure, e.g. <code>'a List.t</code></p></div></div></details></div><h6 id="final-functions"><a href="#final-functions" class="anchor"></a>Final functions</h6><p>These functions consume the enumeration until it ends or an exception is raised by the first argument function.</p><div class="odoc-spec"><div class="spec value" id="val-iter" class="anchored"><a href="#val-iter" class="anchor"></a><code><span><span class="keyword">val</span> iter : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>iter f e</code> calls the function <code>f</code> with each elements of <code>e</code> in turn.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-iter2" class="anchored"><a href="#val-iter2" class="anchor"></a><code><span><span class="keyword">val</span> iter2 : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>iter2 f e1 e2</code> calls the function <code>f</code> with the next elements of <code>e1</code> and <code>e2</code> repeatedly until one of the two enumerations ends.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-exists" class="anchored"><a href="#val-exists" class="anchor"></a><code><span><span class="keyword">val</span> exists : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>exists f e</code> returns <code>true</code> if there is some <code>x</code> in <code>e</code> such that <code>f x</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-for_all" class="anchored"><a href="#val-for_all" class="anchor"></a><code><span><span class="keyword">val</span> for_all : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>for_all f e</code> returns <code>true</code> if for every <code>x</code> in <code>e</code>, <code>f x</code> is true</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold" class="anchored"><a href="#val-fold" class="anchor"></a><code><span><span class="keyword">val</span> fold : <span><span>(<span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span></span></code></div><div class="spec-doc"><p>A general loop on an enumeration.</p><p>If <code>e</code> is empty, <code>fold f v e</code> returns <code>v</code>. Otherwise, <code>fold v e</code> returns <code>f (... (f (f v a0) a1) ...) aN</code> where <code>a0,a1..aN</code> are the elements of <code>e</code>. This function may be used, for instance, to compute the sum of all elements of an enumeration <code>e</code> as follows: <code>fold ( + ) 0 e</code>. Eager.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-reduce" class="anchored"><a href="#val-reduce" class="anchor"></a><code><span><span class="keyword">val</span> reduce : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>A simplified version of <code>fold</code>, which uses the first element of the enumeration as a default value.</p><p><code>reduce f e</code> throws <code>Not_found</code> if <code>e</code> is empty, returns its only element if e is a singleton, otherwise <code>f (... (f (f a0 a1)
      a2)...) aN</code> where <code>a0,a1..aN</code> are the elements of <code>e</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sum" class="anchored"><a href="#val-sum" class="anchor"></a><code><span><span class="keyword">val</span> sum : <span><span>int <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>sum</code> returns the sum of the given int enum. If the argument is empty, returns 0. Eager</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fsum" class="anchored"><a href="#val-fsum" class="anchor"></a><code><span><span class="keyword">val</span> fsum : <span><span>float <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>the sum of the enum's elements. Uses Kahan summing to get a more accurate answer than <code>reduce (+.)</code> would return, but runs slower.</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-kahan_sum" class="anchored"><a href="#val-kahan_sum" class="anchor"></a><code><span><span class="keyword">val</span> kahan_sum : <span><span>float <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p><code>kahan_sum l</code> returns a numerically-accurate sum of the floats of <code>l</code>. See <a href="../BatArray/index.html#val-fsum"><code>BatArray.fsum</code></a> for more details.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.2.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-fold2" class="anchored"><a href="#val-fold2" class="anchor"></a><code><span><span class="keyword">val</span> fold2 : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span></span></code></div><div class="spec-doc"><p><code>fold2</code> is similar to <code>fold</code> but will fold over two enumerations at the same time until one of the two enumerations ends.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-scanl" class="anchored"><a href="#val-scanl" class="anchor"></a><code><span><span class="keyword">val</span> scanl : <span><span>(<span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>A variant of <code>fold</code> producing an enumeration of its intermediate values. If <code>e</code> contains <code>x0</code>, <code>x1</code>, ..., <code>scanl f init e</code> is the enumeration containing <code>init</code>, <code>f init x0</code>, <code>f (f init x0) x1</code>... Lazy.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-scan" class="anchored"><a href="#val-scan" class="anchor"></a><code><span><span class="keyword">val</span> scan : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>scan</code> is similar to <code>scanl</code> but without the <code>init</code> value: if <code>e</code> contains <code>x0</code>, <code>x1</code>, <code>x2</code> ..., <code>scan f e</code> is the enumeration containing <code>x0</code>, <code>f x0 x1</code>, <code>f (f x0 x1) x2</code>...</p><p>For instance, <code>scan ( * ) (1 -- 10)</code> will produce an enumeration containing the successive values of the factorial function.</p></div></div><p>Indexed functions : these functions are similar to previous ones except that they call the function with one additional argument which is an index starting at 0 and incremented after each call to the function.</p><div class="odoc-spec"><div class="spec value" id="val-iteri" class="anchored"><a href="#val-iteri" class="anchor"></a><code><span><span class="keyword">val</span> iteri : <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-iter2i" class="anchored"><a href="#val-iter2i" class="anchor"></a><code><span><span class="keyword">val</span> iter2i : <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-foldi" class="anchored"><a href="#val-foldi" class="anchor"></a><code><span><span class="keyword">val</span> foldi : <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-fold2i" class="anchored"><a href="#val-fold2i" class="anchor"></a><code><span><span class="keyword">val</span> fold2i : <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span></span></code></div></div><h6 id="useful-functions"><a href="#useful-functions" class="anchor"></a>Useful functions</h6><div class="odoc-spec"><div class="spec value" id="val-find" class="anchored"><a href="#val-find" class="anchor"></a><code><span><span class="keyword">val</span> find : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>find f e</code> returns the first element <code>x</code> of <code>e</code> such that <code>f x</code> returns <code>true</code>, consuming the enumeration up to and including the found element.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Not_found</span> <p>if no such element exists in the enumeration, consuming the whole enumeration in the search.</p><p>Since <code>find</code> (eagerly) consumes a prefix of the enumeration, it can be used several times on the same enumeration to find the next element.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-find_map" class="anchored"><a href="#val-find_map" class="anchor"></a><code><span><span class="keyword">val</span> find_map : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span></span></code></div><div class="spec-doc"><p><code>find_map f e</code> finds the first element <code>x</code> of <code>e</code> such that <code>f x</code> returns <code>Some r</code>, then returns r. It consumes the enumeration up to and including the found element.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Not_found</span> <p>if no such element exists in the enumeration, consuming the whole enumeration in the search.</p><p>Since <code>find_map</code> (eagerly) consumes a prefix of the enumeration, it can be used several times on the same enumeration to find the next element.</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-is_empty" class="anchored"><a href="#val-is_empty" class="anchor"></a><code><span><span class="keyword">val</span> is_empty : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_empty e</code> returns true if <code>e</code> does not contains any element. Forces at most one element.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-peek" class="anchored"><a href="#val-peek" class="anchor"></a><code><span><span class="keyword">val</span> peek : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div><div class="spec-doc"><p><code>peek e</code> returns <code>None</code> if <code>e</code> is empty or <code>Some x</code> where <code>x</code> is the next element of <code>e</code>. The element is not removed from the enumeration.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get" class="anchored"><a href="#val-get" class="anchor"></a><code><span><span class="keyword">val</span> get : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div><div class="spec-doc"><p><code>get e</code> returns <code>None</code> if <code>e</code> is empty or <code>Some x</code> where <code>x</code> is the next element of <code>e</code>, in which case the element is removed from the enumeration.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_exn" class="anchored"><a href="#val-get_exn" class="anchor"></a><code><span><span class="keyword">val</span> get_exn : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>get_exn e</code> returns the first element of <code>e</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">No_more_elements</span> <p>if <code>e</code> is empty.</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-push" class="anchored"><a href="#val-push" class="anchor"></a><code><span><span class="keyword">val</span> push : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>push e x</code> will add <code>x</code> at the beginning of <code>e</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-junk" class="anchored"><a href="#val-junk" class="anchor"></a><code><span><span class="keyword">val</span> junk : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>junk e</code> removes the first element from the enumeration, if any.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-clone" class="anchored"><a href="#val-clone" class="anchor"></a><code><span><span class="keyword">val</span> clone : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>clone e</code> creates a new enumeration that is copy of <code>e</code>. If <code>e</code> is consumed by later operations, the clone will not get affected.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-force" class="anchored"><a href="#val-force" class="anchor"></a><code><span><span class="keyword">val</span> force : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>force e</code> forces the application of all lazy functions and the enumeration of all elements, exhausting the enumeration.</p><p>An efficient intermediate data structure of enumerated elements is constructed and <code>e</code> will now enumerate over that data structure.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-take" class="anchored"><a href="#val-take" class="anchor"></a><code><span><span class="keyword">val</span> take : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>take n e</code> returns the prefix of <code>e</code> of length <code>n</code>, or <code>e</code> itself if <code>n</code> is greater than the length of <code>e</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-drop" class="anchored"><a href="#val-drop" class="anchor"></a><code><span><span class="keyword">val</span> drop : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>drop n e</code> removes the first <code>n</code> element from the enumeration, if any.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-skip" class="anchored"><a href="#val-skip" class="anchor"></a><code><span><span class="keyword">val</span> skip : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>skip n e</code> removes the first <code>n</code> element from the enumeration, if any, then returns <code>e</code>.</p><p>This function has the same behavior as <code>drop</code> but is often easier to compose with, e.g., <code>skip 5 %&gt; take 3</code> is a new function which skips 5 elements and then returns the next 3 elements.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-take_while" class="anchored"><a href="#val-take_while" class="anchor"></a><code><span><span class="keyword">val</span> take_while : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>take_while f e</code> produces a new enumeration in which only remain the first few elements <code>x</code> of <code>e</code> such that <code>f x</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-drop_while" class="anchored"><a href="#val-drop_while" class="anchor"></a><code><span><span class="keyword">val</span> drop_while : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>drop_while p e</code> produces a new enumeration in which only all the first elements such that <code>f e</code> have been junked.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-span" class="anchored"><a href="#val-span" class="anchor"></a><code><span><span class="keyword">val</span> span : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> * <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>span test e</code> produces two enumerations <code>(hd, tl)</code>, such that <code>hd</code> is the same as <code>take_while test e</code> and <code>tl</code> is the same as <code>drop_while test e</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-break" class="anchored"><a href="#val-break" class="anchor"></a><code><span><span class="keyword">val</span> break : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> * <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Negated span. <code>break test e</code> is equivalent to <code>span (fun x -&gt; not (test x)) e</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-group" class="anchored"><a href="#val-group" class="anchor"></a><code><span><span class="keyword">val</span> group : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>group test e</code> divides <code>e</code> into an enumeration of enumerations, where each sub-enumeration is the longest continuous enumeration of elements whose <code>test</code> results are the same.</p><p><code>Enum.group (x -&gt; x mod 2) [1;2;4;1] = [[1];[2;4];[1]]</code></p><p><code>Enum.group (fun x -&gt; x mod 3) [1;2;4;1] = [[1];[2];[4;1]]</code></p><p><code>Enum.group (fun s -&gt; s.[0]) [&quot;cat&quot;; &quot;canary&quot;; &quot;dog&quot;; &quot;dodo&quot;; &quot;ant&quot;; &quot;cow&quot;] = [[&quot;cat&quot;; &quot;canary&quot;];[&quot;dog&quot;;&quot;dodo&quot;];[&quot;ant&quot;];[&quot;cow&quot;]]</code></p><p>Warning: The result of this operation cannot be directly cloned safely; instead, reify to a non-lazy structure and read from that structure multiple times.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-group_by" class="anchored"><a href="#val-group_by" class="anchor"></a><code><span><span class="keyword">val</span> group_by : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>group_by eq e</code> divides <code>e</code> into an enumeration of enumerations, where each sub-enumeration is the longest continuous enumeration of elements that are equal, as judged by <code>eq</code>.</p><p>Warning: The result of this operation cannot be directly cloned safely; instead, reify to a non-lazy structure and read from that structure multiple times.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-clump" class="anchored"><a href="#val-clump" class="anchor"></a><code><span><span class="keyword">val</span> clump : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>clump size add get e</code> runs <code>add</code> on <code>size</code> (or less at the end) elements of <code>e</code> and then runs <code>get</code> to produce value for the result enumeration. Useful to convert a char enum into string enum.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-cartesian_product" class="anchored"><a href="#val-cartesian_product" class="anchor"></a><code><span><span class="keyword">val</span> cartesian_product : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>cartesian_product e1 e2</code> computes the cartesian product of <code>e1</code> and <code>e2</code>. Pairs are enumerated in a non-specified order, but in fair enough an order so that it works on infinite enums (i.e. even then, any pair is eventually returned)</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.2.0</li></ul></div></div><h6 id="lazy-constructors"><a href="#lazy-constructors" class="anchor"></a>Lazy constructors</h6><p>These functions are lazy which means that they will create a new modified enumeration without actually enumerating any element until they are asked to do so by the programmer (using one of the functions above).</p><p>When the resulting enumerations of these functions are consumed, the underlying enumerations they were created from are also consumed.</p><div class="odoc-spec"><div class="spec value" id="val-map" class="anchored"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>map f e</code> returns an enumeration over <code>(f a0, f a1, ...)</code> where <code>a0,a1...</code> are the elements of <code>e</code>. Lazy.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mapi" class="anchored"><a href="#val-mapi" class="anchor"></a><code><span><span class="keyword">val</span> mapi : <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>mapi</code> is similar to <code>map</code> except that <code>f</code> is passed one extra argument which is the index of the element in the enumeration, starting from 0 : mapi f e returns an enumeration over <code>(f 0 a0, f 1 a1, ...)</code> where <code>a0,a1...</code> are the elements of <code>e</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-filter" class="anchored"><a href="#val-filter" class="anchor"></a><code><span><span class="keyword">val</span> filter : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>filter f e</code> returns an enumeration over all elements <code>x</code> of <code>e</code> such as <code>f x</code> returns <code>true</code>. Lazy.</p><p><b>Note</b> filter is lazy in that it returns a lazy enumeration, but each element in the result is eagerly searched in the input enumeration. Therefore, the access to a given element in the result will diverge if it is preceded, in the input enumeration, by infinitely many false elements (elements on which the predicate <code>p</code> returns <code>false</code>).</p><p>Other functions that may drop an unbound number of elements (<code>filter_map</code>, <code>take_while</code>, etc.) have the same behavior.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-filter_map" class="anchored"><a href="#val-filter_map" class="anchor"></a><code><span><span class="keyword">val</span> filter_map : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>filter_map f e</code> returns an enumeration over all elements <code>x</code> such as <code>f y</code> returns <code>Some x</code> , where <code>y</code> is an element of <code>e</code>.</p><p><code>filter_map</code> works on infinite enumerations; see <code>filter</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-append" class="anchored"><a href="#val-append" class="anchor"></a><code><span><span class="keyword">val</span> append : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>append e1 e2</code> returns an enumeration that will enumerate over all elements of <code>e1</code> followed by all elements of <code>e2</code>. Lazy.</p><p><b>Note</b> The behavior of appending <code>e</code> to itself or to something derived from <code>e</code> is not specified. In particular, cloning <code>append e e</code> may destroy any sharing between the first and the second argument.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-prefix_action" class="anchored"><a href="#val-prefix_action" class="anchor"></a><code><span><span class="keyword">val</span> prefix_action : <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>prefix_action f e</code> will behave as <code>e</code> but guarantees that <code>f ()</code> will be invoked exactly once before the current first element of <code>e</code> is read.</p><p>If <code>prefix_action f e</code> is cloned, <code>f</code> is invoked only once, during the cloning. If <code>prefix_action f e</code> is counted, <code>f</code> is invoked only once, during the counting.</p><p>May be used for signalling that reading starts or for performing delayed evaluations.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-suffix_action" class="anchored"><a href="#val-suffix_action" class="anchor"></a><code><span><span class="keyword">val</span> suffix_action : <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>suffix_action f e</code> will behave as <code>e</code> but guarantees that <code>f ()</code> will be invoked after the contents of <code>e</code> are exhausted.</p><p>If <code>suffix_action f e</code> is cloned, <code>f</code> is invoked only once, when the original enumeration is exhausted. If <code>suffix_action f e</code> is counted, <code>f</code> is only invoked if the act of counting requires a call to <code>force</code>.</p><p>May be used for signalling that reading stopped or for performing delayed evaluations.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-concat" class="anchored"><a href="#val-concat" class="anchor"></a><code><span><span class="keyword">val</span> concat : <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>concat e</code> returns an enumeration over all elements of all enumerations of <code>e</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-flatten" class="anchored"><a href="#val-flatten" class="anchor"></a><code><span><span class="keyword">val</span> flatten : <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Synonym of <a href="#val-concat"><code>concat</code></a></p></div></div><div class="odoc-spec"><div class="spec value" id="val-concat_map" class="anchored"><a href="#val-concat_map" class="anchor"></a><code><span><span class="keyword">val</span> concat_map : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Synonym of <a href="Monad/index.html#val-bind"><code>Monad.bind</code></a>, with flipped arguments. <code>concat_map f e</code> is the same as <code>concat (map f e)</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.2.0</li></ul></div></div><h6 id="constructors"><a href="#constructors" class="anchor"></a>Constructors</h6><p>In this section the word <i>shall</i> denotes a semantic requirement. The correct operation of the functions in this interface are conditional on the client meeting these requirements.</p><div class="odoc-spec"><div class="spec exception" id="exception-No_more_elements" class="anchored"><a href="#exception-No_more_elements" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">No_more_elements</span></span></code></div><div class="spec-doc"><p>This exception <i>shall</i> be raised by the <code>next</code> function of <code>make</code> or <code>from</code> when no more elements can be enumerated, it <i>shall not</i> be raised by any function which is an argument to any other function specified in the interface.</p></div></div><div class="odoc-spec"><div class="spec exception" id="exception-Infinite_enum" class="anchored"><a href="#exception-Infinite_enum" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Infinite_enum</span></span></code></div><div class="spec-doc"><p>As a convenience for debugging, this exception <i>may</i> be raised by the <code>count</code> function of <code>make</code> when attempting to count an infinite enum.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-empty" class="anchored"><a href="#val-empty" class="anchor"></a><code><span><span class="keyword">val</span> empty : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>The empty enumeration : contains no element</p></div></div><div class="odoc-spec"><div class="spec value" id="val-make" class="anchored"><a href="#val-make" class="anchor"></a><code><span><span class="keyword">val</span> make : <span>next:<span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>count:<span>(<span>unit <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span>clone:<span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>This function creates a fully defined enumeration.</p><ul><li>the <code>next</code> function <i>shall</i> return the next element of the enumeration or raise <code>No_more_elements</code> if the underlying data structure does not have any more elements to enumerate.</li><li>the <code>count</code> function <i>shall</i> return the actual number of remaining elements in the enumeration or <i>may</i> raise <code>Infinite_enum</code> if it is known that the enumeration is infinite.</li><li>the <code>clone</code> function <i>shall</i> create a clone of the enumeration such as operations on the original enumeration will not affect the clone.</li></ul><p>For some samples on how to correctly use <code>make</code>, you can have a look at implementation of <code>BatList.enum</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-from" class="anchored"><a href="#val-from" class="anchor"></a><code><span><span class="keyword">val</span> from : <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>from next</code> creates an enumeration from the <code>next</code> function. <code>next</code> <i>shall</i> return the next element of the enumeration or raise <code>No_more_elements</code> when no more elements can be enumerated. Since the enumeration definition is incomplete, a call to <code>count</code> will result in a call to <code>force</code> that will enumerate all elements in order to return a correct value.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-from_while" class="anchored"><a href="#val-from_while" class="anchor"></a><code><span><span class="keyword">val</span> from_while : <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>from_while next</code> creates an enumeration from the <code>next</code> function. <code>next</code> <i>shall</i> return <code>Some x</code> where <code>x</code> is the next element of the enumeration or <code>None</code> when no more elements can be enumerated. Since the enumeration definition is incomplete, a call to <code>clone</code> or <code>count</code> will result in a call to <code>force</code> that will enumerate all elements in order to return a correct value.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-from_loop" class="anchored"><a href="#val-from_loop" class="anchor"></a><code><span><span class="keyword">val</span> from_loop : <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>from_loop data next</code> creates a (possibly infinite) enumeration from the successive results of applying <code>next</code> to <code>data</code>, then to the result, etc. The list ends whenever the function raises <a href="#exception-No_more_elements"><code>BatEnum.No_more_elements</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-seq" class="anchored"><a href="#val-seq" class="anchor"></a><code><span><span class="keyword">val</span> seq : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>seq init step cond</code> creates a sequence of data, which starts from <code>init</code>, extends by <code>step</code>, until the condition <code>cond</code> fails. E.g. <code>seq 1 ((+) 1) ((&gt;) 100)</code> returns <code>1, 2, ... 99</code>. If <code>cond
    init</code> is false, the result is empty.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unfold" class="anchored"><a href="#val-unfold" class="anchor"></a><code><span><span class="keyword">val</span> unfold : <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>As <code>from_loop</code>, except uses option type to signal the end of the enumeration.</p><p><code>unfold data next</code> creates a (possibly infinite) enumeration from the successive results of applying <code>next</code> to <code>data</code>, then to the result, etc. The enumeration ends whenever the function returns <code>None</code></p><p>Example: <code>Enum.unfold n (fun x -&gt; if x = 1 then None else Some
   (x, if x land 1 = 1 then 3 * x + 1 else x / 2))</code> returns the hailstone sequence starting at <code>n</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-init" class="anchored"><a href="#val-init" class="anchor"></a><code><span><span class="keyword">val</span> init : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>init n f</code> creates a new enumeration over elements <code>f 0, f 1, ..., f (n-1)</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-singleton" class="anchored"><a href="#val-singleton" class="anchor"></a><code><span><span class="keyword">val</span> singleton : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Create an enumeration consisting of exactly one element.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-repeat" class="anchored"><a href="#val-repeat" class="anchor"></a><code><span><span class="keyword">val</span> repeat : <span>?times:int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>repeat ~times:n x</code> creates a enum sequence filled with <code>n</code> times of <code>x</code>. It return infinite enum when <code>~times</code> is absent. It returns empty enum when <code>times &lt;= 0</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-cycle" class="anchored"><a href="#val-cycle" class="anchor"></a><code><span><span class="keyword">val</span> cycle : <span>?times:int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>cycle</code> is similar to <code>repeat</code>, except that the content to fill is a subenum rather than a single element. Note that <code>times</code> represents the times of repeating not the length of enum. When <code>~times</code> is absent the result is an infinite enum.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-delay" class="anchored"><a href="#val-delay" class="anchor"></a><code><span><span class="keyword">val</span> delay : <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>delay (fun () -&gt; e)</code> produces an enumeration which behaves as <code>e</code>. The enumeration itself will only be computed when consumed.</p><p>A typical use of this function is to explore lazily non-trivial data structures, as follows:</p><p><code>type 'a tree = Leaf
                  | Node of 'a * 'a tree * 'a tree
    let enum_tree =
    let rec aux = function
    | Leaf           -&gt; BatEnum.empty ()
    | Node (n, l, r) -&gt; BatEnum.append (BatEnum.singleton n)
    (BatEnum.append (delay (fun () -&gt; aux l))
    (delay (fun () -&gt; aux r)))
    </code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_object" class="anchored"><a href="#val-to_object" class="anchor"></a><code><span><span class="keyword">val</span> to_object : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>&lt; next : <span class="type-var">'a</span>; count : int; clone : <span class="type-var">'b</span>; &gt;</span> <span class="keyword">as</span> 'b</span></code></div><div class="spec-doc"><p><code>to_object e</code> returns a representation of <code>e</code> as an object.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_object" class="anchored"><a href="#val-of_object" class="anchor"></a><code><span><span class="keyword">val</span> of_object : <span><span>&lt; next : <span class="type-var">'a</span>; count : int; clone : <span class="type-var">'b</span>; &gt;</span> <span class="keyword">as</span> 'b <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>of_object e</code> returns a representation of an object as an enumeration</p></div></div><div class="odoc-spec"><div class="spec value" id="val-enum" class="anchored"><a href="#val-enum" class="anchor"></a><code><span><span class="keyword">val</span> enum : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>identity : added for consistency with the other data structures</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_enum" class="anchored"><a href="#val-of_enum" class="anchor"></a><code><span><span class="keyword">val</span> of_enum : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>identity : added for consistency with the other data structures</p></div></div><div class="odoc-spec"><div class="spec value" id="val-combination" class="anchored"><a href="#val-combination" class="anchor"></a><code><span><span class="keyword">val</span> combination : <span>?repeat:bool <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><span>int list</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>combination n k</code> returns an enumeration over combination of <code>k</code> elements between <code>n</code> distincts elements.</p><p>If <code>repeat</code> is true, the combination may contain the same elements many times.</p></div></div><h6 id="counting"><a href="#counting" class="anchor"></a>Counting</h6><div class="odoc-spec"><div class="spec value" id="val-count" class="anchored"><a href="#val-count" class="anchor"></a><code><span><span class="keyword">val</span> count : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>count e</code> returns the number of remaining elements in <code>e</code> without consuming the enumeration.</p><p>Depending of the underlying data structure that is implementing the enumeration functions, the count operation can be costly, and even sometimes can cause a call to <code>force</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fast_count" class="anchored"><a href="#val-fast_count" class="anchor"></a><code><span><span class="keyword">val</span> fast_count : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>For users worried about the speed of <code>count</code> you can call the <code>fast_count</code> function that will give an hint about <code>count</code> implementation. Basically, if the enumeration has been created with <code>make</code> or <code>init</code> or if <code>force</code> has been called on it, then <code>fast_count</code> will return true.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-hard_count" class="anchored"><a href="#val-hard_count" class="anchor"></a><code><span><span class="keyword">val</span> hard_count : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>hard_count</code> returns the number of remaining in elements in <code>e</code>, consuming the whole enumeration somewhere along the way. This function is always at least as fast as the fastest of either <code>count</code> or a <code>fold</code> on the elements of <code>t</code>.</p><p>This function is useful when you have opened an enumeration for the sole purpose of counting its elements (e.g. the number of lines in a file).</p></div></div><h6 id="utilities"><a href="#utilities" class="anchor"></a>Utilities</h6><div class="odoc-spec"><div class="spec value" id="val-range" class="anchored"><a href="#val-range" class="anchor"></a><code><span><span class="keyword">val</span> range : <span>?until:int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>range p until:q</code> creates an enumeration of integers <code>[p, p+1, ..., q]</code>. If <code>until</code> is omitted, the enumeration is not bounded. Behaviour is not-specified once <code>max_int</code> has been reached.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-dup" class="anchored"><a href="#val-dup" class="anchor"></a><code><span><span class="keyword">val</span> dup : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> * <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>dup stream</code> returns a pair of streams which are identical to <code>stream</code>. Note that stream is a destructive data structure, the point of <code>dup</code> is to return two streams can be used independently.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-combine" class="anchored"><a href="#val-combine" class="anchor"></a><code><span><span class="keyword">val</span> combine : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>combine</code> transform two streams into a stream of pairs of corresponding elements. If one stream is shorter, excess elements of the longer stream are ignored. Curried </p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-uncombine" class="anchored"><a href="#val-uncombine" class="anchor"></a><code><span><span class="keyword">val</span> uncombine : <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> * <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>uncombine</code> is the opposite of <code>combine</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-merge" class="anchored"><a href="#val-merge" class="anchor"></a><code><span><span class="keyword">val</span> merge : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>merge test a b</code> merge the elements from <code>a</code> and <code>b</code> into a single enumeration. At each step, <code>test</code> is applied to the first element <code>xa</code> of <code>a</code> and the first element <code>xb</code> of <code>b</code> to determine which should get first into resulting enumeration. If <code>test xa xb</code> returns <code>true</code>, <code>xa</code> (the first element of <code>a</code>) is used, otherwise <code>xb</code> is used. If <code>a</code> or <code>b</code> runs out of elements, the process will append all elements of the other enumeration to the result.</p><p>For example, if <code>a</code> and <code>b</code> are enumerations of integers sorted in increasing order, then <code>merge (&lt;) a b</code> will also be sorted.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-interleave" class="anchored"><a href="#val-interleave" class="anchor"></a><code><span><span class="keyword">val</span> interleave : <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> array</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>interleave enums</code> creates a new enumeration from an array of enumerations. The new enumeration first yields the first elements of the enumerations in the supplied order, then second elements, etc. Thus, a sequence <code> [| [x11 ; x12 ; ...] ; [x21 ; x22, ...] , ... [xN1 ; xN2 ; ...] |] </code> becomes <code>[ x11 ; x12 ; ... ; xN1 ; x21 ; x22 ; ... ; xN2 ; x31 ; ... ]</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-uniq" class="anchored"><a href="#val-uniq" class="anchor"></a><code><span><span class="keyword">val</span> uniq : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>uniq e</code> returns a duplicate of <code>e</code> with repeated values omitted (similar to unix's <code>uniq</code> command). It uses structural equality to compare consecutive elements.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-uniqq" class="anchored"><a href="#val-uniqq" class="anchor"></a><code><span><span class="keyword">val</span> uniqq : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>uniqq e</code> behaves as <code>uniq e</code> except it uses physical equality to compare consecutive elements.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.4.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-uniq_by" class="anchored"><a href="#val-uniq_by" class="anchor"></a><code><span><span class="keyword">val</span> uniq_by : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>uniq_by cmp e</code> behaves as <code>uniq e</code> except it allows to specify a comparison function.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.4.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-switch" class="anchored"><a href="#val-switch" class="anchor"></a><code><span><span class="keyword">val</span> switch : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> * <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>switch test enum</code> splits <code>enum</code> into two enums, where the first enum have all the elements satisfying <code>test</code>, the second enum is opposite. The order of elements in the source enum is preserved.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-partition" class="anchored"><a href="#val-partition" class="anchor"></a><code><span><span class="keyword">val</span> partition : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> * <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>as <code>switch</code></p><p>@added v1.4.0</p></div></div><div class="odoc-spec"><div class="spec value" id="val-arg_min" class="anchored"><a href="#val-arg_min" class="anchor"></a><code><span><span class="keyword">val</span> arg_min : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-arg_max" class="anchored"><a href="#val-arg_max" class="anchor"></a><code><span><span class="keyword">val</span> arg_max : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>arg_min f xs</code> returns the <code>x</code> in <code>xs</code> for which <code>f x</code> is minimum. Similarly for <code>arg_max</code>, except it returns the maximum. If multiple values reach the maximum, one of them is returned. (currently the first, but this is not guaranteed)</p><p>Example: <code>-5 -- 5 |&gt; arg_min (fun x -&gt; x * x + 6 * x - 5) = -3</code> Example: <code>List.enum [&quot;cat&quot;; &quot;canary&quot;; &quot;dog&quot;; &quot;dodo&quot;; &quot;ant&quot;; &quot;cow&quot;] |&gt; arg_max String.length = &quot;canary&quot;</code></p><p>@added v1.4.0</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if the input enum is empty</p></li></ul></div></div><h6 id="trampolining"><a href="#trampolining" class="anchor"></a>Trampolining</h6><div class="odoc-spec"><div class="spec value" id="val-while_do" class="anchored"><a href="#val-while_do" class="anchor"></a><code><span><span class="keyword">val</span> while_do : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>while_do cont f e</code> is a loop on <code>e</code> using <code>f</code> as body and <code>cont</code> as condition for continuing.</p><p>If <code>e</code> contains elements <code>x0</code>, <code>x1</code>, <code>x2</code>..., then if <code>cont x0</code> is <code>false</code>, <code>x0</code> is returned as such and treatment stops. On the other hand, if <code>cont x0</code> is <code>true</code>, <code>f x0</code> is returned and the loop proceeds with <code>x1</code>...</p><p>Note that f is used as halting condition <i>after</i> the corresponding element has been added to the result stream.</p></div></div><h6 id="infix-operators"><a href="#infix-operators" class="anchor"></a>Infix operators</h6><p>Infix versions of some functions</p><p>This module groups together all infix operators so that you can open it without opening the whole batEnum module.</p><div class="odoc-spec"><div class="spec module" id="module-Infix" class="anchored"><a href="#module-Infix" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Infix/index.html">Infix</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-(--)" class="anchored"><a href="#val-(--)" class="anchor"></a><code><span><span class="keyword">val</span> (--) : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-(--^)" class="anchored"><a href="#val-(--^)" class="anchor"></a><code><span><span class="keyword">val</span> (--^) : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-(--.)" class="anchored"><a href="#val-(--.)" class="anchor"></a><code><span><span class="keyword">val</span> (--.) : <span><span>(float * float)</span> <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <span>float <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-(---)" class="anchored"><a href="#val-(---)" class="anchor"></a><code><span><span class="keyword">val</span> (---) : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-(--~)" class="anchored"><a href="#val-(--~)" class="anchor"></a><code><span><span class="keyword">val</span> (--~) : <span>char <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> <span>char <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-(//)" class="anchored"><a href="#val-(//)" class="anchor"></a><code><span><span class="keyword">val</span> (//) : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-(/@)" class="anchored"><a href="#val-(/@)" class="anchor"></a><code><span><span class="keyword">val</span> (/@) : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-(@/)" class="anchored"><a href="#val-(@/)" class="anchor"></a><code><span><span class="keyword">val</span> (@/) : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-(//@)" class="anchored"><a href="#val-(//@)" class="anchor"></a><code><span><span class="keyword">val</span> (//@) : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-(@//)" class="anchored"><a href="#val-(@//)" class="anchor"></a><code><span><span class="keyword">val</span> (@//) : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div></div><h6 id="monad-related-modules"><a href="#monad-related-modules" class="anchor"></a>Monad related modules</h6><div class="odoc-spec"><div class="spec module" id="module-WithMonad" class="anchored"><a href="#module-WithMonad" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="WithMonad/index.html">WithMonad</a></span><span> (<a href="WithMonad/argument-1-Mon/index.html">Mon</a> : <a href="../BatInterfaces/module-type-Monad/index.html">BatInterfaces.Monad</a>) : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Monadic operations on Enumerations containing monadic elements</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Monad" class="anchored"><a href="#module-Monad" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Monad/index.html">Monad</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The BatEnum Monad</p></div></div><h6 id="boilerplate-code"><a href="#boilerplate-code" class="anchor"></a>Boilerplate code</h6><div class="odoc-spec"><div class="spec value" id="val-print" class="anchored"><a href="#val-print" class="anchor"></a><code><span><span class="keyword">val</span> print : <span>?first:string <span class="arrow">&#45;&gt;</span></span> <span>?last:string <span class="arrow">&#45;&gt;</span></span> <span>?sep:string <span class="arrow">&#45;&gt;</span></span>
<span><span>(<span><span><span class="type-var">'a</span> <a href="../BatInnerIO/index.html#type-output">BatInnerIO.output</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="../BatInnerIO/index.html#type-output">BatInnerIO.output</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Print and consume the contents of an enumeration.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-print_at_most" class="anchored"><a href="#val-print_at_most" class="anchor"></a><code><span><span class="keyword">val</span> print_at_most : <span>?first:string <span class="arrow">&#45;&gt;</span></span> <span>?last:string <span class="arrow">&#45;&gt;</span></span> <span>?sep:string <span class="arrow">&#45;&gt;</span></span> <span>limit:int <span class="arrow">&#45;&gt;</span></span>
<span><span>(<span><span><span class="type-var">'a</span> <a href="../BatInnerIO/index.html#type-output">BatInnerIO.output</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="../BatInnerIO/index.html#type-output">BatInnerIO.output</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>print_at_most pp limit out enum</code> consumes <code>enum</code> to print its elements into <code>out</code> (using <code>pp</code> to print individual elements). At most <code>limit</code> arguments are printed, if more elements are available an ellipsis &quot;...&quot; is added.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if the limit is &lt;= 0.</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.2.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-compare" class="anchored"><a href="#val-compare" class="anchor"></a><code><span><span class="keyword">val</span> compare : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>compare cmp a b</code> compares enumerations <code>a</code> and <code>b</code> by lexicographical order using comparison <code>cmp</code>.</p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>0 if <code>a</code> and <code>b</code> are equal wrt <code>cmp</code></p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>-1 if <code>a</code> is empty and <code>b</code> is not</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>1 if <code>b</code> is empty and <code>a</code> is not</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p><code>cmp x y</code>, where <code>x</code> is the first element of <code>a</code> and <code>y</code> is the first element of <code>b</code>, if <code>cmp x y &lt;&gt; 0</code></p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p><code>compare cmp a' b'</code>, where <code>a'</code> and <code>b'</code> are respectively equal to <code>a</code> and <code>b</code> without their first element, if both <code>a</code> and <code>b</code> are non-empty and <code>cmp x y = 0</code>, where <code>x</code> is the first element of <code>a</code> and <code>y</code> is the first element of <code>b</code></p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-ord" class="anchored"><a href="#val-ord" class="anchor"></a><code><span><span class="keyword">val</span> ord : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <a href="../BatOrd/index.html#type-order">BatOrd.order</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="../BatOrd/index.html#type-order">BatOrd.order</a></span></code></div><div class="spec-doc"><p>Same as <code>compare</code> but returning a <a href="../BatOrd/index.html#type-order"><code>BatOrd.order</code></a> instead of an integer.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-equal" class="anchored"><a href="#val-equal" class="anchor"></a><code><span><span class="keyword">val</span> equal : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>equal eq a b</code> returns <code>true</code> when <code>a</code> and <code>b</code> contain the same sequence of elements.</p></div></div><h6 id="override-modules"><a href="#override-modules" class="anchor"></a>Override modules</h6><p>The following modules replace functions defined in <a href="#"><code>BatEnum</code></a> with functions behaving slightly differently but having the same name. This is by design: the functions meant to override the corresponding functions of <a href="#"><code>BatEnum</code></a>.</p><div class="odoc-spec"><div class="spec module" id="module-Exceptionless" class="anchored"><a href="#module-Exceptionless" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Exceptionless/index.html">Exceptionless</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Operations on <a href="#"><code>BatEnum</code></a> without exceptions.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Labels" class="anchored"><a href="#module-Labels" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Labels/index.html">Labels</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Operations on <a href="#"><code>BatEnum</code></a> with labels.</p></div></div></div></body></html>