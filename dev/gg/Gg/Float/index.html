<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Float (gg.Gg.Float)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">gg</a> &#x00BB; <a href="../index.html">Gg</a> &#x00BB; Float</nav><h1>Module <code>Gg.Float</code></h1><p>Floating point number utilities.</p><p>This module defines a few useful <a href="index.html#constants"><span>constants</span></a>, <a href="index.html#functions"><span>functions</span></a>, <a href="index.html#preds"><span>predicates and comparisons</span></a> on floating point numbers. The <a href="index.html#printers"><span>printers</span></a> output a lossless textual representation of floats.</p><p><a href="index.html#floatrecall"><span>Quick recall</span></a> on OCaml's floating point representation.</p><nav class="toc"><ul><li><a href="#constants">Constants</a></li><li><a href="#functions">Functions</a></li><li><a href="#preds">Predicates and comparisons</a></li><li><a href="#printers">Printers</a></li><li><a href="#floatrecall">Quick recall on OCaml's <code>float</code>s</a></li></ul></nav></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code><code> = float</code></dt><dd><p>The type for floating point numbers.</p></dd></dl><section><header><h2 id="constants"><a href="#constants" class="anchor"></a>Constants</h2></header><dl><dt class="spec value" id="val-e"><a href="#val-e" class="anchor"></a><code><span class="keyword">val</span> e : float</code></dt><dd><p>The constant <a href="http://mathworld.wolfram.com/e.html">e</a>.</p></dd></dl><dl><dt class="spec value" id="val-pi"><a href="#val-pi" class="anchor"></a><code><span class="keyword">val</span> pi : float</code></dt><dd><p>The constant <a href="http://mathworld.wolfram.com/Pi.html">pi</a>.</p></dd></dl><dl><dt class="spec value" id="val-two_pi"><a href="#val-two_pi" class="anchor"></a><code><span class="keyword">val</span> two_pi : float</code></dt><dd><p><code>2 *. pi</code></p></dd></dl><dl><dt class="spec value" id="val-pi_div_2"><a href="#val-pi_div_2" class="anchor"></a><code><span class="keyword">val</span> pi_div_2 : float</code></dt><dd><p><code>pi /. 2</code>.</p></dd></dl><dl><dt class="spec value" id="val-pi_div_4"><a href="#val-pi_div_4" class="anchor"></a><code><span class="keyword">val</span> pi_div_4 : float</code></dt><dd><p><code>pi /. 4</code>.</p></dd></dl><dl><dt class="spec value" id="val-inv_pi"><a href="#val-inv_pi" class="anchor"></a><code><span class="keyword">val</span> inv_pi : float</code></dt><dd><p><code>1 /. pi</code>.</p></dd></dl><dl><dt class="spec value" id="val-max_sub_float"><a href="#val-max_sub_float" class="anchor"></a><code><span class="keyword">val</span> max_sub_float : float</code></dt><dd><p>The greatest positive subnormal floating point number.</p></dd></dl><dl><dt class="spec value" id="val-min_sub_float"><a href="#val-min_sub_float" class="anchor"></a><code><span class="keyword">val</span> min_sub_float : float</code></dt><dd><p>The smallest positive subnormal floating point number.</p></dd></dl><dl><dt class="spec value" id="val-max_frac_float"><a href="#val-max_frac_float" class="anchor"></a><code><span class="keyword">val</span> max_frac_float : float</code></dt><dd><p>The greatest positive floating point number with a fractional part (the <code>float</code> before 2<sup>52</sup>). Any number outside [<code>-max_frac_float;max_frac_float</code>] is an integer.</p></dd></dl><dl><dt class="spec value" id="val-max_int_arith"><a href="#val-max_int_arith" class="anchor"></a><code><span class="keyword">val</span> max_int_arith : float</code></dt><dd><p>The greatest positive floating point number (2<sup>53</sup>) such that any <em>integer</em> in the range [<code>-max_int_arith;max_int_arith</code>] is represented exactly. Integer arithmetic can be performed exactly in this interval.</p></dd></dl></section><section><header><h2 id="functions"><a href="#functions" class="anchor"></a>Functions</h2><p><b>Note.</b> If applicable, a function taking NaNs returns a NaN unless otherwise specified.</p></header><dl><dt class="spec value" id="val-deg_of_rad"><a href="#val-deg_of_rad" class="anchor"></a><code><span class="keyword">val</span> deg_of_rad : float <span>&#45;&gt;</span> float</code></dt><dd><p><code>deg_of_rad r</code> is <code>r</code> <a href="http://mathworld.wolfram.com/Radian.html">radians</a> in <a href="http://mathworld.wolfram.com/Degree.html">degrees</a>.</p></dd></dl><dl><dt class="spec value" id="val-rad_of_deg"><a href="#val-rad_of_deg" class="anchor"></a><code><span class="keyword">val</span> rad_of_deg : float <span>&#45;&gt;</span> float</code></dt><dd><p><code>rad_of_deg d</code> is <code>d</code> <a href="http://mathworld.wolfram.com/Degree.html">degrees</a> in <a href="http://mathworld.wolfram.com/Radian.html">radians</a>.</p></dd></dl><dl><dt class="spec value" id="val-wrap_angle"><a href="#val-wrap_angle" class="anchor"></a><code><span class="keyword">val</span> wrap_angle : float <span>&#45;&gt;</span> float</code></dt><dd><p><code>wrap_angle r</code> is the angle <code>r</code> in the interval [<code>-pi;pi</code>[.</p></dd></dl><dl><dt class="spec value" id="val-random"><a href="#val-random" class="anchor"></a><code><span class="keyword">val</span> random : ?&#8288;min:float <span>&#45;&gt;</span> len:float <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> float</code></dt><dd><p><code>random min len ()</code> is a random float in the interval [<code>min;min+len</code>] (<code>min</code> defaults to 0.). Uses the standard library's default <code>Random</code> state for the generation.</p><p><b>Warning.</b> The float generated by a given state may change in future versions of the library.</p></dd></dl><dl><dt class="spec value" id="val-srandom"><a href="#val-srandom" class="anchor"></a><code><span class="keyword">val</span> srandom : <a href="../../../ocaml/Stdlib__random/State/index.html#type-t">Stdlib.Random.State.t</a> <span>&#45;&gt;</span> ?&#8288;min:float <span>&#45;&gt;</span> len:float <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> float</code></dt><dd><p><code>srandom state min len ()</code> is like <a href="index.html#val-random"><code>random</code></a> but uses <code>state</code> for the generation.</p><p><b>Warning.</b> The float generated by a given <code>state</code> may change in future versions of the library.</p></dd></dl><dl><dt class="spec value" id="val-mix"><a href="#val-mix" class="anchor"></a><code><span class="keyword">val</span> mix : float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float</code></dt><dd><p><code>mix x y t</code> is the linear interpolation <code>x +. t *. (y -. x)</code>.</p></dd></dl><dl><dt class="spec value" id="val-step"><a href="#val-step" class="anchor"></a><code><span class="keyword">val</span> step : float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float</code></dt><dd><p><code>step edge x</code> is <code>0.</code> if <code>x &lt; edge</code> and <code>1.</code> otherwise. The result is undefined on NaNs.</p></dd></dl><dl><dt class="spec value" id="val-smooth_step"><a href="#val-smooth_step" class="anchor"></a><code><span class="keyword">val</span> smooth_step : float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float</code></dt><dd><p><code>smooth_step e0 e1 x</code> is <code>0.</code> if <code>x &lt;= e0</code>, <code>1.</code> if <code>x &gt;= e1</code> and cubic hermite interpolation between 0. and 1. otherwise. The result is undefined on NaNs.</p></dd></dl><dl><dt class="spec value" id="val-fmax"><a href="#val-fmax" class="anchor"></a><code><span class="keyword">val</span> fmax : float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float</code></dt><dd><p><code>fmax x y</code> is <code>y</code> if <code>x &lt; y</code> and <code>x</code> otherwise. If <code>x</code> or <code>y</code> is NaN returns the other argument. If both are NaNs returns NaN.</p></dd></dl><dl><dt class="spec value" id="val-fmin"><a href="#val-fmin" class="anchor"></a><code><span class="keyword">val</span> fmin : float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float</code></dt><dd><p><code>fmin x y</code> is <code>x</code> if <code>x &lt; y</code> and <code>y</code> otherwise. If <code>x</code> or <code>y</code> is NaN returns the other argument. If both are NaNs returns NaN.</p></dd></dl><dl><dt class="spec value" id="val-clamp"><a href="#val-clamp" class="anchor"></a><code><span class="keyword">val</span> clamp : min:float <span>&#45;&gt;</span> max:float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float</code></dt><dd><p><code>clamp min max x</code> is <code>min</code> if <code>x &lt; min</code>, <code>max</code> if <code>x &gt; max</code> and <code>x</code> otherwise. The result is undefined on NaNs and if <code>min &gt;
      max</code>.</p></dd></dl><dl><dt class="spec value" id="val-remap"><a href="#val-remap" class="anchor"></a><code><span class="keyword">val</span> remap : x0:float <span>&#45;&gt;</span> x1:float <span>&#45;&gt;</span> y0:float <span>&#45;&gt;</span> y1:float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float</code></dt><dd><p><code>remap x0 x1 y0 y1 v</code> applies to <code>v</code> the <a href="http://mathworld.wolfram.com/AffineTransformation.html">affine transform</a> that maps <code>x0</code> to <code>y0</code> and <code>x1</code> to <code>y1</code>. If the transform is undefined (<code>x0 = x1</code> and <code>y0 &lt;&gt; y1</code>) the function returns <code>y0</code> for any <code>v</code>.</p></dd></dl><dl><dt class="spec value" id="val-round"><a href="#val-round" class="anchor"></a><code><span class="keyword">val</span> round : float <span>&#45;&gt;</span> float</code></dt><dd><p><code>round x</code> is the integer nearest to <code>x</code>. Ties are rounded towards positive infinity. If <code>x</code> is an infinity, returns <code>x</code>.</p><p><b>Note.</b> If the absolute magnitude of <code>x</code> is an integer strictly greater than <a href="index.html#val-max_frac_float"><code>max_frac_float</code></a>, <code>round x = x</code> may be <code>false</code>.</p></dd></dl><dl><dt class="spec value" id="val-int_of_round"><a href="#val-int_of_round" class="anchor"></a><code><span class="keyword">val</span> int_of_round : float <span>&#45;&gt;</span> int</code></dt><dd><p><code>int_of_round x</code> is <code>truncate (round v)</code>. The result is undefined on NaNs and infinities.</p></dd></dl><dl><dt class="spec value" id="val-round_dfrac"><a href="#val-round_dfrac" class="anchor"></a><code><span class="keyword">val</span> round_dfrac : int <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float</code></dt><dd><p><code>round_dfrac d x</code> rounds <code>x</code> to the <code>d</code>th <em>decimal</em> fractional digit. Ties are rounded towards positive infinity. If <code>x</code> is an infinity, returns <code>x</code>. The result is only defined for <code>0 &lt;= d &lt;=
      16</code>.</p></dd></dl><dl><dt class="spec value" id="val-round_dsig"><a href="#val-round_dsig" class="anchor"></a><code><span class="keyword">val</span> round_dsig : int <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float</code></dt><dd><p><code>round_dsig d x</code> rounds the normalized <em>decimal</em> significand of <code>x</code> to the <code>d</code>th decimal fractional digit. Ties are rounded towards positive infinity. The result is NaN on infinities. The result only defined for <code>0 &lt;= d &lt;= 16</code>.</p><p><b>Warning.</b> The current implementation overflows on large <code>x</code> and <code>d</code>.</p></dd></dl><dl><dt class="spec value" id="val-round_zero"><a href="#val-round_zero" class="anchor"></a><code><span class="keyword">val</span> round_zero : eps:float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float</code></dt><dd><p><code>round_zero eps x</code> is <code>0.</code> if <code>abs_float x &lt; eps</code> and <code>x</code> otherwise. The result is undefined if <code>eps</code> is NaN.</p></dd></dl><dl><dt class="spec value" id="val-chop"><a href="#val-chop" class="anchor"></a><code><span class="keyword">val</span> chop : eps:float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float</code></dt><dd><p><code>chop eps x</code> is <code>round x</code> if <code>abs_float (x -. round x) &lt; eps</code> and <code>x</code> otherwise. The result is undefined if <code>eps</code> is NaN.</p></dd></dl><dl><dt class="spec value" id="val-sign"><a href="#val-sign" class="anchor"></a><code><span class="keyword">val</span> sign : float <span>&#45;&gt;</span> float</code></dt><dd><p><code>sign x</code> is <code>1.</code> if <code>x &gt; 0.</code>, <code>0.</code> if <code>x = 0.</code>, <code>-1.</code> if <code>x &lt; 0.</code></p></dd></dl><dl><dt class="spec value" id="val-sign_bit"><a href="#val-sign_bit" class="anchor"></a><code><span class="keyword">val</span> sign_bit : float <span>&#45;&gt;</span> bool</code></dt><dd><p><code>sign_bit x</code> is <code>true</code> iff the sign bit is set in <code>x</code>.</p></dd></dl><dl><dt class="spec value" id="val-succ"><a href="#val-succ" class="anchor"></a><code><span class="keyword">val</span> succ : float <span>&#45;&gt;</span> float</code></dt><dd><p><code>succ x</code> is the floating point value just after <code>x</code> towards positive infinity. Returns in particular :</p><ul><li>NaN on NaNs.</li><li><code>infinity</code> on <code>infinity</code>.</li><li><code>-max_float</code> on <code>neg_infinity</code>.</li><li><code>min_sub_float</code> on <code>0.</code> <b>or</b> <code>-0.</code>.</li></ul></dd></dl><dl><dt class="spec value" id="val-pred"><a href="#val-pred" class="anchor"></a><code><span class="keyword">val</span> pred : float <span>&#45;&gt;</span> float</code></dt><dd><p><code>pred x</code> is <code>-. succ (-.x)</code>, i.e. the floating point value before <code>x</code> towards negative infinity.</p></dd></dl><dl><dt class="spec value" id="val-nan"><a href="#val-nan" class="anchor"></a><code><span class="keyword">val</span> nan : int <span>&#45;&gt;</span> float</code></dt><dd><p><code>nan payload</code> is a NaN whose 51 lower significand bits are defined by the 51 lower (or less, as <code>int</code> allows) bits of <code>payload</code>.</p></dd></dl><dl><dt class="spec value" id="val-nan_payload"><a href="#val-nan_payload" class="anchor"></a><code><span class="keyword">val</span> nan_payload : float <span>&#45;&gt;</span> int</code></dt><dd><p><code>nan_payload x</code> is the 51 lower significand bits (or less, as <code>int</code> allows) of the NaN <code>x</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>x</code> is not a NaN.</p></dd></dl></dd></dl></section><section><header><h2 id="preds"><a href="#preds" class="anchor"></a>Predicates and comparisons</h2></header><dl><dt class="spec value" id="val-is_zero"><a href="#val-is_zero" class="anchor"></a><code><span class="keyword">val</span> is_zero : eps:float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_zero eps x</code> is <code>true</code> if <code>abs_float x &lt; eps</code> and <code>false</code> otherwise. The result is undefined if <code>eps</code> is NaN.</p></dd></dl><dl><dt class="spec value" id="val-is_nan"><a href="#val-is_nan" class="anchor"></a><code><span class="keyword">val</span> is_nan : float <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_nan x</code> is <code>true</code> iff <code>x</code> is a NaN.</p></dd></dl><dl><dt class="spec value" id="val-is_inf"><a href="#val-is_inf" class="anchor"></a><code><span class="keyword">val</span> is_inf : float <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_inf x</code> is <code>true</code> iff <code>x</code> is <code>infinity</code> or <code>neg_infinity</code>.</p></dd></dl><dl><dt class="spec value" id="val-is_int"><a href="#val-is_int" class="anchor"></a><code><span class="keyword">val</span> is_int : float <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_int x</code> is <code>true</code> iff <code>x</code> is an integer.</p></dd></dl><dl><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val</span> equal : float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> bool</code></dt><dd><p><code>equal x y</code> is <code>x = y</code>.</p></dd></dl><dl><dt class="spec value" id="val-equal_tol"><a href="#val-equal_tol" class="anchor"></a><code><span class="keyword">val</span> equal_tol : eps:float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> bool</code></dt><dd><p><code>equal_tol eps x y</code> is <code>true</code> iff |<code>x - y</code>| &lt;= <code>eps</code> * max (1,|<code>x</code>|,|<code>y</code>|). On special values the function behaves like <code>compare x y = 0</code>. The condition turns into an absolute tolerance test for small magnitudes and a relative tolerance test for large magnitudes.</p></dd></dl><dl><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val</span> compare : float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> int</code></dt><dd><p><code>compare x y</code> is <code>Pervasives.compare x y</code>.</p></dd></dl><dl><dt class="spec value" id="val-compare_tol"><a href="#val-compare_tol" class="anchor"></a><code><span class="keyword">val</span> compare_tol : eps:float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> int</code></dt><dd><p><code>compare_tol ~eps x y</code> is <code>0</code> iff <code>equal_tol ~eps x y</code> is <code>true</code> and <code>Pervasives.compare x y</code> otherwise.</p></dd></dl></section><section><header><h2 id="printers"><a href="#printers" class="anchor"></a>Printers</h2></header><dl><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val</span> pp : <a href="../../../ocaml/Stdlib/Format/index.html#type-formatter">Stdlib.Format.formatter</a> <span>&#45;&gt;</span> float <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp ppf x</code> prints a lossless textual representation of <code>x</code> on <code>ppf</code>.</p><ul><li>Normals are represented by <code>&quot;[-]0x1.&lt;f&gt;p&lt;e&gt;&quot;</code> where <code>&lt;f&gt;</code> is the significand bits in hexadecimal and <code>&lt;e&gt;</code> the unbiased exponent in decimal.</li><li>Subnormals are represented by <code>&quot;[-]0x0.&lt;f&gt;p-1022&quot;</code> where <code>&lt;f&gt;</code> is the significand bits in hexadecimal.</li><li>NaNs are represented by <code>&quot;[-]nan(0x&lt;p&gt;)&quot;</code> where <code>&lt;p&gt;</code> is the payload in hexadecimal.</li><li>Infinities and zeroes are represented by <code>&quot;[-]inf&quot;</code> and <code>&quot;[-]0.&quot;</code>.</li></ul><p>This format should be compatible with recent implementations of <a href="http://www.opengroup.org/onlinepubs/000095399/functions/strtod.html">strtod</a> and hence with <code>float_of_string</code> (but negative NaNs seem to be problematic to get back).</p></dd></dl></section><section><header><h2 id="floatrecall"><a href="#floatrecall" class="anchor"></a>Quick recall on OCaml's <code>float</code>s</h2><p>An OCaml <code>float</code> is an <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE-754</a> 64 bit double precision binary floating point number. The 64 bits are laid out as follows :</p><pre>+----------------+-----------------------+-------------------------+
| sign s (1 bit) | exponent e (11 bits)  | significand t (52 bits) |
+----------------+-----------------------+-------------------------+
               63|62                   52|51                      0|</pre><p>The value represented depends on s, e and t :</p><pre>sign   exponent       significand   value represented           meaning
-------------------------------------------------------------------------
s      0              0             -1^s * 0                    zero
s      0              t &lt;&gt; 0        -1^s * 0.t * 2^-1022        subnormal
s      0 &lt; e &lt; 2047   f             -1^s * 1.t * 2^(e - 1023)   normal
s      2047           0             -1^s * infinity             infinity
s      2047           t &lt;&gt; 0        NaN                         not a number</pre><p>There are two zeros, a positive and a negative one but both are deemed equal by <code>=</code> and <code>Pervasives.compare</code>. A NaN is never equal (=) to <em>itself</em> or to another NaN however <code>Pervasives.compare</code> asserts any NaN to be equal to itself and to any other NaN.</p><p>The bit layout of a <code>float</code> can be converted to an <code>int64</code> and back using <code>Int64.bits_of_float</code> and <code>Int64.float_of_bits</code>.</p><p>The bit 51 of a NaN is used to distinguish between quiet (bit set) and signaling NaNs (bit cleared); the remaining 51 lower bits of the significand are the NaN's <em>payload</em> which can be used to store diagnostic information. These features don't seem to used in OCaml.</p><p>The significand of a floating point number is made of 53 binary digits (don't forget the implicit digit), this corresponds to log<sub>10</sub>(2<sup>53</sup>) ~ 16 <em>decimal</em> digits.</p><p>Only <code>float</code> values in the interval ]<code>-2</code><sup>52</sup>;2<sup>52</sup>[ may have a fractional part. <a href="index.html#val-max_frac_float"><code>Float.max_frac_float</code></a> is the greatest positive <code>float</code> with a fractional part.</p><p>Any integer value in the interval [<code>-2</code><sup>53</sup>;2<sup>53</sup>] can be represented exactly by a <code>float</code> value. <em>Integer</em> arithmetic performed in this interval is exact. <a href="index.html#val-max_int_arith"><code>Float.max_int_arith</code></a> is 2<sup>53</sup>.</p></header></section></div></body></html>