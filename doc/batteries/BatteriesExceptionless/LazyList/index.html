<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>LazyList (batteries.BatteriesExceptionless.LazyList)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">batteries</a> &#x00BB; <a href="../index.html">BatteriesExceptionless</a> &#x00BB; LazyList</nav><h1>Module <code>BatteriesExceptionless.LazyList</code></h1></header><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> <a href="../../Batteries/index.html#module-LazyList">Batteries.LazyList</a> <span class="keyword">with</span> <span class="keyword">module</span> <a href="../../Batteries/index.html#module-LazyList">LazyList</a>.Labels := <a href="../../BatLazyList/index.html#module-Labels">Batteries.LazyList.Labels</a></code></span></summary><aside><p>Lazy lists of elements.</p><p>Lazy lists are similar to lists, with the exception that their contents are only computed whenever requested. This makes them particularly useful in contexts where streams of data are to be handled.</p><p><b>Note</b> For this documentation, we will assume the existence of a lazy list syntax extension such that <code>[^ ^]</code> is the empty lazy list and <code>[^ a;b;c ^]</code> is the lazy list containing elements <code>a</code>, <code>b</code>, <code>c</code>.</p><p><b>Note</b> Enumerations (as featured in module <a href="../../BatEnum/index.html"><code>BatEnum</code></a>) and lazy lists (as featured in this module) are quite similar in purpose. Lazy lists are slightly higher level, insofar as no cloning is required to get them to work, which makes them slightly more useful in contexts where backtracking is common. Enumerations, on the other hand, are closer to traditional stream processing, and require more low-level marking whenever backtracking is required, but may be faster and more memory-efficient when used properly. Either choice is recommended over OCaml's built-in <a href="../Stream/index.html"><code>Stream</code></a>.</p><dl><dt>author</dt><dd>David Teller</dd></dl></aside><section><header><h6 id="exceptions"><a href="#exceptions" class="anchor"></a>Exceptions</h6></header><dl><dt class="spec exception" id="exception-Empty_list"><a href="#exception-Empty_list" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Empty_list</span></code></dt><dd><p><code>Empty_list</code> is raised when an operation applied on an empty list is invalid. For instance, <code>hd nil</code> will raise <code>Empty_list</code>.</p></dd></dl><dl><dt class="spec exception" id="exception-Invalid_index"><a href="#exception-Invalid_index" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Invalid_index</span> <span class="keyword">of</span> int</code></dt><dd><p><code>Invalid_index</code> is raised when an indexed access on a list is out of list bounds.</p></dd></dl><dl><dt class="spec exception" id="exception-Different_list_size"><a href="#exception-Different_list_size" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Different_list_size</span> <span class="keyword">of</span> string</code></dt><dd><p><code>Different_list_size</code> is raised when applying functions such as <code>iter2</code> on two lists having different size.</p></dd></dl><dl><dt class="spec exception" id="exception-No_more_elements"><a href="#exception-No_more_elements" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">No_more_elements</span></code></dt><dd><p>See <a href="index.html#val-from"><code>from</code></a> and <a href="index.html#val-from_loop"><code>from_loop</code></a> for more information on this exception.</p></dd></dl></section><section><header><h6 id="type"><a href="#type" class="anchor"></a>Type</h6><p><b>Note</b> The types are kept concrete so as to allow pattern-matching. However, it is generally easier to manipulate <a href="index.html#val-nil"><code>nil</code></a> and <a href="index.html#val-cons"><code>cons</code></a>.</p></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> 'a t</code><code> = <span class="type-var">'a</span> <a href="index.html#type-node_t">node_t</a> <a href="../../../ocaml/Stdlib/Lazy/index.html#type-t">Stdlib.Lazy.t</a></code></dt><dd><p>The type of a lazy list.</p></dd></dl><dl><dt class="spec type" id="type-node_t"><a href="#type-node_t" class="anchor"></a><code><span class="keyword">and</span> 'a node_t</code><code> = </code><table class="variant"><tr id="type-node_t.Nil" class="anchored"><td class="def constructor"><a href="#type-node_t.Nil" class="anchor"></a><code>| </code><code><span class="constructor">Nil</span></code></td></tr><tr id="type-node_t.Cons" class="anchored"><td class="def constructor"><a href="#type-node_t.Cons" class="anchor"></a><code>| </code><code><span class="constructor">Cons</span> <span class="keyword">of</span> <span class="type-var">'a</span> * <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></td><td class="doc"><p>The type of an item in the list.</p></td></tr></table></dt></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../../BatEnum/index.html#module-type-Enumerable">BatEnum.Enumerable</a> <span class="keyword">with</span> <span class="keyword">type</span> 'a <a href="../../BatEnum/module-type-Enumerable/index.html#type-enumerable">enumerable</a> = <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></span></summary><dl><dt class="spec type" id="type-enumerable"><a href="#type-enumerable" class="anchor"></a><code><span class="keyword">type</span> 'a enumerable</code><code> = <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>The data structure, e.g. <code>'a List.t</code></p></dd></dl><dl><dt class="spec value" id="val-enum"><a href="#val-enum" class="anchor"></a><code><span class="keyword">val</span> enum : <span class="type-var">'a</span> <a href="index.html#type-enumerable">enumerable</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../BatEnum/index.html#type-t">BatEnum.t</a></code></dt><dd><p>Return an enumeration of the elements of the data structure</p></dd></dl><dl><dt class="spec value" id="val-of_enum"><a href="#val-of_enum" class="anchor"></a><code><span class="keyword">val</span> of_enum : <span class="type-var">'a</span> <a href="../../BatEnum/index.html#type-t">BatEnum.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-enumerable">enumerable</a></code></dt><dd><p>Build a data structure from an enumeration</p></dd></dl></details></div></div></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../../BatInterfaces/index.html#module-type-Mappable">BatInterfaces.Mappable</a> <span class="keyword">with</span> <span class="keyword">type</span> 'a <a href="../../BatInterfaces/module-type-Mappable/index.html#type-mappable">mappable</a> = <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></span></summary><dl><dt class="spec type" id="type-mappable"><a href="#type-mappable" class="anchor"></a><code><span class="keyword">type</span> 'a mappable</code><code> = <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>The data structure, e.g. <code>'a List.t</code></p></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-mappable">mappable</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-mappable">mappable</a></code></dt><dd><p><code>map f e</code> applies <code>f</code> to every element of <code>e</code> and returns the corresponding data structure</p></dd></dl></details></div></div></div></section><section><header><h6 id="access"><a href="#access" class="anchor"></a>Access</h6></header><dl><dt class="spec value" id="val-nil"><a href="#val-nil" class="anchor"></a><code><span class="keyword">val</span> nil : <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>The empty list.</p></dd></dl><dl><dt class="spec value" id="val-cons"><a href="#val-cons" class="anchor"></a><code><span class="keyword">val</span> cons : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Build a list from a head and a tail.</p></dd></dl><dl><dt class="spec value" id="val-(^:^)"><a href="#val-(^:^)" class="anchor"></a><code><span class="keyword">val</span> (^:^) : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>As <code>cons</code>: <code>x^:^l</code> is the lazy list with head <code>x</code> and tail <code>l</code></p></dd></dl><dl><dt class="spec value" id="val-peek"><a href="#val-peek" class="anchor"></a><code><span class="keyword">val</span> peek : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt><dd><p><code>peek l</code> returns the first element of <code>l</code>, if it exists.</p></dd></dl><dl><dt class="spec value" id="val-get"><a href="#val-get" class="anchor"></a><code><span class="keyword">val</span> get : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'a</span> <a href="index.html#type-t">t</a>) option</code></dt><dd><p><code>get l</code> returns the head and tail of <code>l</code>, if <code>l</code> is not empty.</p></dd></dl></section><section><header><h6 id="list-creation"><a href="#list-creation" class="anchor"></a>List creation</h6></header><dl><dt class="spec value" id="val-from"><a href="#val-from" class="anchor"></a><code><span class="keyword">val</span> from : (unit <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>from next</code> creates a (possibly infinite) lazy list from the successive results of <code>next</code>.</p><dl><dt>raises LazyList.No_more_elements</dt><dd><p>to denote the end of the list.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-from_while"><a href="#val-from_while" class="anchor"></a><code><span class="keyword">val</span> from_while : (unit <span>&#45;&gt;</span> <span class="type-var">'a</span> option) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>from next</code> creates a (possibly infinite) lazy list from the successive results of <code>next</code>. The list ends whenever <code>next</code> returns <code>None</code>.</p></dd></dl><dl><dt class="spec value" id="val-seq"><a href="#val-seq" class="anchor"></a><code><span class="keyword">val</span> seq : <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>seq data next cond</code> creates a lazy list from the successive results of applying <code>next</code> to <code>data</code>, then to the result, etc. The list continues until the condition <code>cond</code> fails. For example, <code>seq 1 ((+) 1) ((&gt;) 100)</code> returns <code>[^1, 2, ... 99^]</code>. If <code>cond init</code> is false, the result is empty. To create an infinite lazy list, pass <code>(fun _ -&gt; true)</code> as <code>cond</code>.</p></dd></dl><dl><dt class="spec value" id="val-unfold"><a href="#val-unfold" class="anchor"></a><code><span class="keyword">val</span> unfold : <span class="type-var">'b</span> <span>&#45;&gt;</span> (<span class="type-var">'b</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) option) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>unfold data next</code> creates a (possibly infinite) lazy list from the successive results of applying <code>next</code> to <code>data</code>, then to the result, etc. The list ends whenever <code>next</code> returns <code>None</code>. The function <code>next</code> should return a pair <code>option</code> whose first element will be the current value of the sequence; the second element will be passed (lazily) to <code>next</code> in order to compute the following element. One example of a use of <code>unfold</code> is to make each element of the resulting sequence to depend on the previous two elements, as in this Fibonacci sequence definition:</p><pre><code class="ml">let data = (1, 1)
let next (x, y) = Some (x, (y, x + y))
let fib = unfold data next</code></pre><p>The first element <code>x</code> of the pair within <code>Some</code> will be the current value of the sequence; the next value of the sequence, and the one after that, are recorded as <code>y</code> and <code>x + y</code> respectively.</p></dd></dl><dl><dt class="spec value" id="val-from_loop"><a href="#val-from_loop" class="anchor"></a><code><span class="keyword">val</span> from_loop : <span class="type-var">'b</span> <span>&#45;&gt;</span> (<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> * <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>from_loop data next</code> creates a (possibly infinite) lazy list from the successive results of applying <code>next</code> to <code>data</code>, then to the result, etc. The list ends whenever the function raises <a href="index.html#exception-No_more_elements"><code>LazyList.No_more_elements</code></a>. (For further information see <code>unfold</code>; ignore references to <code>option</code> and <code>Some</code>.)</p></dd></dl><dl><dt class="spec value" id="val-init"><a href="#val-init" class="anchor"></a><code><span class="keyword">val</span> init : int <span>&#45;&gt;</span> (int <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Similar to <code>Array.init</code>, <code>init n f</code> returns the lazy list containing the results of (f 0),(f 1).... (f (n-1)).</p><dl><dt>raises Invalid_argument</dt><dd><p><code>&quot;LazyList.init&quot;</code> if n &lt; 0.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-make"><a href="#val-make" class="anchor"></a><code><span class="keyword">val</span> make : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Similar to <code>String.make</code>, <code>make n x</code> returns a list containing <code>n</code> elements <code>x</code>.</p></dd></dl><dl><dt class="spec value" id="val-range"><a href="#val-range" class="anchor"></a><code><span class="keyword">val</span> range : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <a href="index.html#type-t">t</a></code></dt><dd><p>Compute lazily a range of integers a .. b as a lazy list.</p><p>The range is empty if b &lt;= a.</p></dd></dl></section><section><header><h6 id="higher-order-functions"><a href="#higher-order-functions" class="anchor"></a>Higher-order functions</h6></header><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Eager iteration</p><p><code>iter f [^ a0; a1; ...; an ^]</code> applies function <code>f</code> in turn to <code>a0;
   a1; ...; an</code>. It is equivalent to <code>begin f a0; f a1; ...; f an; ()
   end</code>. In particular, it causes all the elements of the list to be evaluated.</p></dd></dl><dl><dt class="spec value" id="val-iteri"><a href="#val-iteri" class="anchor"></a><code><span class="keyword">val</span> iteri : (int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Eager iteration, with indices</p><p><code>iteri f [^ a0; a1; ...; an ^]</code> applies function <code>f</code> in turn to <code>a0; a1;...; an</code>, along with the corresponding <code>0,1..n</code> index. It is equivalent to <code>begin f 0 a0; f 1 a1; ...; f n an; ()
   end</code>. In particular, it causes all the elements of the list to be evaluated.</p></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Lazy map</p><p><code>map f [^ a0; a1; ... ^]</code> builds the list <code>[^ f a0; f a1; ... ^]</code> with the results returned by <code>f</code>. Not tail-recursive. Evaluations of <code>f</code> take place only when the contents of the list are forced.</p></dd></dl><dl><dt class="spec value" id="val-mapi"><a href="#val-mapi" class="anchor"></a><code><span class="keyword">val</span> mapi : (int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Lazy map, with indices</p><p><code>mapi f [^ a0; a1; ... ^]</code> builds the list <code>[^ f 0 a0; f 1 a1;
   ... ^]</code> with the results returned by <code>f</code>. Not tail-recursive. Evaluations of <code>f</code> take place only when the contents of the list are forced.</p></dd></dl><dl><dt class="spec value" id="val-fold_left"><a href="#val-fold_left" class="anchor"></a><code><span class="keyword">val</span> fold_left : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Eager fold_left</p><p><code>LazyList.fold_left f a [^ b0; b1; ...; bn ^]</code> is <code>f (... (f (f
   a b0) b1) ...) bn</code>. This causes evaluation of all the elements of the list.</p></dd></dl><dl><dt class="spec value" id="val-fold_right"><a href="#val-fold_right" class="anchor"></a><code><span class="keyword">val</span> fold_right : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p>Eager fold_right</p><p><code>fold_right f b [^ a0; a1; ...; an ^]</code> is <code>f a0 (f a1 (... (f an b) ...))</code>. This causes evaluation of all the elements of the list. Not tail-recursive.</p><p>Note that the argument order of this function is the same as <code>fold_left</code> above, but inconsistent with other <code>fold_right</code> functions in Batteries. We hope to fix this inconsistency in the next compatibility-breaking release, so you should rather use the more consistent <code>eager_fold_right</code>.</p><dl><dt>since</dt><dd>2.2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-eager_fold_right"><a href="#val-eager_fold_right" class="anchor"></a><code><span class="keyword">val</span> eager_fold_right : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p>Eager fold_right</p><p>As <code>fold_right</code> above, but with the usual argument order for a fold_right.</p><p>Just as <code>fold_left</code> on a structure <code>'a t</code> turns an element-level function of type <code>('b -&gt; 'a -&gt; 'b)</code>, with the accumulator argument <code>'b</code> on the left, into a structure-level function <code>'b -&gt; 'a t -&gt; 'b</code>, <code>fold_right</code> turns a function <code>('a -&gt; 'b -&gt; 'b)</code> (accumulator on the right) into a <code>'a t -&gt; 'b -&gt; 'b</code>.</p></dd></dl><dl><dt class="spec value" id="val-lazy_fold_right"><a href="#val-lazy_fold_right" class="anchor"></a><code><span class="keyword">val</span> lazy_fold_right : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="../../../ocaml/Stdlib/Lazy/index.html#type-t">Stdlib.Lazy.t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="../../../ocaml/Stdlib/Lazy/index.html#type-t">Stdlib.Lazy.t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="../../../ocaml/Stdlib/Lazy/index.html#type-t">Stdlib.Lazy.t</a></code></dt><dd><p>Lazy fold_right <code>lazy_fold_right f (Cons (a0, Cons (a1, Cons (a2, nil)))) b</code> is <code>lazy (f a0 (lazy (f a1 (lazy (f a2 b)))))</code>.</p><p>Forcing the result of <code>lazy_fold_right</code> forces the first element of the list; the rest is forced only if/when the function <code>f</code> forces its accumulator argument.</p><dl><dt>since</dt><dd>2.1</dd></dl></dd></dl></section><section><header><h6 id="finding"><a href="#finding" class="anchor"></a>Finding</h6></header><dl><dt class="spec value" id="val-mem"><a href="#val-mem" class="anchor"></a><code><span class="keyword">val</span> mem : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>mem x l</code> determines if <code>x</code> is part of <code>l</code>. Evaluates all the elements of <code>l</code> which appear before <code>x</code>.</p></dd></dl><dl><dt class="spec value" id="val-memq"><a href="#val-memq" class="anchor"></a><code><span class="keyword">val</span> memq : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>As <code>mem</code>, but with physical equality</p></dd></dl><dl><dt class="spec value" id="val-find"><a href="#val-find" class="anchor"></a><code><span class="keyword">val</span> find : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>find p l</code> returns the first element of <code>l</code> such as <code>p x</code> returns <code>true</code>.</p><dl><dt>raises Not_found</dt><dd><p>if such an element has not been found.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-rfind"><a href="#val-rfind" class="anchor"></a><code><span class="keyword">val</span> rfind : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>rfind p l</code> returns the last element <code>x</code> of <code>l</code> such as <code>p x</code> returns <code>true</code>.</p><dl><dt>raises Not_found</dt><dd><p>if such element as not been found.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-find_exn"><a href="#val-find_exn" class="anchor"></a><code><span class="keyword">val</span> find_exn : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> exn <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>find_exn p e l</code> returns the first element of <code>l</code> such as <code>p x</code> returns <code>true</code> or raises <code>e</code> if such an element has not been found.</p></dd></dl><dl><dt class="spec value" id="val-rfind_exn"><a href="#val-rfind_exn" class="anchor"></a><code><span class="keyword">val</span> rfind_exn : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> exn <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>rfind_exn p e l</code> returns the last element of <code>l</code> such as <code>p x</code> returns <code>true</code> or raises <code>e</code> if such an element has not been found.</p></dd></dl><dl><dt class="spec value" id="val-findi"><a href="#val-findi" class="anchor"></a><code><span class="keyword">val</span> findi : (int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int * <span class="type-var">'a</span></code></dt><dd><p><code>findi p e l</code> returns the first element <code>ai</code> of <code>l</code> along with its index <code>i</code> such that <code>p i ai</code> is true.</p><dl><dt>raises Not_found</dt><dd><p>if no such element has been found.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-rfindi"><a href="#val-rfindi" class="anchor"></a><code><span class="keyword">val</span> rfindi : (int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int * <span class="type-var">'a</span></code></dt><dd><p><code>rfindi p e l</code> returns the last element <code>ai</code> of <code>l</code> along with its index <code>i</code> such that <code>p i ai</code> is true.</p><dl><dt>raises Not_found</dt><dd><p>if no such element has been found.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-index_of"><a href="#val-index_of" class="anchor"></a><code><span class="keyword">val</span> index_of : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int option</code></dt><dd><p><code>index_of e l</code> returns the index of the first occurrence of <code>e</code> in <code>l</code>, or <code>None</code> if there is no occurrence of <code>e</code> in <code>l</code></p></dd></dl><dl><dt class="spec value" id="val-index_ofq"><a href="#val-index_ofq" class="anchor"></a><code><span class="keyword">val</span> index_ofq : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int option</code></dt><dd><p><code>index_ofq e l</code> behaves as <code>index_of e l</code> except it uses physical equality</p></dd></dl><dl><dt class="spec value" id="val-rindex_of"><a href="#val-rindex_of" class="anchor"></a><code><span class="keyword">val</span> rindex_of : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int option</code></dt><dd><p><code>index_of e l</code> returns the index of the last occurrence of <code>e</code> in <code>l</code>, or <code>None</code> if there is no occurrence of <code>e</code> in <code>l</code></p></dd></dl><dl><dt class="spec value" id="val-rindex_ofq"><a href="#val-rindex_ofq" class="anchor"></a><code><span class="keyword">val</span> rindex_ofq : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int option</code></dt><dd><p><code>rindex_ofq e l</code> behaves as <code>rindex_of e l</code> except it uses physical equality</p></dd></dl></section><section><header><h6 id="common-functions"><a href="#common-functions" class="anchor"></a>Common functions</h6></header><dl><dt class="spec value" id="val-next"><a href="#val-next" class="anchor"></a><code><span class="keyword">val</span> next : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-node_t">node_t</a></code></dt><dd><p>Compute and return the first node from the list as a <code>Cons</code>. This differs from <code>hd</code>, which returns the first element (the first component of the first node).</p></dd></dl><dl><dt class="spec value" id="val-length"><a href="#val-length" class="anchor"></a><code><span class="keyword">val</span> length : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Return the length (number of elements) of the given list.</p><p>Causes the evaluation of all the elements of the list.</p></dd></dl><dl><dt class="spec value" id="val-is_empty"><a href="#val-is_empty" class="anchor"></a><code><span class="keyword">val</span> is_empty : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Returns <code>true</code> if the list is empty, false otherwise.</p></dd></dl><dl><dt class="spec value" id="val-would_at_fail"><a href="#val-would_at_fail" class="anchor"></a><code><span class="keyword">val</span> would_at_fail : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> bool</code></dt><dd><p><code>would_at_fail l n</code> returns <code>true</code> if <code>l</code> contains strictly less than <code>n</code> elements, <code>false</code> otherwise</p></dd></dl><dl><dt class="spec value" id="val-hd"><a href="#val-hd" class="anchor"></a><code><span class="keyword">val</span> hd : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Return the first element of the given list. </p><dl><dt>raises Empty_list</dt><dd><p>if the list is empty.</p><p>Note: this function does not comply with the usual exceptionless error-management recommendations, as doing so would essentially render it useless.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-tl"><a href="#val-tl" class="anchor"></a><code><span class="keyword">val</span> tl : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Return the given list without its first element. </p><dl><dt>raises Empty_list</dt><dd><p>if the list is empty.</p><p>Note: this function does not comply with the usual exceptionless error-management recommendations, as doing so would essentially render it useless.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-first"><a href="#val-first" class="anchor"></a><code><span class="keyword">val</span> first : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>As <code>hd</code></p></dd></dl><dl><dt class="spec value" id="val-last"><a href="#val-last" class="anchor"></a><code><span class="keyword">val</span> last : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Returns the last element of the list. </p><dl><dt>raises Empty_list</dt><dd><p>if the list is empty. This function takes linear time and causes the evaluation of all elements of the list</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-at"><a href="#val-at" class="anchor"></a><code><span class="keyword">val</span> at : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>at l n</code> returns the element at index <code>n</code> (starting from <code>0</code>) in the list <code>l</code>. </p><dl><dt>raises Invalid_index</dt><dd><p>is the index is outside of <code>l</code> bounds.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-nth"><a href="#val-nth" class="anchor"></a><code><span class="keyword">val</span> nth : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Obsolete. As <code>at</code></p></dd></dl></section><section><header><h6 id="association-lists"><a href="#association-lists" class="anchor"></a>Association lists</h6><p>These lists behave essentially as <code>HashMap</code>, although they are typically faster for short number of associations, and much slower for for large number of associations.</p></header><dl><dt class="spec value" id="val-assoc"><a href="#val-assoc" class="anchor"></a><code><span class="keyword">val</span> assoc : <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p><code>assoc a l</code> returns the value associated with key <code>a</code> in the list of pairs <code>l</code>. That is, <code>assoc a [^ ...; (a,b); ...^] = b</code> if <code>(a,b)</code> is the leftmost binding of <code>a</code> in list <code>l</code>.</p><dl><dt>raises Not_found</dt><dd><p>if there is no value associated with <code>a</code> in the list <code>l</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-assq"><a href="#val-assq" class="anchor"></a><code><span class="keyword">val</span> assq : <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p>As <a href="index.html#val-assoc"><code>assoc</code></a> but with physical equality</p></dd></dl><dl><dt class="spec value" id="val-mem_assoc"><a href="#val-mem_assoc" class="anchor"></a><code><span class="keyword">val</span> mem_assoc : <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>As <a href="index.html#val-assoc"><code>assoc</code></a> but simply returns <code>true</code> if a binding exists, <code>false</code> otherwise.</p></dd></dl><dl><dt class="spec value" id="val-mem_assq"><a href="#val-mem_assq" class="anchor"></a><code><span class="keyword">val</span> mem_assq : <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>As <a href="index.html#val-mem_assoc"><code>mem_assoc</code></a> but with physical equality.</p></dd></dl><dl><dt class="spec value" id="val-rev"><a href="#val-rev" class="anchor"></a><code><span class="keyword">val</span> rev : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Eager list reversal.</p></dd></dl></section><section><header><h6 id="transformations"><a href="#transformations" class="anchor"></a>Transformations</h6></header><dl><dt class="spec value" id="val-eager_append"><a href="#val-eager_append" class="anchor"></a><code><span class="keyword">val</span> eager_append : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Evaluate a list and append another list after this one.</p><p>Cost is linear in the length of the first list, not tail-recursive.</p></dd></dl><dl><dt class="spec value" id="val-rev_append"><a href="#val-rev_append" class="anchor"></a><code><span class="keyword">val</span> rev_append : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Eager reverse-and-append</p><p>Cost is linear in the length of the first list, tail-recursive.</p></dd></dl><dl><dt class="spec value" id="val-append"><a href="#val-append" class="anchor"></a><code><span class="keyword">val</span> append : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Lazy append</p><p>Cost is constant. All evaluation is delayed until the contents of the list are actually read. Reading itself is delayed by a constant.</p></dd></dl><dl><dt class="spec value" id="val-(^@^)"><a href="#val-(^@^)" class="anchor"></a><code><span class="keyword">val</span> (^@^) : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>As lazy append</p></dd></dl><dl><dt class="spec value" id="val-concat"><a href="#val-concat" class="anchor"></a><code><span class="keyword">val</span> concat : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Lazy concatenation of a lazy list of lazy lists</p></dd></dl><dl><dt class="spec value" id="val-flatten"><a href="#val-flatten" class="anchor"></a><code><span class="keyword">val</span> flatten : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Lazy concatenation of a list of lazy lists</p></dd></dl><dl><dt class="spec value" id="val-split_at"><a href="#val-split_at" class="anchor"></a><code><span class="keyword">val</span> split_at : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> * <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>split_at n l</code> returns two lists <code>l1</code> and <code>l2</code>, <code>l1</code> containing the first <code>n</code> elements of <code>l</code> and <code>l2</code> the others. </p><dl><dt>raises Invalid_index</dt><dd><p>if <code>n</code> is outside of <code>l</code> size bounds.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-split_nth"><a href="#val-split_nth" class="anchor"></a><code><span class="keyword">val</span> split_nth : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> * <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Obsolete. As <code>split_at</code>.</p></dd></dl></section><section><header><h6 id="dropping-elements"><a href="#dropping-elements" class="anchor"></a>Dropping elements</h6></header><dl><dt class="spec value" id="val-unique"><a href="#val-unique" class="anchor"></a><code><span class="keyword">val</span> unique : ?&#8288;cmp:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>unique cmp l</code> returns the list <code>l</code> without any duplicate element. Default comparator ( = ) is used if no comparison function specified.</p></dd></dl><dl><dt class="spec value" id="val-unique_eq"><a href="#val-unique_eq" class="anchor"></a><code><span class="keyword">val</span> unique_eq : ?&#8288;eq:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>as <code>unique</code> except only uses an equality function. Use for short lists when comparing is expensive compared to equality testing</p><dl><dt>since</dt><dd>1.3.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-remove"><a href="#val-remove" class="anchor"></a><code><span class="keyword">val</span> remove : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>remove l x</code> returns the list <code>l</code> without the first element <code>x</code> found or returns <code>l</code> if no element is equal to <code>x</code>. Elements are compared using ( = ).</p></dd></dl><dl><dt class="spec value" id="val-remove_if"><a href="#val-remove_if" class="anchor"></a><code><span class="keyword">val</span> remove_if : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>remove_if cmp l</code> is similar to <code>remove</code>, but with <code>cmp</code> used instead of ( = ).</p></dd></dl><dl><dt class="spec value" id="val-remove_all"><a href="#val-remove_all" class="anchor"></a><code><span class="keyword">val</span> remove_all : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>remove_all l x</code> is similar to <code>remove</code> but removes all elements that are equal to <code>x</code> and not only the first one.</p></dd></dl><dl><dt class="spec value" id="val-remove_all_such"><a href="#val-remove_all_such" class="anchor"></a><code><span class="keyword">val</span> remove_all_such : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>remove_all_such f l</code> is similar to <code>remove</code> but removes all elements that satisfy the predicate <code>f</code> and not only the first one.</p></dd></dl><dl><dt class="spec value" id="val-take"><a href="#val-take" class="anchor"></a><code><span class="keyword">val</span> take : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>take n l</code> returns up to the <code>n</code> first elements from list <code>l</code>, if available.</p></dd></dl><dl><dt class="spec value" id="val-drop"><a href="#val-drop" class="anchor"></a><code><span class="keyword">val</span> drop : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>drop n l</code> returns <code>l</code> without the first <code>n</code> elements, or the empty list if <code>l</code> have less than <code>n</code> elements.</p></dd></dl><dl><dt class="spec value" id="val-take_while"><a href="#val-take_while" class="anchor"></a><code><span class="keyword">val</span> take_while : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>take_while f xs</code> returns the first elements of list <code>xs</code> which satisfy the predicate <code>f</code>.</p></dd></dl><dl><dt class="spec value" id="val-drop_while"><a href="#val-drop_while" class="anchor"></a><code><span class="keyword">val</span> drop_while : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>drop_while f xs</code> returns the list <code>xs</code> with the first elements satisfying the predicate <code>f</code> dropped.</p></dd></dl></section><section><header><h6 id="conversions"><a href="#conversions" class="anchor"></a>Conversions</h6></header><dl><dt class="spec value" id="val-to_list"><a href="#val-to_list" class="anchor"></a><code><span class="keyword">val</span> to_list : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>Eager conversion to string.</p></dd></dl><dl><dt class="spec value" id="val-to_stream"><a href="#val-to_stream" class="anchor"></a><code><span class="keyword">val</span> to_stream : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../../ocaml/Stdlib/Stream/index.html#type-t">Stdlib.Stream.t</a></code></dt><dd><p>Lazy conversion to stream.</p></dd></dl><dl><dt class="spec value" id="val-to_array"><a href="#val-to_array" class="anchor"></a><code><span class="keyword">val</span> to_array : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> array</code></dt><dd><p>Eager conversion to array.</p></dd></dl><dl><dt class="spec value" id="val-enum"><a href="#val-enum" class="anchor"></a><code><span class="keyword">val</span> enum : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../BatEnum/index.html#type-t">BatEnum.t</a></code></dt><dd><p>Lazy conversion to enumeration</p></dd></dl><dl><dt class="spec value" id="val-of_list"><a href="#val-of_list" class="anchor"></a><code><span class="keyword">val</span> of_list : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Lazy conversion from lists</p><p>Albeit slower than eager conversion, this is the default mechanism for converting from regular lists to lazy lists. This for two reasons : * if you're using lazy lists, total speed probably isn't as much an issue as start-up speed * this will let you convert regular infinite lists to lazy lists.</p></dd></dl><dl><dt class="spec value" id="val-of_stream"><a href="#val-of_stream" class="anchor"></a><code><span class="keyword">val</span> of_stream : <span class="type-var">'a</span> <a href="../../../ocaml/Stdlib/Stream/index.html#type-t">Stdlib.Stream.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Lazy conversion from stream.</p></dd></dl><dl><dt class="spec value" id="val-of_enum"><a href="#val-of_enum" class="anchor"></a><code><span class="keyword">val</span> of_enum : <span class="type-var">'a</span> <a href="../../BatEnum/index.html#type-t">BatEnum.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Lazy conversion from enum.</p></dd></dl><dl><dt class="spec value" id="val-eager_of_list"><a href="#val-eager_of_list" class="anchor"></a><code><span class="keyword">val</span> eager_of_list : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Eager conversion from lists.</p><p>This function is much faster than <a href="index.html#val-of_list"><code>of_list</code></a> but will freeze on cyclic lists.</p></dd></dl><dl><dt class="spec value" id="val-of_array"><a href="#val-of_array" class="anchor"></a><code><span class="keyword">val</span> of_array : <span class="type-var">'a</span> array <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Eager conversion from array</p></dd></dl></section><section><header><h6 id="predicates"><a href="#predicates" class="anchor"></a>Predicates</h6></header><dl><dt class="spec value" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span class="keyword">val</span> filter : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Lazy filtering.</p><p><code>filter p l</code> returns all the elements of the list <code>l</code> that satisfy the predicate <code>p</code>. The order of the elements in the input list is preserved.</p></dd></dl><dl><dt class="spec value" id="val-exists"><a href="#val-exists" class="anchor"></a><code><span class="keyword">val</span> exists : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Eager existential.</p><p><code>exists p [^ a0; a1; ... ^]</code> checks if at least one element of the list satisfies the predicate <code>p</code>. That is, it returns <code> (p a0) || (p a1) || ... </code>.</p></dd></dl><dl><dt class="spec value" id="val-for_all"><a href="#val-for_all" class="anchor"></a><code><span class="keyword">val</span> for_all : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Eager universal.</p><p><code>for_all p [^ a0; a1; ... ^]</code> checks if all elements of the list satisfy the predicate <code>p</code>. That is, it returns <code>(p a0) &amp;&amp; (p a1) &amp;&amp; ... </code>.</p></dd></dl><dl><dt class="spec value" id="val-filter_map"><a href="#val-filter_map" class="anchor"></a><code><span class="keyword">val</span> filter_map : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> option) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Lazily eliminate some elements and transform others.</p><p><code>filter_map f [^ a0; a1; ... ^]</code> applies lazily <code>f</code> to each <code>a0</code>, <code>a1</code>... If <code>f ai</code> evaluates to <code>None</code>, the element is not included in the result. Otherwise, if <code>f ai</code> evaluates to <code>Some x</code>, element <code>x</code> is included in the result.</p><p>This is equivalent to <code>match f a0 with
     | Some x0 -&gt; x0 ^:^ (match f a1 with
            | Some x1 -&gt; x1 ^:^ ...
            | None -&gt; [^ ^])
     | None   -&gt; [^ ^] </code>.</p></dd></dl></section><section><header><h6 id="misc."><a href="#misc." class="anchor"></a>Misc.</h6></header><dl><dt class="spec value" id="val-eternity"><a href="#val-eternity" class="anchor"></a><code><span class="keyword">val</span> eternity : unit <a href="index.html#type-t">t</a></code></dt><dd><p>An infinite list of nothing</p></dd></dl></section><section><header><h6 id="sorting"><a href="#sorting" class="anchor"></a>Sorting</h6></header><dl><dt class="spec value" id="val-sort"><a href="#val-sort" class="anchor"></a><code><span class="keyword">val</span> sort : ?&#8288;cmp:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Sort the list using optional comparator (by default <code>compare</code>).</p></dd></dl><dl><dt class="spec value" id="val-stable_sort"><a href="#val-stable_sort" class="anchor"></a><code><span class="keyword">val</span> stable_sort : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt></dl></section><section><header><h6 id="operations-on-two-lists"><a href="#operations-on-two-lists" class="anchor"></a>Operations on two lists</h6></header><dl><dt class="spec value" id="val-map2"><a href="#val-map2" class="anchor"></a><code><span class="keyword">val</span> map2 : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>map2 f [^ a0; a1; ...^] [^ b0; b1; ... ^]</code> is <code>[^ f a0 b0; f a1
    b1; ... ^]</code>. </p><dl><dt>raises Different_list_size</dt><dd><p>if the two lists have different lengths. Not tail-recursive, lazy. In particular, the exception is raised only after the shortest list has been entirely consumed.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-iter2"><a href="#val-iter2" class="anchor"></a><code><span class="keyword">val</span> iter2 : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>iter2 f [^ a0; ...; an ^] [^ b0; ...; bn ^]</code> calls in turn <code>f a0 b0; ...; f an bn</code>. Tail-recursive, eager.</p><dl><dt>raises Different_list_size</dt><dd><p>if the two lists have different lengths.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-fold_left2"><a href="#val-fold_left2" class="anchor"></a><code><span class="keyword">val</span> fold_left2 : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>fold_left2 f a [^ b0; b1; ...; bn ^] [^ c0; c1; ...; cn ^]</code> is <code>f (... (f (f a b0 c0) b1 c1) ...) bn cn</code>. Eager.</p><dl><dt>raises Different_list_size</dt><dd><p>if the two lists have different lengths.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-fold_right2"><a href="#val-fold_right2" class="anchor"></a><code><span class="keyword">val</span> fold_right2 : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'c</span></code></dt><dd><p><code>fold_right2 f [^ a0; a1; ...; an ^] [^ b0; b1; ...; bn ^] c</code> is <code>f a0 b0 (f a1 b1 (... (f an bn c) ...))</code>. Eager.</p><dl><dt>raises Different_list_size</dt><dd><p>if the two lists have different lengths. Tail-recursive.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-for_all2"><a href="#val-for_all2" class="anchor"></a><code><span class="keyword">val</span> for_all2 : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Same as <a href="index.html#val-for_all"><code>for_all</code></a>, but for a two-argument predicate.</p><dl><dt>raises Different_list_size</dt><dd><p>if the two lists have different lengths.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-exists2"><a href="#val-exists2" class="anchor"></a><code><span class="keyword">val</span> exists2 : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Same as <a href="index.html#val-exists"><code>exists</code></a>, but for a two-argument predicate.</p><dl><dt>raises Different_list_size</dt><dd><p>if the two lists have different lengths.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-combine"><a href="#val-combine" class="anchor"></a><code><span class="keyword">val</span> combine : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>Transform a pair of lists into a list of pairs: <code>combine [^ a0; a1; ... ^] [^ b0; b1; ... ^]</code> is <code>[^ (a0, b0); (a1, b1); ... ^]</code>.</p><dl><dt>raises Different_list_size</dt><dd><p>if the two lists have different lengths. Tail-recursive, lazy.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-uncombine"><a href="#val-uncombine" class="anchor"></a><code><span class="keyword">val</span> uncombine : (<span class="type-var">'a</span> * <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> * <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Divide a list of pairs into a pair of lists.</p></dd></dl><dl><dt class="spec module" id="module-Infix"><a href="#module-Infix" class="anchor"></a><code><span class="keyword">module</span> Infix = <a href="../../Batteries/LazyList/index.html#module-Infix">Batteries.LazyList.Infix</a></code></dt><dd></dd></dl></section><section><header><h6 id="boilerplate-code"><a href="#boilerplate-code" class="anchor"></a>Boilerplate code</h6></header></section><section><header><h6 id="printing"><a href="#printing" class="anchor"></a>Printing</h6></header><dl><dt class="spec value" id="val-print"><a href="#val-print" class="anchor"></a><code><span class="keyword">val</span> print : ?&#8288;first:string <span>&#45;&gt;</span> ?&#8288;last:string <span>&#45;&gt;</span> ?&#8288;sep:string <span>&#45;&gt;</span> (<span class="type-var">'a</span> <a href="../../BatInnerIO/index.html#type-output">BatInnerIO.output</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../BatInnerIO/index.html#type-output">BatInnerIO.output</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt></dl></section><section><header><h6 id="override-modules"><a href="#override-modules" class="anchor"></a>Override modules</h6></header><aside><p>The following modules replace functions defined in <a href="index.html"><code>LazyList</code></a> with functions behaving slightly differently but having the same name. This is by design: the functions meant to override the corresponding functions of <a href="index.html"><code>LazyList</code></a>.</p></aside><dl><dt class="spec module" id="module-Exceptionless"><a href="#module-Exceptionless" class="anchor"></a><code><span class="keyword">module</span> Exceptionless = <a href="../../Batteries/LazyList/index.html#module-Exceptionless">Batteries.LazyList.Exceptionless</a></code></dt><dd><p>Exceptionless counterparts for error-raising operations</p></dd></dl><dl><dt class="spec module" id="module-Labels"><a href="#module-Labels" class="anchor"></a><code><span class="keyword">module</span> Labels = <a href="../../Batteries/LazyList/index.html#module-Labels">Batteries.LazyList.Labels</a></code></dt><dd><p>Operations on <a href="index.html"><code>LazyList</code></a> with labels.</p></dd></dl></section></details></div></div></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../../BatLazyList/index.html#module-Exceptionless">BatLazyList.Exceptionless</a></code></span></summary><dl><dt class="spec value" id="val-find"><a href="#val-find" class="anchor"></a><code><span class="keyword">val</span> find : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../BatLazyList/index.html#type-t">BatLazyList.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt><dd><p><code>find p l</code> returns <code>Some x</code> where <code>x</code> is the first element of <code>l</code> such that <code>p x</code> returns <code>true</code> or <code>None</code> if such element as not been found.</p></dd></dl><dl><dt class="spec value" id="val-rfind"><a href="#val-rfind" class="anchor"></a><code><span class="keyword">val</span> rfind : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../BatLazyList/index.html#type-t">BatLazyList.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt><dd><p><code>rfind p l</code> returns <code>Some x</code> where <code>x</code> is the last element of <code>l</code> such that <code>p x</code> returns <code>true</code> or <code>None</code> if such element as not been found.</p></dd></dl><dl><dt class="spec value" id="val-findi"><a href="#val-findi" class="anchor"></a><code><span class="keyword">val</span> findi : (int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../BatLazyList/index.html#type-t">BatLazyList.t</a> <span>&#45;&gt;</span> (int * <span class="type-var">'a</span>) option</code></dt><dd><p><code>findi p e l</code> returns <code>Some (i, ai)</code> where <code>ai</code> and <code>i</code> are respectively the first element of <code>l</code> and its index, such that <code>p i ai</code> is true, or <code>None</code> if no such element has been found.</p></dd></dl><dl><dt class="spec value" id="val-rfindi"><a href="#val-rfindi" class="anchor"></a><code><span class="keyword">val</span> rfindi : (int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../BatLazyList/index.html#type-t">BatLazyList.t</a> <span>&#45;&gt;</span> (int * <span class="type-var">'a</span>) option</code></dt><dd><p><code>rfindi p e l</code> returns <code>Some (i, ai)</code> where <code>ai</code> and <code>i</code> are respectively the last element of <code>l</code> and its index, such that <code>p i ai</code> is true, or <code>None</code> if no such element has been found.</p></dd></dl><dl><dt class="spec value" id="val-split_at"><a href="#val-split_at" class="anchor"></a><code><span class="keyword">val</span> split_at : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../BatLazyList/index.html#type-t">BatLazyList.t</a> <span>&#45;&gt;</span> [ `Ok of <span class="type-var">'a</span> <a href="../../BatLazyList/index.html#type-t">BatLazyList.t</a> * <span class="type-var">'a</span> <a href="../../BatLazyList/index.html#type-t">BatLazyList.t</a> | `Invalid_index of int ]</code></dt><dd><p>Whenever <code>n</code> is inside of <code>l</code> size bounds, <code>split_at n l</code> returns <code>`Ok (l1,l2)</code>, where <code>l1</code> contains the first <code>n</code> elements of <code>l</code> and <code>l2</code> contains the others. Otherwise, returns <code>`Invalid_index n</code></p></dd></dl><dl><dt class="spec value" id="val-at"><a href="#val-at" class="anchor"></a><code><span class="keyword">val</span> at : <span class="type-var">'a</span> <a href="../../BatLazyList/index.html#type-t">BatLazyList.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> [ `Ok of <span class="type-var">'a</span> | `Invalid_index of int ]</code></dt><dd><p>If <code>n</code> is inside the bounds of <code>l</code>, <code>at l n</code> returns <code>`Ok x</code>, where <code>x</code> is the n-th element of the list <code>l</code>. Otherwise, returns <code>`Invalid_index n</code>.</p></dd></dl><dl><dt class="spec value" id="val-assoc"><a href="#val-assoc" class="anchor"></a><code><span class="keyword">val</span> assoc : <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) <a href="../../BatLazyList/index.html#type-t">BatLazyList.t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> option</code></dt><dd><p><code>assoc a l</code> returns <code>Some b</code> where <code>b</code> is the value associated with key <code>a</code> in the list of pairs <code>l</code>. That is, <code>assoc a [ ...; (a,b); ...] = Some b</code> if <code>(a,b)</code> is the leftmost binding of <code>a</code> in list <code>l</code>. Return <code>None</code> if there is no value associated with <code>a</code> in the list <code>l</code>.</p></dd></dl><dl><dt class="spec value" id="val-assq"><a href="#val-assq" class="anchor"></a><code><span class="keyword">val</span> assq : <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) <a href="../../BatLazyList/index.html#type-t">BatLazyList.t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> option</code></dt><dd><p>As <a href="index.html#val-assoc"><code>assoc</code></a> but with physical equality</p></dd></dl></details></div></div></div><div class="spec module" id="module-Labels"><a href="#module-Labels" class="anchor"></a><code><span class="keyword">module</span> <a href="Labels/index.html">Labels</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></div></body></html>