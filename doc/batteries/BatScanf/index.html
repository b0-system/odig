<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>BatScanf (batteries.BatScanf)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../index.html">batteries</a> &#x00BB; BatScanf</nav><header class="odoc-preamble"><h1>Module <code><span>BatScanf</span></code></h1><p>Formatted input functions.</p><ul class="at-tags"><li class="author"><span class="at-tag">author</span> Pierre Weis (Base module)</li></ul><ul class="at-tags"><li class="author"><span class="at-tag">author</span> David Teller</li></ul></header><nav class="odoc-toc"><ul><li><a href="#introduction">Introduction</a></li><li><a href="#functional-input-with-format-strings">Functional input with format strings</a></li><li><a href="#a-simple-example">A simple example</a></li><li><a href="#formatted-input-as-a-functional-feature">Formatted input as a functional feature</a></li><li><a href="#type-of-formatted-input-functions">Type of formatted input functions</a></li><li><a href="#the-general-formatted-input-function">The general formatted input function</a></li><li><a href="#format-string-description">Format string description</a></li><li><a href="#the-space-character-in-format-strings">The space character in format strings</a></li><li><a href="#conversion-specifications-in-format-strings">Conversion specifications in format strings</a></li><li><a href="#scanning-indications-in-format-strings">Scanning indications in format strings</a></li><li><a href="#exceptions-during-scanning">Exceptions during scanning</a></li><li><a href="#specialized-formatted-input-functions">Specialized formatted input functions</a></li><li><a href="#reading-format-strings-from-input">Reading format strings from input</a></li></ul></nav><div class="odoc-content"><h6 id="introduction"><a href="#introduction" class="anchor"></a>Introduction</h6><h6 id="functional-input-with-format-strings"><a href="#functional-input-with-format-strings" class="anchor"></a>Functional input with format strings</h6><p>The module <code>Scanf</code> provides formatted input functions or <em>scanners</em>.</p><p>The formatted input functions can read from any kind of input, including strings, files, or anything that can return characters. The more general source of characters is named a <em>scanning buffer</em> and has type <a href="Scanning/index.html#type-scanbuf"><code>Scanning.scanbuf</code></a>. The more general formatted input function reads from any scanning buffer and is named <code>bscanf</code>.</p><p>Generally speaking, the formatted input functions have 3 arguments:</p><ul><li>the first argument is a source of characters for the input,</li><li>the second argument is a format string that specifies the values to read,</li><li>the third argument is a <em>receiver function</em> that is applied to the values read.</li></ul><p>Hence, a typical call to the formatted input function <code>Scanf</code>.bscanf is <code>bscanf ib fmt f</code>, where:</p><ul><li><code>ib</code> is a source of characters (typically a <em>scanning buffer</em> with type <a href="Scanning/index.html#type-scanbuf"><code>Scanning.scanbuf</code></a>),</li></ul><ul><li><code>fmt</code> is a format string (the same format strings as those used to print material with module <code>Printf</code> or <code>Format</code>),</li></ul><ul><li><code>f</code> is a function that has as many arguments as the number of values to read in the input.</li></ul><h6 id="a-simple-example"><a href="#a-simple-example" class="anchor"></a>A simple example</h6><p>As suggested above, the expression <code>bscanf ib &quot;%d&quot; f</code> reads a decimal integer <code>n</code> from the source of characters <code>ib</code> and returns <code>f n</code>.</p><p>For instance,</p><ul><li>if we use <code>stdib</code> as the source of characters (<a href="Scanning/index.html#val-stdib"><code>Scanning.stdib</code></a> is the predefined input buffer that reads from standard input),</li></ul><ul><li>if we define the receiver <code>f</code> as <code>let f x = x + 1</code>,</li></ul><p>then <code>bscanf stdib &quot;%d&quot; f</code> reads an integer <code>n</code> from the standard input and returns <code>f n</code> (that is <code>n + 1</code>). Thus, if we evaluate <code>bscanf stdib
    &quot;%d&quot; f</code>, and then enter <code>41</code> at the keyboard, we get <code>42</code> as the final result.</p><h6 id="formatted-input-as-a-functional-feature"><a href="#formatted-input-as-a-functional-feature" class="anchor"></a>Formatted input as a functional feature</h6><p>The OCaml scanning facility is reminiscent of the corresponding C feature. However, it is also largely different, simpler, and yet more powerful: the formatted input functions are higher-order functionals and the parameter passing mechanism is just the regular function application not the variable assignment based mechanism which is typical for formatted input in imperative languages; the OCaml format strings also feature useful additions to easily define complex tokens; as expected within a functional programming language, the formatted input functions also support polymorphism, in particular arbitrary interaction with polymorphic user-defined scanners. Furthermore, the OCaml formatted input facility is fully type-checked at compile time.</p><div class="odoc-spec"><div class="spec module" id="module-Scanning" class="anchored"><a href="#module-Scanning" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Scanning/index.html">Scanning</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><h6 id="type-of-formatted-input-functions"><a href="#type-of-formatted-input-functions" class="anchor"></a>Type of formatted input functions</h6><div class="odoc-spec"><div class="spec type" id="type-scanner" class="anchored"><a href="#type-scanner" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 'b, 'c, 'd) scanner</span></span><span> = <span><span><span>(<span class="type-var">'a</span>, <a href="Scanning/index.html#type-scanbuf">Scanning.scanbuf</a>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'d</span>, <span class="type-var">'d</span>)</span> <a href="../../ocaml/Stdlib/index.html#type-format6">format6</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span></span></code></div><div class="spec-doc"><p>The type of formatted input scanners: <code>('a, 'b, 'c, 'd) scanner</code> is the type of a formatted input function that reads from some scanning buffer according to some format string; more precisely, if <code>scan</code> is some formatted input function, then <code>scan ib fmt f</code> applies <code>f</code> to the arguments specified by the format string <code>fmt</code>, when <code>scan</code> has read those arguments from the scanning input buffer <code>ib</code>.</p><p>For instance, the <code>scanf</code> function below has type <code>('a, 'b, 'c, 'd)
    scanner</code>, since it is a formatted input function that reads from <code>stdib</code>: <code>scanf fmt f</code> applies <code>f</code> to the arguments specified by <code>fmt</code>, reading those arguments from <code>stdin</code> as expected.</p><p>If the format <code>fmt</code> has some <code>%r</code> indications, the corresponding input functions must be provided before the receiver <code>f</code> argument. For instance, if <code>read_elem</code> is an input function for values of type <code>t</code>, then <code>bscanf ib &quot;%r;&quot; read_elem f</code> reads a value <code>v</code> of type <code>t</code> followed by a <code>';'</code> character, and returns <code>f v</code>.</p></div></div><div class="odoc-spec"><div class="spec exception" id="exception-Scan_failure" class="anchored"><a href="#exception-Scan_failure" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Scan_failure</span> <span class="keyword">of</span> string</span></code></div><div class="spec-doc"><p>The exception that formatted input functions raise when the input cannot be read according to the given format.</p></div></div><h6 id="the-general-formatted-input-function"><a href="#the-general-formatted-input-function" class="anchor"></a>The general formatted input function</h6><div class="odoc-spec"><div class="spec value" id="val-bscanf" class="anchored"><a href="#val-bscanf" class="anchor"></a><code><span><span class="keyword">val</span> bscanf : <span><a href="Scanning/index.html#type-scanbuf">Scanning.scanbuf</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>)</span> <a href="#type-scanner">scanner</a></span></span></code></div><div class="spec-doc"><p><code>bscanf ib fmt r1 ... rN f</code> reads arguments for the function <code>f</code>, from the scanning buffer <code>ib</code>, according to the format string <code>fmt</code>, and applies <code>f</code> to these values. The result of this call to <code>f</code> is returned as the result of the entire <code>bscanf</code> call. For instance, if <code>f</code> is the function <code>fun s i -&gt; i + 1</code>, then <code>Scanf.sscanf &quot;x=  1&quot; &quot;%s = %i&quot; f</code> returns <code>2</code>.</p><p>Arguments <code>r1</code> to <code>rN</code> are user-defined input functions that read the argument corresponding to a <code>%r</code> conversion.</p></div></div><h6 id="format-string-description"><a href="#format-string-description" class="anchor"></a>Format string description</h6><p>The format is a character string which contains three types of objects:</p><ul><li>plain characters, which are simply matched with the characters of the input,</li><li>conversion specifications, each of which causes reading and conversion of one argument for the function <code>f</code>,</li><li>scanning indications to specify boundaries of tokens.</li></ul><h6 id="the-space-character-in-format-strings"><a href="#the-space-character-in-format-strings" class="anchor"></a>The space character in format strings</h6><p>As mentioned above, a plain character in the format string is just matched with the characters of the input; however, one character is a special exception to this simple rule: the space character (ASCII code 32) does not match a single space character, but any amount of ``whitespace'' in the input. More precisely, a space inside the format string matches <em>any number</em> of tab, space, line feed and carriage return characters.</p><p>Matching <em>any</em> amount of whitespace, a space in the format string also matches no amount of whitespace at all; hence, the call <code>bscanf ib
    &quot;Price = %d $&quot; (fun p -&gt; p)</code> succeeds and returns <code>1</code> when reading an input with various whitespace in it, such as <code>Price = 1 $</code>, <code>Price  =  1    $</code>, or even <code>Price=1$</code>.</p><h6 id="conversion-specifications-in-format-strings"><a href="#conversion-specifications-in-format-strings" class="anchor"></a>Conversion specifications in format strings</h6><p>Conversion specifications consist in the <code>%</code> character, followed by an optional flag, an optional field width, and followed by one or two conversion characters. The conversion characters and their meanings are:</p><ul><li><code>d</code>: reads an optionally signed decimal integer.</li><li><code>i</code>: reads an optionally signed integer (usual input formats for hexadecimal (<code>0x[d]+</code> and <code>0X[d]+</code>), octal (<code>0o[d]+</code>), and binary <code>0b[d]+</code> notations are understood).</li><li><code>u</code>: reads an unsigned decimal integer.</li><li><code>x</code> or <code>X</code>: reads an unsigned hexadecimal integer.</li><li><code>o</code>: reads an unsigned octal integer.</li><li><code>s</code>: reads a string argument that spreads as much as possible, until the following bounding condition holds: a whitespace has been found, a scanning indication has been encountered, or the end-of-input has been reached. Hence, this conversion always succeeds: it returns an empty string, if the bounding condition holds when the scan begins.</li><li><code>S</code>: reads a delimited string argument (delimiters and special escaped characters follow the lexical conventions of OCaml).</li><li><p><code>c</code>: reads a single character. To test the current input character without reading it, specify a null field width, i.e. use specification <code>%0c</code>. </p><p>@raise Invalid_argument,</p><p>if the field width specification is greater than 1.</p></li><li><code>C</code>: reads a single delimited character (delimiters and special escaped characters follow the lexical conventions of OCaml).</li><li><code>f</code>, <code>e</code>, <code>E</code>, <code>g</code>, <code>G</code>: reads an optionally signed floating-point number in decimal notation, in the style <code>dddd.ddd
      e/E+-dd</code>.</li><li><code>F</code>: reads a floating point number according to the lexical conventions of OCaml (hence the decimal point is mandatory if the exponent part is not mentioned).</li><li><code>B</code>: reads a boolean argument (<code>true</code> or <code>false</code>).</li><li><code>b</code>: reads a boolean argument (for backward compatibility; do not use in new programs).</li><li><code>ld</code>, <code>li</code>, <code>lu</code>, <code>lx</code>, <code>lX</code>, <code>lo</code>: reads an <code>int32</code> argument to the format specified by the second letter (decimal, hexadecimal, etc).</li><li><code>nd</code>, <code>ni</code>, <code>nu</code>, <code>nx</code>, <code>nX</code>, <code>no</code>: reads a <code>nativeint</code> argument to the format specified by the second letter.</li><li><code>Ld</code>, <code>Li</code>, <code>Lu</code>, <code>Lx</code>, <code>LX</code>, <code>Lo</code>: reads an <code>int64</code> argument to the format specified by the second letter.</li><li><code>[ range ]</code>: reads characters that matches one of the characters mentioned in the range of characters <code>range</code> (or not mentioned in it, if the range starts with <code>^</code>). Reads a <code>string</code> that can be empty, if the next input character does not match the range. The set of characters from <code>c1</code> to <code>c2</code> (inclusively) is denoted by <code>c1-c2</code>. Hence, <code>%[0-9]</code> returns a string representing a decimal number or an empty string if no decimal digit is found; similarly, <code>%[\\048-\\057\\065-\\070]</code> returns a string of hexadecimal digits. If a closing bracket appears in a range, it must occur as the first character of the range (or just after the <code>^</code> in case of range negation); hence <code>[]]</code> matches a <code>]</code> character and <code>[^]]</code> matches any character that is not <code>]</code>.</li><li><code>r</code>: user-defined reader. Takes the next <code>ri</code> formatted input function and applies it to the scanning buffer <code>ib</code> to read the next argument. The input function <code>ri</code> must therefore have type <code>Scanning.scanbuf -&gt; 'a</code> and the argument read has type <code>'a</code>.</li><li><code>\{ fmt %\}</code>: reads a format string argument. The format string read must have the same type as the format string specification <code>fmt</code>. For instance, <code>&quot;%\{%i%\}&quot;</code> reads any format string that can read a value of type <code>int</code>; hence <code>Scanf.sscanf &quot;fmt:\\\&quot;number is %u\\\&quot;&quot; &quot;fmt:%\{%i%\}&quot;</code> succeeds and returns the format string <code>&quot;number is %u&quot;</code>.</li><li><code>\( fmt %\)</code>: scanning format substitution. Reads a format string to replace <code>fmt</code>. The format string read must have the same type as the format string specification <code>fmt</code>. For instance, <code>&quot;%\( %i% \)&quot;</code> reads any format string that can read a value of type <code>int</code>; hence <code>Scanf.sscanf &quot;\\\&quot;%4d\\\&quot;1234.00&quot; &quot;%\(%i%\)&quot;</code> is equivalent to <code>Scanf.sscanf &quot;1234.00&quot; &quot;%4d&quot;</code>.</li><li><code>l</code>: returns the number of lines read so far.</li><li><code>n</code>: returns the number of characters read so far.</li><li><code>N</code> or <code>L</code>: returns the number of tokens read so far.</li><li><code>!</code>: matches the end of input condition.</li><li><code>%</code>: matches one <code>%</code> character in the input.</li></ul><p>Following the <code>%</code> character that introduces a conversion, there may be the special flag <code>_</code>: the conversion that follows occurs as usual, but the resulting value is discarded. For instance, if <code>f</code> is the function <code>fun i -&gt; i + 1</code>, then <code>Scanf.sscanf &quot;x = 1&quot; &quot;%_s = %i&quot; f</code> returns <code>2</code>.</p><p>The field width is composed of an optional integer literal indicating the maximal width of the token to read. For instance, <code>%6d</code> reads an integer, having at most 6 decimal digits; <code>%4f</code> reads a float with at most 4 characters; and <code>%8[\\000-\\255]</code> returns the next 8 characters (or all the characters still available, if fewer than 8 characters are available in the input).</p><p>Notes:</p><ul><li>as mentioned above, a <code>%s</code> conversion always succeeds, even if there is nothing to read in the input: it simply returns <code>&quot;&quot;</code>.</li></ul><ul><li>in addition to the relevant digits, <code>'_'</code> characters may appear inside numbers (this is reminiscent to the usual OCaml lexical conventions). If stricter scanning is desired, use the range conversion facility instead of the number conversions.</li></ul><ul><li>the <code>scanf</code> facility is not intended for heavy duty lexical analysis and parsing. If it appears not expressive enough for your needs, several alternative exists: regular expressions (module <code>Str</code>), stream parsers, <code>ocamllex</code>-generated lexers, <code>ocamlyacc</code>-generated parsers.</li></ul><h6 id="scanning-indications-in-format-strings"><a href="#scanning-indications-in-format-strings" class="anchor"></a>Scanning indications in format strings</h6><p>Scanning indications appear just after the string conversions <code>%s</code> and <code>%[ range ]</code> to delimit the end of the token. A scanning indication is introduced by a <code>@</code> character, followed by some constant character <code>c</code>. It means that the string token should end just before the next matching <code>c</code> (which is skipped). If no <code>c</code> character is encountered, the string token spreads as much as possible. For instance, <code>&quot;%s@\t&quot;</code> reads a string up to the next tab character or to the end of input. If a scanning indication <code>\@c</code> does not follow a string conversion, it is treated as a plain <code>c</code> character.</p><p>Note:</p><ul><li>the scanning indications introduce slight differences in the syntax of <code>Scanf</code> format strings, compared to those used for the <code>Printf</code> module. However, the scanning indications are similar to those used in the <code>Format</code> module; hence, when producing formatted text to be scanned by <code>!Scanf.bscanf</code>, it is wise to use printing functions from the <code>Format</code> module (or, if you need to use functions from <code>Printf</code>, banish or carefully double check the format strings that contain <code>'\@'</code> characters).</li></ul><h6 id="exceptions-during-scanning"><a href="#exceptions-during-scanning" class="anchor"></a>Exceptions during scanning</h6><p>Scanners may raise the following exceptions when the input cannot be read according to the format string:</p><ul><li><p>@raise Scanf.Scan_failure</p><p>if the input does not match the format.</p></li></ul><ul><li><p>@raise Failure</p><p>if a conversion to a number is not possible.</p></li></ul><ul><li><p>@raise End_of_file</p><p>if the end of input is encountered while some more characters are needed to read the current conversion specification.</p></li></ul><ul><li><p>@raise Invalid_argument</p><p>if the format string is invalid.</p></li></ul><p>Note:</p><ul><li>as a consequence, scanning a <code>%s</code> conversion never raises exception <code>End_of_file</code>: if the end of input is reached the conversion succeeds and simply returns the characters read so far, or <code>&quot;&quot;</code> if none were read.</li></ul><h6 id="specialized-formatted-input-functions"><a href="#specialized-formatted-input-functions" class="anchor"></a>Specialized formatted input functions</h6><div class="odoc-spec"><div class="spec value" id="val-fscanf" class="anchored"><a href="#val-fscanf" class="anchor"></a><code><span><span class="keyword">val</span> fscanf : <span><a href="../../ocaml/Stdlib/index.html#type-in_channel">in_channel</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>)</span> <a href="#type-scanner">scanner</a></span></span></code></div><div class="spec-doc"><p>Same as <code>Scanf</code>.bscanf, but reads from the given channel.</p><p>Warning: since all formatted input functions operate from a scanning buffer, be aware that each <code>fscanf</code> invocation will operate with a scanning buffer reading from the given channel. This extra level of bufferization can lead to strange scanning behaviour if you use low level primitives on the channel (reading characters, seeking the reading position, and so on).</p><p>As a consequence, never mixt direct low level reading and high level scanning from the same input channel.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sscanf" class="anchored"><a href="#val-sscanf" class="anchor"></a><code><span><span class="keyword">val</span> sscanf : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>)</span> <a href="#type-scanner">scanner</a></span></span></code></div><div class="spec-doc"><p>Same as <code>Scanf</code>.bscanf, but reads from the given string.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-scanf" class="anchored"><a href="#val-scanf" class="anchor"></a><code><span><span class="keyword">val</span> scanf : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>)</span> <a href="#type-scanner">scanner</a></span></span></code></div><div class="spec-doc"><p>Same as <code>Scanf</code>.bscanf, but reads from the predefined scanning buffer <code>Scanf</code>.Scanning.stdib that is connected to <code>stdin</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-kscanf" class="anchored"><a href="#val-kscanf" class="anchor"></a><code><span><span class="keyword">val</span> kscanf : <span><a href="Scanning/index.html#type-scanbuf">Scanning.scanbuf</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><a href="Scanning/index.html#type-scanbuf">Scanning.scanbuf</a> <span class="arrow">&#45;&gt;</span></span> <span>exn <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'d</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>)</span> <a href="#type-scanner">scanner</a></span></span></code></div><div class="spec-doc"><p>Same as <code>Scanf</code>.bscanf, but takes an additional function argument <code>ef</code> that is called in case of error: if the scanning process or some conversion fails, the scanning function aborts and calls the error handling function <code>ef</code> with the scanning buffer and the exception that aborted the scanning process.</p></div></div><h6 id="reading-format-strings-from-input"><a href="#reading-format-strings-from-input" class="anchor"></a>Reading format strings from input</h6><div class="odoc-spec"><div class="spec value" id="val-bscanf_format" class="anchored"><a href="#val-bscanf_format" class="anchor"></a><code><span><span class="keyword">val</span> bscanf_format : <span><a href="Scanning/index.html#type-scanbuf">Scanning.scanbuf</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>, <span class="type-var">'e</span>, <span class="type-var">'f</span>)</span> <a href="../../ocaml/Stdlib/index.html#type-format6">format6</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>, <span class="type-var">'e</span>, <span class="type-var">'f</span>)</span> <a href="../../ocaml/Stdlib/index.html#type-format6">format6</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'g</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'g</span></span></code></div><div class="spec-doc"><p><code>bscanf_format ib fmt f</code> reads a format string token from the scanning buffer <code>ib</code>, according to the given format string <code>fmt</code>, and applies <code>f</code> to the resulting format string value.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Scan_failure</span> <p>if the format string value read does not have the same type as <code>fmt</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-sscanf_format" class="anchored"><a href="#val-sscanf_format" class="anchor"></a><code><span><span class="keyword">val</span> sscanf_format : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>, <span class="type-var">'e</span>, <span class="type-var">'f</span>)</span> <a href="../../ocaml/Stdlib/index.html#type-format6">format6</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>, <span class="type-var">'e</span>, <span class="type-var">'f</span>)</span> <a href="../../ocaml/Stdlib/index.html#type-format6">format6</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'g</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'g</span></span></code></div><div class="spec-doc"><p>Same as <code>Scanf</code>.bscanf_format, but reads from the given string.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-format_from_string" class="anchored"><a href="#val-format_from_string" class="anchor"></a><code><span><span class="keyword">val</span> format_from_string : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>, <span class="type-var">'e</span>, <span class="type-var">'f</span>)</span> <a href="../../ocaml/Stdlib/index.html#type-format6">format6</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>, <span class="type-var">'e</span>, <span class="type-var">'f</span>)</span> <a href="../../ocaml/Stdlib/index.html#type-format6">format6</a></span></span></code></div><div class="spec-doc"><p><code>format_from_string s fmt</code> converts a string argument to a format string, according to the given format string <code>fmt</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Scan_failure</span> <p>if <code>s</code>, considered as a format string, does not have the same type as <code>fmt</code>.</p></li></ul></div></div></div></body></html>