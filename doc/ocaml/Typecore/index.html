<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Typecore (ocaml.Typecore)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">ocaml</a> &#x00BB; Typecore</nav><h1>Module <code>Typecore</code></h1></header><dl><dt class="spec value" id="val-is_nonexpansive"><a href="#val-is_nonexpansive" class="anchor"></a><code><span class="keyword">val </span>is_nonexpansive : Typedtree.expression <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-type_binding"><a href="#val-type_binding" class="anchor"></a><code><span class="keyword">val </span>type_binding : Env.t <span>&#45;&gt;</span> Asttypes.rec_flag <span>&#45;&gt;</span> Parsetree.value_binding list <span>&#45;&gt;</span> Annot.ident option <span>&#45;&gt;</span> Typedtree.value_binding list<span class="keyword"> * </span>Env.t</code></dt><dt class="spec value" id="val-type_let"><a href="#val-type_let" class="anchor"></a><code><span class="keyword">val </span>type_let : Env.t <span>&#45;&gt;</span> Asttypes.rec_flag <span>&#45;&gt;</span> Parsetree.value_binding list <span>&#45;&gt;</span> Annot.ident option <span>&#45;&gt;</span> Typedtree.value_binding list<span class="keyword"> * </span>Env.t</code></dt><dt class="spec value" id="val-type_expression"><a href="#val-type_expression" class="anchor"></a><code><span class="keyword">val </span>type_expression : Env.t <span>&#45;&gt;</span> Parsetree.expression <span>&#45;&gt;</span> Typedtree.expression</code></dt><dt class="spec value" id="val-type_class_arg_pattern"><a href="#val-type_class_arg_pattern" class="anchor"></a><code><span class="keyword">val </span>type_class_arg_pattern : string <span>&#45;&gt;</span> Env.t <span>&#45;&gt;</span> Env.t <span>&#45;&gt;</span> Asttypes.arg_label <span>&#45;&gt;</span> Parsetree.pattern <span>&#45;&gt;</span> Typedtree.pattern<span class="keyword"> * </span>(Ident.t<span class="keyword"> * </span>string Asttypes.loc<span class="keyword"> * </span>Ident.t<span class="keyword"> * </span>Types.type_expr) list<span class="keyword"> * </span>Env.t<span class="keyword"> * </span>Env.t</code></dt><dt class="spec value" id="val-type_self_pattern"><a href="#val-type_self_pattern" class="anchor"></a><code><span class="keyword">val </span>type_self_pattern : string <span>&#45;&gt;</span> Types.type_expr <span>&#45;&gt;</span> Env.t <span>&#45;&gt;</span> Env.t <span>&#45;&gt;</span> Env.t <span>&#45;&gt;</span> Parsetree.pattern <span>&#45;&gt;</span> Typedtree.pattern<span class="keyword"> * </span>(Ident.t<span class="keyword"> * </span>Types.type_expr) Types.Meths.t Pervasives.ref<span class="keyword"> * </span>(Ident.t<span class="keyword"> * </span>Asttypes.mutable_flag<span class="keyword"> * </span>Asttypes.virtual_flag<span class="keyword"> * </span>Types.type_expr) Types.Vars.t Pervasives.ref<span class="keyword"> * </span>Env.t<span class="keyword"> * </span>Env.t<span class="keyword"> * </span>Env.t</code></dt><dt class="spec value" id="val-check_partial"><a href="#val-check_partial" class="anchor"></a><code><span class="keyword">val </span>check_partial : ?&#8288;lev:int <span>&#45;&gt;</span> Env.t <span>&#45;&gt;</span> Types.type_expr <span>&#45;&gt;</span> Location.t <span>&#45;&gt;</span> Typedtree.case list <span>&#45;&gt;</span> Typedtree.partial</code></dt><dt class="spec value" id="val-type_expect"><a href="#val-type_expect" class="anchor"></a><code><span class="keyword">val </span>type_expect : ?&#8288;in_function:(Location.t<span class="keyword"> * </span>Types.type_expr) <span>&#45;&gt;</span> Env.t <span>&#45;&gt;</span> Parsetree.expression <span>&#45;&gt;</span> Types.type_expr <span>&#45;&gt;</span> Typedtree.expression</code></dt><dt class="spec value" id="val-type_exp"><a href="#val-type_exp" class="anchor"></a><code><span class="keyword">val </span>type_exp : Env.t <span>&#45;&gt;</span> Parsetree.expression <span>&#45;&gt;</span> Typedtree.expression</code></dt><dt class="spec value" id="val-type_approx"><a href="#val-type_approx" class="anchor"></a><code><span class="keyword">val </span>type_approx : Env.t <span>&#45;&gt;</span> Parsetree.expression <span>&#45;&gt;</span> Types.type_expr</code></dt><dt class="spec value" id="val-type_argument"><a href="#val-type_argument" class="anchor"></a><code><span class="keyword">val </span>type_argument : Env.t <span>&#45;&gt;</span> Parsetree.expression <span>&#45;&gt;</span> Types.type_expr <span>&#45;&gt;</span> Types.type_expr <span>&#45;&gt;</span> Typedtree.expression</code></dt><dt class="spec value" id="val-option_some"><a href="#val-option_some" class="anchor"></a><code><span class="keyword">val </span>option_some : Typedtree.expression <span>&#45;&gt;</span> Typedtree.expression</code></dt><dt class="spec value" id="val-option_none"><a href="#val-option_none" class="anchor"></a><code><span class="keyword">val </span>option_none : Types.type_expr <span>&#45;&gt;</span> Location.t <span>&#45;&gt;</span> Typedtree.expression</code></dt><dt class="spec value" id="val-extract_option_type"><a href="#val-extract_option_type" class="anchor"></a><code><span class="keyword">val </span>extract_option_type : Env.t <span>&#45;&gt;</span> Types.type_expr <span>&#45;&gt;</span> Types.type_expr</code></dt><dt class="spec value" id="val-iter_pattern"><a href="#val-iter_pattern" class="anchor"></a><code><span class="keyword">val </span>iter_pattern : (Typedtree.pattern <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> Typedtree.pattern <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-generalizable"><a href="#val-generalizable" class="anchor"></a><code><span class="keyword">val </span>generalizable : int <span>&#45;&gt;</span> Types.type_expr <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-reset_delayed_checks"><a href="#val-reset_delayed_checks" class="anchor"></a><code><span class="keyword">val </span>reset_delayed_checks : unit <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-force_delayed_checks"><a href="#val-force_delayed_checks" class="anchor"></a><code><span class="keyword">val </span>force_delayed_checks : unit <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-self_coercion"><a href="#val-self_coercion" class="anchor"></a><code><span class="keyword">val </span>self_coercion : (Path.t<span class="keyword"> * </span>Location.t list Pervasives.ref) list Pervasives.ref</code></dt></dl><dl><dt class="spec type" id="type-error"><a href="#type-error" class="anchor"></a><code><span class="keyword">type </span>error</code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-error.Polymorphic_label" class="anchored"><td class="def constructor"><a href="#type-error.Polymorphic_label" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Polymorphic_label</span><span class="keyword"> of </span>Longident.t</code></td></tr><tr id="type-error.Constructor_arity_mismatch" class="anchored"><td class="def constructor"><a href="#type-error.Constructor_arity_mismatch" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Constructor_arity_mismatch</span><span class="keyword"> of </span>Longident.t<span class="keyword"> * </span>int<span class="keyword"> * </span>int</code></td></tr><tr id="type-error.Label_mismatch" class="anchored"><td class="def constructor"><a href="#type-error.Label_mismatch" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Label_mismatch</span><span class="keyword"> of </span>Longident.t<span class="keyword"> * </span>(Types.type_expr<span class="keyword"> * </span>Types.type_expr) list</code></td></tr><tr id="type-error.Pattern_type_clash" class="anchored"><td class="def constructor"><a href="#type-error.Pattern_type_clash" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Pattern_type_clash</span><span class="keyword"> of </span>(Types.type_expr<span class="keyword"> * </span>Types.type_expr) list</code></td></tr><tr id="type-error.Or_pattern_type_clash" class="anchored"><td class="def constructor"><a href="#type-error.Or_pattern_type_clash" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Or_pattern_type_clash</span><span class="keyword"> of </span>Ident.t<span class="keyword"> * </span>(Types.type_expr<span class="keyword"> * </span>Types.type_expr) list</code></td></tr><tr id="type-error.Multiply_bound_variable" class="anchored"><td class="def constructor"><a href="#type-error.Multiply_bound_variable" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Multiply_bound_variable</span><span class="keyword"> of </span>string</code></td></tr><tr id="type-error.Orpat_vars" class="anchored"><td class="def constructor"><a href="#type-error.Orpat_vars" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Orpat_vars</span><span class="keyword"> of </span>Ident.t<span class="keyword"> * </span>Ident.t list</code></td></tr><tr id="type-error.Expr_type_clash" class="anchored"><td class="def constructor"><a href="#type-error.Expr_type_clash" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Expr_type_clash</span><span class="keyword"> of </span>(Types.type_expr<span class="keyword"> * </span>Types.type_expr) list</code></td></tr><tr id="type-error.Apply_non_function" class="anchored"><td class="def constructor"><a href="#type-error.Apply_non_function" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Apply_non_function</span><span class="keyword"> of </span>Types.type_expr</code></td></tr><tr id="type-error.Apply_wrong_label" class="anchored"><td class="def constructor"><a href="#type-error.Apply_wrong_label" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Apply_wrong_label</span><span class="keyword"> of </span>Asttypes.arg_label<span class="keyword"> * </span>Types.type_expr</code></td></tr><tr id="type-error.Label_multiply_defined" class="anchored"><td class="def constructor"><a href="#type-error.Label_multiply_defined" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Label_multiply_defined</span><span class="keyword"> of </span>string</code></td></tr><tr id="type-error.Label_missing" class="anchored"><td class="def constructor"><a href="#type-error.Label_missing" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Label_missing</span><span class="keyword"> of </span>Ident.t list</code></td></tr><tr id="type-error.Label_not_mutable" class="anchored"><td class="def constructor"><a href="#type-error.Label_not_mutable" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Label_not_mutable</span><span class="keyword"> of </span>Longident.t</code></td></tr><tr id="type-error.Wrong_name" class="anchored"><td class="def constructor"><a href="#type-error.Wrong_name" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Wrong_name</span><span class="keyword"> of </span>string<span class="keyword"> * </span>Types.type_expr<span class="keyword"> * </span>string<span class="keyword"> * </span>Path.t<span class="keyword"> * </span>string<span class="keyword"> * </span>string list</code></td></tr><tr id="type-error.Name_type_mismatch" class="anchored"><td class="def constructor"><a href="#type-error.Name_type_mismatch" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Name_type_mismatch</span><span class="keyword"> of </span>string<span class="keyword"> * </span>Longident.t<span class="keyword"> * </span>Path.t<span class="keyword"> * </span>Path.t<span class="keyword"> * </span>(Path.t<span class="keyword"> * </span>Path.t) list</code></td></tr><tr id="type-error.Invalid_format" class="anchored"><td class="def constructor"><a href="#type-error.Invalid_format" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Invalid_format</span><span class="keyword"> of </span>string</code></td></tr><tr id="type-error.Undefined_method" class="anchored"><td class="def constructor"><a href="#type-error.Undefined_method" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Undefined_method</span><span class="keyword"> of </span>Types.type_expr<span class="keyword"> * </span>string<span class="keyword"> * </span>string list option</code></td></tr><tr id="type-error.Undefined_inherited_method" class="anchored"><td class="def constructor"><a href="#type-error.Undefined_inherited_method" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Undefined_inherited_method</span><span class="keyword"> of </span>string<span class="keyword"> * </span>string list</code></td></tr><tr id="type-error.Virtual_class" class="anchored"><td class="def constructor"><a href="#type-error.Virtual_class" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Virtual_class</span><span class="keyword"> of </span>Longident.t</code></td></tr><tr id="type-error.Private_type" class="anchored"><td class="def constructor"><a href="#type-error.Private_type" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Private_type</span><span class="keyword"> of </span>Types.type_expr</code></td></tr><tr id="type-error.Private_label" class="anchored"><td class="def constructor"><a href="#type-error.Private_label" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Private_label</span><span class="keyword"> of </span>Longident.t<span class="keyword"> * </span>Types.type_expr</code></td></tr><tr id="type-error.Unbound_instance_variable" class="anchored"><td class="def constructor"><a href="#type-error.Unbound_instance_variable" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Unbound_instance_variable</span><span class="keyword"> of </span>string<span class="keyword"> * </span>string list</code></td></tr><tr id="type-error.Instance_variable_not_mutable" class="anchored"><td class="def constructor"><a href="#type-error.Instance_variable_not_mutable" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Instance_variable_not_mutable</span><span class="keyword"> of </span>bool<span class="keyword"> * </span>string</code></td></tr><tr id="type-error.Not_subtype" class="anchored"><td class="def constructor"><a href="#type-error.Not_subtype" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Not_subtype</span><span class="keyword"> of </span>(Types.type_expr<span class="keyword"> * </span>Types.type_expr) list<span class="keyword"> * </span>(Types.type_expr<span class="keyword"> * </span>Types.type_expr) list</code></td></tr><tr id="type-error.Outside_class" class="anchored"><td class="def constructor"><a href="#type-error.Outside_class" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Outside_class</span></code></td></tr><tr id="type-error.Value_multiply_overridden" class="anchored"><td class="def constructor"><a href="#type-error.Value_multiply_overridden" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Value_multiply_overridden</span><span class="keyword"> of </span>string</code></td></tr><tr id="type-error.Coercion_failure" class="anchored"><td class="def constructor"><a href="#type-error.Coercion_failure" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Coercion_failure</span><span class="keyword"> of </span>Types.type_expr<span class="keyword"> * </span>Types.type_expr<span class="keyword"> * </span>(Types.type_expr<span class="keyword"> * </span>Types.type_expr) list<span class="keyword"> * </span>bool</code></td></tr><tr id="type-error.Too_many_arguments" class="anchored"><td class="def constructor"><a href="#type-error.Too_many_arguments" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Too_many_arguments</span><span class="keyword"> of </span>bool<span class="keyword"> * </span>Types.type_expr</code></td></tr><tr id="type-error.Abstract_wrong_label" class="anchored"><td class="def constructor"><a href="#type-error.Abstract_wrong_label" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Abstract_wrong_label</span><span class="keyword"> of </span>Asttypes.arg_label<span class="keyword"> * </span>Types.type_expr</code></td></tr><tr id="type-error.Scoping_let_module" class="anchored"><td class="def constructor"><a href="#type-error.Scoping_let_module" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Scoping_let_module</span><span class="keyword"> of </span>string<span class="keyword"> * </span>Types.type_expr</code></td></tr><tr id="type-error.Masked_instance_variable" class="anchored"><td class="def constructor"><a href="#type-error.Masked_instance_variable" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Masked_instance_variable</span><span class="keyword"> of </span>Longident.t</code></td></tr><tr id="type-error.Not_a_variant_type" class="anchored"><td class="def constructor"><a href="#type-error.Not_a_variant_type" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Not_a_variant_type</span><span class="keyword"> of </span>Longident.t</code></td></tr><tr id="type-error.Incoherent_label_order" class="anchored"><td class="def constructor"><a href="#type-error.Incoherent_label_order" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Incoherent_label_order</span></code></td></tr><tr id="type-error.Less_general" class="anchored"><td class="def constructor"><a href="#type-error.Less_general" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Less_general</span><span class="keyword"> of </span>string<span class="keyword"> * </span>(Types.type_expr<span class="keyword"> * </span>Types.type_expr) list</code></td></tr><tr id="type-error.Modules_not_allowed" class="anchored"><td class="def constructor"><a href="#type-error.Modules_not_allowed" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Modules_not_allowed</span></code></td></tr><tr id="type-error.Cannot_infer_signature" class="anchored"><td class="def constructor"><a href="#type-error.Cannot_infer_signature" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Cannot_infer_signature</span></code></td></tr><tr id="type-error.Not_a_packed_module" class="anchored"><td class="def constructor"><a href="#type-error.Not_a_packed_module" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Not_a_packed_module</span><span class="keyword"> of </span>Types.type_expr</code></td></tr><tr id="type-error.Recursive_local_constraint" class="anchored"><td class="def constructor"><a href="#type-error.Recursive_local_constraint" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Recursive_local_constraint</span><span class="keyword"> of </span>(Types.type_expr<span class="keyword"> * </span>Types.type_expr) list</code></td></tr><tr id="type-error.Unexpected_existential" class="anchored"><td class="def constructor"><a href="#type-error.Unexpected_existential" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Unexpected_existential</span></code></td></tr><tr id="type-error.Unqualified_gadt_pattern" class="anchored"><td class="def constructor"><a href="#type-error.Unqualified_gadt_pattern" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Unqualified_gadt_pattern</span><span class="keyword"> of </span>Path.t<span class="keyword"> * </span>string</code></td></tr><tr id="type-error.Invalid_interval" class="anchored"><td class="def constructor"><a href="#type-error.Invalid_interval" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Invalid_interval</span></code></td></tr><tr id="type-error.Invalid_for_loop_index" class="anchored"><td class="def constructor"><a href="#type-error.Invalid_for_loop_index" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Invalid_for_loop_index</span></code></td></tr><tr id="type-error.No_value_clauses" class="anchored"><td class="def constructor"><a href="#type-error.No_value_clauses" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">No_value_clauses</span></code></td></tr><tr id="type-error.Exception_pattern_below_toplevel" class="anchored"><td class="def constructor"><a href="#type-error.Exception_pattern_below_toplevel" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Exception_pattern_below_toplevel</span></code></td></tr><tr id="type-error.Inlined_record_escape" class="anchored"><td class="def constructor"><a href="#type-error.Inlined_record_escape" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Inlined_record_escape</span></code></td></tr><tr id="type-error.Inlined_record_expected" class="anchored"><td class="def constructor"><a href="#type-error.Inlined_record_expected" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Inlined_record_expected</span></code></td></tr><tr id="type-error.Unrefuted_pattern" class="anchored"><td class="def constructor"><a href="#type-error.Unrefuted_pattern" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Unrefuted_pattern</span><span class="keyword"> of </span>Typedtree.pattern</code></td></tr><tr id="type-error.Invalid_extension_constructor_payload" class="anchored"><td class="def constructor"><a href="#type-error.Invalid_extension_constructor_payload" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Invalid_extension_constructor_payload</span></code></td></tr><tr id="type-error.Not_an_extension_constructor" class="anchored"><td class="def constructor"><a href="#type-error.Not_an_extension_constructor" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Not_an_extension_constructor</span></code></td></tr><tr id="type-error.Literal_overflow" class="anchored"><td class="def constructor"><a href="#type-error.Literal_overflow" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Literal_overflow</span><span class="keyword"> of </span>string</code></td></tr><tr id="type-error.Unknown_literal" class="anchored"><td class="def constructor"><a href="#type-error.Unknown_literal" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Unknown_literal</span><span class="keyword"> of </span>string<span class="keyword"> * </span>char</code></td></tr></table></dt></dl><dl><dt class="spec exception" id="exception-Error"><a href="#exception-Error" class="anchor"></a><code><span class="keyword">exception </span></code><code><span class="exception">Error</span><span class="keyword"> of </span>Location.t<span class="keyword"> * </span>Env.t<span class="keyword"> * </span><a href="index.html#type-error">error</a></code></dt><dt class="spec exception" id="exception-Error_forward"><a href="#exception-Error_forward" class="anchor"></a><code><span class="keyword">exception </span></code><code><span class="exception">Error_forward</span><span class="keyword"> of </span>Location.error</code></dt></dl><dl><dt class="spec value" id="val-report_error"><a href="#val-report_error" class="anchor"></a><code><span class="keyword">val </span>report_error : Env.t <span>&#45;&gt;</span> Format.formatter <span>&#45;&gt;</span> <a href="index.html#type-error">error</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-type_module"><a href="#val-type_module" class="anchor"></a><code><span class="keyword">val </span>type_module : (Env.t <span>&#45;&gt;</span> Parsetree.module_expr <span>&#45;&gt;</span> Typedtree.module_expr) Pervasives.ref</code></dt><dt class="spec value" id="val-type_open"><a href="#val-type_open" class="anchor"></a><code><span class="keyword">val </span>type_open : (Asttypes.override_flag <span>&#45;&gt;</span> Env.t <span>&#45;&gt;</span> Location.t <span>&#45;&gt;</span> Longident.t Asttypes.loc <span>&#45;&gt;</span> Path.t<span class="keyword"> * </span>Env.t) Pervasives.ref</code></dt><dt class="spec value" id="val-type_object"><a href="#val-type_object" class="anchor"></a><code><span class="keyword">val </span>type_object : (Env.t <span>&#45;&gt;</span> Location.t <span>&#45;&gt;</span> Parsetree.class_structure <span>&#45;&gt;</span> Typedtree.class_structure<span class="keyword"> * </span>Types.class_signature<span class="keyword"> * </span>string list) Pervasives.ref</code></dt><dt class="spec value" id="val-type_package"><a href="#val-type_package" class="anchor"></a><code><span class="keyword">val </span>type_package : (Env.t <span>&#45;&gt;</span> Parsetree.module_expr <span>&#45;&gt;</span> Path.t <span>&#45;&gt;</span> Longident.t list <span>&#45;&gt;</span> Types.type_expr list <span>&#45;&gt;</span> Typedtree.module_expr<span class="keyword"> * </span>Types.type_expr list) Pervasives.ref</code></dt><dt class="spec value" id="val-create_package_type"><a href="#val-create_package_type" class="anchor"></a><code><span class="keyword">val </span>create_package_type : Location.t <span>&#45;&gt;</span> Env.t <span>&#45;&gt;</span> (Longident.t<span class="keyword"> * </span>(Longident.t<span class="keyword"> * </span>Parsetree.core_type) list) <span>&#45;&gt;</span> Path.t<span class="keyword"> * </span>(Longident.t<span class="keyword"> * </span>Typedtree.core_type) list<span class="keyword"> * </span>Types.type_expr</code></dt><dt class="spec value" id="val-constant"><a href="#val-constant" class="anchor"></a><code><span class="keyword">val </span>constant : Parsetree.constant <span>&#45;&gt;</span> (Asttypes.constant, <a href="index.html#type-error">error</a>) Pervasives.result</code></dt></dl></div></body></html>