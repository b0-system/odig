<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Soup (lambdasoup.Soup)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">lambdasoup</a> &#x00BB; Soup</nav><h1>Module <code>Soup</code></h1><p>Easy functional HTML scraping and manipulation.</p><p>Lambda Soup is an HTML data extraction and analysis library. It supports CSS selectors, DOM traversals, mutation, and HTML output. This very documentation page was generated by <code>ocamldoc</code> and then <a href="https://github.com/aantron/lambda-soup/blob/master/docs/postprocess.ml">rewritten</a> by Lambda Soup!</p><p>Here are some usage examples:</p><pre><code class="ml">open Soup

let soup = read_channel stdin |&gt; parse in

(* Print the page title. *)
soup $ &quot;title&quot; |&gt; R.leaf_text |&gt; print_endline;

(* Print the targets of all links. *)
soup $$ &quot;a[href]&quot;
|&gt; iter (fun a -&gt; print_endline (R.attribute &quot;href&quot; a));

(* Find the first unordered list. *)
let ul = soup $ &quot;ul&quot; in

(* Print the contents of all its items. *)
ul $$ &quot;li&quot;
|&gt; iter (fun li -&gt;
  trimmed_texts li |&gt; String.concat &quot;&quot; |&gt; print_endline)

(* Find all subsequent sibling elements of the same list. *)
let _ = ul $$ &quot;~ *&quot; in

(* Find all previous sibling elements instead. *)
let _ = ul |&gt; previous_siblings |&gt; elements in

(* ... *)</code></pre><p>Lambda Soup is based around two kind of values: <em>nodes</em>, which represent HTML elements, text content, and so on, and <em>traversals</em>, which are lazy sequences of nodes. The top-level node is the <em>soup node</em> (a.k.a. document node), which you typically get by calling <a href="index.html#val-parse"><code>parse</code></a> on a string containing HTML.</p><p>Once you have a node, you call <a href="index.html#val-select"><code>select</code></a> on it to traverse to other nodes using CSS. There are also specialized functions, such as <a href="index.html#val-ancestors"><code>ancestors</code></a> and <a href="index.html#val-previous_siblings"><code>previous_siblings</code></a>, which allow you to traverse in directions that CSS cannot express.</p><p>Traversals can be manipulated with familiar combinators such as <a href="index.html#val-map"><code>map</code></a>, <a href="index.html#val-fold"><code>fold</code></a>, and <a href="index.html#val-filter"><code>filter</code></a>. They can also be terminated early.</p><p>Once you have traversed to a node you are interested in, you can extract its content or attributes, mutate it, cause other side effects, begin another traversal, or do anything else your application requires. Enjoy!</p><p>Lambda Soup is developed on <a href="https://github.com/aantron/lambda-soup">GitHub</a> and distributed under the <a href="https://github.com/aantron/lambda-soup/blob/master/LICENSE.md">BSD license</a>.</p><p>This documentation page is for version 0.6.3 of the library. Documentation for other versions can be downloaded from the <a href="https://github.com/aantron/lambda-soup/releases">releases page</a>.</p><nav class="toc"><ul><li><a href="#types">Types</a></li><li><a href="#high-level-interface">High-level interface</a></li><li><a href="#options">Options</a></li><li><a href="#early-termination">Early termination</a></li><li><a href="#element-access">Element access</a></li><li><a href="#content-access">Content access</a></li><li><a href="#elementary-traversals">Elementary traversals</a></li><li><a href="#combinators">Combinators</a></li><li><a href="#projection">Projection</a></li><li><a href="#convenience">Convenience</a></li><li><a href="#printing">Printing</a></li><li><a href="#parsing-signals">Parsing signals</a></li><li><a href="#equality">Equality</a></li><li><a href="#mutation">Mutation</a></li><li><a href="#i/o">I/O</a></li></ul></nav></header><section><header><h3 id="types"><a href="#types" class="anchor"></a>Types</h3></header><dl><dt class="spec type" id="type-element"><a href="#type-element" class="anchor"></a><code><span class="keyword">type</span> element</code></dt><dt class="spec type" id="type-general"><a href="#type-general" class="anchor"></a><code><span class="keyword">type</span> general</code></dt><dt class="spec type" id="type-soup"><a href="#type-soup" class="anchor"></a><code><span class="keyword">type</span> soup</code></dt><dd><p>&quot;Phantom&quot; types for use with <code>'a node</code>. See explanation below.</p></dd></dl><dl><dt class="spec type" id="type-node"><a href="#type-node" class="anchor"></a><code><span class="keyword">type</span> 'a node</code></dt><dd><p>HTML nodes. These come in three varieties: <code>element node</code> represents a node that is known to be an element, <code>soup node</code> represents an entire document, and <code>general node</code> represents a node that might be anything, including an element, a document, or text. There is no phantom type specifically for text nodes.</p><p>Throughout Lambda Soup, if a function can operate on any kind of node, the argument is typed at <code>'a node</code>. If an element node or the entire document is required, the argument type is <code>element node</code> or <code>soup node</code>, respectively. <code>general node</code> is the result of a function that can't guarantee that it evaluates to only elements or only documents.</p></dd></dl><dl><dt class="spec type" id="type-nodes"><a href="#type-nodes" class="anchor"></a><code><span class="keyword">type</span> 'a nodes</code></dt><dd><p>Sequence of nodes. This is always instantiated as either <code>element nodes</code> or or <code>general nodes</code>. The sequence is <em>lazy</em> in the sense that only as many elements as needed are evaluated. This can be used with <a href="index.html#val-with_stop"><code>with_stop</code></a> to traverse part of a document until some condition is met.</p></dd></dl></section><section><header><h3 id="high-level-interface"><a href="#high-level-interface" class="anchor"></a>High-level interface</h3></header><dl><dt class="spec value" id="val-parse"><a href="#val-parse" class="anchor"></a><code><span class="keyword">val</span> parse : string <span>&#45;&gt;</span> <a href="index.html#type-soup">soup</a> <a href="index.html#type-node">node</a></code></dt><dd><p>Parses the given HTML and produces a document node. Entity references are resolved. The character encoding is detected automatically.</p><p>If you need to parse XML, want finer control over parsing, or want to feed Lambda Soup something other than bytes, see <a href="#2_Parsingsignals">Parsing signals</a>.</p></dd></dl><dl><dt class="spec value" id="val-select"><a href="#val-select" class="anchor"></a><code><span class="keyword">val</span> select : string <span>&#45;&gt;</span> <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> <a href="index.html#type-element">element</a> <a href="index.html#type-nodes">nodes</a></code></dt><dd><p><code>select selector node</code> is all the descendants of <code>node</code> matching CSS selector <code>selector</code>. All <a href="http://www.w3.org/TR/selectors/#selectors">CSS3 selectors</a> are supported, except those which imply layout or a user interface:</p><pre><code class="ml">:link, :visited, :hover, :active, :focus, :target, :lang, :enabled,
:disabled, :checked, :indeterminate, ::first-line, ::first-letter,
::selection, ::before, ::after</code></pre><p>XML namespace selectors are not supported. Lambda Soup supports the canceled <a href="http://www.w3.org/TR/2001/CR-css3-selectors-20011113/#content-selectors"><code>:contains(&quot;foo&quot;)</code></a> pseudo-class.</p><p>In regular CSS, a selector cannot start with a combinator such as <code>&gt;</code>. Lambda Soup allows selectors such as <code>&gt; p</code>, <code>+ p</code>, and <code>~ p</code>, which select immediate children of <code>node</code>, adjacent next siblings, and all next siblings, respectively.</p><p>In addition, you can use the empty selector to select <code>node</code> itself. In this case, note that if <code>node</code> is not an element (for example, it is often the soup node), <code>select</code> will result in nothing: <code>select</code> always results in sequences of <em>element</em> nodes only.</p></dd></dl><dl><dt class="spec value" id="val-select_one"><a href="#val-select_one" class="anchor"></a><code><span class="keyword">val</span> select_one : string <span>&#45;&gt;</span> <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> <a href="index.html#type-element">element</a> <a href="index.html#type-node">node</a> option</code></dt><dd><p>Like <code>select</code>, but evaluates to at most one element. Note that there is also <code>R.select_one</code> if you don't want an optional result, which is explained at <a href="index.html#val-require"><code>require</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-($$)"><a href="#val-($$)" class="anchor"></a><code><span class="keyword">val</span> ($$) : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-element">element</a> <a href="index.html#type-nodes">nodes</a></code></dt><dd><p><code>node $$ selector</code> is the same as <code>select selector node</code>.</p></dd></dl><dl><dt class="spec value" id="val-($?)"><a href="#val-($?)" class="anchor"></a><code><span class="keyword">val</span> ($?) : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-element">element</a> <a href="index.html#type-node">node</a> option</code></dt><dd><p><code>node $? selector</code> is the same as <code>select_one selector node</code>.</p></dd></dl><dl><dt class="spec value" id="val-($)"><a href="#val-($)" class="anchor"></a><code><span class="keyword">val</span> ($) : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-element">element</a> <a href="index.html#type-node">node</a></code></dt><dd><p><code>node $ selector</code> is the same as <code>select_one selector node |&gt; require</code>.</p></dd></dl><dl><dt class="spec module" id="module-Infix"><a href="#module-Infix" class="anchor"></a><code><span class="keyword">module</span> <a href="Infix/index.html">Infix</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Open <code>Soup.Infix</code> instead of <code>Soup</code> to introduce only the infix operators <code>$$</code>, <code>$?</code>, and <code>$</code> into your scope.</p></dd></dl></section><section><header><h3 id="options"><a href="#options" class="anchor"></a>Options</h3></header><dl><dt class="spec value" id="val-require"><a href="#val-require" class="anchor"></a><code><span class="keyword">val</span> require : <span class="type-var">'a</span> option <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>require (Some v)</code> evaluates to <code>v</code>, and <code>require None</code> raises <code>Failure</code>.</p></dd></dl><dl><dt class="spec module" id="module-R"><a href="#module-R" class="anchor"></a><code><span class="keyword">module</span> <a href="R/index.html">R</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>For each function <code>Soup.f</code> that evaluates to an option, <code>Soup.R.f</code> is a version of <code>f</code> that is post-composed with <a href="index.html#val-require"><code>require</code></a>, so, for example, you can write <code>soup |&gt; children |&gt; R.first</code> instead of <code>soup |&gt; children |&gt; first |&gt; require</code>.</p></dd></dl></section><section><header><h3 id="early-termination"><a href="#early-termination" class="anchor"></a>Early termination</h3></header><dl><dt class="spec type" id="type-stop"><a href="#type-stop" class="anchor"></a><code><span class="keyword">type</span> 'a stop</code><code> = </code><code>{</code><table class="record"><tr id="type-stop.throw" class="anchored"><td class="def field"><a href="#type-stop.throw" class="anchor"></a><code>throw : b. <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>;</code></td></tr></table><code>}</code></dt><dd><p>Used for early termination. See <a href="index.html#val-with_stop"><code>with_stop</code></a> below.</p></dd></dl><dl><dt class="spec value" id="val-with_stop"><a href="#val-with_stop" class="anchor"></a><code><span class="keyword">val</span> with_stop : (<span class="type-var">'a</span> <a href="index.html#type-stop">stop</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>with_stop (fun stop -&gt; e)</code> behaves as <code>e</code>. However, if the evaluation of <code>e</code> calls <code>stop.throw v</code>, the whole expression immediately evaluates to <code>v</code> instead.</p><p>For example, here is an expression that finds the first node with a <code>draggable</code> attribute, stopping traversal immediately when that occurs:</p><pre><code class="ml">with_stop (fun stop -&gt;
  some_root_node
  |&gt; descendants
  |&gt; elements
  |&gt; iter (fun element -&gt;
    if has_attribute &quot;draggable&quot; element then
      stop.throw (Some element));
  None)</code></pre></dd></dl></section><section><header><h3 id="element-access"><a href="#element-access" class="anchor"></a>Element access</h3></header><dl><dt class="spec value" id="val-name"><a href="#val-name" class="anchor"></a><code><span class="keyword">val</span> name : <a href="index.html#type-element">element</a> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> string</code></dt><dd><p>The element's tag name. For example, an <code>&lt;a&gt;</code> element has tag name <code>a</code>. All tag names are converted to lowercase.</p></dd></dl><dl><dt class="spec value" id="val-attribute"><a href="#val-attribute" class="anchor"></a><code><span class="keyword">val</span> attribute : string <span>&#45;&gt;</span> <a href="index.html#type-element">element</a> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> string option</code></dt><dd><p><code>attribute attr element</code> retrieves the value of attribute <code>attr</code> from the given element.</p></dd></dl><dl><dt class="spec value" id="val-classes"><a href="#val-classes" class="anchor"></a><code><span class="keyword">val</span> classes : <a href="index.html#type-element">element</a> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> string list</code></dt><dd><p>The element's class list. For example, <code>&lt;a class=&quot;foo bar&quot;&gt;</code> has class list <code>[&quot;foo&quot;; &quot;bar&quot;]</code>.</p></dd></dl><dl><dt class="spec value" id="val-id"><a href="#val-id" class="anchor"></a><code><span class="keyword">val</span> id : <a href="index.html#type-element">element</a> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> string option</code></dt><dd><p>The element's id.</p></dd></dl><dl><dt class="spec value" id="val-has_attribute"><a href="#val-has_attribute" class="anchor"></a><code><span class="keyword">val</span> has_attribute : string <span>&#45;&gt;</span> <a href="index.html#type-element">element</a> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>has_attribute attr element</code> indicates whether <code>element</code> has attribute <code>attr</code>.</p></dd></dl><dl><dt class="spec value" id="val-fold_attributes"><a href="#val-fold_attributes" class="anchor"></a><code><span class="keyword">val</span> fold_attributes : (<span class="type-var">'a</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-element">element</a> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>fold_attributes f init element</code> applies <code>f</code> successively to the names and values of the attributes of <code>element</code>. The first <code>string</code> argument to <code>f</code> is the attribute name, and the second is the value.</p></dd></dl><dl><dt class="spec value" id="val-coerce"><a href="#val-coerce" class="anchor"></a><code><span class="keyword">val</span> coerce : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> <a href="index.html#type-general">general</a> <a href="index.html#type-node">node</a></code></dt><dd><p><code>coerce node</code> evaluates to <code>node</code>, but with type <code>general node</code>.</p></dd></dl><dl><dt class="spec value" id="val-element"><a href="#val-element" class="anchor"></a><code><span class="keyword">val</span> element : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> <a href="index.html#type-element">element</a> <a href="index.html#type-node">node</a> option</code></dt><dd><p>Given any node, asserts that it is an element <code>e</code>. If so, evaluates to <code>Some e</code>. Otherwise, evaluates to <code>None</code>.</p></dd></dl><dl><dt class="spec value" id="val-elements"><a href="#val-elements" class="anchor"></a><code><span class="keyword">val</span> elements : <span class="type-var">_</span> <a href="index.html#type-nodes">nodes</a> <span>&#45;&gt;</span> <a href="index.html#type-element">element</a> <a href="index.html#type-nodes">nodes</a></code></dt><dd><p>Filters non-elements from a sequence of nodes.</p></dd></dl><dl><dt class="spec value" id="val-is_element"><a href="#val-is_element" class="anchor"></a><code><span class="keyword">val</span> is_element : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Indicates whether the given node is an element.</p></dd></dl></section><section><header><h3 id="content-access"><a href="#content-access" class="anchor"></a>Content access</h3></header><dl><dt class="spec value" id="val-texts"><a href="#val-texts" class="anchor"></a><code><span class="keyword">val</span> texts : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> string list</code></dt><dd><p><code>texts node</code> is the content of all text nodes that are descendants of <code>node</code>. If <code>node</code> is itself a text node, evaluates to <code>node</code>'s content.</p></dd></dl><dl><dt class="spec value" id="val-trimmed_texts"><a href="#val-trimmed_texts" class="anchor"></a><code><span class="keyword">val</span> trimmed_texts : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> string list</code></dt><dd><p>Same as <a href="index.html#val-texts"><code>texts</code></a>, but all strings are passed through <code>String.trim</code>, and then all empty strings are filtered out.</p></dd></dl><dl><dt class="spec value" id="val-leaf_text"><a href="#val-leaf_text" class="anchor"></a><code><span class="keyword">val</span> leaf_text : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> string option</code></dt><dd><p><code>leaf_text node</code> retrieves the content of one text node in <code>node</code>:</p><ul><li>If <code>node</code> is a text node itself, with value <code>s</code>, <code>leaf_text node</code> evaluates to <code>Some s</code>.</li><li>If <code>node</code> is an element or soup node, then, <code>leaf_text node</code> filters out all text children of <code>node</code> containing only whitespace. If there is only one child <code>child</code> remaining, it evaluates to <code>leaf_text child</code>. If there are no children remaining, it evaluates to <code>Some &quot;&quot;</code>. If there are two or more children remaining, it evaluates to <code>None</code>.</li></ul><p>Here are some examples of what <code>leaf_text</code> produces for various nodes:</p><pre><code class="ml">some text                                =&gt;   Some &quot;some text&quot;
&lt;p&gt;some text&lt;/p&gt;                         =&gt;   Some &quot;some text&quot;
&lt;div&gt;&lt;p&gt;some text&lt;/p&gt;&lt;/div&gt;              =&gt;   Some &quot;some text&quot;
&lt;div&gt; &lt;p&gt;some text&lt;/p&gt;&lt;/div&gt;             =&gt;   Some &quot;some text&quot;
&lt;div&gt;&lt;p&gt;some text&lt;/p&gt;&lt;p&gt;more&lt;/p&gt;&lt;/div&gt;   =&gt;   None
&lt;div&gt;&lt;/div&gt;                              =&gt;   Some &quot;&quot;</code></pre></dd></dl></section><section><header><h3 id="elementary-traversals"><a href="#elementary-traversals" class="anchor"></a>Elementary traversals</h3></header><dl><dt class="spec value" id="val-children"><a href="#val-children" class="anchor"></a><code><span class="keyword">val</span> children : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> <a href="index.html#type-general">general</a> <a href="index.html#type-nodes">nodes</a></code></dt><dd><p><code>children node</code> is the sequence of all children of <code>node</code>. If <code>node</code> is a text node, the traversal is empty.</p></dd></dl><dl><dt class="spec value" id="val-descendants"><a href="#val-descendants" class="anchor"></a><code><span class="keyword">val</span> descendants : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> <a href="index.html#type-general">general</a> <a href="index.html#type-nodes">nodes</a></code></dt><dd><p><code>descendants node</code> is the sequence of all descendants of <code>node</code>. <code>node</code> is not considered to be its own descendant. If <code>node</code> is a text node, the traversal is empty.</p></dd></dl><dl><dt class="spec value" id="val-ancestors"><a href="#val-ancestors" class="anchor"></a><code><span class="keyword">val</span> ancestors : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> <a href="index.html#type-element">element</a> <a href="index.html#type-nodes">nodes</a></code></dt><dd><p><code>ancestors node</code> is the sequence of all ancestors of <code>node</code>. <code>node</code> is not considered to be its own ancestor. The soup node is not included. Ancestors are ordered by proximity to <code>node</code>, i.e. the sequence goes up the DOM tree to a root element.</p></dd></dl><dl><dt class="spec value" id="val-siblings"><a href="#val-siblings" class="anchor"></a><code><span class="keyword">val</span> siblings : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> <a href="index.html#type-general">general</a> <a href="index.html#type-nodes">nodes</a></code></dt><dd><p><code>siblings node</code> is the sequence of all siblings of <code>node</code>. <code>node</code> is not considered to be its own sibling. The siblings are ordered as they appear in the child list of <code>node</code>'s parent.</p></dd></dl><dl><dt class="spec value" id="val-next_siblings"><a href="#val-next_siblings" class="anchor"></a><code><span class="keyword">val</span> next_siblings : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> <a href="index.html#type-general">general</a> <a href="index.html#type-nodes">nodes</a></code></dt><dd><p>Like <a href="index.html#val-siblings"><code>siblings</code></a>, but only those siblings which follow <code>node</code> in its parent's child list.</p></dd></dl><dl><dt class="spec value" id="val-previous_siblings"><a href="#val-previous_siblings" class="anchor"></a><code><span class="keyword">val</span> previous_siblings : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> <a href="index.html#type-general">general</a> <a href="index.html#type-nodes">nodes</a></code></dt><dd><p>Like <a href="index.html#val-siblings"><code>siblings</code></a>, but only those siblings which precede <code>node</code> in its parent's child list, and ordered by proximity to <code>node</code>, i.e. the reverse order of appearance in <code>node</code>'s parent's child list.</p></dd></dl></section><section><header><h3 id="combinators"><a href="#combinators" class="anchor"></a>Combinators</h3></header><dl><dt class="spec value" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span class="keyword">val</span> fold : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-nodes">nodes</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>fold f init s</code> folds <code>f</code> over the nodes of <code>s</code>, i.e. if <code>s</code> is <code>n, n', n'', ...</code>, evaluates <code>f (f (f init n) n') n'' ...</code>.</p></dd></dl><dl><dt class="spec value" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span class="keyword">val</span> filter : (<span class="type-var">'a</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-nodes">nodes</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-nodes">nodes</a></code></dt><dd><p><code>filter f s</code> is the sequence consisting of the nodes <code>n</code> of <code>s</code> for which <code>f n</code> evaluates to <code>true</code>.</p></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : (<span class="type-var">'a</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-node">node</a>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-nodes">nodes</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-nodes">nodes</a></code></dt><dd><p><code>map f s</code> is the sequence consisting of nodes <code>f n</code> for each node <code>n</code> of <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-filter_map"><a href="#val-filter_map" class="anchor"></a><code><span class="keyword">val</span> filter_map : (<span class="type-var">'a</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-node">node</a> option) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-nodes">nodes</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-nodes">nodes</a></code></dt><dd><p><code>filter_map f s</code> is the sequence consisting of nodes <code>n'</code> for each node <code>n</code> of <code>s</code> for which <code>f n</code> evaluates to <code>Some n'</code>. Nodes for which <code>f n</code> evaluates to <code>None</code> are dropped.</p></dd></dl><dl><dt class="spec value" id="val-flatten"><a href="#val-flatten" class="anchor"></a><code><span class="keyword">val</span> flatten : (<span class="type-var">'a</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-nodes">nodes</a>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-nodes">nodes</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-nodes">nodes</a></code></dt><dd><p><code>flatten f s</code> is the sequence consisting of the concatenation of all the sequences <code>f n</code> for each <code>n</code> in <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : (<span class="type-var">'a</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-nodes">nodes</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>iter f s</code> applies <code>f</code> to each node in <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-rev"><a href="#val-rev" class="anchor"></a><code><span class="keyword">val</span> rev : <span class="type-var">'a</span> <a href="index.html#type-nodes">nodes</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-nodes">nodes</a></code></dt><dd><p>Reverses the given node sequence. Note that this forces traversal of the sequence.</p></dd></dl><dl><dt class="spec value" id="val-to_list"><a href="#val-to_list" class="anchor"></a><code><span class="keyword">val</span> to_list : <span class="type-var">'a</span> <a href="index.html#type-nodes">nodes</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-node">node</a> list</code></dt><dd><p>Converts the given node sequence to a list.</p></dd></dl></section><section><header><h3 id="projection"><a href="#projection" class="anchor"></a>Projection</h3></header><dl><dt class="spec value" id="val-nth"><a href="#val-nth" class="anchor"></a><code><span class="keyword">val</span> nth : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-nodes">nodes</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-node">node</a> option</code></dt><dd><p><code>nth n s</code> evaluates to the <code>n</code>th member of <code>s</code>, if it is present. The index is 1-based. This is for consistency with the CSS <code>:nth-child</code> selectors.</p></dd></dl><dl><dt class="spec value" id="val-first"><a href="#val-first" class="anchor"></a><code><span class="keyword">val</span> first : <span class="type-var">'a</span> <a href="index.html#type-nodes">nodes</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-node">node</a> option</code></dt><dd><p>Evaluates to the first node of the given sequence.</p></dd></dl><dl><dt class="spec value" id="val-last"><a href="#val-last" class="anchor"></a><code><span class="keyword">val</span> last : <span class="type-var">'a</span> <a href="index.html#type-nodes">nodes</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-node">node</a> option</code></dt><dd><p>Evaluates the entire given sequence and returns the last node.</p></dd></dl><dl><dt class="spec value" id="val-count"><a href="#val-count" class="anchor"></a><code><span class="keyword">val</span> count : <span class="type-var">'a</span> <a href="index.html#type-nodes">nodes</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Evaluates the entire given sequence and then returns the number of nodes.</p></dd></dl><dl><dt class="spec value" id="val-index_of"><a href="#val-index_of" class="anchor"></a><code><span class="keyword">val</span> index_of : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Evaluates to the index of the given node in its parent's child list. If the node has no parent, the index is 1. The index is 1-based, according to CSS convention.</p></dd></dl><dl><dt class="spec value" id="val-index_of_element"><a href="#val-index_of_element" class="anchor"></a><code><span class="keyword">val</span> index_of_element : <a href="index.html#type-element">element</a> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Evaluates to the element index of the given element in the parent's child list. That is, the index of the given element when the parent's non-element children are disregarded. The index is 1-based, according to CSS convention.</p></dd></dl></section><section><header><h3 id="convenience"><a href="#convenience" class="anchor"></a>Convenience</h3></header><dl><dt class="spec value" id="val-tags"><a href="#val-tags" class="anchor"></a><code><span class="keyword">val</span> tags : string <span>&#45;&gt;</span> <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> <a href="index.html#type-element">element</a> <a href="index.html#type-nodes">nodes</a></code></dt><dd><p>Evaluates to all descendant elements of the given node that have the given tag name. For example, <code>some_root_node |&gt; tags &quot;a&quot;</code> is a sequence of all <code>a</code> elements under <code>some_root_node</code>. It is equivalent to</p><pre><code class="ml">some_root_node
|&gt; descendants |&gt; elements |&gt; filter (fun e -&gt; name e = &quot;a&quot;)</code></pre><p>and</p><pre><code class="ml">some_root_node $$ &quot;a&quot;</code></pre><p>Tag names are case-insensitive.</p></dd></dl><dl><dt class="spec value" id="val-tag"><a href="#val-tag" class="anchor"></a><code><span class="keyword">val</span> tag : string <span>&#45;&gt;</span> <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> <a href="index.html#type-element">element</a> <a href="index.html#type-node">node</a> option</code></dt><dd><p>Like <a href="index.html#val-tags"><code>tags</code></a>, but evaluates to only the first element.</p></dd></dl><dl><dt class="spec value" id="val-parent"><a href="#val-parent" class="anchor"></a><code><span class="keyword">val</span> parent : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> <a href="index.html#type-element">element</a> <a href="index.html#type-node">node</a> option</code></dt><dd><p>Given a node, evaluates to its parent element, if it has one. Note that root nodes do not have a parent <em>element</em>, as their parent is the soup node. Equivalent to <code>n |&gt; ancestors |&gt; first</code>.</p></dd></dl><dl><dt class="spec value" id="val-is_root"><a href="#val-is_root" class="anchor"></a><code><span class="keyword">val</span> is_root : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Indicates whether the given node is not a soup node, and either has no parent, or its parent is a soup node.</p></dd></dl><dl><dt class="spec value" id="val-child"><a href="#val-child" class="anchor"></a><code><span class="keyword">val</span> child : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> <a href="index.html#type-general">general</a> <a href="index.html#type-node">node</a> option</code></dt><dd><p><code>child node</code> evaluates to <code>node</code>'s first child. Equivalent to <code>node |&gt; children |&gt; first</code>.</p></dd></dl><dl><dt class="spec value" id="val-child_element"><a href="#val-child_element" class="anchor"></a><code><span class="keyword">val</span> child_element : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> <a href="index.html#type-element">element</a> <a href="index.html#type-node">node</a> option</code></dt><dd><p><code>child_element node</code> evaluates to <code>node</code>'s first child element. Equivalent to <code>node |&gt; children |&gt; elements |&gt; first</code>.</p></dd></dl><dl><dt class="spec value" id="val-next_sibling"><a href="#val-next_sibling" class="anchor"></a><code><span class="keyword">val</span> next_sibling : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> <a href="index.html#type-general">general</a> <a href="index.html#type-node">node</a> option</code></dt><dd><p><code>next_sibling node</code> is the next sibling of <code>node</code> in <code>node</code>'s parent's child list. Equivalent to <code>node |&gt; next_siblings |&gt; first</code>.</p></dd></dl><dl><dt class="spec value" id="val-previous_sibling"><a href="#val-previous_sibling" class="anchor"></a><code><span class="keyword">val</span> previous_sibling : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> <a href="index.html#type-general">general</a> <a href="index.html#type-node">node</a> option</code></dt><dd><p>Like <a href="index.html#val-next_sibling"><code>next_sibling</code></a>, but for the preceding sibling instead.</p></dd></dl><dl><dt class="spec value" id="val-next_element"><a href="#val-next_element" class="anchor"></a><code><span class="keyword">val</span> next_element : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> <a href="index.html#type-element">element</a> <a href="index.html#type-node">node</a> option</code></dt><dd><p><code>next_element node</code> is the next sibling of <code>node</code> that is an element. Equivalent to <code>n |&gt; next_siblings |&gt; elements |&gt; first</code>.</p></dd></dl><dl><dt class="spec value" id="val-previous_element"><a href="#val-previous_element" class="anchor"></a><code><span class="keyword">val</span> previous_element : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> <a href="index.html#type-element">element</a> <a href="index.html#type-node">node</a> option</code></dt><dd><p>Like <a href="index.html#val-next_element"><code>next_element</code></a>, but for the preceding siblings instead.</p></dd></dl><dl><dt class="spec value" id="val-no_children"><a href="#val-no_children" class="anchor"></a><code><span class="keyword">val</span> no_children : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Indicates whether the given node has no child nodes.</p></dd></dl><dl><dt class="spec value" id="val-at_most_one_child"><a href="#val-at_most_one_child" class="anchor"></a><code><span class="keyword">val</span> at_most_one_child : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Indicates whether the given node has at most one child node.</p></dd></dl></section><section><header><h3 id="printing"><a href="#printing" class="anchor"></a>Printing</h3></header><dl><dt class="spec value" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span class="keyword">val</span> to_string : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> string</code></dt><dd><p>Converts the node tree rooted at the given node to an HTML5 string, preserving whitespace nodes.</p></dd></dl><dl><dt class="spec value" id="val-pretty_print"><a href="#val-pretty_print" class="anchor"></a><code><span class="keyword">val</span> pretty_print : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> string</code></dt><dd><p>Converts the node tree rooted at the given node to an HTML5 string formatted for easy reading by humans, difference algorthims, etc.</p><p>Note that this can change the whitespace structure of the HTML, so it may display differently in a browser than the original parsed document.</p></dd></dl></section><section><header><h3 id="parsing-signals"><a href="#parsing-signals" class="anchor"></a>Parsing signals</h3><p>Lambda Soup uses <a href="https://github.com/aantron/markup.ml">Markup.ml</a> internally to parse and write markup. If you wish to:</p><ul><li>scrape HTML output of some process without first writing it to a string,</li><li>scrape XML,</li><li>have fine control over how parsing is done, such as encoding selection, or</li><li>run the input or output of Lambda Soup through streaming filters,</li></ul><p>then you should use the functions below instead of <a href="index.html#val-parse"><code>parse</code></a> and <a href="index.html#val-to_string"><code>to_string</code></a>.</p><p>See the <a href="http://aantron.github.io/markup.ml/">Markup.ml documentation</a> for a description of the types involved. The <a href="https://github.com/aantron/markup.ml#overview-and-basic-usage">Markup.ml overview</a> may be a good place to start.</p></header><dl><dt class="spec value" id="val-signals"><a href="#val-signals" class="anchor"></a><code><span class="keyword">val</span> signals : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> (<a href="../../markup/Markup/index.html#type-signal">Markup.signal</a>, <a href="../../markup/Markup/index.html#type-sync">Markup.sync</a>) <a href="../../markup/Markup/index.html#type-stream">Markup.stream</a></code></dt><dd><p>Converts the node tree rooted at the given node to a stream of Markup.ml signals. This underlies <a href="index.html#val-to_string"><code>to_string</code></a> and <a href="index.html#val-pretty_print"><code>pretty_print</code></a>.</p><p>For example, you can use this function together with <a href="http://aantron.github.io/markup.ml/#VALwrite_xml"><code>Markup.write_xml</code></a> to output XML, instead of HTML:</p><pre><code class="ml">soup |&gt; signals |&gt; Markup.write_xml |&gt; Markup.to_string</code></pre></dd></dl><dl><dt class="spec value" id="val-from_signals"><a href="#val-from_signals" class="anchor"></a><code><span class="keyword">val</span> from_signals : (<a href="../../markup/Markup/index.html#type-signal">Markup.signal</a>, <a href="../../markup/Markup/index.html#type-sync">Markup.sync</a>) <a href="../../markup/Markup/index.html#type-stream">Markup.stream</a> <span>&#45;&gt;</span> <a href="index.html#type-soup">soup</a> <a href="index.html#type-node">node</a></code></dt><dd><p>Converts a stream of Markup.ml signals to a Lambda Soup document. This underlies <a href="index.html#val-parse"><code>parse</code></a>.</p><p>For example, you can use this function together with <a href="http://aantron.github.io/markup.ml/#VALparse_xml"><code>Markup.parse_xml</code></a> to load XML into Lambda Soup:</p><pre><code class="ml">Markup.string s |&gt; Markup.parse_xml |&gt; Markup.signals |&gt; from_signals</code></pre><p>Namespaces are ignored at the moment.</p></dd></dl></section><section><header><h3 id="equality"><a href="#equality" class="anchor"></a>Equality</h3></header><dl><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val</span> equal : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>equal n n'</code> recursively tests the node trees rooted at <code>n</code> and <code>n'</code> for equality. To test <code>true</code>, the trees must be identical, including whitespace text nodes. Class attributes and other multi-valued attributes are compared literally: classes must be listed in the same order, with the same amount of whitespace in the attribute value. For the purposes of comparison, adjacent text nodes are merged, and empty text nodes are ignored: this is the standard HTML normalization procedure.</p></dd></dl><dl><dt class="spec value" id="val-equal_modulo_whitespace"><a href="#val-equal_modulo_whitespace" class="anchor"></a><code><span class="keyword">val</span> equal_modulo_whitespace : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>equal_modulo_whitespace n n'</code> is like <code>equal n n'</code>, but all text nodes have their values passed through <code>String.trim</code>. Text nodes that become empty are then ignored for the purpose of comparison, as in <code>equal</code>.</p></dd></dl></section><section><header><h3 id="mutation"><a href="#mutation" class="anchor"></a>Mutation</h3></header><dl><dt class="spec value" id="val-create_element"><a href="#val-create_element" class="anchor"></a><code><span class="keyword">val</span> create_element : ?&#8288;id:string <span>&#45;&gt;</span> ?&#8288;class_:string <span>&#45;&gt;</span> ?&#8288;classes:string list <span>&#45;&gt;</span> ?&#8288;attributes:(string * string) list <span>&#45;&gt;</span> ?&#8288;inner_text:string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-element">element</a> <a href="index.html#type-node">node</a></code></dt><dd><p><code>create_element tag</code> creates a new element with the name <code>tag</code>.</p><p>If <code>~attributes</code> is specified, the given attributes are added to the element. <code>~attributes</code> defaults to <code>[]</code>.</p><p>If <code>~classes</code> is specified, the class names are concatenated into a single string <code>s</code> and the <code>class</code> attribute is set on the element to the resulting value. This takes precedence over <code>~attributes</code>.</p><p>If <code>~class</code> is specified, the class is set on the element. This takes precedence over both <code>~attributes</code> and <code>~classes</code>.</p><p>If <code>~id</code> is specified, the id is set. This takes precedence over <code>~attributes</code>.</p><p>If <code>~inner_text</code> is specified, a text node is created with the given string, and made the single child of the new element.</p></dd></dl><dl><dt class="spec value" id="val-create_text"><a href="#val-create_text" class="anchor"></a><code><span class="keyword">val</span> create_text : string <span>&#45;&gt;</span> <a href="index.html#type-general">general</a> <a href="index.html#type-node">node</a></code></dt><dd><p>Creates a new text node with the given content.</p></dd></dl><dl><dt class="spec value" id="val-create_soup"><a href="#val-create_soup" class="anchor"></a><code><span class="keyword">val</span> create_soup : unit <span>&#45;&gt;</span> <a href="index.html#type-soup">soup</a> <a href="index.html#type-node">node</a></code></dt><dd><p>Creates a new empty document node.</p></dd></dl><dl><dt class="spec value" id="val-append_child"><a href="#val-append_child" class="anchor"></a><code><span class="keyword">val</span> append_child : <a href="index.html#type-element">element</a> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>append_child element node</code> adds <code>node</code> to the end of the child list of <code>element</code>.</p></dd></dl><dl><dt class="spec value" id="val-prepend_child"><a href="#val-prepend_child" class="anchor"></a><code><span class="keyword">val</span> prepend_child : <a href="index.html#type-element">element</a> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>prepend_child element node</code> adds <code>node</code> to the beginning of the child list of <code>element</code>.</p></dd></dl><dl><dt class="spec value" id="val-insert_at_index"><a href="#val-insert_at_index" class="anchor"></a><code><span class="keyword">val</span> insert_at_index : int <span>&#45;&gt;</span> <a href="index.html#type-element">element</a> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>insert_at_index k element node</code> makes <code>node</code> the <code>k</code>th child of <code>element</code>. Note that the index is 1-based. If <code>k</code> is outside the range of current valid indices, <code>node</code> is inserted at the beginning or end of <code>element</code>'s child list.</p></dd></dl><dl><dt class="spec value" id="val-insert_before"><a href="#val-insert_before" class="anchor"></a><code><span class="keyword">val</span> insert_before : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>insert_before node node'</code> inserts <code>node'</code> immediately before <code>node</code> in <code>node</code>'s parent's child list.</p></dd></dl><dl><dt class="spec value" id="val-insert_after"><a href="#val-insert_after" class="anchor"></a><code><span class="keyword">val</span> insert_after : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>insert_after node node'</code> inserts <code>node'</code> immediately after <code>node</code> in <code>node</code>'s parent's child list.</p></dd></dl><dl><dt class="spec value" id="val-delete"><a href="#val-delete" class="anchor"></a><code><span class="keyword">val</span> delete : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Deletes the given node by unlinking it from its parent. If the node has descendants, they are implicitly deleted by this operation as well, in the sense that they become unreachable from the parent.</p></dd></dl><dl><dt class="spec value" id="val-clear"><a href="#val-clear" class="anchor"></a><code><span class="keyword">val</span> clear : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Unlinks all children of the given node.</p></dd></dl><dl><dt class="spec value" id="val-replace"><a href="#val-replace" class="anchor"></a><code><span class="keyword">val</span> replace : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>replace target other</code> mutably replaces <code>target</code> with <code>other</code>. <code>target</code> and <code>other</code> are both deleted from their respective document trees. Then, <code>other</code> is inserted where <code>target</code> used to be in its document tree.</p><p>Note that you cannot replace multiple targets with <code>other</code>: <code>replace</code> will work as expected for the first target, but for the second target, it will <em>remove</em> <code>other</code> from where the first target was, and insert it where the second target is. To replace multiple targets, you need multiple copies of <code>other</code>.</p></dd></dl><dl><dt class="spec value" id="val-swap"><a href="#val-swap" class="anchor"></a><code><span class="keyword">val</span> swap : <a href="index.html#type-element">element</a> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> <a href="index.html#type-element">element</a> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>swap element element'</code> replaces <code>element</code> with <code>element'</code> in <code>element</code>'s parent's child list. All children of <code>element</code> are transferred to <code>element'</code>, and all original children of <code>element'</code> are transferred to <code>element</code>.</p></dd></dl><dl><dt class="spec value" id="val-wrap"><a href="#val-wrap" class="anchor"></a><code><span class="keyword">val</span> wrap : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> <a href="index.html#type-element">element</a> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>wrap node element</code> inserts <code>element</code> in the place of <code>node</code>, and then makes <code>node</code> <code>element</code>'s child. All original children of <code>element</code> are unlinked.</p></dd></dl><dl><dt class="spec value" id="val-unwrap"><a href="#val-unwrap" class="anchor"></a><code><span class="keyword">val</span> unwrap : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>unwrap node</code> unlinks <code>node</code>, and inserts all of <code>node</code>'s children as children of <code>node</code>'s parent at the former location of <code>node</code>.</p></dd></dl><dl><dt class="spec value" id="val-append_root"><a href="#val-append_root" class="anchor"></a><code><span class="keyword">val</span> append_root : <a href="index.html#type-soup">soup</a> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>append_root soup node</code> adds <code>node</code> as the last root node of <code>soup</code>.</p></dd></dl><dl><dt class="spec value" id="val-set_name"><a href="#val-set_name" class="anchor"></a><code><span class="keyword">val</span> set_name : string <span>&#45;&gt;</span> <a href="index.html#type-element">element</a> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Sets the tag name of the given element.</p></dd></dl><dl><dt class="spec value" id="val-set_attribute"><a href="#val-set_attribute" class="anchor"></a><code><span class="keyword">val</span> set_attribute : string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-element">element</a> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>set_attribute attr value element</code> sets the value of attribute <code>attr</code> on <code>element</code> to <code>value</code>. If the attribute is not present, it is added to <code>element</code>. If it is already present, the value is replaced.</p></dd></dl><dl><dt class="spec value" id="val-delete_attribute"><a href="#val-delete_attribute" class="anchor"></a><code><span class="keyword">val</span> delete_attribute : string <span>&#45;&gt;</span> <a href="index.html#type-element">element</a> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Removes the given attribute from the given element. If the attribute is not present, has no effect.</p></dd></dl><dl><dt class="spec value" id="val-add_class"><a href="#val-add_class" class="anchor"></a><code><span class="keyword">val</span> add_class : string <span>&#45;&gt;</span> <a href="index.html#type-element">element</a> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>add_class c element</code> adds class <code>c</code> to <code>element</code>, if <code>element</code> does not already have class <code>c</code>.</p></dd></dl><dl><dt class="spec value" id="val-remove_class"><a href="#val-remove_class" class="anchor"></a><code><span class="keyword">val</span> remove_class : string <span>&#45;&gt;</span> <a href="index.html#type-element">element</a> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>remove_class c element</code> removes class <code>c</code> from <code>element</code>, if <code>element</code> has class <code>c</code>.</p></dd></dl></section><section><header><h3 id="i/o"><a href="#i/o" class="anchor"></a>I/O</h3><p>Lambda Soup is not an I/O library. However, it provides a few simple helpers based on standard I/O functions in <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#6_Inputoutput"><code>Pervasives</code></a>. These should not be used for &quot;serious&quot; code. They are only for when you need to get something done quickly, and/or don't care about corner cases, concurrency, or excellent reliability. In such cases, they allow you to avoid writing I/O wrappers or using additional libraries.</p><p>Using these, you can write little command-line scrapers and filters:</p><pre><code class="ml">let () =
  let soup = read_channel stdin |&gt; parse in
  let () = (* ...do things to soup... *) in
  soup |&gt; to_string |&gt; write_channel stdout</code></pre><p>If the above is compiled to a file <code>scrape</code>, you can then run</p><pre><code class="ml">curl -L &quot;http://location.com&quot; | ./scrape</code></pre></header><dl><dt class="spec value" id="val-read_file"><a href="#val-read_file" class="anchor"></a><code><span class="keyword">val</span> read_file : string <span>&#45;&gt;</span> string</code></dt><dd><p>Reads the entire contents of the file with the given path. Raises <code>Sys_error</code> on failure.</p></dd></dl><dl><dt class="spec value" id="val-read_channel"><a href="#val-read_channel" class="anchor"></a><code><span class="keyword">val</span> read_channel : <a href="../../ocaml/Stdlib/index.html#type-in_channel">Stdlib.in_channel</a> <span>&#45;&gt;</span> string</code></dt><dd><p>Reads all bytes from the given channel.</p></dd></dl><dl><dt class="spec value" id="val-write_file"><a href="#val-write_file" class="anchor"></a><code><span class="keyword">val</span> write_file : string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> unit</code></dt><dd><p><code>write_file path data</code> writes <code>data</code> to the file given by <code>path</code>. If the file already exists, it is truncated (erased). If you want to append to file, use <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#VALopen_out_gen"><code>open_out_gen</code></a> with the necessary flags, and pass the resulting channel to <code>write_channel</code>. Raises <code>Sys_error</code> on failure.</p></dd></dl><dl><dt class="spec value" id="val-write_channel"><a href="#val-write_channel" class="anchor"></a><code><span class="keyword">val</span> write_channel : <a href="../../ocaml/Stdlib/index.html#type-out_channel">Stdlib.out_channel</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> unit</code></dt><dd><p>Writes the given data to the given channel.</p></dd></dl></section></div></body></html>