<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Consumer (async_kernel.Async_kernel__Pipe.Consumer)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">async_kernel</a> &#x00BB; <a href="../index.html">Async_kernel__Pipe</a> &#x00BB; Consumer</nav><h1>Module <code>Async_kernel__Pipe.Consumer</code></h1></header><aside><p>A <code>Consumer</code> is used to augment our notion of flushing (<code>Pipe.upstream_flushed</code> and <code>Pipe.downstream_flushed</code>) to include the time spent processing an element once it has been removed from the pipe. It can be thought of as sitting at the end of a pipe, or between two pipes, and it provides more detailed feedback on the time an element spends outside of the pipe proper. So we have the following two cases:</p><pre>        Pipe --&gt; Consumer
        Pipe --&gt; Consumer --&gt; Pipe --&gt; ...</pre><p>The time outside of the pipe can be broken down into two parts: a part (probably short-lived) during which the consumer processes the elements in some way, and a downstream portion where the consumer acts as a sentinel to report when the element has been fully processed.</p><p>For instance, consider the simple case of a pipe attached to an <code>Async.Writer</code> that is writing elements to disk. Part one would be whatever transform the consumer applies to the elements in the pipe before it hands them off to the writer, and part two would be waiting for the writer to finish writing the transformed element to disk. A more complex case is chaining two pipes together (maybe with a transform like <code>map</code>). Part one in this case is the transform and the write to the downstream pipe, and part two is waiting for that pipe (and any further pipes in the chain) to flush.</p><p>In each case the consumer is responsible for indicating when:</p><ul><li>it has finished any local work (by attaching itself to elements via the ~consumer argument to <code>read</code> and <code>read'</code>) and calling <code>values_sent_downstream</code> when it has sent the values downstream.</li></ul><ul><li>when any further processing has been completed (by providing an appropriate function to <code>~downstream_flushed</code> when <code>add_consumer</code> is called).</li></ul><p>If a reader does not use a consumer to do the reading then an element is considered flushed the moment it leaves the pipe. This may lead to odd results as entire queues of elements are removed by a call to <code>read'</code> but are processed over a long period.</p></aside><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt></dl><dl><dt class="spec value" id="val-values_sent_downstream"><a href="#val-values_sent_downstream" class="anchor"></a><code><span class="keyword">val</span> values_sent_downstream : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt></dl></div></body></html>