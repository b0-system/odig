<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Odepack (odepack.Odepack)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">odepack</a> &#x00BB; Odepack</nav><h1>Module <code>Odepack</code></h1><p>Binding to ODEPACK. This is a collection of solvers for the initial value problem for ordinary differential equation systems. See <a href="http://computation.llnl.gov/casc/odepack/">the ODEPACK page</a> and <a href="http://www.netlib.org/odepack/">Netlib</a>.</p><p>You can jump to the interface of the <a href="index.html#lib"><span>Odepack library</span></a>.</p><h3 id="example-of-use"><a href="#example-of-use" class="anchor"></a>Example of use</h3><p>To solve the equation ∂ₜ²u = f(t,u) with initial conditions u(t₀) = u₀ and ∂ₜu(t₀) = u'₀, you must first reduce it to a first order ODE: ∂ₜ(y₁,y₂) = (y₂, f(t,y₁)) with the initial condition y(t₀) = (u₀, u'₀). Then write an OCaml function to evaluate the right hand side of this ODE:</p><pre><code class="ml">let ode t (y: vec) (dy: vec) =
  dy.{1} &lt;- y.{2};
  dy.{2} &lt;- f t y.{1}                                 </code></pre><p>and get an approximate value of the vector y(t) with</p><pre><code class="ml">let init = Array1.of_array float64 fortran_layout [|u₀; u'₀|] in
Odepack.vec(Odepack.lsoda ode init t₀ t)</code></pre><p>You must explicitly project the return value of <code>Odepack.lsoda</code> with <code>Odepack.vec</code> to get the state of the system because there are several other operations that you can perform on this value (see above). The value of u(t) is the given by the first component of <code>y</code>, so you can define (an approximation of) u with</p><pre><code class="ml">let u ~u0 ~u'0 t =
  let init = Array1.of_array float64 fortran_layout [|u0; u'0|] in
  Odepack.vec(Odepack.lsoda ode init t₀ t).{1}</code></pre><dl><dt>version</dt><dd>0.7</dd></dl><dl><dt>author</dt><dd>Christophe Troestler (Christophe.Troestler@umons.ac.be)</dd></dl><nav class="toc"><ul><li><a href="#lib">Odepack library</a></li></ul></nav></header><section><header><h3 id="lib"><a href="#lib" class="anchor"></a>Odepack library</h3></header><dl><dt class="spec type" id="type-vec"><a href="#type-vec" class="anchor"></a><code><span class="keyword">type</span> vec</code><code> = (float, <a href="../../ocaml/Bigarray/index.html#type-float64_elt">Bigarray.float64_elt</a>, <a href="../../ocaml/Bigarray/index.html#type-fortran_layout">Bigarray.fortran_layout</a>) <a href="../../ocaml/Bigarray/Array1/index.html#type-t">Bigarray.Array1.t</a></code></dt><dd><p>Representation of vectors.</p></dd></dl><dl><dt class="spec type" id="type-mat"><a href="#type-mat" class="anchor"></a><code><span class="keyword">type</span> mat</code><code> = (float, <a href="../../ocaml/Bigarray/index.html#type-float64_elt">Bigarray.float64_elt</a>, <a href="../../ocaml/Bigarray/index.html#type-fortran_layout">Bigarray.fortran_layout</a>) <a href="../../ocaml/Bigarray/Array2/index.html#type-t">Bigarray.Array2.t</a></code></dt><dd><p>Representation of matrices.</p></dd></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><p>A mutable value holding the current state of solving the ODE.</p></dd></dl><dl><dt class="spec type" id="type-jacobian"><a href="#type-jacobian" class="anchor"></a><code><span class="keyword">type</span> jacobian</code><code> = </code><table class="variant"><tr id="type-jacobian.Auto_full" class="anchored"><td class="def constructor"><a href="#type-jacobian.Auto_full" class="anchor"></a><code>| </code><code><span class="constructor">Auto_full</span></code></td><td class="doc"><p>Internally generated (difference quotient) full Jacobian</p></td></tr><tr id="type-jacobian.Auto_band" class="anchored"><td class="def constructor"><a href="#type-jacobian.Auto_band" class="anchor"></a><code>| </code><code><span class="constructor">Auto_band</span> <span class="keyword">of</span> int * int</code></td><td class="doc"><p>Internally generated (difference quotient) band Jacobian. It takes <code>(l,u)</code> where <code>l</code> (resp. <code>u</code>) is the number of lines below (resp. above) the diagonal (excluded).</p></td></tr><tr id="type-jacobian.Full" class="anchored"><td class="def constructor"><a href="#type-jacobian.Full" class="anchor"></a><code>| </code><code><span class="constructor">Full</span> <span class="keyword">of</span> float <span>&#45;&gt;</span> <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></td><td class="doc"><p><code>Full df</code> means that a function <code>df</code> is provided to compute the full Jacobian matrix (∂fᵢ/∂yⱼ) of the vector field f(t,y). <code>df t y jac</code> must store ∂fᵢ/∂yⱼ(<code>t</code>,<code>y</code>) into <code>jac.{i,j}</code>.</p></td></tr><tr id="type-jacobian.Band" class="anchored"><td class="def constructor"><a href="#type-jacobian.Band" class="anchor"></a><code>| </code><code><span class="constructor">Band</span> <span class="keyword">of</span> int * int * float <span>&#45;&gt;</span> <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></td><td class="doc"><p><code>Band(l, u, df)</code> means that a function <code>df</code> is provided to compute the banded Jacobian matrix with <code>l</code> (resp. <code>u</code>) diagonals below (resp. above) the main one (not counted). <code>df t y d jac</code> must store ∂fᵢ/∂yⱼ(<code>t</code>,<code>y</code>) into <code>jac.{i-j+d, j}</code>. <code>d</code> is the row of <code>jac</code> corresponding to the main diagonal of the Jacobian matrix.</p></td></tr></table></dt><dd><p>Types of Jacobian matrices.</p></dd></dl><dl><dt class="spec value" id="val-lsoda"><a href="#val-lsoda" class="anchor"></a><code><span class="keyword">val</span> lsoda : ?&#8288;rtol:float <span>&#45;&gt;</span> ?&#8288;rtol_vec:<a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> ?&#8288;atol:float <span>&#45;&gt;</span> ?&#8288;atol_vec:<a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> ?&#8288;jac:<a href="index.html#type-jacobian">jacobian</a> <span>&#45;&gt;</span> ?&#8288;mxstep:int <span>&#45;&gt;</span> ?&#8288;copy_y0:bool <span>&#45;&gt;</span> ?&#8288;debug:bool <span>&#45;&gt;</span> ?&#8288;debug_switches:bool <span>&#45;&gt;</span> (float <span>&#45;&gt;</span> <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>lsoda f y0 t0 t</code> solves the ODE dy/dt = F(t,y) with initial condition y(<code>t0</code>) = <code>y0</code>. The execution of <code>f t y y'</code> must compute the value of the F(<code>t</code>, <code>y</code>) and store it in <code>y'</code>. It uses a dense or banded Jacobian when the problem is stiff, but it automatically selects between nonstiff (Adams) and stiff (BDF) methods. It uses the nonstiff method initially, and dynamically monitors data in order to decide which method to use.</p><dl><dt>parameter rtol</dt><dd><p>relative error tolerance parameter. Default <code>1e-6</code>.</p></dd></dl><dl><dt>parameter rtol_vec</dt><dd><p>relative error tolerance vector.</p></dd></dl><dl><dt>parameter atol</dt><dd><p>absolute error tolerance parameter. Default <code>1e-6</code>.</p></dd></dl><dl><dt>parameter atol_vec</dt><dd><p>absolute error tolerance vector.</p><p>If <code>rtol_vec</code> (resp. <code>atol_vec</code>) is specified, it is used in place of <code>rtol</code> (resp. <code>atol</code>). Specifying only <code>rtol</code> (resp. <code>atol</code>) is equivalent to pass a constant <code>rtol_vec</code> (resp. <code>atol_vec</code>). The solver will control the vector E = (E(i)) of estimated local errors in <code>y</code>, according to an inequality of the form max-norm(E(i)/EWT(i)) &lt;= 1, where EWT(i) = <code>rtol_vec.{i} * abs_float(y.{i}) + atol_vec.{i}</code>.</p></dd></dl><dl><dt>parameter jac</dt><dd><p>is an optional Jabobian matrix. If the problem is expected to be stiff much of the time, you are encouraged to supply <code>jac</code>, for the sake of efficiency. Default: <code>Auto_full</code>.</p></dd></dl><dl><dt>parameter mxstep</dt><dd><p>maximum number of (internally defined) steps allowed during one call to the solver. The default value is 500.</p></dd></dl><dl><dt>parameter copy_y0</dt><dd><p>if <code>false</code>, the vector <code>y0</code> is MODIFIED to contain the value of the solution at time <code>t</code>. Otherwise <code>y0</code> is unchanged (the current solution vector is then obtained by <a href="index.html#type-vec"><code>Odepack.vec</code></a>). Default: <code>true</code>.</p></dd></dl><dl><dt>parameter debug</dt><dd><p>allows <code>lsoda</code> to print messages. Default <code>true</code>. The messages contain valuable information, it is not recommended to turn them off.</p></dd></dl><dl><dt>parameter debug_switches</dt><dd><p>prints a message to stdout on each (automatic) method switch (between nonstiff and stiff). Default: <code>false</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-lsodar"><a href="#val-lsodar" class="anchor"></a><code><span class="keyword">val</span> lsodar : ?&#8288;rtol:float <span>&#45;&gt;</span> ?&#8288;rtol_vec:<a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> ?&#8288;atol:float <span>&#45;&gt;</span> ?&#8288;atol_vec:<a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> ?&#8288;jac:<a href="index.html#type-jacobian">jacobian</a> <span>&#45;&gt;</span> ?&#8288;mxstep:int <span>&#45;&gt;</span> ?&#8288;copy_y0:bool <span>&#45;&gt;</span> ?&#8288;debug:bool <span>&#45;&gt;</span> ?&#8288;debug_switches:bool <span>&#45;&gt;</span> g:(float <span>&#45;&gt;</span> <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> ng:int <span>&#45;&gt;</span> (float <span>&#45;&gt;</span> <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>lsodar f y0 t0 t ~g ~ng</code> is like <a href="index.html#val-lsoda"><code>lsoda</code></a> but has root searching capabilities. The algorithm will stop before reaching time <code>t</code> if a root of one of the <code>ng</code> constraints is found. You can determine whether the <code>lsodar</code> stopped at a root using <a href="index.html#val-has_root"><code>has_root</code></a>. It only finds those roots for which some component of <code>g</code>, as a function of t, changes sign in the interval of integration. The function <code>g</code> is evaluated like <code>f</code>, that is: <code>g t y gout</code> must write to <code>gout.{1},..., gout.{ng}</code> the values of the <code>ng</code> constraints.</p></dd></dl><dl><dt class="spec value" id="val-vec"><a href="#val-vec" class="anchor"></a><code><span class="keyword">val</span> vec : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-vec">vec</a></code></dt><dd><p><code>vec ode</code> returns the current value of the solution vector.</p></dd></dl><dl><dt class="spec value" id="val-time"><a href="#val-time" class="anchor"></a><code><span class="keyword">val</span> time : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>t ode</code> returns the current time at which the solution vector was computed.</p></dd></dl><dl><dt class="spec value" id="val-advance"><a href="#val-advance" class="anchor"></a><code><span class="keyword">val</span> advance : ?&#8288;time:float <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>advance ode ~time:t</code> modifies <code>ode</code> so that an approximation of the value of the solution at times <code>t</code> is computed. Note that, if the solver has root searching capabilities and a time is provided, the solver may stop before that time if a root is found. The time is recorded for future calls to <code>advance ode</code>. If the solver has no root finding capabilities and no time is provided, this function does nothing.</p></dd></dl><dl><dt class="spec value" id="val-has_root"><a href="#val-has_root" class="anchor"></a><code><span class="keyword">val</span> has_root : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>has_root ode</code> says wheter the solver stopped (i.e. the current state of <code>ode</code> is) because a root was found. If the solver has no root searching capabilities, this returns <code>false</code>.</p></dd></dl><dl><dt class="spec value" id="val-root"><a href="#val-root" class="anchor"></a><code><span class="keyword">val</span> root : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> bool</code></dt><dd><p><code>root t i</code> returns true iff the <code>i</code>th constraint in <code>lsodar</code> has a root. It raises <code>Invalid_argument</code> if <code>i</code> is not between 1 and <code>ng</code>, the number of constraints (included). This only makes sense if <code>has_root t</code> holds.</p></dd></dl><dl><dt class="spec value" id="val-roots"><a href="#val-roots" class="anchor"></a><code><span class="keyword">val</span> roots : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool array</code></dt><dd><p><code>roots t</code> returns an array <code>r</code> such that <code>r.(i)</code> holds if and only if the <code>i</code>th constraint has a root.</p></dd></dl><dl><dt class="spec value" id="val-sol"><a href="#val-sol" class="anchor"></a><code><span class="keyword">val</span> sol : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> float <span>&#45;&gt;</span> <a href="index.html#type-vec">vec</a></code></dt><dd><p><code>sol ode t</code> modifies <code>ode</code> so that it holds an approximation of the solution at <code>t</code> and returns this approximation. Any root that might be found is ignored.</p></dd></dl></section></div></body></html>