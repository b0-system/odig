<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Angstrom (angstrom.Angstrom)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../index.html">angstrom</a> &#x00BB; Angstrom</nav><header class="odoc-preamble"><h1>Module <code><span>Angstrom</span></code></h1><p>Parser combinators built for speed and memory-efficiency.</p><p>Angstrom is a parser-combinator library that provides monadic and applicative interfaces for constructing parsers with unbounded lookahead. Its parsers can consume input incrementally, whether in a blocking or non-blocking environment. To achieve efficient incremental parsing, Angstrom offers both a buffered and unbuffered interface to input streams, with the <a href="Unbuffered/index.html"><code>Unbuffered</code></a> interface enabling zero-copy IO. With these features and low-level iteration parser primitives like <a href="#val-take_while"><code>take_while</code></a> and <a href="#val-skip_while"><code>skip_while</code></a>, Angstrom makes it easy to write efficient, expressive, and reusable parsers suitable for high-performance applications.</p></header><nav class="odoc-toc"><ul><li><a href="#basic-parsers">Basic parsers</a></li><li><a href="#combinators">Combinators</a></li><li><a href="#alternatives">Alternatives</a></li><li><a href="#monadic/applicative-interface">Monadic/Applicative interface</a></li><li><a href="#running">Running</a></li><li><a href="#expert-parsers">Expert Parsers</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>+'a t</span></span></code></div><div class="spec-doc"><p>A parser for values of type <code>'a</code>.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-bigstring" class="anchored"><a href="#type-bigstring" class="anchor"></a><code><span><span class="keyword">type</span> bigstring</span><span> = <span><span>(char, <a href="../../ocaml/Stdlib/Bigarray/index.html#type-int8_unsigned_elt">Bigarray.int8_unsigned_elt</a>, <a href="../../ocaml/Stdlib/Bigarray/index.html#type-c_layout">Bigarray.c_layout</a>)</span> <a href="../../ocaml/Stdlib/Bigarray/Array1/index.html#type-t">Bigarray.Array1.t</a></span></span></code></div></div><h3 id="basic-parsers"><a href="#basic-parsers" class="anchor"></a>Basic parsers</h3><div class="odoc-spec"><div class="spec value" id="val-peek_char" class="anchored"><a href="#val-peek_char" class="anchor"></a><code><span><span class="keyword">val</span> peek_char : <span><span>char option</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>peek_char</code> accepts any char and returns it, or returns <code>None</code> if the end of input has been reached.</p><p>This parser does not advance the input. Use it for lookahead.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-peek_char_fail" class="anchored"><a href="#val-peek_char_fail" class="anchor"></a><code><span><span class="keyword">val</span> peek_char_fail : <span>char <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>peek_char_fail</code> accepts any char and returns it. If end of input has been reached, it will fail.</p><p>This parser does not advance the input. Use it for lookahead.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-peek_string" class="anchored"><a href="#val-peek_string" class="anchor"></a><code><span><span class="keyword">val</span> peek_string : <span>int <span class="arrow">&#45;&gt;</span></span> <span>string <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>peek_string n</code> accepts exactly <code>n</code> characters and returns them as a string. If there is not enough input, it will fail.</p><p>This parser does not advance the input. Use it for lookahead.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-char" class="anchored"><a href="#val-char" class="anchor"></a><code><span><span class="keyword">val</span> char : <span>char <span class="arrow">&#45;&gt;</span></span> <span>char <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>char c</code> accepts <code>c</code> and returns it.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-not_char" class="anchored"><a href="#val-not_char" class="anchor"></a><code><span><span class="keyword">val</span> not_char : <span>char <span class="arrow">&#45;&gt;</span></span> <span>char <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>not_char</code> accepts any character that is not <code>c</code> and returns the matched character.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-any_char" class="anchored"><a href="#val-any_char" class="anchor"></a><code><span><span class="keyword">val</span> any_char : <span>char <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>any_char</code> accepts any character and returns it.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-satisfy" class="anchored"><a href="#val-satisfy" class="anchor"></a><code><span><span class="keyword">val</span> satisfy : <span><span>(<span>char <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span>char <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>satisfy f</code> accepts any character for which <code>f</code> returns <code>true</code> and returns the accepted character. In the case that none of the parser succeeds, then the parser will fail indicating the offending character.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-string" class="anchored"><a href="#val-string" class="anchor"></a><code><span><span class="keyword">val</span> string : <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>string s</code> accepts <code>s</code> exactly and returns it.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-string_ci" class="anchored"><a href="#val-string_ci" class="anchor"></a><code><span><span class="keyword">val</span> string_ci : <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>string_ci s</code> accepts <code>s</code>, ignoring case, and returns the matched string, preserving the case of the original input.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-skip" class="anchored"><a href="#val-skip" class="anchor"></a><code><span><span class="keyword">val</span> skip : <span><span>(<span>char <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>skip f</code> accepts any character for which <code>f</code> returns <code>true</code> and discards the accepted character. <code>skip f</code> is equivalent to <code>satisfy f</code> but discards the accepted character.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-skip_while" class="anchored"><a href="#val-skip_while" class="anchor"></a><code><span><span class="keyword">val</span> skip_while : <span><span>(<span>char <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>skip_while f</code> accepts input as long as <code>f</code> returns <code>true</code> and discards the accepted characters.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-take" class="anchored"><a href="#val-take" class="anchor"></a><code><span><span class="keyword">val</span> take : <span>int <span class="arrow">&#45;&gt;</span></span> <span>string <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>take n</code> accepts exactly <code>n</code> characters of input and returns them as a string.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-take_while" class="anchored"><a href="#val-take_while" class="anchor"></a><code><span><span class="keyword">val</span> take_while : <span><span>(<span>char <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span>string <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>take_while f</code> accepts input as long as <code>f</code> returns <code>true</code> and returns the accepted characters as a string.</p><p>This parser does not fail. If <code>f</code> returns <code>false</code> on the first character, it will return the empty string.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-take_while1" class="anchored"><a href="#val-take_while1" class="anchor"></a><code><span><span class="keyword">val</span> take_while1 : <span><span>(<span>char <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span>string <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>take_while1 f</code> accepts input as long as <code>f</code> returns <code>true</code> and returns the accepted characters as a string.</p><p>This parser requires that <code>f</code> return <code>true</code> for at least one character of input, and will fail otherwise.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-take_till" class="anchored"><a href="#val-take_till" class="anchor"></a><code><span><span class="keyword">val</span> take_till : <span><span>(<span>char <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span>string <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>take_till f</code> accepts input as long as <code>f</code> returns <code>false</code> and returns the accepted characters as a string.</p><p>This parser does not fail. If <code>f</code> returns <code>true</code> on the first character, it will return the empty string.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-consumed" class="anchored"><a href="#val-consumed" class="anchor"></a><code><span><span class="keyword">val</span> consumed : <span><span><span class="type-var">_</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>string <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>consumed p</code> runs <code>p</code> and returns the contents that were consumed during the parsing as a string</p></div></div><div class="odoc-spec"><div class="spec value" id="val-take_bigstring" class="anchored"><a href="#val-take_bigstring" class="anchor"></a><code><span><span class="keyword">val</span> take_bigstring : <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-bigstring">bigstring</a> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>take_bigstring n</code> accepts exactly <code>n</code> characters of input and returns them as a newly allocated bigstring.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-take_bigstring_while" class="anchored"><a href="#val-take_bigstring_while" class="anchor"></a><code><span><span class="keyword">val</span> take_bigstring_while : <span><span>(<span>char <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-bigstring">bigstring</a> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>take_bigstring_while f</code> accepts input as long as <code>f</code> returns <code>true</code> and returns the accepted characters as a newly allocated bigstring.</p><p>This parser does not fail. If <code>f</code> returns <code>false</code> on the first character, it will return the empty bigstring.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-take_bigstring_while1" class="anchored"><a href="#val-take_bigstring_while1" class="anchor"></a><code><span><span class="keyword">val</span> take_bigstring_while1 : <span><span>(<span>char <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-bigstring">bigstring</a> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>take_bigstring_while1 f</code> accepts input as long as <code>f</code> returns <code>true</code> and returns the accepted characters as a newly allocated bigstring.</p><p>This parser requires that <code>f</code> return <code>true</code> for at least one character of input, and will fail otherwise.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-take_bigstring_till" class="anchored"><a href="#val-take_bigstring_till" class="anchor"></a><code><span><span class="keyword">val</span> take_bigstring_till : <span><span>(<span>char <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-bigstring">bigstring</a> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>take_bigstring_till f</code> accepts input as long as <code>f</code> returns <code>false</code> and returns the accepted characters as a newly allocated bigstring.</p><p>This parser does not fail. If <code>f</code> returns <code>true</code> on the first character, it will return the empty bigstring.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-consumed_bigstring" class="anchored"><a href="#val-consumed_bigstring" class="anchor"></a><code><span><span class="keyword">val</span> consumed_bigstring : <span><span><span class="type-var">_</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-bigstring">bigstring</a> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>consumed p</code> runs <code>p</code> and returns the contents that were consumed during the parsing as a bigstring</p></div></div><div class="odoc-spec"><div class="spec value" id="val-advance" class="anchored"><a href="#val-advance" class="anchor"></a><code><span><span class="keyword">val</span> advance : <span>int <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>advance n</code> advances the input <code>n</code> characters, failing if the remaining input is less than <code>n</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-end_of_line" class="anchored"><a href="#val-end_of_line" class="anchor"></a><code><span><span class="keyword">val</span> end_of_line : <span>unit <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>end_of_line</code> accepts either a line feed <code>\n</code>, or a carriage return followed by a line feed <code>\r\n</code> and returns unit.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-at_end_of_input" class="anchored"><a href="#val-at_end_of_input" class="anchor"></a><code><span><span class="keyword">val</span> at_end_of_input : <span>bool <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>at_end_of_input</code> returns whether the end of the end of input has been reached. This parser always succeeds.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-end_of_input" class="anchored"><a href="#val-end_of_input" class="anchor"></a><code><span><span class="keyword">val</span> end_of_input : <span>unit <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>end_of_input</code> succeeds if all the input has been consumed, and fails otherwise.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-scan" class="anchored"><a href="#val-scan" class="anchor"></a><code><span><span class="keyword">val</span> scan : <span><span class="type-var">'state</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'state</span> <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'state</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(string * <span class="type-var">'state</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>scan init f</code> consumes until <code>f</code> returns <code>None</code>. Returns the final state before <code>None</code> and the accumulated string</p></div></div><div class="odoc-spec"><div class="spec value" id="val-scan_state" class="anchored"><a href="#val-scan_state" class="anchor"></a><code><span><span class="keyword">val</span> scan_state : <span><span class="type-var">'state</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'state</span> <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'state</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'state</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>scan_state init f</code> is like <a href="#val-scan"><code>scan</code></a> but only returns the final state before <code>None</code>. Much more efficient than <a href="#val-scan"><code>scan</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-scan_string" class="anchored"><a href="#val-scan_string" class="anchor"></a><code><span><span class="keyword">val</span> scan_string : <span><span class="type-var">'state</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'state</span> <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'state</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>string <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>scan_string init f</code> is like <a href="#val-scan"><code>scan</code></a> but discards the final state and returns the accumulated string.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-int8" class="anchored"><a href="#val-int8" class="anchor"></a><code><span><span class="keyword">val</span> int8 : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>int8 i</code> accepts one byte that matches the lower-order byte of <code>i</code> and returns unit.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-any_uint8" class="anchored"><a href="#val-any_uint8" class="anchor"></a><code><span><span class="keyword">val</span> any_uint8 : <span>int <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>any_uint8</code> accepts any byte and returns it as an unsigned int8.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-any_int8" class="anchored"><a href="#val-any_int8" class="anchor"></a><code><span><span class="keyword">val</span> any_int8 : <span>int <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>any_int8</code> accepts any byte and returns it as a signed int8.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-BE" class="anchored"><a href="#module-BE" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="BE/index.html">BE</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Big endian parsers</p></div></div><div class="odoc-spec"><div class="spec module" id="module-LE" class="anchored"><a href="#module-LE" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="LE/index.html">LE</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Little endian parsers</p></div></div><h3 id="combinators"><a href="#combinators" class="anchor"></a>Combinators</h3><div class="odoc-spec"><div class="spec value" id="val-option" class="anchored"><a href="#val-option" class="anchor"></a><code><span><span class="keyword">val</span> option : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>option v p</code> runs <code>p</code>, returning the result of <code>p</code> if it succeeds and <code>v</code> if it fails.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-both" class="anchored"><a href="#val-both" class="anchor"></a><code><span><span class="keyword">val</span> both : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>both p q</code> runs <code>p</code> followed by <code>q</code> and returns both results in a tuple</p></div></div><div class="odoc-spec"><div class="spec value" id="val-list" class="anchored"><a href="#val-list" class="anchor"></a><code><span><span class="keyword">val</span> list : <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>list ps</code> runs each <code>p</code> in <code>ps</code> in sequence, returning a list of results of each <code>p</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-count" class="anchored"><a href="#val-count" class="anchor"></a><code><span><span class="keyword">val</span> count : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>count n p</code> runs <code>p</code> <code>n</code> times, returning a list of the results.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-many" class="anchored"><a href="#val-many" class="anchor"></a><code><span><span class="keyword">val</span> many : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>many p</code> runs <code>p</code> <i>zero</i> or more times and returns a list of results from the runs of <code>p</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-many1" class="anchored"><a href="#val-many1" class="anchor"></a><code><span><span class="keyword">val</span> many1 : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>many1 p</code> runs <code>p</code> <i>one</i> or more times and returns a list of results from the runs of <code>p</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-many_till" class="anchored"><a href="#val-many_till" class="anchor"></a><code><span><span class="keyword">val</span> many_till : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">_</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>many_till p e</code> runs parser <code>p</code> <i>zero</i> or more times until action <code>e</code> succeeds and returns the list of result from the runs of <code>p</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sep_by" class="anchored"><a href="#val-sep_by" class="anchor"></a><code><span><span class="keyword">val</span> sep_by : <span><span><span class="type-var">_</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>sep_by s p</code> runs <code>p</code> <i>zero</i> or more times, interspersing runs of <code>s</code> in between.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sep_by1" class="anchored"><a href="#val-sep_by1" class="anchor"></a><code><span><span class="keyword">val</span> sep_by1 : <span><span><span class="type-var">_</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>sep_by1 s p</code> runs <code>p</code> <i>one</i> or more times, interspersing runs of <code>s</code> in between.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-skip_many" class="anchored"><a href="#val-skip_many" class="anchor"></a><code><span><span class="keyword">val</span> skip_many : <span><span><span class="type-var">_</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>skip_many p</code> runs <code>p</code> <i>zero</i> or more times, discarding the results.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-skip_many1" class="anchored"><a href="#val-skip_many1" class="anchor"></a><code><span><span class="keyword">val</span> skip_many1 : <span><span><span class="type-var">_</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>skip_many1 p</code> runs <code>p</code> <i>one</i> or more times, discarding the results.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fix" class="anchored"><a href="#val-fix" class="anchor"></a><code><span><span class="keyword">val</span> fix : <span><span>(<span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>fix f</code> computes the fixpoint of <code>f</code> and runs the resultant parser. The argument that <code>f</code> receives is the result of <code>fix f</code>, which <code>f</code> must use, paradoxically, to define <code>fix f</code>.</p><p><code>fix</code> is useful when constructing parsers for inductively-defined types such as sequences, trees, etc. Consider for example the implementation of the <a href="#val-many"><code>many</code></a> combinator defined in this library:</p><pre><code>let many p =
fix (fun m -&gt;
  (cons &lt;$&gt; p &lt;*&gt; m) &lt;|&gt; return [])</code></pre><p><code>many p</code> is a parser that will run <code>p</code> zero or more times, accumulating the result of every run into a list, returning the result. It's defined by passing <code>fix</code> a function. This function assumes its argument <code>m</code> is a parser that behaves exactly like <code>many p</code>. You can see this in the expression comprising the left hand side of the alternative operator <code>&lt;|&gt;</code>. This expression runs the parser <code>p</code> followed by the parser <code>m</code>, and after which the result of <code>p</code> is cons'd onto the list that <code>m</code> produces. The right-hand side of the alternative operator provides a base case for the combinator: if <code>p</code> fails and the parse cannot proceed, return an empty list.</p><p>Another way to illustrate the uses of <code>fix</code> is to construct a JSON parser. Assuming that parsers exist for the basic types such as <code>false</code>, <code>true</code>, <code>null</code>, strings, and numbers, the question then becomes how to define a parser for objects and arrays? Both contain values that are themselves JSON values, so it seems as though it's impossible to write a parser that will accept JSON objects and arrays before writing a parser for JSON values as a whole.</p><p>This is the exact situation that <code>fix</code> was made for. By defining the parsers for arrays and objects within the function that you pass to <code>fix</code>, you will gain access to a parser that you can use to parse JSON values, the very parser you are defining!</p><pre><code>let json =
fix (fun json -&gt;
  let arr = char '[' *&gt; sep_by (char ',') json &lt;* char ']' in
  let obj = char '{' *&gt; ... json ... &lt;* char '}' in
  choice [str; num; arr json, ...])</code></pre></div></div><h3 id="alternatives"><a href="#alternatives" class="anchor"></a>Alternatives</h3><div class="odoc-spec"><div class="spec value" id="val-(&lt;|&gt;)" class="anchored"><a href="#val-(&lt;|&gt;)" class="anchor"></a><code><span><span class="keyword">val</span> (&lt;|&gt;) : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>p &lt;|&gt; q</code> runs <code>p</code> and returns the result if succeeds. If <code>p</code> fails, then the input will be reset and <code>q</code> will run instead.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-choice" class="anchored"><a href="#val-choice" class="anchor"></a><code><span><span class="keyword">val</span> choice : <span>?failure_msg:string <span class="arrow">&#45;&gt;</span></span> <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>choice ?failure_msg ts</code> runs each parser in <code>ts</code> in order until one succeeds and returns that result. In the case that none of the parser succeeds, then the parser will fail with the message <code>failure_msg</code>, if provided, or a much less informative message otherwise.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-(&lt;?&gt;)" class="anchored"><a href="#val-(&lt;?&gt;)" class="anchor"></a><code><span><span class="keyword">val</span> (&lt;?&gt;) : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>p &lt;?&gt; name</code> associates <code>name</code> with the parser <code>p</code>, which will be reported in the case of failure.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-commit" class="anchored"><a href="#val-commit" class="anchor"></a><code><span><span class="keyword">val</span> commit : <span>unit <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>commit</code> prevents backtracking beyond the current position of the input, allowing the manager of the input buffer to reuse the preceding bytes for other purposes.</p><p>The <a href="Unbuffered/index.html"><code>Unbuffered</code></a> parsing interface will report directly to the caller the number of bytes committed to the when returning a <a href="Unbuffered/index.html#type-state.Partial"><code>Unbuffered.state.Partial</code></a> state, allowing the caller to reuse those bytes for any purpose. The <a href="Buffered/index.html"><code>Buffered</code></a> will keep track of the region of committed bytes in its internal buffer and reuse that region to store additional input when necessary.</p></div></div><h3 id="monadic/applicative-interface"><a href="#monadic/applicative-interface" class="anchor"></a>Monadic/Applicative interface</h3><div class="odoc-spec"><div class="spec value" id="val-return" class="anchored"><a href="#val-return" class="anchor"></a><code><span><span class="keyword">val</span> return : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>return v</code> creates a parser that will always succeed and return <code>v</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-fail" class="anchored"><a href="#val-fail" class="anchor"></a><code><span><span class="keyword">val</span> fail : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">_</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>fail msg</code> creates a parser that will always fail with the message <code>msg</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-(&gt;&gt;=)" class="anchored"><a href="#val-(&gt;&gt;=)" class="anchor"></a><code><span><span class="keyword">val</span> (&gt;&gt;=) : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>p &gt;&gt;= f</code> creates a parser that will run <code>p</code>, pass its result to <code>f</code>, run the parser that <code>f</code> produces, and return its result.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-bind" class="anchored"><a href="#val-bind" class="anchor"></a><code><span><span class="keyword">val</span> bind : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>bind</code> is a prefix version of <code>&gt;&gt;=</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-(&gt;&gt;|)" class="anchored"><a href="#val-(&gt;&gt;|)" class="anchor"></a><code><span><span class="keyword">val</span> (&gt;&gt;|) : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>p &gt;&gt;| f</code> creates a parser that will run <code>p</code>, and if it succeeds with result <code>v</code>, will return <code>f v</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-(&lt;*&gt;)" class="anchored"><a href="#val-(&lt;*&gt;)" class="anchor"></a><code><span><span class="keyword">val</span> (&lt;*&gt;) : <span><span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>f &lt;*&gt; p</code> is equivalent to <code>f &gt;&gt;= fun f -&gt; p &gt;&gt;| f</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-(&lt;$&gt;)" class="anchored"><a href="#val-(&lt;$&gt;)" class="anchor"></a><code><span><span class="keyword">val</span> (&lt;$&gt;) : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>f &lt;$&gt; p</code> is equivalent to <code>p &gt;&gt;| f</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-(*&gt;)" class="anchored"><a href="#val-(*&gt;)" class="anchor"></a><code><span><span class="keyword">val</span> (*&gt;) : <span><span><span class="type-var">_</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>p *&gt; q</code> runs <code>p</code>, discards its result and then runs <code>q</code>, and returns its result.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-(&lt;*)" class="anchored"><a href="#val-(&lt;*)" class="anchor"></a><code><span><span class="keyword">val</span> (&lt;*) : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">_</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>p &lt;* q</code> runs <code>p</code>, then runs <code>q</code>, discards its result, and returns the result of <code>p</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-lift" class="anchored"><a href="#val-lift" class="anchor"></a><code><span><span class="keyword">val</span> lift : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-lift2" class="anchored"><a href="#val-lift2" class="anchor"></a><code><span><span class="keyword">val</span> lift2 : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-lift3" class="anchored"><a href="#val-lift3" class="anchor"></a><code><span><span class="keyword">val</span> lift3 : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'d</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'c</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'d</span> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-lift4" class="anchored"><a href="#val-lift4" class="anchor"></a><code><span><span class="keyword">val</span> lift4 : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'d</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'e</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'c</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'d</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'e</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>The <code>liftn</code> family of functions promote functions to the parser monad. For any of these functions, the following equivalence holds:</p><pre><code>liftn f p1 ... pn = f &lt;$&gt; p1 &lt;*&gt; ... &lt;*&gt; pn</code></pre><p>These functions are more efficient than using the applicative interface directly, mostly in terms of memory allocation but also in terms of speed. Prefer them over the applicative interface, even when the arity of the function to be lifted exceeds the maximum <code>n</code> for which there is an implementation for <code>liftn</code>. In other words, if <code>f</code> has an arity of <code>5</code> but only <code>lift4</code> is provided, do the following:</p><pre><code>lift4 f m1 m2 m3 m4 &lt;*&gt; m5</code></pre><p>Even with the partial application, it will be more efficient than the applicative implementation.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-map" class="anchored"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-map2" class="anchored"><a href="#val-map2" class="anchor"></a><code><span><span class="keyword">val</span> map2 : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-map3" class="anchored"><a href="#val-map3" class="anchor"></a><code><span><span class="keyword">val</span> map3 : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'c</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'d</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'d</span> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-map4" class="anchored"><a href="#val-map4" class="anchor"></a><code><span><span class="keyword">val</span> map4 : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'c</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'d</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'d</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'e</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'e</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>The <code>mapn</code> family of functions are just like <code>liftn</code>, with a slightly different interface.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Let_syntax" class="anchored"><a href="#module-Let_syntax" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Let_syntax/index.html">Let_syntax</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The <code>Let_syntax</code> module is intended to be used with the <code>ppx_let</code> pre-processor, and just contains copies of functions described elsewhere.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-let+" class="anchored"><a href="#val-let+" class="anchor"></a><code><span><span class="keyword">val</span> let+ : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-let*" class="anchored"><a href="#val-let*" class="anchor"></a><code><span><span class="keyword">val</span> let* : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-and+" class="anchored"><a href="#val-and+" class="anchor"></a><code><span><span class="keyword">val</span> and+ : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Unsafe" class="anchored"><a href="#module-Unsafe" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Unsafe/index.html">Unsafe</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Unsafe Operations on Angstrom's Internal Buffer</p></div></div><h3 id="running"><a href="#running" class="anchor"></a>Running</h3><div class="odoc-spec"><div class="spec module" id="module-Consume" class="anchored"><a href="#module-Consume" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Consume/index.html">Consume</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-parse_bigstring" class="anchored"><a href="#val-parse_bigstring" class="anchor"></a><code><span><span class="keyword">val</span> parse_bigstring : <span>consume:<a href="Consume/index.html#type-t">Consume.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-bigstring">bigstring</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, string)</span> <a href="../../ocaml/Stdlib/index.html#type-result">result</a></span></span></code></div></div><p><code>parse_bigstring ~consume t bs</code> runs <code>t</code> on <code>bs</code>. The parser will receive an <code>`Eof</code> after all of <code>bs</code> has been consumed. Passing <code>Prefix</code> in the <code>consume</code> argument allows the parse to successfully complete without reaching eof. To require the parser to reach eof, pass <code>All</code> in the <code>consume</code> argument.</p><p>For use-cases requiring that the parser be fed input incrementally, see the <a href="Buffered/index.html"><code>Buffered</code></a> and <a href="Unbuffered/index.html"><code>Unbuffered</code></a> modules below.</p><div class="odoc-spec"><div class="spec value" id="val-parse_string" class="anchored"><a href="#val-parse_string" class="anchor"></a><code><span><span class="keyword">val</span> parse_string : <span>consume:<a href="Consume/index.html#type-t">Consume.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, string)</span> <a href="../../ocaml/Stdlib/index.html#type-result">result</a></span></span></code></div><div class="spec-doc"><p><code>parse_string ~consume t bs</code> runs <code>t</code> on <code>bs</code>. The parser will receive an <code>`Eof</code> after all of <code>bs</code> has been consumed. Passing <code>Prefix</code> in the <code>consume</code> argument allows the parse to successfully complete without reaching eof. To require the parser to reach eof, pass <code>All</code> in the <code>consume</code> argument.</p><p>For use-cases requiring that the parser be fed input incrementally, see the <a href="Buffered/index.html"><code>Buffered</code></a> and <a href="Unbuffered/index.html"><code>Unbuffered</code></a> modules below.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Buffered" class="anchored"><a href="#module-Buffered" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Buffered/index.html">Buffered</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Buffered parsing interface.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Unbuffered" class="anchored"><a href="#module-Unbuffered" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Unbuffered/index.html">Unbuffered</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Unbuffered parsing interface.</p></div></div><h3 id="expert-parsers"><a href="#expert-parsers" class="anchor"></a>Expert Parsers</h3><p>For people that know what they're doing. If you want to use them, read the code. No further documentation will be provided.</p><div class="odoc-spec"><div class="spec value" id="val-pos" class="anchored"><a href="#val-pos" class="anchor"></a><code><span><span class="keyword">val</span> pos : <span>int <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-available" class="anchored"><a href="#val-available" class="anchor"></a><code><span><span class="keyword">val</span> available : <span>int <a href="#type-t">t</a></span></span></code></div></div></div></body></html>