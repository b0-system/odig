<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>BatLazyList (batteries.BatLazyList)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">batteries</a> &#x00BB; BatLazyList</nav><header class="odoc-preamble"><h1>Module <code><span>BatLazyList</span></code></h1><p>Lazy lists of elements.</p><p>Lazy lists are similar to lists, with the exception that their contents are only computed whenever requested. This makes them particularly useful in contexts where streams of data are to be handled.</p><p><b>Note</b> For this documentation, we will assume the existence of a lazy list syntax extension such that <code>[^ ^]</code> is the empty lazy list and <code>[^ a;b;c ^]</code> is the lazy list containing elements <code>a</code>, <code>b</code>, <code>c</code>.</p><p><b>Note</b> Enumerations (as featured in module <a href="../BatEnum/index.html"><code>BatEnum</code></a>) and lazy lists (as featured in this module) are quite similar in purpose. Lazy lists are slightly higher level, insofar as no cloning is required to get them to work, which makes them slightly more useful in contexts where backtracking is common. Enumerations, on the other hand, are closer to traditional stream processing, and require more low-level marking whenever backtracking is required, but may be faster and more memory-efficient when used properly. Either choice is recommended over OCaml's built-in <code>Stream</code>.</p><ul class="at-tags"><li class="author"><span class="at-tag">author</span> David Teller</li></ul></header><nav class="odoc-toc"><ul><li><a href="#exceptions">Exceptions</a></li><li><a href="#type">Type</a></li><li><a href="#access">Access</a></li><li><a href="#list-creation">List creation</a></li><li><a href="#higher-order-functions">Higher-order functions</a></li><li><a href="#finding">Finding</a></li><li><a href="#common-functions">Common functions</a></li><li><a href="#association-lists">Association lists</a></li><li><a href="#transformations">Transformations</a></li><li><a href="#dropping-elements">Dropping elements</a></li><li><a href="#conversions">Conversions</a></li><li><a href="#predicates">Predicates</a></li><li><a href="#misc.">Misc.</a></li><li><a href="#sorting">Sorting</a></li><li><a href="#operations-on-two-lists">Operations on two lists</a></li><li><a href="#boilerplate-code">Boilerplate code</a></li><li><a href="#printing">Printing</a></li><li><a href="#override-modules">Override modules</a></li></ul></nav><div class="odoc-content"><h6 id="exceptions"><a href="#exceptions" class="anchor"></a>Exceptions</h6><div class="odoc-spec"><div class="spec exception" id="exception-Empty_list" class="anchored"><a href="#exception-Empty_list" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Empty_list</span></span></code></div><div class="spec-doc"><p><code>Empty_list</code> is raised when an operation applied on an empty list is invalid. For instance, <code>hd nil</code> will raise <code>Empty_list</code>.</p></div></div><div class="odoc-spec"><div class="spec exception" id="exception-Invalid_index" class="anchored"><a href="#exception-Invalid_index" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Invalid_index</span> <span class="keyword">of</span> int</span></code></div><div class="spec-doc"><p><code>Invalid_index</code> is raised when an indexed access on a list is out of list bounds.</p></div></div><div class="odoc-spec"><div class="spec exception" id="exception-Different_list_size" class="anchored"><a href="#exception-Different_list_size" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Different_list_size</span> <span class="keyword">of</span> string</span></code></div><div class="spec-doc"><p><code>Different_list_size</code> is raised when applying functions such as <code>iter2</code> on two lists having different size.</p></div></div><div class="odoc-spec"><div class="spec exception" id="exception-No_more_elements" class="anchored"><a href="#exception-No_more_elements" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">No_more_elements</span></span></code></div><div class="spec-doc"><p>See <a href="#val-from"><code>from</code></a> and <a href="#val-from_loop"><code>from_loop</code></a> for more information on this exception.</p></div></div><h6 id="type"><a href="#type" class="anchor"></a>Type</h6><p><b>Note</b> The types are kept concrete so as to allow pattern-matching. However, it is generally easier to manipulate <a href="#val-nil"><code>nil</code></a> and <a href="#val-cons"><code>cons</code></a>.</p><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a t</span></span><span> = <span><span><span class="type-var">'a</span> <a href="#type-node_t">node_t</a></span> <a href="../../ocaml/Stdlib/Lazy/index.html#type-t">Lazy.t</a></span></span></code></div><div class="spec-doc"><p>The type of a lazy list.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-node_t" class="anchored"><a href="#type-node_t" class="anchor"></a><code><span><span class="keyword">and</span> <span>'a node_t</span></span><span> = </span></code><table><tr id="type-node_t.Nil" class="anchored"><td class="def variant constructor"><a href="#type-node_t.Nil" class="anchor"></a><code><span>| </span><span><span class="constructor">Nil</span></span></code></td></tr><tr id="type-node_t.Cons" class="anchored"><td class="def variant constructor"><a href="#type-node_t.Cons" class="anchor"></a><code><span>| </span><span><span class="constructor">Cons</span> <span class="keyword">of</span> <span class="type-var">'a</span> * <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The type of an item in the list.</p><span class="comment-delim">*)</span></td></tr></table></div></div><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../BatEnum/module-type-Enumerable/index.html">BatEnum.Enumerable</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="../BatEnum/module-type-Enumerable/index.html#type-enumerable">enumerable</a></span> = <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></span></code></summary><div class="odoc-spec"><div class="spec type" id="type-enumerable" class="anchored"><a href="#type-enumerable" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a enumerable</span></span><span> = <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>The data structure, e.g. <code>'a List.t</code></p></div></div></details></div><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../BatInterfaces/module-type-Mappable/index.html">BatInterfaces.Mappable</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="../BatInterfaces/module-type-Mappable/index.html#type-mappable">mappable</a></span> = <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></span></code></summary><div class="odoc-spec"><div class="spec type" id="type-mappable" class="anchored"><a href="#type-mappable" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a mappable</span></span><span> = <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>The data structure, e.g. <code>'a List.t</code></p></div></div></details></div><h6 id="access"><a href="#access" class="anchor"></a>Access</h6><div class="odoc-spec"><div class="spec value" id="val-nil" class="anchored"><a href="#val-nil" class="anchor"></a><code><span><span class="keyword">val</span> nil : <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>The empty list.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-cons" class="anchored"><a href="#val-cons" class="anchor"></a><code><span><span class="keyword">val</span> cons : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Build a list from a head and a tail.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-(^:^)" class="anchored"><a href="#val-(^:^)" class="anchor"></a><code><span><span class="keyword">val</span> (^:^) : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>As <code>cons</code>: <code>x^:^l</code> is the lazy list with head <code>x</code> and tail <code>l</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-peek" class="anchored"><a href="#val-peek" class="anchor"></a><code><span><span class="keyword">val</span> peek : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div><div class="spec-doc"><p><code>peek l</code> returns the first element of <code>l</code>, if it exists.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get" class="anchored"><a href="#val-get" class="anchor"></a><code><span><span class="keyword">val</span> get : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span><span class="type-var">'a</span> <a href="#type-t">t</a></span>)</span> option</span></span></code></div><div class="spec-doc"><p><code>get l</code> returns the head and tail of <code>l</code>, if <code>l</code> is not empty.</p></div></div><h6 id="list-creation"><a href="#list-creation" class="anchor"></a>List creation</h6><div class="odoc-spec"><div class="spec value" id="val-from" class="anchored"><a href="#val-from" class="anchor"></a><code><span><span class="keyword">val</span> from : <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>from next</code> creates a (possibly infinite) lazy list from the successive results of <code>next</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">LazyList.No_more_elements</span> <p>to denote the end of the list.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-from_while" class="anchored"><a href="#val-from_while" class="anchor"></a><code><span><span class="keyword">val</span> from_while : <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>from next</code> creates a (possibly infinite) lazy list from the successive results of <code>next</code>. The list ends whenever <code>next</code> returns <code>None</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-seq" class="anchored"><a href="#val-seq" class="anchor"></a><code><span><span class="keyword">val</span> seq : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>seq data next cond</code> creates a lazy list from the successive results of applying <code>next</code> to <code>data</code>, then to the result, etc. The list continues until the condition <code>cond</code> fails. For example, <code>seq 1 ((+) 1) ((&gt;) 100)</code> returns <code>[^1, 2, ... 99^]</code>. If <code>cond init</code> is false, the result is empty. To create an infinite lazy list, pass <code>(fun _ -&gt; true)</code> as <code>cond</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unfold" class="anchored"><a href="#val-unfold" class="anchor"></a><code><span><span class="keyword">val</span> unfold : <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>unfold data next</code> creates a (possibly infinite) lazy list from the successive results of applying <code>next</code> to <code>data</code>, then to the result, etc. The list ends whenever <code>next</code> returns <code>None</code>. The function <code>next</code> should return a pair <code>option</code> whose first element will be the current value of the sequence; the second element will be passed (lazily) to <code>next</code> in order to compute the following element. One example of a use of <code>unfold</code> is to make each element of the resulting sequence to depend on the previous two elements, as in this Fibonacci sequence definition:</p><pre><code>let data = (1, 1)
let next (x, y) = Some (x, (y, x + y))
let fib = unfold data next</code></pre><p>The first element <code>x</code> of the pair within <code>Some</code> will be the current value of the sequence; the next value of the sequence, and the one after that, are recorded as <code>y</code> and <code>x + y</code> respectively.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-from_loop" class="anchored"><a href="#val-from_loop" class="anchor"></a><code><span><span class="keyword">val</span> from_loop : <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>from_loop data next</code> creates a (possibly infinite) lazy list from the successive results of applying <code>next</code> to <code>data</code>, then to the result, etc. The list ends whenever the function raises <code>LazyList</code>.No_more_elements. (For further information see <code>unfold</code>; ignore references to <code>option</code> and <code>Some</code>.)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-init" class="anchored"><a href="#val-init" class="anchor"></a><code><span><span class="keyword">val</span> init : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Similar to <code>Array.init</code>, <code>init n f</code> returns the lazy list containing the results of (f 0),(f 1).... (f (n-1)).</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p><code>&quot;LazyList.init&quot;</code> if n &lt; 0.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-make" class="anchored"><a href="#val-make" class="anchor"></a><code><span><span class="keyword">val</span> make : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Similar to <code>String.make</code>, <code>make n x</code> returns a list containing <code>n</code> elements <code>x</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-range" class="anchored"><a href="#val-range" class="anchor"></a><code><span><span class="keyword">val</span> range : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Compute lazily a range of integers a .. b as a lazy list.</p><p>The range is empty if b &lt;= a.</p></div></div><h6 id="higher-order-functions"><a href="#higher-order-functions" class="anchor"></a>Higher-order functions</h6><div class="odoc-spec"><div class="spec value" id="val-iter" class="anchored"><a href="#val-iter" class="anchor"></a><code><span><span class="keyword">val</span> iter : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Eager iteration</p><p><code>iter f [^ a0; a1; ...; an ^]</code> applies function <code>f</code> in turn to <code>a0;
   a1; ...; an</code>. It is equivalent to <code>begin f a0; f a1; ...; f an; ()
   end</code>. In particular, it causes all the elements of the list to be evaluated.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-iteri" class="anchored"><a href="#val-iteri" class="anchor"></a><code><span><span class="keyword">val</span> iteri : <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Eager iteration, with indices</p><p><code>iteri f [^ a0; a1; ...; an ^]</code> applies function <code>f</code> in turn to <code>a0; a1;...; an</code>, along with the corresponding <code>0,1..n</code> index. It is equivalent to <code>begin f 0 a0; f 1 a1; ...; f n an; ()
   end</code>. In particular, it causes all the elements of the list to be evaluated.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-map" class="anchored"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Lazy map</p><p><code>map f [^ a0; a1; ... ^]</code> builds the list <code>[^ f a0; f a1; ... ^]</code> with the results returned by <code>f</code>. Not tail-recursive. Evaluations of <code>f</code> take place only when the contents of the list are forced.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mapi" class="anchored"><a href="#val-mapi" class="anchor"></a><code><span><span class="keyword">val</span> mapi : <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Lazy map, with indices</p><p><code>mapi f [^ a0; a1; ... ^]</code> builds the list <code>[^ f 0 a0; f 1 a1;
   ... ^]</code> with the results returned by <code>f</code>. Not tail-recursive. Evaluations of <code>f</code> take place only when the contents of the list are forced.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_left" class="anchored"><a href="#val-fold_left" class="anchor"></a><code><span><span class="keyword">val</span> fold_left : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Eager fold_left</p><p><code>LazyList.fold_left f a [^ b0; b1; ...; bn ^]</code> is <code>f (... (f (f
   a b0) b1) ...) bn</code>. This causes evaluation of all the elements of the list.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_right" class="anchored"><a href="#val-fold_right" class="anchor"></a><code><span><span class="keyword">val</span> fold_right : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span></span></code></div><div class="spec-doc"><p>Eager fold_right</p><p><code>fold_right f b [^ a0; a1; ...; an ^]</code> is <code>f a0 (f a1 (... (f an b) ...))</code>. This causes evaluation of all the elements of the list. Not tail-recursive.</p><p>Note that the argument order of this function is the same as <code>fold_left</code> above, but inconsistent with other <code>fold_right</code> functions in Batteries. We hope to fix this inconsistency in the next compatibility-breaking release, so you should rather use the more consistent <code>eager_fold_right</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.2.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-eager_fold_right" class="anchored"><a href="#val-eager_fold_right" class="anchor"></a><code><span><span class="keyword">val</span> eager_fold_right : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span></span></code></div><div class="spec-doc"><p>Eager fold_right</p><p>As <code>fold_right</code> above, but with the usual argument order for a fold_right.</p><p>Just as <code>fold_left</code> on a structure <code>'a t</code> turns an element-level function of type <code>('bÂ -&gt;Â 'aÂ -&gt;Â 'b)</code>, with the accumulator argument <code>'b</code> on the left, into a structure-level function <code>'bÂ -&gt;Â 'aÂ tÂ -&gt;Â 'b</code>, <code>fold_right</code> turns a function <code>('aÂ -&gt;Â 'bÂ -&gt;Â 'b)</code> (accumulator on the right) into a <code>'aÂ tÂ -&gt;Â 'bÂ -&gt;Â 'b</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-lazy_fold_right" class="anchored"><a href="#val-lazy_fold_right" class="anchor"></a><code><span><span class="keyword">val</span> lazy_fold_right : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="../../ocaml/Stdlib/Lazy/index.html#type-t">Lazy.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="../../ocaml/Stdlib/Lazy/index.html#type-t">Lazy.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="../../ocaml/Stdlib/Lazy/index.html#type-t">Lazy.t</a></span></span></code></div><div class="spec-doc"><p>Lazy fold_right <code>lazy_fold_right f (Cons (a0, Cons (a1, Cons (a2, nil)))) b</code> is <code>lazy (f a0 (lazy (f a1 (lazy (f a2 b)))))</code>.</p><p>Forcing the result of <code>lazy_fold_right</code> forces the first element of the list; the rest is forced only if/when the function <code>f</code> forces its accumulator argument.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.1</li></ul></div></div><h6 id="finding"><a href="#finding" class="anchor"></a>Finding</h6><div class="odoc-spec"><div class="spec value" id="val-mem" class="anchored"><a href="#val-mem" class="anchor"></a><code><span><span class="keyword">val</span> mem : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>mem x l</code> determines if <code>x</code> is part of <code>l</code>. Evaluates all the elements of <code>l</code> which appear before <code>x</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-memq" class="anchored"><a href="#val-memq" class="anchor"></a><code><span><span class="keyword">val</span> memq : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>As <code>mem</code>, but with physical equality</p></div></div><div class="odoc-spec"><div class="spec value" id="val-find" class="anchored"><a href="#val-find" class="anchor"></a><code><span><span class="keyword">val</span> find : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>find p l</code> returns the first element of <code>l</code> such as <code>p x</code> returns <code>true</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Not_found</span> <p>if such an element has not been found.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-rfind" class="anchored"><a href="#val-rfind" class="anchor"></a><code><span><span class="keyword">val</span> rfind : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>rfind p l</code> returns the last element <code>x</code> of <code>l</code> such as <code>p x</code> returns <code>true</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Not_found</span> <p>if such element as not been found.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-find_exn" class="anchored"><a href="#val-find_exn" class="anchor"></a><code><span><span class="keyword">val</span> find_exn : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span>exn <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>find_exn p e l</code> returns the first element of <code>l</code> such as <code>p x</code> returns <code>true</code> or raises <code>e</code> if such an element has not been found.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-rfind_exn" class="anchored"><a href="#val-rfind_exn" class="anchor"></a><code><span><span class="keyword">val</span> rfind_exn : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span>exn <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>rfind_exn p e l</code> returns the last element of <code>l</code> such as <code>p x</code> returns <code>true</code> or raises <code>e</code> if such an element has not been found.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-findi" class="anchored"><a href="#val-findi" class="anchor"></a><code><span><span class="keyword">val</span> findi : <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> int * <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>findi p e l</code> returns the first element <code>ai</code> of <code>l</code> along with its index <code>i</code> such that <code>p i ai</code> is true.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Not_found</span> <p>if no such element has been found.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-rfindi" class="anchored"><a href="#val-rfindi" class="anchor"></a><code><span><span class="keyword">val</span> rfindi : <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> int * <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>rfindi p e l</code> returns the last element <code>ai</code> of <code>l</code> along with its index <code>i</code> such that <code>p i ai</code> is true.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Not_found</span> <p>if no such element has been found.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-index_of" class="anchored"><a href="#val-index_of" class="anchor"></a><code><span><span class="keyword">val</span> index_of : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>int option</span></span></code></div><div class="spec-doc"><p><code>index_of e l</code> returns the index of the first occurrence of <code>e</code> in <code>l</code>, or <code>None</code> if there is no occurrence of <code>e</code> in <code>l</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-index_ofq" class="anchored"><a href="#val-index_ofq" class="anchor"></a><code><span><span class="keyword">val</span> index_ofq : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>int option</span></span></code></div><div class="spec-doc"><p><code>index_ofq e l</code> behaves as <code>index_of e l</code> except it uses physical equality</p></div></div><div class="odoc-spec"><div class="spec value" id="val-rindex_of" class="anchored"><a href="#val-rindex_of" class="anchor"></a><code><span><span class="keyword">val</span> rindex_of : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>int option</span></span></code></div><div class="spec-doc"><p><code>index_of e l</code> returns the index of the last occurrence of <code>e</code> in <code>l</code>, or <code>None</code> if there is no occurrence of <code>e</code> in <code>l</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-rindex_ofq" class="anchored"><a href="#val-rindex_ofq" class="anchor"></a><code><span><span class="keyword">val</span> rindex_ofq : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>int option</span></span></code></div><div class="spec-doc"><p><code>rindex_ofq e l</code> behaves as <code>rindex_of e l</code> except it uses physical equality</p></div></div><h6 id="common-functions"><a href="#common-functions" class="anchor"></a>Common functions</h6><div class="odoc-spec"><div class="spec value" id="val-next" class="anchored"><a href="#val-next" class="anchor"></a><code><span><span class="keyword">val</span> next : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-node_t">node_t</a></span></span></code></div><div class="spec-doc"><p>Compute and return the first node from the list as a <code>Cons</code>. This differs from <code>hd</code>, which returns the first element (the first component of the first node).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-length" class="anchored"><a href="#val-length" class="anchor"></a><code><span><span class="keyword">val</span> length : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Return the length (number of elements) of the given list.</p><p>Causes the evaluation of all the elements of the list.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_empty" class="anchored"><a href="#val-is_empty" class="anchor"></a><code><span><span class="keyword">val</span> is_empty : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Returns <code>true</code> if the list is empty, false otherwise.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-would_at_fail" class="anchored"><a href="#val-would_at_fail" class="anchor"></a><code><span><span class="keyword">val</span> would_at_fail : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>would_at_fail l n</code> returns <code>true</code> if <code>l</code> contains strictly less than <code>n</code> elements, <code>false</code> otherwise</p></div></div><div class="odoc-spec"><div class="spec value" id="val-hd" class="anchored"><a href="#val-hd" class="anchor"></a><code><span><span class="keyword">val</span> hd : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Return the first element of the given list. </p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Empty_list</span> <p>if the list is empty.</p><p>Note: this function does not comply with the usual exceptionless error-management recommendations, as doing so would essentially render it useless.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-tl" class="anchored"><a href="#val-tl" class="anchor"></a><code><span><span class="keyword">val</span> tl : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Return the given list without its first element. </p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Empty_list</span> <p>if the list is empty.</p><p>Note: this function does not comply with the usual exceptionless error-management recommendations, as doing so would essentially render it useless.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-first" class="anchored"><a href="#val-first" class="anchor"></a><code><span><span class="keyword">val</span> first : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>As <code>hd</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-last" class="anchored"><a href="#val-last" class="anchor"></a><code><span><span class="keyword">val</span> last : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Returns the last element of the list. </p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Empty_list</span> <p>if the list is empty. This function takes linear time and causes the evaluation of all elements of the list</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-at" class="anchored"><a href="#val-at" class="anchor"></a><code><span><span class="keyword">val</span> at : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>at l n</code> returns the element at index <code>n</code> (starting from <code>0</code>) in the list <code>l</code>. </p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_index</span> <p>is the index is outside of <code>l</code> bounds.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-nth" class="anchored"><a href="#val-nth" class="anchor"></a><code><span><span class="keyword">val</span> nth : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Obsolete. As <code>at</code></p></div></div><h6 id="association-lists"><a href="#association-lists" class="anchor"></a>Association lists</h6><p>These lists behave essentially as <code>HashMap</code>, although they are typically faster for short number of associations, and much slower for for large number of associations.</p><div class="odoc-spec"><div class="spec value" id="val-assoc" class="anchored"><a href="#val-assoc" class="anchor"></a><code><span><span class="keyword">val</span> assoc : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span></span></code></div><div class="spec-doc"><p><code>assoc a l</code> returns the value associated with key <code>a</code> in the list of pairs <code>l</code>. That is, <code>assoc a [^ ...; (a,b); ...^] = b</code> if <code>(a,b)</code> is the leftmost binding of <code>a</code> in list <code>l</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Not_found</span> <p>if there is no value associated with <code>a</code> in the list <code>l</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-assq" class="anchored"><a href="#val-assq" class="anchor"></a><code><span><span class="keyword">val</span> assq : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span></span></code></div><div class="spec-doc"><p>As <a href="#val-assoc"><code>assoc</code></a> but with physical equality</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mem_assoc" class="anchored"><a href="#val-mem_assoc" class="anchor"></a><code><span><span class="keyword">val</span> mem_assoc : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>As <a href="#val-assoc"><code>assoc</code></a> but simply returns <code>true</code> if a binding exists, <code>false</code> otherwise.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mem_assq" class="anchored"><a href="#val-mem_assq" class="anchor"></a><code><span><span class="keyword">val</span> mem_assq : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>As <a href="#val-mem_assoc"><code>mem_assoc</code></a> but with physical equality.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-rev" class="anchored"><a href="#val-rev" class="anchor"></a><code><span><span class="keyword">val</span> rev : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Eager list reversal.</p></div></div><h6 id="transformations"><a href="#transformations" class="anchor"></a>Transformations</h6><div class="odoc-spec"><div class="spec value" id="val-eager_append" class="anchored"><a href="#val-eager_append" class="anchor"></a><code><span><span class="keyword">val</span> eager_append : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Evaluate a list and append another list after this one.</p><p>Cost is linear in the length of the first list, not tail-recursive.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-rev_append" class="anchored"><a href="#val-rev_append" class="anchor"></a><code><span><span class="keyword">val</span> rev_append : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Eager reverse-and-append</p><p>Cost is linear in the length of the first list, tail-recursive.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-append" class="anchored"><a href="#val-append" class="anchor"></a><code><span><span class="keyword">val</span> append : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Lazy append</p><p>Cost is constant. All evaluation is delayed until the contents of the list are actually read. Reading itself is delayed by a constant.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-(^@^)" class="anchored"><a href="#val-(^@^)" class="anchor"></a><code><span><span class="keyword">val</span> (^@^) : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>As lazy append</p></div></div><div class="odoc-spec"><div class="spec value" id="val-concat" class="anchored"><a href="#val-concat" class="anchor"></a><code><span><span class="keyword">val</span> concat : <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Lazy concatenation of a lazy list of lazy lists</p></div></div><div class="odoc-spec"><div class="spec value" id="val-flatten" class="anchored"><a href="#val-flatten" class="anchor"></a><code><span><span class="keyword">val</span> flatten : <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Lazy concatenation of a list of lazy lists</p></div></div><div class="odoc-spec"><div class="spec value" id="val-split_at" class="anchored"><a href="#val-split_at" class="anchor"></a><code><span><span class="keyword">val</span> split_at : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> * <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>split_at n l</code> returns two lists <code>l1</code> and <code>l2</code>, <code>l1</code> containing the first <code>n</code> elements of <code>l</code> and <code>l2</code> the others. </p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_index</span> <p>if <code>n</code> is outside of <code>l</code> size bounds.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-split_nth" class="anchored"><a href="#val-split_nth" class="anchor"></a><code><span><span class="keyword">val</span> split_nth : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> * <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Obsolete. As <code>split_at</code>.</p></div></div><h6 id="dropping-elements"><a href="#dropping-elements" class="anchor"></a>Dropping elements</h6><div class="odoc-spec"><div class="spec value" id="val-unique" class="anchored"><a href="#val-unique" class="anchor"></a><code><span><span class="keyword">val</span> unique : <span>?cmp:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>unique cmp l</code> returns the list <code>l</code> without any duplicate element. Default comparator ( = ) is used if no comparison function specified.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unique_eq" class="anchored"><a href="#val-unique_eq" class="anchor"></a><code><span><span class="keyword">val</span> unique_eq : <span>?eq:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>as <code>unique</code> except only uses an equality function. Use for short lists when comparing is expensive compared to equality testing</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.3.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-remove" class="anchored"><a href="#val-remove" class="anchor"></a><code><span><span class="keyword">val</span> remove : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>remove l x</code> returns the list <code>l</code> without the first element <code>x</code> found or returns <code>l</code> if no element is equal to <code>x</code>. Elements are compared using ( = ).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-remove_if" class="anchored"><a href="#val-remove_if" class="anchor"></a><code><span><span class="keyword">val</span> remove_if : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>remove_if cmp l</code> is similar to <code>remove</code>, but with <code>cmp</code> used instead of ( = ).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-remove_all" class="anchored"><a href="#val-remove_all" class="anchor"></a><code><span><span class="keyword">val</span> remove_all : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>remove_all l x</code> is similar to <code>remove</code> but removes all elements that are equal to <code>x</code> and not only the first one.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-remove_all_such" class="anchored"><a href="#val-remove_all_such" class="anchor"></a><code><span><span class="keyword">val</span> remove_all_such : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>remove_all_such f l</code> is similar to <code>remove</code> but removes all elements that satisfy the predicate <code>f</code> and not only the first one.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-take" class="anchored"><a href="#val-take" class="anchor"></a><code><span><span class="keyword">val</span> take : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>take n l</code> returns up to the <code>n</code> first elements from list <code>l</code>, if available.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-drop" class="anchored"><a href="#val-drop" class="anchor"></a><code><span><span class="keyword">val</span> drop : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>drop n l</code> returns <code>l</code> without the first <code>n</code> elements, or the empty list if <code>l</code> have less than <code>n</code> elements.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-take_while" class="anchored"><a href="#val-take_while" class="anchor"></a><code><span><span class="keyword">val</span> take_while : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>take_while f xs</code> returns the first elements of list <code>xs</code> which satisfy the predicate <code>f</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-drop_while" class="anchored"><a href="#val-drop_while" class="anchor"></a><code><span><span class="keyword">val</span> drop_while : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>drop_while f xs</code> returns the list <code>xs</code> with the first elements satisfying the predicate <code>f</code> dropped.</p></div></div><h6 id="conversions"><a href="#conversions" class="anchor"></a>Conversions</h6><div class="odoc-spec"><div class="spec value" id="val-to_list" class="anchored"><a href="#val-to_list" class="anchor"></a><code><span><span class="keyword">val</span> to_list : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p>Eager conversion to string.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_stream" class="anchored"><a href="#val-to_stream" class="anchor"></a><code><span><span class="keyword">val</span> to_stream : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../../ocaml/Stdlib/Stream/index.html#type-t">Stream.t</a></span></span></code></div><div class="spec-doc"><p>Lazy conversion to stream.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_array" class="anchored"><a href="#val-to_array" class="anchor"></a><code><span><span class="keyword">val</span> to_array : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> array</span></span></code></div><div class="spec-doc"><p>Eager conversion to array.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-enum" class="anchored"><a href="#val-enum" class="anchor"></a><code><span><span class="keyword">val</span> enum : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../BatEnum/index.html#type-t">BatEnum.t</a></span></span></code></div><div class="spec-doc"><p>Lazy conversion to enumeration</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_list" class="anchored"><a href="#val-of_list" class="anchor"></a><code><span><span class="keyword">val</span> of_list : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Lazy conversion from lists</p><p>Albeit slower than eager conversion, this is the default mechanism for converting from regular lists to lazy lists. This for two reasons : * if you're using lazy lists, total speed probably isn't as much an issue as start-up speed * this will let you convert regular infinite lists to lazy lists.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_stream" class="anchored"><a href="#val-of_stream" class="anchor"></a><code><span><span class="keyword">val</span> of_stream : <span><span><span class="type-var">'a</span> <a href="../../ocaml/Stdlib/Stream/index.html#type-t">Stream.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Lazy conversion from stream.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_enum" class="anchored"><a href="#val-of_enum" class="anchor"></a><code><span><span class="keyword">val</span> of_enum : <span><span><span class="type-var">'a</span> <a href="../BatEnum/index.html#type-t">BatEnum.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Lazy conversion from enum.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-eager_of_list" class="anchored"><a href="#val-eager_of_list" class="anchor"></a><code><span><span class="keyword">val</span> eager_of_list : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Eager conversion from lists.</p><p>This function is much faster than <a href="#val-of_list"><code>of_list</code></a> but will freeze on cyclic lists.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_array" class="anchored"><a href="#val-of_array" class="anchor"></a><code><span><span class="keyword">val</span> of_array : <span><span><span class="type-var">'a</span> array</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Eager conversion from array</p></div></div><h6 id="predicates"><a href="#predicates" class="anchor"></a>Predicates</h6><div class="odoc-spec"><div class="spec value" id="val-filter" class="anchored"><a href="#val-filter" class="anchor"></a><code><span><span class="keyword">val</span> filter : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Lazy filtering.</p><p><code>filter p l</code> returns all the elements of the list <code>l</code> that satisfy the predicate <code>p</code>. The order of the elements in the input list is preserved.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-exists" class="anchored"><a href="#val-exists" class="anchor"></a><code><span><span class="keyword">val</span> exists : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Eager existential.</p><p><code>exists p [^ a0; a1; ... ^]</code> checks if at least one element of the list satisfies the predicate <code>p</code>. That is, it returns <code> (p a0) || (p a1) || ... </code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-for_all" class="anchored"><a href="#val-for_all" class="anchor"></a><code><span><span class="keyword">val</span> for_all : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Eager universal.</p><p><code>for_all p [^ a0; a1; ... ^]</code> checks if all elements of the list satisfy the predicate <code>p</code>. That is, it returns <code>(p a0) &amp;&amp; (p a1) &amp;&amp; ... </code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-filter_map" class="anchored"><a href="#val-filter_map" class="anchor"></a><code><span><span class="keyword">val</span> filter_map : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Lazily eliminate some elements and transform others.</p><p><code>filter_map f [^ a0; a1; ... ^]</code> applies lazily <code>f</code> to each <code>a0</code>, <code>a1</code>... If <code>f ai</code> evaluates to <code>None</code>, the element is not included in the result. Otherwise, if <code>f ai</code> evaluates to <code>Some x</code>, element <code>x</code> is included in the result.</p><p>This is equivalent to <code>match f a0 with
     | Some x0 -&gt; x0 ^:^ (match f a1 with
            | Some x1 -&gt; x1 ^:^ ...
            | None -&gt; [^ ^])
     | None   -&gt; [^ ^] </code>.</p></div></div><h6 id="misc."><a href="#misc." class="anchor"></a>Misc.</h6><div class="odoc-spec"><div class="spec value" id="val-eternity" class="anchored"><a href="#val-eternity" class="anchor"></a><code><span><span class="keyword">val</span> eternity : <span>unit <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>An infinite list of nothing</p></div></div><h6 id="sorting"><a href="#sorting" class="anchor"></a>Sorting</h6><div class="odoc-spec"><div class="spec value" id="val-sort" class="anchored"><a href="#val-sort" class="anchor"></a><code><span><span class="keyword">val</span> sort : <span>?cmp:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Sort the list using optional comparator (by default <code>compare</code>).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-stable_sort" class="anchored"><a href="#val-stable_sort" class="anchor"></a><code><span><span class="keyword">val</span> stable_sort : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div></div><h6 id="operations-on-two-lists"><a href="#operations-on-two-lists" class="anchor"></a>Operations on two lists</h6><div class="odoc-spec"><div class="spec value" id="val-map2" class="anchored"><a href="#val-map2" class="anchor"></a><code><span><span class="keyword">val</span> map2 : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>map2 f [^ a0; a1; ...^] [^ b0; b1; ... ^]</code> is <code>[^ f a0 b0; f a1
    b1; ... ^]</code>. </p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Different_list_size</span> <p>if the two lists have different lengths. Not tail-recursive, lazy. In particular, the exception is raised only after the shortest list has been entirely consumed.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-iter2" class="anchored"><a href="#val-iter2" class="anchor"></a><code><span><span class="keyword">val</span> iter2 : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>iter2 f [^ a0; ...; an ^] [^ b0; ...; bn ^]</code> calls in turn <code>f a0 b0; ...; f an bn</code>. Tail-recursive, eager.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Different_list_size</span> <p>if the two lists have different lengths.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_left2" class="anchored"><a href="#val-fold_left2" class="anchor"></a><code><span><span class="keyword">val</span> fold_left2 : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'c</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>fold_left2 f a [^ b0; b1; ...; bn ^] [^ c0; c1; ...; cn ^]</code> is <code>f (... (f (f a b0 c0) b1 c1) ...) bn cn</code>. Eager.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Different_list_size</span> <p>if the two lists have different lengths.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_right2" class="anchored"><a href="#val-fold_right2" class="anchor"></a><code><span><span class="keyword">val</span> fold_right2 : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span></span></code></div><div class="spec-doc"><p><code>fold_right2 f [^ a0; a1; ...; an ^] [^ b0; b1; ...; bn ^] c</code> is <code>f a0 b0 (f a1 b1 (... (f an bn c) ...))</code>. Eager.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Different_list_size</span> <p>if the two lists have different lengths. Tail-recursive.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-for_all2" class="anchored"><a href="#val-for_all2" class="anchor"></a><code><span><span class="keyword">val</span> for_all2 : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Same as <a href="#val-for_all"><code>for_all</code></a>, but for a two-argument predicate.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Different_list_size</span> <p>if the two lists have different lengths.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-equal" class="anchored"><a href="#val-equal" class="anchor"></a><code><span><span class="keyword">val</span> equal : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>equal eq s1 s2</code> compares elements of <code>s1</code> and <code>s2</code> pairwise using <code>eq</code> and returns true if all elements pass the test and the lists have the same length; otherwise it returns false. Examples:</p><pre><code>equal (=) (range 0 4) (range 0 4) (* true *)

(* Make lazy lists of lazy lists: *)
let s1 = init 5 (range 0) 
let s2 = init 5 (range 0) 
equal (equal (=)) s1 s2 (* true *)</code></pre><p>(Calling <code>=</code> directly on a pair of lazy lists may succeed but is not guaranteed to behave consistently.)</p><p>Note that on lists of equal length, <code>equal</code> and <code>for_all2</code> can perform the same function; their intended uses differ, however, as signaled by behavior on lists of different lengths.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-exists2" class="anchored"><a href="#val-exists2" class="anchor"></a><code><span><span class="keyword">val</span> exists2 : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Same as <a href="#val-exists"><code>exists</code></a>, but for a two-argument predicate.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Different_list_size</span> <p>if the two lists have different lengths.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-combine" class="anchored"><a href="#val-combine" class="anchor"></a><code><span><span class="keyword">val</span> combine : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Transform a pair of lists into a list of pairs: <code>combine [^ a0; a1; ... ^] [^ b0; b1; ... ^]</code> is <code>[^ (a0, b0); (a1, b1); ... ^]</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Different_list_size</span> <p>if the two lists have different lengths. Tail-recursive, lazy.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-uncombine" class="anchored"><a href="#val-uncombine" class="anchor"></a><code><span><span class="keyword">val</span> uncombine : <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> * <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Divide a list of pairs into a pair of lists.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Infix" class="anchored"><a href="#module-Infix" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Infix/index.html">Infix</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><h6 id="boilerplate-code"><a href="#boilerplate-code" class="anchor"></a>Boilerplate code</h6><h6 id="printing"><a href="#printing" class="anchor"></a>Printing</h6><div class="odoc-spec"><div class="spec value" id="val-print" class="anchored"><a href="#val-print" class="anchor"></a><code><span><span class="keyword">val</span> print : <span>?first:string <span class="arrow">&#45;&gt;</span></span> <span>?last:string <span class="arrow">&#45;&gt;</span></span> <span>?sep:string <span class="arrow">&#45;&gt;</span></span>
<span><span>(<span><span><span class="type-var">'a</span> <a href="../BatInnerIO/index.html#type-output">BatInnerIO.output</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="../BatInnerIO/index.html#type-output">BatInnerIO.output</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><h6 id="override-modules"><a href="#override-modules" class="anchor"></a>Override modules</h6><p>The following modules replace functions defined in <code>LazyList</code> with functions behaving slightly differently but having the same name. This is by design: the functions meant to override the corresponding functions of <code>LazyList</code>.</p><div class="odoc-spec"><div class="spec module" id="module-Exceptionless" class="anchored"><a href="#module-Exceptionless" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Exceptionless/index.html">Exceptionless</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Exceptionless counterparts for error-raising operations</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Labels" class="anchored"><a href="#module-Labels" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Labels/index.html">Labels</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Operations on <code>LazyList</code> with labels.</p></div></div></div></body></html>