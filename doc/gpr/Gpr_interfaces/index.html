<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Gpr_interfaces (gpr.Gpr_interfaces)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">gpr</a> &#x00BB; Gpr_interfaces</nav><h1>Module <code>Gpr_interfaces</code></h1><h6 id="representations-of-(sparse)-derivative-matrices"><a href="#representations-of-(sparse)-derivative-matrices" class="anchor"></a>Representations of (sparse) derivative matrices</h6></header><dl><dt class="spec module" id="module-Sparse_indices"><a href="#module-Sparse_indices" class="anchor"></a><code><span class="keyword">module</span> Sparse_indices = <a href="../Gpr_utils/index.html#module-Int_vec">Gpr_utils.Int_vec</a></code></dt><dd><p>Representation of indices into sparse matrices</p></dd></dl><dl><dt class="spec type" id="type-common_mat_deriv"><a href="#type-common_mat_deriv" class="anchor"></a><code><span class="keyword">type</span> common_mat_deriv</code> = <code>[ </code><table class="variant"><tr id="type-common_mat_deriv.Dense" class="anchored"><td class="def constructor"><a href="#type-common_mat_deriv.Dense" class="anchor"></a><code>| </code><code>`Dense <span class="keyword">of</span> <a href="../../lacaml/Lacaml_D/index.html#type-mat">Lacaml.D.mat</a></code></td></tr><tr id="type-common_mat_deriv.Sparse_rows" class="anchored"><td class="def constructor"><a href="#type-common_mat_deriv.Sparse_rows" class="anchor"></a><code>| </code><code>`Sparse_rows <span class="keyword">of</span> <a href="../../lacaml/Lacaml_D/index.html#type-mat">Lacaml.D.mat</a> * <a href="../Gpr_utils/Int_vec/index.html#type-t">Sparse_indices.t</a></code></td></tr><tr id="type-common_mat_deriv.Const" class="anchored"><td class="def constructor"><a href="#type-common_mat_deriv.Const" class="anchor"></a><code>| </code><code>`Const <span class="keyword">of</span> float</code></td></tr><tr id="type-common_mat_deriv.Factor" class="anchored"><td class="def constructor"><a href="#type-common_mat_deriv.Factor" class="anchor"></a><code>| </code><code>`Factor <span class="keyword">of</span> float</code></td></tr></table><code> ]</code></dt><dd><p>Derivative representations for both symmetric and unsymmetric matrices.</p><ul><li>Dense: matrix is dense.</li><li>Sparse_rows: matrix is zero everywhere except for rows whose index is stored in the sparse index argument. The rows in the matrix correspond to the given indices.</li><li>Const: matrix is constant everywhere.</li><li>Factor: matrix is the non-derived matrix times the given factor (useful with exponential functions).</li></ul></dd></dl><dl><dt class="spec type" id="type-mat_deriv"><a href="#type-mat_deriv" class="anchor"></a><code><span class="keyword">type</span> mat_deriv</code> = <code>[ </code><table class="variant"><tr id="type-mat_deriv.common_mat_deriv" class="anchored"><td class="def type"><a href="#type-mat_deriv.common_mat_deriv" class="anchor"></a><code>| </code><code><a href="index.html#type-common_mat_deriv">common_mat_deriv</a></code></td></tr><tr id="type-mat_deriv.Sparse_cols" class="anchored"><td class="def constructor"><a href="#type-mat_deriv.Sparse_cols" class="anchor"></a><code>| </code><code>`Sparse_cols <span class="keyword">of</span> <a href="../../lacaml/Lacaml_D/index.html#type-mat">Lacaml.D.mat</a> * <a href="../Gpr_utils/Int_vec/index.html#type-t">Sparse_indices.t</a></code></td></tr></table><code> ]</code></dt><dd><p>Only general matrices support sparse column representations.</p><ul><li>Sparse_cols: matrix is zero everywhere except for columns whose index is stored in the sparse index argument. The columns in the matrix correspond to the given indices.</li></ul></dd></dl><dl><dt class="spec type" id="type-symm_mat_deriv"><a href="#type-symm_mat_deriv" class="anchor"></a><code><span class="keyword">type</span> symm_mat_deriv</code> = <code>[ </code><table class="variant"><tr id="type-symm_mat_deriv.common_mat_deriv" class="anchored"><td class="def type"><a href="#type-symm_mat_deriv.common_mat_deriv" class="anchor"></a><code>| </code><code><a href="index.html#type-common_mat_deriv">common_mat_deriv</a></code></td></tr><tr id="type-symm_mat_deriv.Diag_vec" class="anchored"><td class="def constructor"><a href="#type-symm_mat_deriv.Diag_vec" class="anchor"></a><code>| </code><code>`Diag_vec <span class="keyword">of</span> <a href="../../lacaml/Lacaml_D/index.html#type-vec">Lacaml.D.vec</a></code></td></tr><tr id="type-symm_mat_deriv.Diag_const" class="anchored"><td class="def constructor"><a href="#type-symm_mat_deriv.Diag_const" class="anchor"></a><code>| </code><code>`Diag_const <span class="keyword">of</span> float</code></td></tr></table><code> ]</code></dt><dd><p>Only symmetric (square) matrices support diagonal vectors and diagonal constants as derivatives.</p><ul><li>Diag_vec: matrix is zero everywhere except for the diagonal whose values are given in the argument.</li><li>Diag_const: matrix is zero everywhere except for the diagonal whose values are set to the given constant.</li></ul><p>Note that sparse rows do not need to compute or store all elements for symmetric matrices. Entries that have already appeared in previous rows by symmetry can be left uninitialized.</p></dd></dl><dl><dt class="spec type" id="type-diag_deriv"><a href="#type-diag_deriv" class="anchor"></a><code><span class="keyword">type</span> diag_deriv</code> = <code>[ </code><table class="variant"><tr id="type-diag_deriv.Vec" class="anchored"><td class="def constructor"><a href="#type-diag_deriv.Vec" class="anchor"></a><code>| </code><code>`Vec <span class="keyword">of</span> <a href="../../lacaml/Lacaml_D/index.html#type-vec">Lacaml.D.vec</a></code></td></tr><tr id="type-diag_deriv.Sparse_vec" class="anchored"><td class="def constructor"><a href="#type-diag_deriv.Sparse_vec" class="anchor"></a><code>| </code><code>`Sparse_vec <span class="keyword">of</span> <a href="../../lacaml/Lacaml_D/index.html#type-vec">Lacaml.D.vec</a> * <a href="../Gpr_utils/Int_vec/index.html#type-t">Sparse_indices.t</a></code></td></tr><tr id="type-diag_deriv.Const" class="anchored"><td class="def constructor"><a href="#type-diag_deriv.Const" class="anchor"></a><code>| </code><code>`Const <span class="keyword">of</span> float</code></td></tr><tr id="type-diag_deriv.Factor" class="anchored"><td class="def constructor"><a href="#type-diag_deriv.Factor" class="anchor"></a><code>| </code><code>`Factor <span class="keyword">of</span> float</code></td></tr></table><code> ]</code></dt><dd><p>Derivatives of diagonal matrices.</p><ul><li>Vec: the derivatives of the diagonal given in a dense vector.</li><li>Sparse_vec: matrix is zero everywhere except at those indices along the diagonal that are mentioned in the sparse indices argument. The element associated with such an index is stored in the vector argument.</li><li>Const: the derivative of the diagonal matrix is a constant.</li><li>Factor: the derivative of the diagonal is the the non-derived diagonal matrix times the given factor (useful with exponential functions).</li></ul></dd></dl><dl><dt class="spec module" id="module-Specs"><a href="#module-Specs" class="anchor"></a><code><span class="keyword">module</span> <a href="Specs/index.html">Specs</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Specifications of covariance functions (= kernels) and their derivatives</p></dd></dl><dl><dt class="spec module" id="module-Sigs"><a href="#module-Sigs" class="anchor"></a><code><span class="keyword">module</span> <a href="Sigs/index.html">Sigs</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Signatures for learning sparse Gaussian processes with inducing inputs</p></dd></dl></div></body></html>