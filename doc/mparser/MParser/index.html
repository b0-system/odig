<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>MParser (mparser.MParser)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">mparser</a> &#x00BB; MParser</nav><h1>Module <code>MParser</code></h1><p>A monadic parser combinator library.</p><nav class="toc"><ul><li><a href="#parser-state">Parser state</a></li><li><a href="#error-handling-and-reporting">Error handling and reporting</a></li><li><a href="#the-parser-type">The parser type</a></li><li><a href="#running-a-parser">Running a parser</a></li><li><a href="#parser-combinators">Parser combinators</a></li><li><a href="#parsers-accessing-the-parser-state">Parsers accessing the parser state</a></li><li><a href="#parsers-accessing-the-user-state">Parsers accessing the user state</a></li><li><a href="#character-based-parsers">Character-based parsers</a></li><li><a href="#expression-parser">Expression parser</a></li><li><a href="#regexp-related-features">Regexp-related features</a></li></ul></nav></header><aside><p>The parser combinators provided by this module can be used to build parsers for context-sensitive, infinite look-ahead grammars that are reasonably efficient and produce good error messages due to a controlled use of backtracking. The performance of the resulting parsers should be sufficient for most applications. The parsers get their input from character streams provided by the <a href="../MParser_Char_Stream/index.html"><code>MParser_Char_Stream</code></a> module, which means that it is possible to parse files up to a size of at least 1GB.</p><p>The <code>MParser</code> module is an OCaml version of the <a href="http://www.quanttec.com/fparsec">FParsec</a> library for F# by Stephan Tolksdorf and the <a href="http://research.microsoft.com/users/daan/parsec.html">Parsec</a> library for Haskell by Daan Leijen. The interface of the <code>MParser</code> module is very similar to the interfaces of Parsec and FParsec. For this reason, we keep the documentation here rather terse. See the excellent documentation of Parsec and FParsec for more information. Parsers should be easily portable from these two libraries to <code>MParser</code> (although some functions might behave subtly different). Where the behavior of Parsec and FParsec differs, <code>MParser</code> generally behaves like FParsec (but there might be exceptions).</p><p>A significant drawback of the implementation is that it relies on the standard OCaml types <code>char</code> and <code>string</code> and therefore there is <em>currently no support for Unicode</em>.</p></aside><section><header><h3 id="parser-state"><a href="#parser-state" class="anchor"></a>Parser state</h3><p>The state of a parser consists of the input to be parsed, the current position in the input, the number of the current line, the position of the first character of the current line in the input, and an optional user state. A position <code>p</code> is valid if it satisfies <code>0 &lt;= p &amp;&amp; p &lt; l</code>, where <code>l</code> is the length of the input; all other positions are invalid. Characters can only be read from valid positions.</p><p>The following functions that directly access or change the parser state should only be used to write very low-level parsers. All other parsers should be composed from parser combinators (see below).</p></header><dl><dt class="spec type" id="type-state"><a href="#type-state" class="anchor"></a><code><span class="keyword">type</span> 's state</code></dt><dd><p>The type of parser states.</p></dd></dl><dl><dt class="spec value" id="val-init"><a href="#val-init" class="anchor"></a><code><span class="keyword">val</span> init : <a href="../MParser_Char_Stream/index.html#type-t">MParser_Char_Stream.t</a> <span>&#45;&gt;</span> <span class="type-var">'s</span> <span>&#45;&gt;</span> <span class="type-var">'s</span> <a href="index.html#type-state">state</a></code></dt><dd><p><code>init input user</code> returns an initial parser state using the input stream <code>input</code> and the initial user state <code>user</code>.</p></dd></dl><dl><dt class="spec value" id="val-is_eof"><a href="#val-is_eof" class="anchor"></a><code><span class="keyword">val</span> is_eof : <span class="type-var">'s</span> <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_eof s</code> returns <code>true</code> if the current position of <code>s</code> is not a valid position, and <code>false</code> otherwise. If <code>is_eof</code> returns <code>false</code>, a character can be read from the current position.</p></dd></dl><dl><dt class="spec value" id="val-next_state"><a href="#val-next_state" class="anchor"></a><code><span class="keyword">val</span> next_state : <span class="type-var">'s</span> <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> <span class="type-var">'s</span> <a href="index.html#type-state">state</a></code></dt><dd><p><code>advance s</code> returns the state <code>s</code> with the position advanced by one character if the current position of <code>s</code> is a valid position. Otherwise, the same state is returned. This function does not register newlines. If the current character is a newline, <code>advance_state_nl</code> should be used instead.</p></dd></dl><dl><dt class="spec value" id="val-advance_state"><a href="#val-advance_state" class="anchor"></a><code><span class="keyword">val</span> advance_state : <span class="type-var">'s</span> <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'s</span> <a href="index.html#type-state">state</a></code></dt><dd><p><code>advance_state s n</code> returns the state <code>s</code> with the position advanced by <code>n</code> characters if the current position of <code>s</code> is a valid position. Otherwise, the same state is returned. This function does not register newlines. If the current character is a newline, <code>advance_state_nl</code> should be used instead.</p></dd></dl><dl><dt class="spec value" id="val-advance_state_nl"><a href="#val-advance_state_nl" class="anchor"></a><code><span class="keyword">val</span> advance_state_nl : <span class="type-var">'s</span> <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'s</span> <a href="index.html#type-state">state</a></code></dt><dd><p><code>advance_state_nl s n</code> returns the state <code>s</code> with the position advanced by <code>n</code> characters and the line counter increased by one if the current position of <code>s</code> is a valid position. Otherwise, the same state is returned.</p></dd></dl><dl><dt class="spec value" id="val-read_char"><a href="#val-read_char" class="anchor"></a><code><span class="keyword">val</span> read_char : <span class="type-var">'s</span> <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> char option</code></dt><dd><p><code>read_char s</code> returns <code>Some c</code> where <code>c</code> is the character at the current position, or <code>None</code> if this position is not a valid position.</p></dd></dl><dl><dt class="spec value" id="val-read_index"><a href="#val-read_index" class="anchor"></a><code><span class="keyword">val</span> read_index : <span class="type-var">'s</span> <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> char option</code></dt><dd><p><code>read_index s pos</code> returns <code>Some c</code> where <code>c</code> is the character at the position <code>pos</code>, or <code>None</code> if this position is not a valid position.</p></dd></dl><dl><dt class="spec value" id="val-next_char"><a href="#val-next_char" class="anchor"></a><code><span class="keyword">val</span> next_char : <span class="type-var">'s</span> <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> char option</code></dt><dd><p><code>next_char s</code> returns <code>Some c</code> where <code>c</code> is the character after the current position, or <code>None</code> if this position is not a valid position.</p></dd></dl><dl><dt class="spec value" id="val-prev_char"><a href="#val-prev_char" class="anchor"></a><code><span class="keyword">val</span> prev_char : <span class="type-var">'s</span> <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> char option</code></dt><dd><p><code>prev_char s</code> returns <code>Some c</code> where <code>c</code> is the character before the current position, or <code>None</code> if this position is not a valid position.</p></dd></dl><dl><dt class="spec value" id="val-read_string"><a href="#val-read_string" class="anchor"></a><code><span class="keyword">val</span> read_string : <span class="type-var">'s</span> <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> string</code></dt><dd><p><code>read_string s maxlen</code> returns a string containing the next <code>n</code> characters, where <code>n</code> is the minimum of <code>maxlen</code> and the number of characters remaining from the current position. If the current position is not a valid position, the empty string is returned.</p></dd></dl><dl><dt class="spec value" id="val-match_char"><a href="#val-match_char" class="anchor"></a><code><span class="keyword">val</span> match_char : <span class="type-var">'s</span> <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> char <span>&#45;&gt;</span> bool</code></dt><dd><p><code>match_char s c</code> returns <code>true</code> if <code>c</code> is the character at the current position, and <code>false</code> otherwise.</p></dd></dl><dl><dt class="spec value" id="val-match_string"><a href="#val-match_string" class="anchor"></a><code><span class="keyword">val</span> match_string : <span class="type-var">'s</span> <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> bool</code></dt><dd><p><code>match_string s str</code> returns <code>true</code> if the input starting at the current position matches the string <code>str</code>, and <code>false</code> otherwise.</p></dd></dl></section><section><header><h3 id="error-handling-and-reporting"><a href="#error-handling-and-reporting" class="anchor"></a>Error handling and reporting</h3><p>When building parsers from the parser combinators and running them using the <code>parse</code> functions (see below), error handling and reporting is nearly automatic. If a parser run fails, the <code>parse</code> functions return a human-readable (plain English) error message that is generated from the labels attached to the parsers using the labelling operators <code>&lt;?&gt;</code> and <code>&lt;??&gt;</code>.</p><p>The following types and functions can be used for explicit creation of errors in parsers and for customizing the handling of errors returned by parser runs. For this purpose the <code>parse</code> functions also return the actual <code>error</code> value in the case of a failed parser run. Typical applications for customized error handling are the internationalization of error messages and the automatic processing of parse errors.</p></header><dl><dt class="spec type" id="type-pos"><a href="#type-pos" class="anchor"></a><code><span class="keyword">type</span> pos</code><code> = int * int * int</code></dt><dd><p>An input position, consisting of an index into the input, a line number, and a column number.</p></dd></dl><dl><dt class="spec type" id="type-error_message"><a href="#type-error_message" class="anchor"></a><code><span class="keyword">type</span> error_message</code><code> = </code><table class="variant"><tr id="type-error_message.Unexpected_error" class="anchored"><td class="def constructor"><a href="#type-error_message.Unexpected_error" class="anchor"></a><code>| </code><code><span class="constructor">Unexpected_error</span> <span class="keyword">of</span> string</code></td><td class="doc"><p>An unexpected symbol occurred in the input.</p></td></tr><tr id="type-error_message.Expected_error" class="anchored"><td class="def constructor"><a href="#type-error_message.Expected_error" class="anchor"></a><code>| </code><code><span class="constructor">Expected_error</span> <span class="keyword">of</span> string</code></td><td class="doc"><p>A symbol that was expected in the input could not be parsed.</p></td></tr><tr id="type-error_message.Message_error" class="anchored"><td class="def constructor"><a href="#type-error_message.Message_error" class="anchor"></a><code>| </code><code><span class="constructor">Message_error</span> <span class="keyword">of</span> string</code></td><td class="doc"><p>An error occurred that does not fit into any other category.</p></td></tr><tr id="type-error_message.Compound_error" class="anchored"><td class="def constructor"><a href="#type-error_message.Compound_error" class="anchor"></a><code>| </code><code><span class="constructor">Compound_error</span> <span class="keyword">of</span> string * <a href="index.html#type-error">error</a></code></td><td class="doc"><p>An error occurred while parsing a part of a compound.</p></td></tr><tr id="type-error_message.Backtrack_error" class="anchored"><td class="def constructor"><a href="#type-error_message.Backtrack_error" class="anchor"></a><code>| </code><code><span class="constructor">Backtrack_error</span> <span class="keyword">of</span> <a href="index.html#type-error">error</a></code></td><td class="doc"><p>The parser backtracked after an error occurred.</p></td></tr><tr id="type-error_message.Unknown_error" class="anchored"><td class="def constructor"><a href="#type-error_message.Unknown_error" class="anchor"></a><code>| </code><code><span class="constructor">Unknown_error</span></code></td><td class="doc"><p>An unknown error occurred.</p></td></tr></table></dt><dd><p>The type of error messages returned by parsers.</p></dd></dl><dl><dt class="spec type" id="type-error"><a href="#type-error" class="anchor"></a><code><span class="keyword">and</span> error</code><code> = </code><table class="variant"><tr id="type-error.Parse_error" class="anchored"><td class="def constructor"><a href="#type-error.Parse_error" class="anchor"></a><code>| </code><code><span class="constructor">Parse_error</span> <span class="keyword">of</span> <a href="index.html#type-pos">pos</a> * <a href="index.html#type-error_message">error_message</a> list</code></td></tr><tr id="type-error.No_error" class="anchored"><td class="def constructor"><a href="#type-error.No_error" class="anchor"></a><code>| </code><code><span class="constructor">No_error</span></code></td><td class="doc"><p>The type of errors returned by parsers.</p></td></tr></table></dt></dl><dl><dt class="spec value" id="val-unexpected_error"><a href="#val-unexpected_error" class="anchor"></a><code><span class="keyword">val</span> unexpected_error : <span class="type-var">'s</span> <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-error">error</a></code></dt><dd><p>Creates an <code>Unexpected_error</code>. The argument should describe the unexpected symbol that occurred in the input.</p></dd></dl><dl><dt class="spec value" id="val-expected_error"><a href="#val-expected_error" class="anchor"></a><code><span class="keyword">val</span> expected_error : <span class="type-var">'s</span> <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-error">error</a></code></dt><dd><p>Creates an <code>Expected_error</code>. The argument should describe the symbol that was expected but could not be parsed.</p></dd></dl><dl><dt class="spec value" id="val-message_error"><a href="#val-message_error" class="anchor"></a><code><span class="keyword">val</span> message_error : <span class="type-var">'s</span> <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-error">error</a></code></dt><dd><p>Creates a <code>Message_error</code>. The argument should contain the complete error message.</p></dd></dl><dl><dt class="spec value" id="val-compound_error"><a href="#val-compound_error" class="anchor"></a><code><span class="keyword">val</span> compound_error : <span class="type-var">'s</span> <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-error">error</a> <span>&#45;&gt;</span> <a href="index.html#type-error">error</a></code></dt><dd><p>Creates a <code>Compound_error</code>. The string argument should describe the compound that could not be parsed; the error argument should be the error that caused to compound parser to fail.</p></dd></dl><dl><dt class="spec value" id="val-backtrack_error"><a href="#val-backtrack_error" class="anchor"></a><code><span class="keyword">val</span> backtrack_error : <span class="type-var">'s</span> <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> <a href="index.html#type-error">error</a> <span>&#45;&gt;</span> <a href="index.html#type-error">error</a></code></dt><dd><p>Creates a <code>Backtrack_error</code>. The argument should be the error that caused the parser to backtrack.</p></dd></dl><dl><dt class="spec value" id="val-unknown_error"><a href="#val-unknown_error" class="anchor"></a><code><span class="keyword">val</span> unknown_error : <span class="type-var">'s</span> <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> <a href="index.html#type-error">error</a></code></dt><dd><p>Creates an <code>Unknown_error</code>.</p></dd></dl><dl><dt class="spec value" id="val-merge_errors"><a href="#val-merge_errors" class="anchor"></a><code><span class="keyword">val</span> merge_errors : <a href="index.html#type-error">error</a> <span>&#45;&gt;</span> <a href="index.html#type-error">error</a> <span>&#45;&gt;</span> <a href="index.html#type-error">error</a></code></dt><dd><p>Merges two errors. The behavior of the error reporting is undefined if <code>Parse_error</code> values from different positions are merged.</p></dd></dl></section><section><header><h3 id="the-parser-type"><a href="#the-parser-type" class="anchor"></a>The parser type</h3><p>To make handling of parse errors possible, the reply of a parser must not only indicate whether the parser has failed or succeeded, but also whether the parser has consumed input. When a parser is run, the general rule is that when it fails, alternative parsers created using the <code>&lt;|&gt;</code> and <code>choice</code> combinators are only tried if the first parser did not consume input. Thus by default the resulting parsers are predictive (non-backtracking). This behavior can be changed by using combinators like <code>attempt</code> and <code>look_ahead</code>. By this means the <code>MParser</code> module can be used to build efficient parsers for a very large class of languages that provide nearly automatic handling of errors, which is virtually impossible with full-backtracking parsers (because the position causing the failure cannot be determined).</p><p>This approach to combinator parsing has been pioneered by Daan Leijen's <a href="http://research.microsoft.com/users/daan/parsec.html">Parsec</a> library. A more detailed presentation of it can be found in the following paper: Daan Leijen and Erik Meijer, <em>Parsec: Direct-Style Monadic Parser Combinators For The Real World</em>, Technical Report UU-CS-2001-35, Departement of Computer Science, Universiteit Utrecht, 2001.</p></header><dl><dt class="spec type" id="type-reply"><a href="#type-reply" class="anchor"></a><code><span class="keyword">type</span> ('a, 's) reply</code><code> = </code><table class="variant"><tr id="type-reply.Empty_failed" class="anchored"><td class="def constructor"><a href="#type-reply.Empty_failed" class="anchor"></a><code>| </code><code><span class="constructor">Empty_failed</span> <span class="keyword">of</span> <a href="index.html#type-error">error</a></code></td><td class="doc"><p>The parser failed without consuming input.</p></td></tr><tr id="type-reply.Empty_ok" class="anchored"><td class="def constructor"><a href="#type-reply.Empty_ok" class="anchor"></a><code>| </code><code><span class="constructor">Empty_ok</span> <span class="keyword">of</span> <span class="type-var">'a</span> * <span class="type-var">'s</span> <a href="index.html#type-state">state</a> * <a href="index.html#type-error">error</a></code></td><td class="doc"><p>The parser succeeded without consuming input.</p></td></tr><tr id="type-reply.Consumed_failed" class="anchored"><td class="def constructor"><a href="#type-reply.Consumed_failed" class="anchor"></a><code>| </code><code><span class="constructor">Consumed_failed</span> <span class="keyword">of</span> <a href="index.html#type-error">error</a></code></td><td class="doc"><p>The parser failed after consuming input.</p></td></tr><tr id="type-reply.Consumed_ok" class="anchored"><td class="def constructor"><a href="#type-reply.Consumed_ok" class="anchor"></a><code>| </code><code><span class="constructor">Consumed_ok</span> <span class="keyword">of</span> <span class="type-var">'a</span> * <span class="type-var">'s</span> <a href="index.html#type-state">state</a> * <a href="index.html#type-error">error</a></code></td><td class="doc"><p>The parser succeeded after consuming input.</p></td></tr></table></dt><dd><p>The type of replies returned by parsers.</p></dd></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> ('a, 's) t</code><code> = <span class="type-var">'s</span> <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-reply">reply</a></code></dt><dt class="spec type" id="type-parser"><a href="#type-parser" class="anchor"></a><code><span class="keyword">type</span> ('a, 's) parser</code><code> = (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>The type of parsers with result type <code>'a</code> and user state type <code>'s</code>.</p></dd></dl><dl><dt class="spec value" id="val-make_ok"><a href="#val-make_ok" class="anchor"></a><code><span class="keyword">val</span> make_ok : bool <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'s</span> <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> <a href="index.html#type-error">error</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-reply">reply</a></code></dt><dd><p><code>make_ok consumed result state error</code> returns <code>Empty_ok (result, state,
    error)</code> if <code>consumed = false</code>, and <code>Consumed_ok (result, state, error)</code> if <code>consumed = true</code>.</p></dd></dl><dl><dt class="spec value" id="val-make_failed"><a href="#val-make_failed" class="anchor"></a><code><span class="keyword">val</span> make_failed : bool <span>&#45;&gt;</span> <a href="index.html#type-error">error</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-reply">reply</a></code></dt><dd><p><code>make_failed consumed error</code> returns <code>Empty_failed error</code> if <code>consumed =
    false</code>, and <code>Consumed_failed error</code> of <code>consumed = true</code>.</p></dd></dl><dl><dt class="spec value" id="val-is_consumed"><a href="#val-is_consumed" class="anchor"></a><code><span class="keyword">val</span> is_consumed : (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-reply">reply</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_consumed reply</code> returns <code>true</code> if <code>reply</code> is <code>Consumed_failed</code> or <code>Consumed_ok</code>, and <code>false</code> otherwise.</p></dd></dl><dl><dt class="spec value" id="val-is_empty"><a href="#val-is_empty" class="anchor"></a><code><span class="keyword">val</span> is_empty : (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-reply">reply</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_consumed reply</code> returns <code>true</code> if <code>reply</code> is <code>Empty_failed</code> or <code>Empty_ok</code>, and <code>false</code> otherwise.</p></dd></dl><dl><dt class="spec value" id="val-is_error"><a href="#val-is_error" class="anchor"></a><code><span class="keyword">val</span> is_error : (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-reply">reply</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_error reply</code> returns <code>true</code> if <code>reply</code> is <code>Empty_failed</code> or <code>Consumed_failed</code>, and <code>false</code> otherwise.</p></dd></dl><dl><dt class="spec value" id="val-is_ok"><a href="#val-is_ok" class="anchor"></a><code><span class="keyword">val</span> is_ok : (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-reply">reply</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_error reply</code> returns <code>true</code> if <code>reply</code> is <code>Empty_ok</code> or <code>Consumed_ok</code>, and <code>false</code> otherwise.</p></dd></dl><dl><dt class="spec value" id="val-set_error"><a href="#val-set_error" class="anchor"></a><code><span class="keyword">val</span> set_error : (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-reply">reply</a> <span>&#45;&gt;</span> <a href="index.html#type-error">error</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-reply">reply</a></code></dt><dd><p><code>set_error reply error</code> returns <code>reply</code> with the error message replaced by <code>error</code>.</p></dd></dl></section><section><header><h3 id="running-a-parser"><a href="#running-a-parser" class="anchor"></a>Running a parser</h3></header><dl><dt class="spec type" id="type-result"><a href="#type-result" class="anchor"></a><code><span class="keyword">type</span> 'a result</code><code> = </code><table class="variant"><tr id="type-result.Success" class="anchored"><td class="def constructor"><a href="#type-result.Success" class="anchor"></a><code>| </code><code><span class="constructor">Success</span> <span class="keyword">of</span> <span class="type-var">'a</span></code></td></tr><tr id="type-result.Failed" class="anchored"><td class="def constructor"><a href="#type-result.Failed" class="anchor"></a><code>| </code><code><span class="constructor">Failed</span> <span class="keyword">of</span> string * <a href="index.html#type-error">error</a></code></td></tr></table></dt><dd><p>The result of a parser run. In the case of <code>Failed</code>, it contains a human-readable error message.</p></dd></dl><dl><dt class="spec value" id="val-parse"><a href="#val-parse" class="anchor"></a><code><span class="keyword">val</span> parse : (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../MParser_Char_Stream/index.html#type-t">MParser_Char_Stream.t</a> <span>&#45;&gt;</span> <span class="type-var">'s</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-result">result</a></code></dt><dd><p><code>parse p s user</code> runs the parser <code>p</code> on the input stream <code>s</code> using the initial user state <code>user</code>.</p></dd></dl><dl><dt class="spec value" id="val-parse_string"><a href="#val-parse_string" class="anchor"></a><code><span class="keyword">val</span> parse_string : (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'s</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-result">result</a></code></dt><dd><p><code>parse_string p str user</code> runs the parser <code>p</code> on the input stream produced from the string <code>str</code> using the initial user state <code>user</code>. The stream is created with <code>MParser_Char_Stream.from_string</code>.</p></dd></dl><dl><dt class="spec value" id="val-parse_channel"><a href="#val-parse_channel" class="anchor"></a><code><span class="keyword">val</span> parse_channel : (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../ocaml/Stdlib/index.html#type-in_channel">Stdlib.in_channel</a> <span>&#45;&gt;</span> <span class="type-var">'s</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-result">result</a></code></dt><dd><p><code>parse_string p chn user</code> runs the parser <code>p</code> on the input stream produced from the channel <code>chn</code> using the initial user state <code>user</code>. The stream is created with <code>MParser_Char_Stream.from_channel</code>.</p></dd></dl></section><section><header><h3 id="parser-combinators"><a href="#parser-combinators" class="anchor"></a>Parser combinators</h3><p><em>Note:</em> A statement of the form &quot;parser <code>p</code> is equivalent to <code>q</code>&quot;, where <code>q</code> is a compound parser, means that <code>p</code> is functionally equivalent to <code>q</code>, that is, it behaves exactly the same as <code>q</code>, although it might be implemented differently. Using <code>p</code> is generally more efficient than using the compound parser <code>q</code> and should therefore be preferred.</p></header><dl><dt class="spec value" id="val-return"><a href="#val-return" class="anchor"></a><code><span class="keyword">val</span> return : <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>return x</code> always succeeds with the result <code>x</code> without consuming any input.</p></dd></dl><dl><dt class="spec value" id="val-try_return"><a href="#val-try_return" class="anchor"></a><code><span class="keyword">val</span> try_return : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'s</span> <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> (<span class="type-var">'b</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>try_return f x msg s0</code> succeeds with the result <code>f x</code> without consuming input if <code>f x</code> does not raise an exception. Otherwise, it fails with a <code>Message_error</code> with error message <code>msg</code> at state <code>s0</code>. This combinator is useful where a result must be computed from another parser result and where this computation may raise an exception.</p></dd></dl><dl><dt class="spec value" id="val-try_return2"><a href="#val-try_return2" class="anchor"></a><code><span class="keyword">val</span> try_return2 : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'s</span> <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> (<span class="type-var">'c</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>A variant of <code>try_return</code> for functions with two parameters.</p></dd></dl><dl><dt class="spec value" id="val-try_return3"><a href="#val-try_return3" class="anchor"></a><code><span class="keyword">val</span> try_return3 : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'d</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'s</span> <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> (<span class="type-var">'d</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>A variant of <code>try_return</code> for functions with three parameters.</p></dd></dl><dl><dt class="spec value" id="val-fail"><a href="#val-fail" class="anchor"></a><code><span class="keyword">val</span> fail : string <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>fail msg</code> always fails with a <code>Message_error</code> with error message <code>msg</code>. The <code>fail</code> parser pretends having consumed input, so that all error messages are overwritten.</p></dd></dl><dl><dt class="spec value" id="val-message"><a href="#val-message" class="anchor"></a><code><span class="keyword">val</span> message : string <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>message msg</code> always fails with a <code>Message_error</code> with error message <code>msg</code> without consuming input, so that the error message is merged with other errors generated for the same input position.</p></dd></dl><dl><dt class="spec value" id="val-zero"><a href="#val-zero" class="anchor"></a><code><span class="keyword">val</span> zero : (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>zero</code> always fails with an <code>Unknown_error</code> without consuming input.</p></dd></dl><dl><dt class="spec value" id="val-bind"><a href="#val-bind" class="anchor"></a><code><span class="keyword">val</span> bind : (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'b</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a>) <span>&#45;&gt;</span> (<span class="type-var">'b</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>p &gt;&gt;= f</code> first applies the parser <code>p</code>, then applies <code>f</code> to the resulting value, and finally applies the resulting parser. Since the second parser can depend on the result of the first parser, it is possible to parse context-sensitive grammars.</p></dd></dl><dl><dt class="spec value" id="val-(&gt;&gt;=)"><a href="#val-(&gt;&gt;=)" class="anchor"></a><code><span class="keyword">val</span> (&gt;&gt;=) : (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'b</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a>) <span>&#45;&gt;</span> (<span class="type-var">'b</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>p &gt;&gt;= f</code> is equivalent to <code>bind p f</code></p></dd></dl><dl><dt class="spec value" id="val-(&gt;&gt;)"><a href="#val-(&gt;&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&gt;&gt;) : (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'b</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'b</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>p &gt;&gt; q</code> is equivalent to <code>p &gt;&gt;= (fun _ -&gt; q)</code>.</p></dd></dl><dl><dt class="spec value" id="val-(&lt;&lt;)"><a href="#val-(&lt;&lt;)" class="anchor"></a><code><span class="keyword">val</span> (&lt;&lt;) : (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'b</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>p &lt;&lt; q</code> is equivalent to <code>p &gt;&gt;= (fun x -&gt; q &gt;&gt; return x)</code>.</p></dd></dl><dl><dt class="spec value" id="val-(&gt;&gt;&gt;)"><a href="#val-(&gt;&gt;&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&gt;&gt;&gt;) : (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'b</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'b</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>Camlp4-compatible alternative to <code>&gt;&gt;</code>.</p></dd></dl><dl><dt class="spec value" id="val-(&lt;&lt;&lt;)"><a href="#val-(&lt;&lt;&lt;)" class="anchor"></a><code><span class="keyword">val</span> (&lt;&lt;&lt;) : (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'b</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>Camlp4-compatible alternative to <code>&lt;&lt;</code>.</p></dd></dl><dl><dt class="spec value" id="val-(&gt;&gt;$)"><a href="#val-(&gt;&gt;$)" class="anchor"></a><code><span class="keyword">val</span> (&gt;&gt;$) : (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> (<span class="type-var">'b</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>p &gt;&gt;$ x</code> is equivalent to <code>p &gt;&gt; return x</code>.</p></dd></dl><dl><dt class="spec value" id="val-(&gt;&gt;?)"><a href="#val-(&gt;&gt;?)" class="anchor"></a><code><span class="keyword">val</span> (&gt;&gt;?) : (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'b</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'b</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>p &gt;&gt;? q</code> behaves like <code>p &gt;&gt; q</code>, but if <code>q</code> fails without consuming input, it backtracks and pretends not having consumed input, even if <code>p</code> has consumed input.</p></dd></dl><dl><dt class="spec value" id="val-(|&gt;&gt;)"><a href="#val-(|&gt;&gt;)" class="anchor"></a><code><span class="keyword">val</span> (|&gt;&gt;) : (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> (<span class="type-var">'b</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>p |&gt;&gt; f</code> is equivalent to <code>p &gt;&gt;= (fun x -&gt; return (f x))</code>.</p></dd></dl><dl><dt class="spec value" id="val-pipe2"><a href="#val-pipe2" class="anchor"></a><code><span class="keyword">val</span> pipe2 : (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'b</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>) <span>&#45;&gt;</span> (<span class="type-var">'c</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>A variant of <code>(|&gt;&gt;)</code> for functions with two parameters.</p></dd></dl><dl><dt class="spec value" id="val-pipe3"><a href="#val-pipe3" class="anchor"></a><code><span class="keyword">val</span> pipe3 : (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'b</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'c</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'d</span>) <span>&#45;&gt;</span> (<span class="type-var">'d</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>A variant of <code>(|&gt;&gt;)</code> for functions with three parameters.</p></dd></dl><dl><dt class="spec value" id="val-pipe4"><a href="#val-pipe4" class="anchor"></a><code><span class="keyword">val</span> pipe4 : (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'b</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'c</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'d</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'d</span> <span>&#45;&gt;</span> <span class="type-var">'e</span>) <span>&#45;&gt;</span> (<span class="type-var">'e</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>A variant of <code>(|&gt;&gt;)</code> for functions with four parameters.</p></dd></dl><dl><dt class="spec value" id="val-(&lt;|&gt;)"><a href="#val-(&lt;|&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&lt;|&gt;) : (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>p &lt;|&gt; q</code> first applies <code>p</code>. If <code>p</code> fails without consuming input, it applies <code>q</code>.</p></dd></dl><dl><dt class="spec value" id="val-choice"><a href="#val-choice" class="anchor"></a><code><span class="keyword">val</span> choice : (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>choice [p1; p2; ...; pn ]</code> is equivalent to <code>p1 &lt;|&gt; p2 &lt;|&gt; ... &lt;|&gt; pn
    &lt;|&gt; zero</code>.</p></dd></dl><dl><dt class="spec value" id="val-attempt"><a href="#val-attempt" class="anchor"></a><code><span class="keyword">val</span> attempt : (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>attempt p</code> behaves like <code>p</code>, but if <code>p</code> fails after consuming input, it backtracks and pretends not having consumed input. The error message of <code>p</code> is wrapped inside a <code>Backtrack_error</code>.</p></dd></dl><dl><dt class="spec value" id="val-(&lt;?&gt;)"><a href="#val-(&lt;?&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&lt;?&gt;) : (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>p &lt;?&gt; label</code> attaches the label <code>label</code> to <code>p</code>. If <code>p</code> fails without consuming input, the error message of <code>p</code> is replaced by an <code>Expected_error</code> with the label <code>label</code>.</p></dd></dl><dl><dt class="spec value" id="val-(&lt;??&gt;)"><a href="#val-(&lt;??&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&lt;??&gt;) : (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>p &lt;??&gt; label</code> behaves like <code>p &lt;?&gt; label</code>, but if <code>p</code> fails after consuming input, the error message of <code>p</code> is wrapped inside a <code>Compound_error</code>.</p></dd></dl><dl><dt class="spec value" id="val-look_ahead"><a href="#val-look_ahead" class="anchor"></a><code><span class="keyword">val</span> look_ahead : (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>look_ahead p</code> behaves like <code>p</code>, but restores the original state after parsing. It always returns an empty reply.</p></dd></dl><dl><dt class="spec value" id="val-followed_by"><a href="#val-followed_by" class="anchor"></a><code><span class="keyword">val</span> followed_by : (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> (unit, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>followed_by p msg</code> succeeds without consuming input and returns <code>()</code> if <code>p</code> succeeds at the current position. Otherwise, it fails without consuming input and returns an <code>Expected_error</code> with error message <code>msg</code>.</p></dd></dl><dl><dt class="spec value" id="val-not_followed_by"><a href="#val-not_followed_by" class="anchor"></a><code><span class="keyword">val</span> not_followed_by : (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> (unit, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>not_followed_by p msg</code> succeeds without consuming input and returns <code>()</code> if <code>p</code> does not succeed at the current position. Otherwise, it fails without consuming input and returns an <code>Unexpected_error</code> with error message <code>msg</code>.</p></dd></dl><dl><dt class="spec value" id="val-opt"><a href="#val-opt" class="anchor"></a><code><span class="keyword">val</span> opt : <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>opt x p</code> is equivalent to <code>p &lt;|&gt;$ x</code>.</p></dd></dl><dl><dt class="spec value" id="val-option"><a href="#val-option" class="anchor"></a><code><span class="keyword">val</span> option : (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> option, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>option p</code> is equivalent to <code>p &gt;&gt;= (fun r -&gt; return (Some r)) &lt;|&gt;$
    None</code>.</p></dd></dl><dl><dt class="spec value" id="val-optional"><a href="#val-optional" class="anchor"></a><code><span class="keyword">val</span> optional : (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (unit, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>optional p</code> is equivalent to <code>p &gt;&gt;$ () &lt;|&gt;$ ()</code>.</p></dd></dl><dl><dt class="spec value" id="val-try_skip"><a href="#val-try_skip" class="anchor"></a><code><span class="keyword">val</span> try_skip : (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (bool, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>try_skip p</code> is equivalent to <code>p &gt;&gt;$ true &lt;|&gt;$ false</code>.</p></dd></dl><dl><dt class="spec value" id="val-pair"><a href="#val-pair" class="anchor"></a><code><span class="keyword">val</span> pair : (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'b</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>pair p q</code> is equivalent to <code> p &gt;&gt;= (fun x -&gt; q &gt;&gt;= (fun y -&gt; return (x,
    y)))</code>.</p></dd></dl><dl><dt class="spec value" id="val-many"><a href="#val-many" class="anchor"></a><code><span class="keyword">val</span> many : (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> list, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>many p</code> parses zero or more occurrences of <code>p</code> and returns a list of the results returned by <code>p</code>.</p><dl><dt>raises Failure</dt><dd><p>if <code>p</code> doesn't accept any input.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-many1"><a href="#val-many1" class="anchor"></a><code><span class="keyword">val</span> many1 : (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> list, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>many1 p</code> parses one or more occurrences of <code>p</code> and returns a list of the results returned by <code>p</code>.</p><dl><dt>raises Failure</dt><dd><p>if <code>p</code> doesn't accept any input.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-many_rev"><a href="#val-many_rev" class="anchor"></a><code><span class="keyword">val</span> many_rev : (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> list, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>many_rev p</code> is equivalent to <code>many p |&gt;&gt; List.rev</code>.</p><dl><dt>raises Failure</dt><dd><p>if <code>p</code> doesn't accept any input.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-many1_rev"><a href="#val-many1_rev" class="anchor"></a><code><span class="keyword">val</span> many1_rev : (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> list, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>many1_rev p</code> is equivalent to <code>many1 p |&gt;&gt; List.rev</code>.</p><dl><dt>raises Failure</dt><dd><p>if <code>p</code> doesn't accept any input.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-skip"><a href="#val-skip" class="anchor"></a><code><span class="keyword">val</span> skip : (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (unit, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>skip p</code> is equivalent to <code>p |&gt;&gt; ignore</code>.</p></dd></dl><dl><dt class="spec value" id="val-skip_many"><a href="#val-skip_many" class="anchor"></a><code><span class="keyword">val</span> skip_many : (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (unit, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>skip_many p</code> is equivalent to <code>skip (many p)</code>.</p><dl><dt>raises Failure</dt><dd><p>if <code>p</code> doesn't accept any input.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-skip_many1"><a href="#val-skip_many1" class="anchor"></a><code><span class="keyword">val</span> skip_many1 : (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (unit, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>skip_many1 p</code> is equivalent to <code>skip (many1 p)</code>.</p><dl><dt>raises Failure</dt><dd><p>if <code>p</code> doesn't accept any input.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-many_fold_left"><a href="#val-many_fold_left" class="anchor"></a><code><span class="keyword">val</span> many_fold_left : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'b</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>many_fold_left f a p</code> is equivalent to <code>many p |&gt;&gt; List.fold_left f a</code>.</p><dl><dt>raises Failure</dt><dd><p>if <code>p</code> doesn't accept any input.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-many1_fold_left"><a href="#val-many1_fold_left" class="anchor"></a><code><span class="keyword">val</span> many1_fold_left : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'b</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>many1_fold_left f a p</code> is equivalent to <code>many1 p |&gt;&gt; List.fold_left f a</code>.</p><dl><dt>raises Failure</dt><dd><p>if <code>p</code> doesn't accept any input.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-many_rev_fold_left"><a href="#val-many_rev_fold_left" class="anchor"></a><code><span class="keyword">val</span> many_rev_fold_left : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'b</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>many_rev_fold_left f a p</code> is equivalent to <code>many p |&gt;&gt; List.rev |&gt;&gt; List.fold_left f a</code>.</p><dl><dt>raises Failure</dt><dd><p>if <code>p</code> doesn't accept any input.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-many1_rev_fold_left"><a href="#val-many1_rev_fold_left" class="anchor"></a><code><span class="keyword">val</span> many1_rev_fold_left : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'b</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>many1_rev_fold_left f a p</code> is equivalent to <code>many1 p |&gt;&gt; List.rev |&gt;&gt; List.fold_left f a</code>.</p><dl><dt>raises Failure</dt><dd><p>if <code>p</code> doesn't accept any input.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-chain_left"><a href="#val-chain_left" class="anchor"></a><code><span class="keyword">val</span> chain_left : (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>chain_left p op x</code> parses zero or more occurrences of <code>p</code>, separated by <code>op</code>. It returns the value obtained by the left-associative application of the functions returned by <code>op</code> to the results of <code>p</code>. If there are zero occurrences of <code>p</code>, the value <code>x</code> is returned.</p></dd></dl><dl><dt class="spec value" id="val-chain_left1"><a href="#val-chain_left1" class="anchor"></a><code><span class="keyword">val</span> chain_left1 : (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>chain_left1 p op</code> parses one or more occurrences of <code>p</code>, separated by <code>op</code>. It returns the value obtained by the left-associative application of the functions returned by <code>op</code> to the results of <code>p</code>.</p></dd></dl><dl><dt class="spec value" id="val-chain_right"><a href="#val-chain_right" class="anchor"></a><code><span class="keyword">val</span> chain_right : (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>chain_right p op x</code> parses zero or more occurrences of <code>p</code>, separated by <code>op</code>. It returns the value obtained by the right-associative application of the functions returned by <code>op</code> to the results of <code>p</code>. If there are zero occurrences of <code>p</code>, the value <code>x</code> is returned.</p></dd></dl><dl><dt class="spec value" id="val-chain_right1"><a href="#val-chain_right1" class="anchor"></a><code><span class="keyword">val</span> chain_right1 : (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>chain_right1 p op</code> parses one or more occurrences of <code>p</code>, separated by <code>op</code>. It returns the value obtained by the right-associative application of the functions returned by <code>op</code> to the results of <code>p</code>.</p></dd></dl><dl><dt class="spec value" id="val-count"><a href="#val-count" class="anchor"></a><code><span class="keyword">val</span> count : int <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> list, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>count n p</code> parses exactly <code>n</code> occurrences of <code>p</code> and returns a list of the results returned by <code>p</code>.</p></dd></dl><dl><dt class="spec value" id="val-skip_count"><a href="#val-skip_count" class="anchor"></a><code><span class="keyword">val</span> skip_count : int <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (unit, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>skip_count n p</code> is equivalent to <code>skip (count n p)</code>.</p></dd></dl><dl><dt class="spec value" id="val-between"><a href="#val-between" class="anchor"></a><code><span class="keyword">val</span> between : (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'b</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'c</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'c</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>between left right p</code> is equivalent to <code>left &gt;&gt; p &lt;&lt; right</code>.</p></dd></dl><dl><dt class="spec value" id="val-sep_by"><a href="#val-sep_by" class="anchor"></a><code><span class="keyword">val</span> sep_by : (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'b</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> list, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>sep_by p sep</code> parses zero or more occurrences of <code>p</code>, separated by <code>sep</code>. It returns a list of the results returned by <code>p</code>.</p></dd></dl><dl><dt class="spec value" id="val-sep_by1"><a href="#val-sep_by1" class="anchor"></a><code><span class="keyword">val</span> sep_by1 : (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'b</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> list, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>sep_by1 p sep</code> parses one or more occurrences of <code>p</code>, separated by <code>sep</code>. It returns a list of the results returned by <code>p</code>.</p></dd></dl><dl><dt class="spec value" id="val-sep_end_by"><a href="#val-sep_end_by" class="anchor"></a><code><span class="keyword">val</span> sep_end_by : (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'b</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> list, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>sep_end_by p sep</code> parses zero or more occurrences of <code>p</code>, separated and optionally ended by <code>sep</code>. It returns a list of the results returned by <code>p</code>.</p></dd></dl><dl><dt class="spec value" id="val-sep_end_by1"><a href="#val-sep_end_by1" class="anchor"></a><code><span class="keyword">val</span> sep_end_by1 : (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'b</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> list, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>sep_end_by1 p sep</code> parses one or more occurrences of <code>p</code>, separated and optionally ended by <code>sep</code>. It returns a list of the results returned by <code>p</code>.</p></dd></dl><dl><dt class="spec value" id="val-end_by"><a href="#val-end_by" class="anchor"></a><code><span class="keyword">val</span> end_by : (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'b</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> list, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>end_by p sep</code> parses zero or more occurrences of <code>p</code>, separated and ended by <code>sep</code>. It returns a list of the results returned by <code>p</code>.</p></dd></dl><dl><dt class="spec value" id="val-end_by1"><a href="#val-end_by1" class="anchor"></a><code><span class="keyword">val</span> end_by1 : (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'b</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> list, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>end_by1 p sep</code> parses one or more occurrences of <code>p</code>, separated and ended by <code>sep</code>. It returns a list of the results returned by <code>p</code>.</p></dd></dl><dl><dt class="spec value" id="val-many_until"><a href="#val-many_until" class="anchor"></a><code><span class="keyword">val</span> many_until : (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'b</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> list, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>many_until p q</code> parses zero or more occurrences of <code>p</code> until <code>q</code> succeeds and returns a list of the results returned by <code>p</code>. It is equivalent to <code>many (not_followed_by q &quot;&quot; &gt;&gt; p) &lt;&lt; q</code>. Note that <code>q</code> is parsed twice and should therefore not have side effects.</p></dd></dl><dl><dt class="spec value" id="val-skip_many_until"><a href="#val-skip_many_until" class="anchor"></a><code><span class="keyword">val</span> skip_many_until : (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'b</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (unit, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>skip_many_until p q</code> is equivalent to <code>skip (many_until p q)</code>.</p></dd></dl></section><section><header><h3 id="parsers-accessing-the-parser-state"><a href="#parsers-accessing-the-parser-state" class="anchor"></a>Parsers accessing the parser state</h3></header><dl><dt class="spec value" id="val-get_input"><a href="#val-get_input" class="anchor"></a><code><span class="keyword">val</span> get_input : (<a href="../MParser_Char_Stream/index.html#type-t">MParser_Char_Stream.t</a>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>Returns the input stream.</p></dd></dl><dl><dt class="spec value" id="val-get_index"><a href="#val-get_index" class="anchor"></a><code><span class="keyword">val</span> get_index : (int, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>Returns the current index into the input.</p></dd></dl><dl><dt class="spec value" id="val-get_pos"><a href="#val-get_pos" class="anchor"></a><code><span class="keyword">val</span> get_pos : (<a href="index.html#type-pos">pos</a>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>Returns the current position.</p></dd></dl><dl><dt class="spec value" id="val-register_nl"><a href="#val-register_nl" class="anchor"></a><code><span class="keyword">val</span> register_nl : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> (unit, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>register_nl lines chars_after_nl</code> increases the line counter by <code>lines</code> and sets the beginning of the current line to <code>chars_after_nl</code> characters before the current index.</p></dd></dl><dl><dt class="spec value" id="val-set_pos"><a href="#val-set_pos" class="anchor"></a><code><span class="keyword">val</span> set_pos : <a href="index.html#type-pos">pos</a> <span>&#45;&gt;</span> (unit, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>Sets the current position.</p></dd></dl><dl><dt class="spec value" id="val-eof"><a href="#val-eof" class="anchor"></a><code><span class="keyword">val</span> eof : (unit, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>Parses the end of the input.</p></dd></dl></section><section><header><h3 id="parsers-accessing-the-user-state"><a href="#parsers-accessing-the-user-state" class="anchor"></a>Parsers accessing the user state</h3></header><dl><dt class="spec value" id="val-get_user_state"><a href="#val-get_user_state" class="anchor"></a><code><span class="keyword">val</span> get_user_state : (<span class="type-var">'s</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>Returns the current user state of the parser.</p></dd></dl><dl><dt class="spec value" id="val-set_user_state"><a href="#val-set_user_state" class="anchor"></a><code><span class="keyword">val</span> set_user_state : <span class="type-var">'s</span> <span>&#45;&gt;</span> (unit, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>Sets the current user state of the parser.</p></dd></dl><dl><dt class="spec value" id="val-update_user_state"><a href="#val-update_user_state" class="anchor"></a><code><span class="keyword">val</span> update_user_state : (<span class="type-var">'s</span> <span>&#45;&gt;</span> <span class="type-var">'s</span>) <span>&#45;&gt;</span> (unit, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>update_user_state f</code> applies <code>f</code> to the user state of the parser.</p></dd></dl></section><section><header><h3 id="character-based-parsers"><a href="#character-based-parsers" class="anchor"></a>Character-based parsers</h3><p>The following specialized parsers and parser combinators work directly on the characters of the input stream and are therefore more efficient than the general combinators. Generally, the basic character and string parsers only consume input when they succeed.</p></header><dl><dt class="spec value" id="val-skip_nchars"><a href="#val-skip_nchars" class="anchor"></a><code><span class="keyword">val</span> skip_nchars : int <span>&#45;&gt;</span> (unit, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>skip_nchars n</code> skips <code>n</code> characters of the input. Newlines are not registered. This parser never fails, even if there are less than <code>n</code> characters left.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>n &lt; 0</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-char"><a href="#val-char" class="anchor"></a><code><span class="keyword">val</span> char : char <span>&#45;&gt;</span> (char, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>char c</code> parses the character <code>c</code> and returns it.</p></dd></dl><dl><dt class="spec value" id="val-skip_char"><a href="#val-skip_char" class="anchor"></a><code><span class="keyword">val</span> skip_char : char <span>&#45;&gt;</span> (unit, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>skip_char c</code> is equivalent to <code>skip (char c)</code>.</p></dd></dl><dl><dt class="spec value" id="val-any_char"><a href="#val-any_char" class="anchor"></a><code><span class="keyword">val</span> any_char : (char, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>Parses any character and returns it. This parser does not register newlines. Use <code>any_char_or_nl</code> if the current character can be a newline.</p></dd></dl><dl><dt class="spec value" id="val-skip_any_char"><a href="#val-skip_any_char" class="anchor"></a><code><span class="keyword">val</span> skip_any_char : (unit, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>skip_any_char</code> is equivalent to <code>skip any_char</code>.</p></dd></dl><dl><dt class="spec value" id="val-any_char_or_nl"><a href="#val-any_char_or_nl" class="anchor"></a><code><span class="keyword">val</span> any_char_or_nl : (char, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>any_char_or_nl</code> is equivalent to <code>newline &lt;|&gt; any_char</code>.</p></dd></dl><dl><dt class="spec value" id="val-skip_any_char_or_nl"><a href="#val-skip_any_char_or_nl" class="anchor"></a><code><span class="keyword">val</span> skip_any_char_or_nl : (unit, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>skip_any_char_or_nl</code> is equivalent to <code>skip any_char_or_nl</code>.</p></dd></dl><dl><dt class="spec value" id="val-peek_char"><a href="#val-peek_char" class="anchor"></a><code><span class="keyword">val</span> peek_char : (char, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>Returns the character at the position after the current position or fails if this is not a valid position. This parser does not consume input.</p></dd></dl><dl><dt class="spec value" id="val-string"><a href="#val-string" class="anchor"></a><code><span class="keyword">val</span> string : string <span>&#45;&gt;</span> (string, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>string s</code> parses the string <code>s</code> and returns it.</p></dd></dl><dl><dt class="spec value" id="val-skip_string"><a href="#val-skip_string" class="anchor"></a><code><span class="keyword">val</span> skip_string : string <span>&#45;&gt;</span> (unit, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>skip_string s</code> is equivalent to <code>skip (string s)</code>.</p></dd></dl><dl><dt class="spec value" id="val-any_string"><a href="#val-any_string" class="anchor"></a><code><span class="keyword">val</span> any_string : int <span>&#45;&gt;</span> (string, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>any_string n</code> parses any string of <code>n</code> characters and returns it. Fails if there are less than <code>n</code> characters left in the input.</p></dd></dl><dl><dt class="spec value" id="val-many_chars"><a href="#val-many_chars" class="anchor"></a><code><span class="keyword">val</span> many_chars : (char, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (string, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>many_chars p</code> parses zero or more occurrences of <code>p</code> and returns a string of the results returned by <code>p</code>.</p><dl><dt>raises Failure</dt><dd><p>if <code>p</code> doesn't accept any input.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-many1_chars"><a href="#val-many1_chars" class="anchor"></a><code><span class="keyword">val</span> many1_chars : (char, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (string, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>many1_chars p</code> parses one or more occurrences of <code>p</code> and returns a string of the results returned by <code>p</code>.</p><dl><dt>raises Failure</dt><dd><p>if <code>p</code> doesn't accept any input.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-skip_many_chars"><a href="#val-skip_many_chars" class="anchor"></a><code><span class="keyword">val</span> skip_many_chars : (char, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (unit, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>skip_many_chars p</code> is equivalent to <code>skip (many_chars p)</code>.</p></dd></dl><dl><dt class="spec value" id="val-skip_many1_chars"><a href="#val-skip_many1_chars" class="anchor"></a><code><span class="keyword">val</span> skip_many1_chars : (char, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (unit, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>skip_many1_chars p</code> is equivalent to <code>skip (many1_chars p)</code>.</p></dd></dl><dl><dt class="spec value" id="val-many_chars_until"><a href="#val-many_chars_until" class="anchor"></a><code><span class="keyword">val</span> many_chars_until : (char, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (char, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (string, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>many_chars_until p q</code> parses zero or more occurrences of <code>p</code> until <code>q</code> succeeds and returns a string of the results returned by <code>p</code>. It is equivalent to <code>many_chars (not_followed_by q &quot;&quot; &gt;&gt; p) &lt;&lt; q</code>. Note that <code>q</code> is parsed twice and should therefore not have side effects.</p></dd></dl><dl><dt class="spec value" id="val-skip_many_chars_until"><a href="#val-skip_many_chars_until" class="anchor"></a><code><span class="keyword">val</span> skip_many_chars_until : (char, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (char, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (unit, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>skip_many_chars_until p q</code> is equivalent to <code>skip (many_chars_until p q)</code>.</p></dd></dl><dl><dt class="spec value" id="val-satisfy"><a href="#val-satisfy" class="anchor"></a><code><span class="keyword">val</span> satisfy : (char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> (char, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>satisfy p</code> parses a character for which <code>p</code> returns <code>true</code> and returns this character. It fails with an <code>Unknown_error</code> if the character at the current position does not satisfy <code>p</code>.</p></dd></dl><dl><dt class="spec value" id="val-satisfy_l"><a href="#val-satisfy_l" class="anchor"></a><code><span class="keyword">val</span> satisfy_l : (char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> string <span>&#45;&gt;</span> (char, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>satisfy_l p label</code> is equivalent to <code>satisfy p &lt;?&gt; label</code>.</p></dd></dl><dl><dt class="spec value" id="val-skip_satisfy"><a href="#val-skip_satisfy" class="anchor"></a><code><span class="keyword">val</span> skip_satisfy : (char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> (unit, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>skip_satisfy p</code> is equivalent to <code>skip (satisfy p)</code>.</p></dd></dl><dl><dt class="spec value" id="val-skip_satisfy_l"><a href="#val-skip_satisfy_l" class="anchor"></a><code><span class="keyword">val</span> skip_satisfy_l : (char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> string <span>&#45;&gt;</span> (unit, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>skip_satisfy_l p label</code> is equivalent to <code>skip (satisfy_l p label)</code>.</p></dd></dl><dl><dt class="spec value" id="val-nsatisfy"><a href="#val-nsatisfy" class="anchor"></a><code><span class="keyword">val</span> nsatisfy : int <span>&#45;&gt;</span> (char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> (string, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>nsatisfy n p</code> parses the next <code>n</code> characters if <code>p</code> returns <code>true</code> for each of them. Otherwise it fails with an <code>Unknown_error</code> without consuming input.</p></dd></dl><dl><dt class="spec value" id="val-many_satisfy"><a href="#val-many_satisfy" class="anchor"></a><code><span class="keyword">val</span> many_satisfy : (char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> (string, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>many_satisfy p</code> is equivalent to <code>many_chars (satisfy p)</code>.</p></dd></dl><dl><dt class="spec value" id="val-many1_satisfy"><a href="#val-many1_satisfy" class="anchor"></a><code><span class="keyword">val</span> many1_satisfy : (char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> (string, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>many1_satisfy p</code> is equivalent to <code>many1_chars (satisfy p)</code>.</p></dd></dl><dl><dt class="spec value" id="val-skip_many_satisfy"><a href="#val-skip_many_satisfy" class="anchor"></a><code><span class="keyword">val</span> skip_many_satisfy : (char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> (unit, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>skip_many_satisfy p</code> is equivalent to <code>skip_many (satisfy p)</code>.</p></dd></dl><dl><dt class="spec value" id="val-skip_many1_satisfy"><a href="#val-skip_many1_satisfy" class="anchor"></a><code><span class="keyword">val</span> skip_many1_satisfy : (char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> (unit, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>skip_many1_satisfy p</code> is equivalent to <code>skip_many1 (satisfy p)</code>.</p></dd></dl><dl><dt class="spec value" id="val-next_char_satisfies"><a href="#val-next_char_satisfies" class="anchor"></a><code><span class="keyword">val</span> next_char_satisfies : (char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> (unit, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>next_char_satisfies p</code> succeeds without consuming input if <code>p</code> returns <code>true</code> for the character after the current position. Otherwise it fails with an <code>Unknown_error</code>.</p></dd></dl><dl><dt class="spec value" id="val-prev_char_satisfies"><a href="#val-prev_char_satisfies" class="anchor"></a><code><span class="keyword">val</span> prev_char_satisfies : (char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> (unit, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>prev_char_satisfies p</code> succeeds without consuming input if <code>p</code> returns <code>true</code> for the character before the current position. Otherwise it fails with an <code>Unknown_error</code>.</p></dd></dl><dl><dt class="spec value" id="val-any_of"><a href="#val-any_of" class="anchor"></a><code><span class="keyword">val</span> any_of : string <span>&#45;&gt;</span> (char, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>any_of str</code> parses any character occurring in the string <code>str</code> and returns it.</p></dd></dl><dl><dt class="spec value" id="val-none_of"><a href="#val-none_of" class="anchor"></a><code><span class="keyword">val</span> none_of : string <span>&#45;&gt;</span> (char, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>none_of str</code> parses any character not occurring in the string <code>str</code> and returns it.</p></dd></dl><dl><dt class="spec value" id="val-is_not"><a href="#val-is_not" class="anchor"></a><code><span class="keyword">val</span> is_not : (char, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (char, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>is_not c</code> parses any character that is not accepted by parser <code>c</code>. Fails with <code>Unknown_error</code> if the character is accepted by <code>c</code>.</p></dd></dl><dl><dt class="spec value" id="val-uppercase"><a href="#val-uppercase" class="anchor"></a><code><span class="keyword">val</span> uppercase : (char, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>Parses an English uppercase letter and returns it.</p></dd></dl><dl><dt class="spec value" id="val-lowercase"><a href="#val-lowercase" class="anchor"></a><code><span class="keyword">val</span> lowercase : (char, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>Parses an English lowercase letter and returns it.</p></dd></dl><dl><dt class="spec value" id="val-letter"><a href="#val-letter" class="anchor"></a><code><span class="keyword">val</span> letter : (char, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>Parses an English letter and returns it.</p></dd></dl><dl><dt class="spec value" id="val-digit"><a href="#val-digit" class="anchor"></a><code><span class="keyword">val</span> digit : (char, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>Parses a decimal digit and returns it.</p></dd></dl><dl><dt class="spec value" id="val-hex_digit"><a href="#val-hex_digit" class="anchor"></a><code><span class="keyword">val</span> hex_digit : (char, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>Parses a hexadecimal digit and returns it.</p></dd></dl><dl><dt class="spec value" id="val-oct_digit"><a href="#val-oct_digit" class="anchor"></a><code><span class="keyword">val</span> oct_digit : (char, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>Parses an octal digit and returns it.</p></dd></dl><dl><dt class="spec value" id="val-alphanum"><a href="#val-alphanum" class="anchor"></a><code><span class="keyword">val</span> alphanum : (char, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>Parses an English letter or a decimal digit and returns it.</p></dd></dl><dl><dt class="spec value" id="val-tab"><a href="#val-tab" class="anchor"></a><code><span class="keyword">val</span> tab : (char, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>Parses a tab character (<code>'\t'</code>) and returns it.</p></dd></dl><dl><dt class="spec value" id="val-blank"><a href="#val-blank" class="anchor"></a><code><span class="keyword">val</span> blank : (char, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>Parses a space or a tab character (<code>' '</code> or <code>'\t'</code> and returns it.</p></dd></dl><dl><dt class="spec value" id="val-newline"><a href="#val-newline" class="anchor"></a><code><span class="keyword">val</span> newline : (char, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>Parses a newline (<code>'\n'</code>, <code>'\r'</code>, or the sequence <code>'\r', '\n'</code>). If it succeeds, it always returns <code>'\n'</code>. The position in the parser state is correctly updated.</p></dd></dl><dl><dt class="spec value" id="val-space"><a href="#val-space" class="anchor"></a><code><span class="keyword">val</span> space : (char, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>Parses a space (<code>' '</code>), a tab (<code>'\t'</code>) or a newline (<code>'\n'</code>, <code>'\r'</code>, or the sequence <code>'\r', '\n'</code>). If a newline is parsed, it returns <code>'\n'</code> and correctly updates the position in the parser state. Otherwise it returns the parsed character.</p></dd></dl><dl><dt class="spec value" id="val-non_space"><a href="#val-non_space" class="anchor"></a><code><span class="keyword">val</span> non_space : (char, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>non_space</code> is equivalent to <code>is_not space</code>, with a better error message.</p></dd></dl><dl><dt class="spec value" id="val-spaces"><a href="#val-spaces" class="anchor"></a><code><span class="keyword">val</span> spaces : (unit, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>spaces</code> is equivalent to <code>skip_many_chars space</code>.</p></dd></dl><dl><dt class="spec value" id="val-spaces1"><a href="#val-spaces1" class="anchor"></a><code><span class="keyword">val</span> spaces1 : (unit, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>spaces</code> is equivalent to <code>skip_many_chars1 space</code>.</p></dd></dl></section><section><header><h3 id="expression-parser"><a href="#expression-parser" class="anchor"></a>Expression parser</h3></header><dl><dt class="spec type" id="type-assoc"><a href="#type-assoc" class="anchor"></a><code><span class="keyword">type</span> assoc</code><code> = </code><table class="variant"><tr id="type-assoc.Assoc_none" class="anchored"><td class="def constructor"><a href="#type-assoc.Assoc_none" class="anchor"></a><code>| </code><code><span class="constructor">Assoc_none</span></code></td><td class="doc"><p>None-associative operator.</p></td></tr><tr id="type-assoc.Assoc_left" class="anchored"><td class="def constructor"><a href="#type-assoc.Assoc_left" class="anchor"></a><code>| </code><code><span class="constructor">Assoc_left</span></code></td><td class="doc"><p>Left-associative operator.</p></td></tr><tr id="type-assoc.Assoc_right" class="anchored"><td class="def constructor"><a href="#type-assoc.Assoc_right" class="anchor"></a><code>| </code><code><span class="constructor">Assoc_right</span></code></td><td class="doc"><p>Right-associative operator.</p></td></tr></table></dt><dd><p>The associativity of an operator. An operator <code>(#)</code> is left-associative if <code>a # b # c = (a # b) # c</code>, right-associative if <code>a # b # c = a # (b #
    c)</code>, and non-associative if applying <code>(#)</code> to an expression with head operator <code>(#)</code> is not allowed. Note that a value of this type specifies only how an expression like <code>a # b # c</code> is parsed, not how it is interpreted semanically.</p></dd></dl><dl><dt class="spec type" id="type-operator"><a href="#type-operator" class="anchor"></a><code><span class="keyword">type</span> ('a, 's) operator</code><code> = </code><table class="variant"><tr id="type-operator.Infix" class="anchored"><td class="def constructor"><a href="#type-operator.Infix" class="anchor"></a><code>| </code><code><span class="constructor">Infix</span> <span class="keyword">of</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> * <a href="index.html#type-assoc">assoc</a></code></td><td class="doc"><p>Infix operator.</p></td></tr><tr id="type-operator.Prefix" class="anchored"><td class="def constructor"><a href="#type-operator.Prefix" class="anchor"></a><code>| </code><code><span class="constructor">Prefix</span> <span class="keyword">of</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></td><td class="doc"><p>Prefix operator.</p></td></tr><tr id="type-operator.Postfix" class="anchored"><td class="def constructor"><a href="#type-operator.Postfix" class="anchor"></a><code>| </code><code><span class="constructor">Postfix</span> <span class="keyword">of</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></td><td class="doc"><p>Postfix operator.</p></td></tr></table></dt><dd><p>The type of operators on type <code>'a</code>. The function returned by the parser argument to the <code>Infix</code>, <code>Prefix</code>, and <code>Postfix</code> constructor is used to build the result of applying the operator to its operands.</p></dd></dl><dl><dt class="spec value" id="val-expression"><a href="#val-expression" class="anchor"></a><code><span class="keyword">val</span> expression : (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-operator">operator</a> list list <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>expression operators term</code> parses any well-formed expression that can built from the basic terms parsed by <code>term</code> and the operators specified in the operator table <code>operators</code>. The operator table is a list of <code>operator</code> lists that is ordered in descending precedence. All elements in one list of <code>operators</code> have the same precedence, but may have different associativities.</p><p>Adjacent prefix and postfix operators of the same precedence are not well-formed. For example, if <code>(-)</code> denotes prefix negation, <code>--x</code> is not a well-formed expression (if <code>(--)</code> does not denote an operator on its own). If a prefix and a postfix operator of the same precedence are applied to an expression, the prefix operator is applied before the postfix operator.</p><p>The following example demonstrates the usage of the <code>expression</code> parser. It implements a minimalistic calculator that can be used to evaluate expressions like <code>eval &quot;(1 + 2 * 3) / -2&quot;</code>, which returns <code>-3</code>.</p><pre><code class="ml">open MParser
open Tokens

exception Syntax_error

let infix sym f assoc = Infix  (skip_symbol sym &gt;&gt; return f, assoc)
let prefix sym f = Prefix (skip_symbol sym &gt;&gt; return f)

let negate x = -x

let operators =
[
  [ prefix &quot;-&quot; negate ];
  [ infix &quot;*&quot; ( * ) Assoc_left; infix &quot;/&quot; ( / ) Assoc_left ];
  [ infix &quot;+&quot; ( + ) Assoc_left; infix &quot;-&quot; ( - ) Assoc_left ];
]

let rec term s = (parens expr &lt;|&gt; decimal) s

and expr s = expression operators term s

let eval s =
  match parse_string expr s () with
    | Success x -&gt; x
    | Failed (msg, _) -&gt;
        print_string msg;
        raise Syntax_error</code></pre></dd></dl></section><section><header><h3 id="regexp-related-features"><a href="#regexp-related-features" class="anchor"></a>Regexp-related features</h3></header><div class="spec module" id="module-MakeRegexp"><a href="#module-MakeRegexp" class="anchor"></a><code><span class="keyword">module</span> <a href="MakeRegexp/index.html">MakeRegexp</a> : <span class="keyword">functor</span> (<a href="MakeRegexp/argument-1-Regexp/index.html">Regexp</a> : <a href="../MParser_Sig/index.html#module-type-Regexp">MParser_Sig.Regexp</a>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section></div></body></html>