<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Vg (vg.Vg)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../index.html">vg</a> &#x00BB; Vg</nav><header class="odoc-preamble"><h1>Module <code><span>Vg</span></code></h1><p>Declarative 2D vector graphics.</p><p><code>Vg</code> is a declarative 2D vector graphics library. In <code>Vg</code>, images are <a href="#type-image">values</a> that denote functions mapping points of the cartesian plane to colors. The library provides <a href="I/index.html">combinators</a> to define and compose them. Renderers for <a href="../Vgr_pdf/index.html">PDF</a>, <a href="../Vgr_svg/index.html">SVG</a> and the HTML <a href="../Vgr_htmlc/index.html">canvas</a> are distributed with the library. An API allows to implement new renderers.</p><p>Consult the <a href="#basics">basics</a>, the <a href="#semantics">semantics</a> and <a href="#examples">examples</a>.</p><p>Open the module to use it, this defines only modules and types in your scope.</p></header><nav class="odoc-toc"><ul><li><a href="#fonts">Fonts</a></li><li><a href="#base">Paths and images</a></li><li><a href="#renderers">Image renderers</a></li><li><a href="#basics">Basics</a><ul><li><a href="#collage">A collage model</a></li><li><a href="#infinite">Infinite images</a></li><li><a href="#rendering">Rendering</a></li><li><a href="#coordinates">Coordinate space</a></li><li><a href="#scissors">Scissors and glue</a></li><li><a href="#transforming">Transforming images</a></li><li><a href="#paths_2">Paths</a></li><li><a href="#remarkstips">Remarks and tips</a></li></ul></li><li><a href="#semantics">Semantics</a><ul><li><a href="#semcolors">Colors</a><ul><li><a href="#semstops">Color stops</a></li></ul></li><li><a href="#semimages">Images</a></li><li><a href="#sempaths">Paths and areas</a><ul><li><a href="#semoutlines">Outline areas</a><ul><li><a href="#semjoins">Segment jointures</a></li><li><a href="#semcaps">Subpath caps</a></li><li><a href="#semdashes">Outline dashes</a></li></ul></li></ul></li></ul></li><li><a href="#examples">Examples</a><ul><li><a href="#minpdf">Minimal PDF output</a></li><li><a href="#minsvg">Minimal SVG output</a></li><li><a href="#minhtmlc">Minimal HTML canvas output</a></li><li><a href="#mincairopng">Minimal Cairo PNG output</a></li><li><a href="#mincairomem">Minimal Cairo memory buffer rendering</a></li></ul></li></ul></nav><div class="odoc-content"><h2 id="fonts"><a href="#fonts" class="anchor"></a>Fonts</h2><div class="odoc-spec"><div class="spec module" id="module-Font" class="anchored"><a href="#module-Font" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Font/index.html">Font</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Fonts.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-font" class="anchored"><a href="#type-font" class="anchor"></a><code><span><span class="keyword">type</span> font</span><span> = <a href="Font/index.html#type-t">Font.t</a></span></code></div><div class="spec-doc"><p>The type for fonts.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-glyph" class="anchored"><a href="#type-glyph" class="anchor"></a><code><span><span class="keyword">type</span> glyph</span><span> = int</span></code></div><div class="spec-doc"><p>The type for glyphs. The integer represents a glyph identifier in a backend dependent font format.</p></div></div><h2 id="base"><a href="#base" class="anchor"></a>Paths and images</h2><div class="odoc-spec"><div class="spec type" id="type-path" class="anchored"><a href="#type-path" class="anchor"></a><code><span><span class="keyword">type</span> path</span></code></div><div class="spec-doc"><p>The type for paths.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-image" class="anchored"><a href="#type-image" class="anchor"></a><code><span><span class="keyword">type</span> image</span></code></div><div class="spec-doc"><p>The type for images.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-(&gt;&gt;)" class="anchored"><a href="#val-(&gt;&gt;)" class="anchor"></a><code><span><span class="keyword">val</span> (&gt;&gt;) : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span></span></code></div><div class="spec-doc"><p><code>x &gt;&gt; f</code> is <code>f x</code>, associates to left. Used to build paths and compose images.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-P" class="anchored"><a href="#module-P" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="P/index.html">P</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Paths.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-I" class="anchored"><a href="#module-I" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="I/index.html">I</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Images.</p></div></div><h2 id="renderers"><a href="#renderers" class="anchor"></a>Image renderers</h2><div class="odoc-spec"><div class="spec type" id="type-renderer" class="anchored"><a href="#type-renderer" class="anchor"></a><code><span><span class="keyword">type</span> renderer</span></code></div><div class="spec-doc"><p>The type for image renderers.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Vgr" class="anchored"><a href="#module-Vgr" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Vgr/index.html">Vgr</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Image renderers.</p></div></div><h2 id="basics"><a href="#basics" class="anchor"></a>Basics</h2><p><code>Vg</code> is designed to be opened in your module. This defines only types and modules in your scope. Thus to use <code>Vg</code> start with :</p><pre><code>open Gg
open Vg</code></pre><p><a href="../../gg/Gg/index.html"><code>Gg</code></a> gives us types for points (<a href="../../gg/Gg/index.html#type-p2"><code>Gg.p2</code></a>), vectors (<a href="../../gg/Gg/index.html#type-v2"><code>Gg.v2</code></a>), 2D extents (<a href="../../gg/Gg/index.html#type-size2"><code>Gg.size2</code></a>), rectangles (<a href="../../gg/Gg/index.html#type-box2"><code>Gg.box2</code></a>) and colors (<a href="../../gg/Gg/index.html#type-color"><code>Gg.color</code></a>). Later you may want to read <a href="../../gg/Gg/index.html"><code>Gg</code></a>'s documentation <a href="../../gg/Gg/index.html#basics">basics</a> but for now it is sufficient to know that each of these types has a constructor <code>v</code> in a module named after the capitalized type name (<a href="../../gg/Gg/P2/index.html#val-v"><code>Gg.P2.v</code></a>, <a href="../../gg/Gg/V2/index.html#val-v"><code>Gg.V2.v</code></a>, etc.).</p><h3 id="collage"><a href="#collage" class="anchor"></a>A collage model</h3><p>Usual vector graphics libraries follow a <em>painter model</em> in which paths are filled, stroked and blended on top of each other to produce a final image. <code>Vg</code> departs from that, it has a <em>collage model</em> in which paths define 2D areas in infinite images that are <em>cut</em> to define new infinite images to be blended on top of each other.</p><p>The collage model maps very well to a declarative imaging model. It is also very clear from a specification point of view, both mathematically and metaphorically. This cannot be said from the painter model where the semantics of an operation like stroking a self-intersecting translucent path —  which usually applies the paint only once —  doesn't directly map to the underlying paint stroke metaphor. The collage model is also more economical from a conceptual point view since image cuts and blends naturally unify the distinct concepts of clipping paths, path strokes, path fills and compositing groups (unsupported for now in <code>Vg</code>) of the painter model.</p><p>The collage model introduced in the following sections was stolen and adapted from the following works.</p><ul><li>Conal Elliott. <em><a href="http://conal.net/papers/bridges2001/">Functional Image Synthesis</a></em>, Proceedings of Bridges, 2001.</li><li>Antony Courtney. <em>Haven : Functional Vector Graphics</em>, chapter 6 in <a href="http://web.archive.org/web/20060207195702/http://www.apocalypse.org/pub/u/antony/work/pubs/ac-thesis.pdf">Modeling User Interfaces in a Functional Language</a>, Ph.D. Thesis, Yale University, 2004.</li></ul><h3 id="infinite"><a href="#infinite" class="anchor"></a>Infinite images</h3><p>Images in <code>Vg</code> are immutable and abstract value of type <a href="#type-image"><code>image</code></a>. <em>Conceptually</em>, images are seen as functions mapping points of the infinite 2D plane to colors:</p><p><code>type Vg.image </code> ≈  <code>Gg.p2 -&gt; Gg.color</code></p><p>The simplest image is a constant image: an image that associates the same color to every point in the plane. For a constant gray of intensity 0.5 this would be expressed by the function:</p><pre><code>fun _ -&gt; Color.gray 0.5</code></pre><p>In <code>Vg</code> the combinator <a href="I/index.html#val-const"><code>I.const</code></a> represents constant infinite images and the above function is written:</p><pre><code>let gray = I.const (Color.gray 0.5)</code></pre><p>The module <a href="I/index.html"><code>I</code></a> contains all the combinators to define and compose infinite images, we will explore some of them later. But for now let's just render that fascinating image.</p><h3 id="rendering"><a href="#rendering" class="anchor"></a>Rendering</h3><p>An infinite image alone cannot be rendered. We need a <em>finite</em> view rectangle and a specification of that view's physical size on the render target. These informations are coupled together with an image to form a <a href="Vgr/index.html#renderable"><code>renderable</code></a>.</p><p>Renderables can be given to a renderer for display via the function <a href="Vgr/index.html#render"><code>render</code></a>. Renderers are created with <a href="Vgr/index.html#val-create"><code>Vgr.create</code></a> and need a <a href="Vgr/index.html#type-target">render target</a> value that defines the concrete renderer implementation used (PDF, SVG, HTML canvas etc.).</p><p>The following function outputs the unit square of <code>gray</code> on a 30x30 millimeters SVG target in the file <code>/tmp/vg-basics.svg</code>:</p><pre><code>let svg_of_usquare i =
  let size = Size2.v 30. 30. in
  let view = Box2.unit in
  try
    let oc = open_out &quot;/tmp/vg-basics.svg&quot; in
    let r = Vgr.create (Vgr_svg.target ()) (`Channel oc) in
    try
      ignore (Vgr.render r (`Image (size, view, i)));
      ignore (Vgr.render r `End);
      close_out oc
    with e -&gt; close_out oc; raise e
  with Sys_error e -&gt; prerr_endline e

let () = svg_of_usquare gray</code></pre><p>The result should be an SVG image with a gray square like this:  <img src="../_assets/doc-gray-square.png"
             style="width:30mm; height:30mm;"/> </p><h3 id="coordinates"><a href="#coordinates" class="anchor"></a>Coordinate space</h3><p><code>Vg</code>'s cartesian coordinate space has its origin at the bottom left with the x-axis pointing right, the y-axis pointing up. It has no units, you define what they mean to you. However a <a href="Vgr/index.html#renderable">renderable</a> implicitely defines a physical unit for <code>Vg</code>'s coordinate space: the corners of the specified view rectangle are mapped on a rectangular area of the given physical size on the target.</p><h3 id="scissors"><a href="#scissors" class="anchor"></a>Scissors and glue</h3><p>Constant images can be boring. To make things more interesting <code>Vg</code> gives you scissors: the <a href="I/index.html#cut"><code>cut</code></a> combinator.</p><p>This combinator takes a finite area of the plane defined by a path <code>path</code> (more on paths later) and a source image <code>img</code> to define the image <code>I.cut path img</code> that has the color of the source image in the area defined by the path and the invisible transparent black color (<a href="../../gg/Gg/Color/index.html#val-void"><code>Gg.Color.void</code></a>) everywhere else. In other words <code>I.cut path img</code> represents this function:</p><pre><code>fun pt -&gt; if inside path pt then img pt else Color.void</code></pre><p>The following code cuts a circle of radius <code>0.4</code> centered in the unit square in the <code>gray</code> image defined before.</p><pre><code>let circle = P.empty |&gt; P.circle (P2.v 0.5 0.5) 0.4
let gray_circle = I.cut circle gray</code></pre><p>Rendered by <code>svg_of_usquare</code> the result is:</p> <img src="../_assets/doc-gray-circle.png"
             style="width:30mm; height:30mm;"/> <p>Note that the background white color surrounding the circle does not belong to the image itself, it is the color of the webpage background against which the image is composited. Your eyes require a wavelength there and <a href="../../gg/Gg/Color/index.html#val-void"><code>Gg.Color.void</code></a> cannot provide it.</p><p><a href="I/index.html#cut"><code>cut</code></a> has an optional <code>area</code> argument of type <a href="P/index.html#type-area"><code>P.area</code></a> that determines how a path should be interpreted as an area of the plane. The default value is <code>`Anz</code>, which means that it uses the non-zero winding number rule and for <code>circle</code> that defines its interior.</p><p>But the <code>circle</code> path can also be seen as defining a thin outline area around the ideal mathematical circle of <code>circle</code>. This can be specified by using an outline area `O o. The value <code>o</code> of type <a href="P/index.html#type-outline"><code>P.outline</code></a> defines various parameters that define the outline area; for example its width. The following code cuts the <code>circle</code> outline area of width <code>0.04</code> in an infinite black image.</p><pre><code>let circle_outline =
  let area = `O { P.o with P.width = 0.04 } in
  let black = I.const Color.black in
  I.cut ~area circle black</code></pre><p>Below is the result and again, the white you see here is in fact <a href="../../gg/Gg/Color/index.html#val-void"><code>Gg.Color.void</code></a>.</p> <img src="../_assets/doc-circle-outline.png"
             style="width:30mm; height:30mm;"/> <p><a href="I/index.html#cut"><code>cut</code></a> gives us scissors but to combine the results of cuts we need some glue: the <a href="I/index.html#blend"><code>blend</code></a> combinator. This combinator takes two infinite images <code>front</code> and <code>back</code> and defines an image <code>I.blend front back</code> that has the colors of <code>front</code> alpha blended on top of those of <code>back</code>. <code>I.blend front back</code> represents this function:</p><pre><code>let i' = fun pt -&gt; Color.blend (front pt) (back pt)</code></pre><p>If we blend <code>circle_outline</code> on top of <code>gray_circle</code>:</p><pre><code>let dot = I.blend circle_outline gray_circle</code></pre><p>We get:</p> <img src="../_assets/doc-dot.png"
             style="width:30mm; height:30mm;"/> <p>The order of arguments in <a href="I/index.html#blend"><code>blend</code></a> is defined so that images can be blended using the left-associative composition operator <code>|&gt;</code>. That is <code>dot</code> can also be written as follows:</p><pre><code>let dot = gray_circle |&gt; I.blend circle_outline</code></pre><p>This means that with <code>|&gt;</code> and <a href="I/index.html#blend"><code>blend</code></a> left to right order in code maps to back to front image blending.</p><h3 id="transforming"><a href="#transforming" class="anchor"></a>Transforming images</h3><p>The combinators <a href="I/index.html#val-move"><code>I.move</code></a>, <a href="I/index.html#val-rot"><code>I.rot</code></a>, <a href="I/index.html#val-scale"><code>I.scale</code></a>, and <a href="I/index.html#val-tr"><code>I.tr</code></a> allow to perform arbitrary <a href="http://mathworld.wolfram.com/AffineTransformation.html">affine transformations</a> on an image. For example the image <code>I.move v i</code> is <code>i</code> but translated by the vector <code>v</code>, that is the following function:</p><pre><code>fun pt -&gt; img (V2.(pt - v))</code></pre><p>The following example uses <code>I.move</code>. The function <code>scatter_plot</code> takes a list of points and returns a scatter plot of the points. First we define a <code>dot</code> around the origin, just a black circle of diameter <code>pt_width</code>. Second we define the function <code>mark</code> that given a point returns an image with <code>dot</code> at that point and <code>blend_mark</code> that blends a <code>mark</code> at a point on an image. Finally we blend all the marks toghether.</p><pre><code>let scatter_plot pts pt_width =
  let dot =
    let circle = P.empty |&gt; P.circle P2.o (0.5 *. pt_width) in
    I.const Color.black |&gt; I.cut circle
  in
  let mark pt = dot |&gt; I.move pt in
  let blend_mark acc pt = acc |&gt; I.blend (mark pt) in
  List.fold_left blend_mark I.void pts</code></pre><p>Note that <code>dot</code> is defined outside <code>mark</code>, this means that all <code>mark</code>s share the same <code>dot</code>, doing so allows renderers to perform space and time optimizations. For example the SVG renderer will output a single <code>circle</code> path shared by all marks.</p><p>Here's the result of <code>scatter_point</code> on 800 points with coordinates on independent normal distributions.  <img src="../_assets/doc-scatter-plot.png"
             style="width:40mm; height:40mm;"/> </p><h3 id="paths_2"><a href="#paths_2" class="anchor"></a>Paths</h3><p>Paths are used to define areas of the plane. A path is an immutable value of type <a href="#type-path"><code>path</code></a> which is a list of disconnected subpaths. A <em>subpath</em> is a list of directed and connected curved segments.</p><p>To build a path you start with the empty path <a href="P/index.html#val-empty"><code>P.empty</code></a>, give it to <a href="P/index.html#val-sub"><code>P.sub</code></a> to start a new subpath and give the result to <a href="P/index.html#val-line"><code>P.line</code></a>, <a href="P/index.html#val-qcurve"><code>P.qcurve</code></a>, <a href="P/index.html#val-ccurve"><code>P.ccurve</code></a>, <a href="P/index.html#val-earc"><code>P.earc</code></a> or <a href="P/index.html#val-close"><code>P.close</code></a> to add a new segment and so forth.</p><p>Path combinators take the path they act upon as the last argument so that the left-associative operator <code>|&gt;</code> can be used to construct paths.</p><p>The image below is made by cutting the outline of the single path <code>p</code> defined hereafter.  <img src="../_assets/doc-subpaths.png"
             style="width:30mm; height:30mm;"/> </p><pre><code>let p =
  let rel = true in
  P.empty |&gt;
  P.sub (P2.v 0.1 0.5) |&gt;
    P.line (P2.v 0.3 0.5) |&gt;
    P.qcurve ~rel (P2.v 0.2 0.5) (P2.v 0.2 0.0) |&gt;
    P.ccurve ~rel (P2.v 0.0 (-. 0.5)) (P2.v 0.1 (-. 0.5)) (P2.v 0.3 0.0) |&gt;
    P.earc ~rel (Size2.v 0.1 0.2) (P2.v 0.15 0.0) |&gt;
  P.sub (P2.v 0.18 0.26) |&gt;
    P.qcurve ~rel (P2.v (0.01) (-0.1)) (P2.v 0.1 (-. 0.05)) |&gt;
    P.close |&gt;
  P.sub (P2.v 0.65 0.8) |&gt;
    P.line ~rel (P2.v 0.1 (-. 0.05))
in
let area = `O { P.o with P.width = 0.01 } in
I.const Color.black |&gt; I.cut ~area p</code></pre><p>Except for <a href="P/index.html#val-close"><code>P.close</code></a> which has no other argument but a path, the last point argument before the path argument is always the concrete end point of the segment. When <code>true</code> the optional <code>rel</code> argument indicates that the coordinates given to the constructor are expressed relative to end point of the last segment (or <code>P2.o</code> if there is no such segment).</p><p>Note that after a <code>P.close</code> or on the <code>P.empty</code> path, the call to <a href="P/index.html#val-sub"><code>P.sub</code></a> can be omitted. In that case an implicit <code>P.sub P2.o</code> is introduced.</p><p>For more information about how paths are intepreted as areas, consult their <a href="#sempaths">semantics</a>.</p><h3 id="remarkstips"><a href="#remarkstips" class="anchor"></a>Remarks and tips</h3><ul><li>Angles follow <code>Gg</code>'s <a href="../../gg/Gg/index.html#mathconv">conventions</a>.</li><li>Matrices given to <a href="P/index.html#val-tr"><code>P.tr</code></a> and <a href="I/index.html#val-tr"><code>I.tr</code></a> are supposed to be affine and as such ignore the last row of the matrix.</li><li><code>to_string</code> functions are not thread-safe. Thread-safety can be achieved with <code>pp</code> functions.</li><li>Do not rely on the output of printer functions, they are subject to change.</li><li>Rendering results are undefined if path or image data contains NaNs or infinite floats.</li><li>Any string is assumed to be UTF-8 encoded.</li><li>Sharing (sub)image, path and outline values in the definition of an image may result in more efficient rendering in space and time.</li></ul><h2 id="semantics"><a href="#semantics" class="anchor"></a>Semantics</h2><p>The following notations and definitions are used to give precise meaning to the images and the combinators.</p><h3 id="semcolors"><a href="#semcolors" class="anchor"></a>Colors</h3><p>The semantics of colors is the one ascribed to <a href="../../gg/Gg/Color/index.html#type-t"><code>Gg.color</code></a>: colors are in a <em>linearized</em> sRGBA space.</p><h4 id="semstops"><a href="#semstops" class="anchor"></a>Color stops</h4><p>A value of type <a href="../../gg/Gg/Color/index.html#type-stops"><code>Gg.Color.stops</code></a> specifies a color at each point of the 1D <em>unit</em> space. It is defined by a list of pairs <code>(t</code><sub>i</sub><code>, c</code><sub>i</sub><code>)</code> where <code>t</code><sub>i</sub> is a value from <code>0</code> to <code>1</code> and <code>c</code><sub>i</sub> the corresponding color at that value. Colors at points between <code>t</code><sub>i</sub> and <code>t</code><sub>i+1</sub> are linearly interpolated between <code>c</code><sub>i</sub> and <code>c</code><sub>i+1</sub>. If <code>t</code><sub>i</sub> lies outside <code>0</code> to <code>1</code> or if <code>t</code><sub>i-1</sub> &gt;= <code>t</code><sub>i</sub> the semantics is undefined.</p><p>Given a stops value <code>stops = [</code><code>(t</code><sub>0</sub><code>, c</code><sub>0</sub><code>);</code> <code>(t</code><sub>1</sub><code>,c</code><sub>1</sub><code>);</code> ... <code>(t</code><sub>n</sub><code>, c</code><sub>n</sub><code>)</code><code>]</code> and any point <code>t</code> of 1D space, the semantic function:</p><p>[] <code>: Gg.Color.stops -&gt; float -&gt; Gg.color</code></p><p>maps them to a color value written [<code>stops</code>]<sub>t</sub> as follows.</p><ul><li>[]<sub>t</sub> = <code>(0, 0, 0, 0)</code> for any <code>t</code></li><li>[<code>stops</code>]<sub>t</sub> <code>= c</code><sub>0</sub> if <code>t &lt; t</code><sub>0</sub>.</li><li>[<code>stops</code>]<sub>t</sub> <code>= c</code><sub>n</sub> if <code>t &gt;= t</code><sub>n</sub>.</li><li>[<code>stops</code>]<sub>t</sub> <code>= (1-u)c</code><sub>i</sub><code> + uc</code><sub>i+1</sub> with <code>u = (t - t</code><sub>i</sub><code>)/(t</code><sub>i+1</sub><code>-t</code><sub>i</sub><code>)</code> if <code>t</code><sub>i</sub> <code>&lt;= t &lt;</code> <code>t</code><sub>i+1</sub></li></ul><h3 id="semimages"><a href="#semimages" class="anchor"></a>Images</h3><p>Values of type <a href="#type-image"><code>image</code></a> represent maps from the infinite 2D euclidian space to <a href="#semcolors">colors</a>. Given an image <code>i</code> and a point <code>pt</code> of the plane the semantic function</p><p>[]<code>: image -&gt; Gg.p2 -&gt; Gg.color</code></p><p>maps them to a color value written [<code>i</code>]<sub><code>pt</code></sub> representing the image's color at this point.</p><h3 id="sempaths"><a href="#sempaths" class="anchor"></a>Paths and areas</h3><p>A value of type <a href="#type-path"><code>path</code></a> is a list of subpaths. A subpath is a list of <em>directed</em> and connected curved <em>segments</em>. Subpaths are disconnected from each other and may (self-)intersect.</p><p>A path and a value of type <a href="P/index.html#type-area"><code>P.area</code></a> defines a finite area of the 2D euclidian space. Given an area specification <code>a</code>, a path <code>p</code> and a point <code>pt</code>, the semantic function:</p><p>[]: <code>P.area -&gt; path -&gt; Gg.p2 -&gt; bool</code></p><p>maps them to a boolean value written [<code>a</code>, <code>p</code>]<sub><code>pt</code></sub> that indicates whether <code>pt</code> belongs to the area or not.</p><p>The semantics of area rules is as follows:</p><ul><li>[<code>`Anz</code>, <code>p</code>]<sub><code>pt</code></sub> is <code>true</code> iff the winding number of <code>p</code> around <code>pt</code> is non zero. To determine the winding number cast a ray from <code>pt</code> to infinity in any direction (just make sure the ray doesn't intersect <code>p</code> tangently or at a singularity). Starting with zero add one for each intersection with a counter-clockwise oriented segment of <code>p</code> and substract one for each clockwise ones. The resulting sum is the winding number. This is usually refered to as the <em>non-zero winding rule</em> and is the default for <a href="I/index.html#cut"><code>cut</code></a>.  <img src="../_assets/doc-anz.png" style="width:90mm; height:30mm;"/> </li><li>[<code>`Aeo</code>, <code>p</code>]<sub><code>pt</code></sub> is <code>true</code> iff the number of intersections of <code>p</code> with a ray cast from <code>pt</code> to infinity in any direction is odd (just make sure the ray doesn't intersect <code>p</code> tangently or at a singularity). This is usually refered to as the <em>even-odd rule</em>.  <img src="../_assets/doc-aeo.png" style="width:90mm; height:30mm;"/> </li><li>[<code>`O o</code>, <code>p</code>]<sub><code>pt</code></sub> is <code>true</code> iff <code>pt</code> is in the outline area of <code>p</code> as defined by the value <code>o</code> of type <a href="P/index.html#type-outline"><code>P.outline</code></a>. See <a href="#semoutlines">Outline areas</a>, <a href="#semjoins">Segment jointures</a>, <a href="#semcaps">Subpath caps</a>, <a href="#semdashes">Outline dashes</a>.</li></ul><h4 id="semoutlines"><a href="#semoutlines" class="anchor"></a>Outline areas</h4><p>The outline area of a path is the union of its subpaths outline areas. A subpath outline area is inside the parallel curves at a distance <code>o.width / 2</code> of its path segments that are joined accoring to the join style <code>o.join</code> (see below) and closed at the subpath end points with a cap style <code>o.cap</code> (see below). The outline area of a subpath can also be chopped at regular intervals according to the <code>o.dashes</code> parameter (see below).</p><h5 id="semjoins"><a href="#semjoins" class="anchor"></a>Segment jointures</h5><p>The shape of subpath segment jointures is specified in <code>o.join</code> by a value of type <a href="P/index.html#type-join"><code>P.join</code></a>. From left to right:  <img src="../_assets/doc-joins.png"
             style="width:90mm; height:30mm;"/> </p><ul><li><code>`Miter</code>, the outer parallel curves are extended until they meet unless the joining angle is smaller than <code>o.miter_angle</code> in which case the join is converted to a bevel.</li><li><code>`Round</code>, joins the outer parallel curves by a semicircle centered at the end point with a diameter equal to <code>o.width</code>.</li><li><code>`Bevel</code>, joins the outer parallel curves by a segment.</li></ul><h5 id="semcaps"><a href="#semcaps" class="anchor"></a>Subpath caps</h5><p>The shape of subpath (or dashes) end points is specified in <code>o.cap</code> by a value of type <a href="P/index.html#type-cap"><code>P.cap</code></a>. From left to right:  <img src="../_assets/doc-caps.png" style="width:90mm; height:20mm;"/> </p><ul><li><code>`Butt</code>, end points are square and extend only to the exact end point of the path.</li><li><code>`Round</code>, end points are rounded by a semicircle at the end point with a diameter equal to <code>o.width</code>.</li><li><code>`Square</code>, end points are square and extend by a distance equal to half <code>o.width</code>.</li></ul><h5 id="semdashes"><a href="#semdashes" class="anchor"></a>Outline dashes</h5><p>The path outline area can be chopped at regular intervals by spefiying a value <code>(off, pat)</code> of type <a href="P/index.html#type-dashes"><code>P.dashes</code></a> in <code>o.dashes</code>.</p><p>The <em>dash pattern</em> <code>pat</code> is a list of lengths that specify the length of alternating dashes and gaps (starting with dashes). The <em>dash offset</em> <code>off</code> is a <em>positive</em> offset that indicates where to start in the dash pattern at the beginning of a subpath.</p><h2 id="examples"><a href="#examples" class="anchor"></a>Examples</h2><p>Many examples of images and their source can be found in the <a href="http://erratique.ch/software/vg/demos/rhtmlc.html">online version</a> of <code>Vg</code>'s test image database. Clicking on the title of an image brings you to its definition.</p><p>The following examples show for each renderer the minimal code needed to output an image. This code can also be found in the <code>test</code> directory of the distribution.</p><h3 id="minpdf"><a href="#minpdf" class="anchor"></a>Minimal PDF output</h3><p>The file <code>min_pdf.ml</code> contains the following mostly self-explanatory code. We first define an image and then render it. For the latter step we define some meta-data for the image, a function to print rendering warnings and then render the image on stdout.</p><pre><code>open Gg
open Vg

(* 1. Define your image *)

let aspect = 1.618
let size = Size2.v (aspect *. 100.) 100. (* mm *)
let view = Box2.v P2.o (Size2.v aspect 1.)
let image = I.const (Color.v_srgb 0.314 0.784 0.471)

(* 2. Render *)

let () =
  let title = &quot;Vgr_pdf minimal example&quot; in
  let description = &quot;Emerald Color&quot; in
  let xmp = Vgr.xmp ~title ~description () in
  let warn w = Vgr.pp_warning Format.err_formatter w in
  let r = Vgr.create ~warn (Vgr_pdf.target ~xmp ()) (`Channel stdout) in
  ignore (Vgr.render r (`Image (size, view, image)));
  ignore (Vgr.render r `End)</code></pre><p>This can be compiled with:</p><pre><code>&gt; ocamlfind ocamlopt -package gg,vg,vg.pdf \
                     -linkpkg -o min_pdf.native min_pdf.ml</code></pre><h3 id="minsvg"><a href="#minsvg" class="anchor"></a>Minimal SVG output</h3><p>The file <code>min_svg.ml</code> contains the following mostly self-explanatory code. We first define an image and then render it. For the latter step we define some meta-data for the image, a function to print rendering warnings and then render the image on stdout.</p><pre><code>open Gg
open Vg

(* 1. Define your image *)

let aspect = 1.618
let size = Size2.v (aspect *. 100.) 100. (* mm *)
let view = Box2.v P2.o (Size2.v aspect 1.)
let image = I.const (Color.v_srgb 0.314 0.784 0.471)

(* 2. Render *)

let () =
  let title = &quot;Vgr_svg minimal example&quot; in
  let description = &quot;Emerald Color&quot; in
  let xmp = Vgr.xmp ~title ~description () in
  let warn w = Vgr.pp_warning Format.err_formatter w in
  let r = Vgr.create ~warn (Vgr_svg.target ~xmp ()) (`Channel stdout) in
  ignore (Vgr.render r (`Image (size, view, image)));
  ignore (Vgr.render r `End)</code></pre><p>This can be compiled with:</p><pre><code>&gt; ocamlfind ocamlopt -package gg,vg,vg.svg \
                     -linkpkg -o min_svg.native min_svg.ml</code></pre><h3 id="minhtmlc"><a href="#minhtmlc" class="anchor"></a>Minimal HTML canvas output</h3><p>The file <code>min_htmlc.ml</code> contains the following code. Step by step we have:</p><ol><li>Define an image.</li><li>Create and add to the DOM an anchor <code>a</code> that will parent the canvas. This will allow to download a (usually PNG) file of the image.</li><li>Create a canvas element <code>c</code> and add it as a child of <code>a</code>.</li><li>Create a renderer <code>r</code> targeting the canvas <code>c</code>.</li><li>Render the image.</li><li>Ask the canvas for an image data URL and set it as the the link of the anchor.</li></ol><pre><code>open Gg
open Vg
open Js_of_ocaml

(* 1. Define your image *)

let aspect = 1.618
let size = Size2.v (aspect *. 100.) 100. (* mm *)
let view = Box2.v P2.o (Size2.v aspect 1.)
let image = I.const (Color.v_srgb 0.314 0.784 0.471)

(* Browser bureaucracy. *)

let main _ =
  let d = Dom_html.window ##. document in
  let a = (* 2 *)
    let a = Dom_html.createA d in
    a ##. title := Js.string &quot;Download PNG file&quot;;
    a ##. href := Js.string &quot;#&quot;;
    a ## (setAttribute (Js.string &quot;download&quot;) (Js.string &quot;min_htmlc.png&quot;));
    Dom.appendChild (d ##. body) a; a
  in
  let c = (* 3 *)
    let c = Dom_html.createCanvas d in
    Dom.appendChild a c; c
  in
  let r = Vgr.create (Vgr_htmlc.target c) `Other in   (* 4 *)
  ignore (Vgr.render r (`Image (size, view, image))); (* 5 *)
  ignore (Vgr.render r `End);
  a ##. href := (c ## toDataURL); (* 6 *)
  Js._false

let () = Dom_html.window ##. onload := Dom_html.handler main</code></pre><p>This file needs to be compiled to byte code and then <code>js_of_ocaml</code> must be applied. This can be achieved with:</p><pre><code>&gt; ocamlfind ocamlc \
-package js_of_ocaml,js_of_ocaml-ppx \
-package gg,vg,vg.htmlc \
-linkpkg -o min_htmlc.byte min_htmlc.ml \
&amp;&amp; js_of_ocaml min_htmlc.byte</code></pre><p>Finally we need a minimal HTML file that references our final javascript <code>min_htmlc.js</code>. The following one will do:</p><pre>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,
                                 initial-scale=1.0&quot;&gt;
  &lt;script type=&quot;text/javascript&quot; defer=&quot;defer&quot; src=&quot;min_htmlc.js&quot;&gt;&lt;/script&gt;
  &lt;style type=&quot;text/css&quot;&gt; body \{ background-color: black; margin: 3em; \}&lt;/style&gt;
  &lt;title&gt;Vgr_htmlc minimal example&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;noscript&gt;Sorry, you need to enable JavaScript to see this page.&lt;/noscript&gt;
&lt;/body&gt;
&lt;/html&gt;</pre><h3 id="mincairopng"><a href="#mincairopng" class="anchor"></a>Minimal Cairo PNG output</h3><p>The file <code>min_cairo_png.ml</code> contains the following code. We first define an image and then render it on stdout as a PNG file.</p><pre><code>open Gg
open Vg

(* 1. Define your image *)

let aspect = 1.618
let size = Size2.v (aspect *. 100.) 100. (* mm *)
let view = Box2.v P2.o (Size2.v aspect 1.)
let image = I.const (Color.v_srgb 0.314 0.784 0.471)

(* 2. Render *)

let () =
  let res = 300. /. 0.0254 (* 300dpi in dots per meters *) in
  let fmt = `Png (Size2.v res res) in
  let warn w = Vgr.pp_warning Format.err_formatter w in
  let r = Vgr.create ~warn (Vgr_cairo.stored_target fmt) (`Channel stdout) in
  ignore (Vgr.render r (`Image (size, view, image)));
  ignore (Vgr.render r `End)</code></pre><p>This can be compiled with:</p><pre>&gt;  ocamlfind ocamlopt -package gg,vg,vg.cairo \
                      -linkpkg -o min_cairo_png.native min_cairo_png.ml</pre><h3 id="mincairomem"><a href="#mincairomem" class="anchor"></a>Minimal Cairo memory buffer rendering</h3><p>The file <code>min_cairo_mem.ml</code> contains the following code. We first define an image and then render to a bigarray buffer.</p><pre><code>open Gg
open Vg

(* 1. Define your image *)

let aspect = 1.618
let size = Size2.v (aspect *. 100.) 100. (* mm *)
let view = Box2.v P2.o (Size2.v aspect 1.)
let image = I.const (Color.v_srgb 0.314 0.784 0.471)

(* 2. Render *)

let raster, stride =
  let res = 300. /. 25.4 (* 300dpi in dots per mm *) in
  let w = int_of_float (res *. Size2.w size) in
  let h = int_of_float (res *. Size2.h size) in
  let stride = Cairo.Image.(stride_for_width ARGB32 w) in
  let data = Bigarray.(Array1.create int8_unsigned c_layout (stride * h)) in
  let surface = Cairo.Image.(create_for_data8 data ARGB32 ~stride w h) in
  let ctx = Cairo.create surface in
  Cairo.scale ctx ~x:res ~y:res;
  let target = Vgr_cairo.target ctx in
  let warn w = Vgr.pp_warning Format.err_formatter w in
  let r = Vgr.create ~warn target `Other in
  ignore (Vgr.render r (`Image (size, view, image)));
  ignore (Vgr.render r `End);
  Cairo.Surface.flush surface;
  Cairo.Surface.finish surface;
  data, stride</code></pre><pre>&gt; ocamlfind ocamlopt -package cairo2,gg,vg,vg.cairo \
                     -linkpkg -o min_cairo_mem.native min_cairo_mem.ml</pre></div></body></html>