<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Benchmark_accumulator (ppx_bench.Ppx_bench_lib.Benchmark_accumulator)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">ppx_bench</a> &#x00BB; <a href="../index.html">Ppx_bench_lib</a> &#x00BB; Benchmark_accumulator</nav><h1>Module <code>Ppx_bench_lib.Benchmark_accumulator</code></h1></header><aside><p>The point of <code>Benchmark_accumulator</code> is to provide a global place where inline benchmarking macros can register themselves. Once registered here, the benchmarks are retrieved and analyzed using <code>Core_bench</code>.</p><p>This module holds the registered benchmarks in a global hashtable indexed by library name. We care about the registered benchmarks if and only if the library is being used in a <code>inline_benchmarks_runner.exe</code>. To avoid building this hashtable in cases where we will not use it, this module peeks into the commandline args of the running program to decide if the benchmarks should be registered or not.</p></aside><div class="spec module" id="module-Current_libname"><a href="#module-Current_libname" class="anchor"></a><code><span class="keyword">module</span> <a href="Current_libname/index.html">Current_libname</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Entry"><a href="#module-Entry" class="anchor"></a><code><span class="keyword">module</span> <a href="Entry/index.html">Entry</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-add_environment_var"><a href="#val-add_environment_var" class="anchor"></a><code><span class="keyword">val</span> add_environment_var : bool</code></dt><dd><p><code>add_environment_var</code> returns true if the benchmarks should be added to the hashtable</p></dd></dl><dl><dt class="spec value" id="val-lookup_lib"><a href="#val-lookup_lib" class="anchor"></a><code><span class="keyword">val</span> lookup_lib : libname:string <span>&#45;&gt;</span> <a href="Entry/index.html#type-t">Entry.t</a> list</code></dt><dd><p><code>lookup_lib</code> returns all the benchmarks from the specified library</p></dd></dl><dl><dt class="spec value" id="val-add_bench"><a href="#val-add_bench" class="anchor"></a><code><span class="keyword">val</span> add_bench : name:string <span>&#45;&gt;</span> code:string <span>&#45;&gt;</span> filename:string <span>&#45;&gt;</span> type_conv_path:string <span>&#45;&gt;</span> line:int <span>&#45;&gt;</span> startpos:int <span>&#45;&gt;</span> endpos:int <span>&#45;&gt;</span> <a href="Entry/index.html#type-test_spec">Entry.test_spec</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>add_bench</code> registers benchmarks with the global hashtable maintained in <code>ppx_bench_lib</code>. This is meant to be called by the code generated for the BENCH and BENCH_INDEXED macros</p></dd></dl><dl><dt class="spec value" id="val-add_bench_module"><a href="#val-add_bench_module" class="anchor"></a><code><span class="keyword">val</span> add_bench_module : name:string <span>&#45;&gt;</span> code:string <span>&#45;&gt;</span> type_conv_path:string <span>&#45;&gt;</span> filename:string <span>&#45;&gt;</span> line:int <span>&#45;&gt;</span> startpos:int <span>&#45;&gt;</span> endpos:int <span>&#45;&gt;</span> (unit <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit</code></dt><dd><p><code>add_bench_module</code> adds a bench module name to the benchmarks. This is called by BENCH_MODULE macro</p></dd></dl></div></body></html>