<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Injective (base.Base__.Type_equal.Injective)</title><link rel="stylesheet" href="../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../../index.html">base</a> &#x00BB; <a href="../../index.html">Base__</a> &#x00BB; <a href="../index.html">Type_equal</a> &#x00BB; Injective</nav><h1>Module type <code>Type_equal.Injective</code></h1><p><code>Injective</code> is an interface that states that a type is injective, where the type is viewed as a function from types to other types. The typical usage is:</p><pre><code class="ml">type 'a t
include Injective with type 'a t := 'a t</code></pre><p>For example, <code>'a list</code> is an injective type, because whenever <code>'a list = 'b list</code>, we know that <code>'a</code> = <code>'b</code>. On the other hand, if we define:</p><pre><code class="ml">type 'a t = unit</code></pre><p>then clearly <code>t</code> isn't injective, because, e.g., <code>int t = bool t</code>, but <code>int &lt;&gt; bool</code>.</p><p>If <code>module M : Injective</code>, then <code>M.strip</code> provides a way to get a proof that two types are equal from a proof that both types transformed by <code>M.t</code> are equal.</p><p>OCaml has no built-in language feature to state that a type is injective, which is why we have <code>module type Injective</code>. However, OCaml can infer that a type is injective, and we can use this to match <code>Injective</code>. A typical implementation will look like this:</p><pre><code class="ml">let strip (type a) (type b)
      (Type_equal.T : (a t, b t) Type_equal.t) : (a, b) Type_equal.t =
  Type_equal.T</code></pre><p>This will not type check for all type constructors (certainly not for non-injective ones!), but it's always safe to try the above implementation if you are unsure. If OCaml accepts this definition, then the type is injective. On the other hand, if OCaml doesn't, then the type may or may not be injective. For example, if the definition of the type depends on abstract types that match <code>Injective</code>, OCaml will not automatically use their injectivity, and one will have to write a more complicated definition of <code>strip</code> that causes OCaml to use that fact. For example:</p><pre><code class="ml">module F (M : Type_equal.Injective) : Type_equal.Injective = struct
  type 'a t = 'a M.t * int

  let strip (type a) (type b)
        (e : (a t, b t) Type_equal.t) : (a, b) Type_equal.t =
    let e1, _ = Type_equal.detuple2 e in
    M.strip e1
  ;;
end</code></pre><p>If in the definition of <code>F</code> we had written the simpler implementation of <code>strip</code> that didn't use <code>M.strip</code>, then OCaml would have reported a type error.</p></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> 'a t</code></dt></dl><dl><dt class="spec value" id="val-strip"><a href="#val-strip" class="anchor"></a><code><span class="keyword">val</span> strip : (<span class="type-var">'a</span> <a href="index.html#type-t">t</a>, <span class="type-var">'b</span> <a href="index.html#type-t">t</a>) <a href="../index.html#type-equal">equal</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="../index.html#type-equal">equal</a></code></dt></dl></div></body></html>