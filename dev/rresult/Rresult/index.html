<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Rresult (rresult.Rresult)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">rresult</a> &#x00BB; Rresult</nav><h1>Module <code>Rresult</code></h1><p>Result value combinators.</p><p><code>Rresult</code> is a module for handling computation results and errors in an explicit and declarative manner without resorting to exceptions. It defines a <a href="index.html#type-result"><code>result</code></a> type equal to OCaml 4.03's <code>result</code> type and <a href="R/index.html"><span>combinators</span></a> to operate on these values.</p><p>Open the module to use it, this defines the <a href="index.html#type-result"><span>result type</span></a>, the <a href="R/Infix/index.html"><code>R.Infix</code></a> operators <a href="R/index.html"><code>R</code></a> in your scope.</p><p>Consult <a href="index.html#usage"><span>usage guidelines</span></a> for the type.</p><p><em>v0.6.0 - <a href="http://erratique.ch/software/rresult">homepage</a></em></p><nav class="toc"><ul><li><a href="#results">Results</a></li><li><a href="#usage">Usage design guidelines</a><ul><li><a href="#error-messages">Error messages</a></li><li><a href="#custom-error-types">Custom error types</a></li></ul></li></ul></nav></header><section><header><h2 id="results"><a href="#results" class="anchor"></a>Results</h2></header><dl><dt class="spec type" id="type-result"><a href="#type-result" class="anchor"></a><code><span class="keyword">type</span> ('a, 'b) result</code><code> = (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="../../result/Result/index.html#type-result">Result.result</a></code><code> = </code><table class="variant"><tr id="type-result.Ok" class="anchored"><td class="def constructor"><a href="#type-result.Ok" class="anchor"></a><code>| </code><code><span class="constructor">Ok</span> <span class="keyword">of</span> <span class="type-var">'a</span></code></td></tr><tr id="type-result.Error" class="anchored"><td class="def constructor"><a href="#type-result.Error" class="anchor"></a><code>| </code><code><span class="constructor">Error</span> <span class="keyword">of</span> <span class="type-var">'b</span></code></td></tr></table></dt><dd><p>The type for results.</p></dd></dl><dl><dt class="spec value" id="val-(&gt;&gt;=)"><a href="#val-(&gt;&gt;=)" class="anchor"></a><code><span class="keyword">val</span> (&gt;&gt;=) : (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="../../result/Result/index.html#type-result">Result.result</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'c</span>, <span class="type-var">'b</span>) <a href="../../result/Result/index.html#type-result">Result.result</a>) <span>&#45;&gt;</span> (<span class="type-var">'c</span>, <span class="type-var">'b</span>) <a href="../../result/Result/index.html#type-result">Result.result</a></code></dt><dd><p><code>(&gt;&gt;=)</code> is <span class="xref-unresolved" title="unresolved reference to &quot;R.( &gt;&gt;= )&quot;"><a href="index.html#module-R"><code>R</code></a>.( &gt;&gt;= )</span>.</p></dd></dl><dl><dt class="spec value" id="val-(&gt;&gt;|)"><a href="#val-(&gt;&gt;|)" class="anchor"></a><code><span class="keyword">val</span> (&gt;&gt;|) : (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="../../result/Result/index.html#type-result">Result.result</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>) <span>&#45;&gt;</span> (<span class="type-var">'c</span>, <span class="type-var">'b</span>) <a href="../../result/Result/index.html#type-result">Result.result</a></code></dt><dd><p><code>(&gt;&gt;|)</code> is <span class="xref-unresolved" title="unresolved reference to &quot;R.( &gt;&gt;| )&quot;"><a href="index.html#module-R"><code>R</code></a>.( &gt;&gt;| )</span>.</p></dd></dl><dl><dt class="spec module" id="module-R"><a href="#module-R" class="anchor"></a><code><span class="keyword">module</span> <a href="R/index.html">R</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Result value combinators.</p></dd></dl></section><section><header><h2 id="usage"><a href="#usage" class="anchor"></a>Usage design guidelines</h2><p>These are rough design guidelines, don't forget to think.</p></header><section><header><h3 id="error-messages"><a href="#error-messages" class="anchor"></a>Error messages</h3><p>Use <a href="R/index.html#msgs"><span>error messages</span></a> if:</p><ol><li>Your error messages don't need to be localized, e.g. scripts, command line programs.</li><li>The errors don't need to be processed. They are just meant to be logged at certain point in your program.</li></ol><p>If the above doesn't hold and your errors need to be processed for localization or error recovery then use a custom error type in your result values.</p></header></section><section><header><h3 id="custom-error-types"><a href="#custom-error-types" class="anchor"></a>Custom error types</h3><p>If your module has specific errors then define an error type, and a result type that tags this error type with the library name (or any other tag that may make sense, see for example <a href="R/index.html#exn"><span>Trapping unexpected exceptions</span></a>) along with the following functions:</p><pre><code class="ml">module Mod : sig
  type error = ...
  type 'a result = ('a, [`Mod of error]) Rresult.result
  val pp_error : Format.formatter -&gt; [`Mod of error] -&gt; unit
  val open_error : 'a result -&gt; ('a, [&gt; `Mod of error]) Rresult.result
  val error_to_msg : 'a result -&gt; ('a, Rresult.R.msg) Rresult.result

  val f : ... -&gt; 'a result
end</code></pre><p>If your library has generic errors that may be useful in other context or shared among modules and to be composed together, then define your error type itself as being a variant and return these values without tagging them.</p><pre><code class="ml">module Mod : sig
  type error = [`Generic of ... | ... ]
  type 'a result = ('a, error) Rresult.result
  val pp_error : Format.formatter -&gt; error -&gt; unit
  val open_error : 'a result -&gt; ('a, [&gt; error]) Rresult.result
  val error_to_msg : 'a result -&gt; ('a, Rresult.R.msg) Rresult.result

  val f : ... -&gt; 'a result
end</code></pre><p>In the latter case it may still be useful to provide a function to tag these errors whenever they reach a certain point of the program. For this the following function could be added to <code>Mod</code>:</p><pre><code class="ml">val pack_error : 'a result -&gt;  ('a, [&gt; `Mod of error]) Rresult.result</code></pre><p>You should then provide the following functions aswell, so that the packed error composes well in the system:</p><pre><code class="ml">val pp_pack_error : Format.formatter -&gt; [ `Mod of error] -&gt; unit
val open_pack_error :  ('a, [ `Mod of error]) Rresult.result -&gt;
  ('a, [&gt; `Mod of error]) Rresult.result

val error_pack_to_msg : ('a, [ `Mod of error]) Rresult.result -&gt;
  ('a, Rresult.R.msg) Rresult.result</code></pre></header></section></section></div></body></html>