<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Bi_inbuf (biniou.Bi_inbuf)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">biniou</a> &#x00BB; Bi_inbuf</nav><header class="odoc-preamble"><h1>Module <code><span>Bi_inbuf</span></code></h1><p>Input buffer</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span><span> = </span><span>{</span></code><table><tr id="type-t.i_s" class="anchored"><td class="def record field"><a href="#type-t.i_s" class="anchor"></a><code><span><span class="keyword">mutable</span> i_s : bytes;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>This is the buffer string. It can be accessed for reading but should normally only be written to or replaced only by the <code>i_refill</code> function.</p><span class="comment-delim">*)</span></td></tr><tr id="type-t.i_pos" class="anchored"><td class="def record field"><a href="#type-t.i_pos" class="anchor"></a><code><span><span class="keyword">mutable</span> i_pos : int;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>This is the current position in the input buffer. All data before that may be erased at anytime.</p><span class="comment-delim">*)</span></td></tr><tr id="type-t.i_len" class="anchored"><td class="def record field"><a href="#type-t.i_len" class="anchor"></a><code><span><span class="keyword">mutable</span> i_len : int;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>This is the position of the first byte of invalid input data. Data starting at <code>i_pos</code> and ending at <code>i_len-1</code> is considered valid input data that is available to the user. Beware that calls to <code>try_preread</code>, <code>read</code> and other read functions may move data around and therefore modify the values of <code>i_pos</code> and <code>i_len</code> in order to keep pointing to the correct data segment.</p><span class="comment-delim">*)</span></td></tr><tr id="type-t.i_offs" class="anchored"><td class="def record field"><a href="#type-t.i_offs" class="anchor"></a><code><span><span class="keyword">mutable</span> i_offs : int;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Length of data read and discarded from the buffer. This indicates the position in the input stream of the first byte of the buffer. The current position in the input stream is <code>i_offs + i_pos</code>. The total length of input stream data put into the buffer is <code>i_offs + i_len</code>.</p><span class="comment-delim">*)</span></td></tr><tr id="type-t.i_max_len" class="anchored"><td class="def record field"><a href="#type-t.i_max_len" class="anchor"></a><code><span><span class="keyword">mutable</span> i_max_len : int;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>This is the length of <code>i_s</code>.</p><span class="comment-delim">*)</span></td></tr><tr id="type-t.i_refill" class="anchored"><td class="def record field"><a href="#type-t.i_refill" class="anchor"></a><code><span>i_refill : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Function called when not enough data is available in the buffer. The int argument is the total number of bytes that must be available starting at position <code>i_pos</code> when the function returns. This function typically does nothing if all input data already has been placed into the buffer. The <code>i_pos</code> and <code>i_len</code> fields can be modified the <code>i_refill</code> function, as long as the available data that was starting from <code>i_pos</code> still starts from the new value of <code>i_pos</code>. All the other fields can be modified as well.</p><span class="comment-delim">*)</span></td></tr><tr id="type-t.i_shared" class="anchored"><td class="def record field"><a href="#type-t.i_shared" class="anchor"></a><code><span>i_shared : <span class="xref-unresolved">Bi_share</span>.Rd.tbl;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Hash table used to map positions in the input stream to shared objects (if any).</p><span class="comment-delim">*)</span></td></tr></table><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec exception" id="exception-End_of_input" class="anchored"><a href="#exception-End_of_input" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">End_of_input</span></span></code></div><div class="spec-doc"><p>Exception raised by all the functions of this module when it is not possible to return a valid result because there is not enough data to read from the buffer.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-try_preread" class="anchored"><a href="#val-try_preread" class="anchor"></a><code><span><span class="keyword">val</span> try_preread : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>try_preread ib n</code> make at least <code>n</code> bytes available for reading in <code>ib.i_s</code>, unless the end of the input is reached. The result indicates how many bytes were made available. If smaller than <code>n</code>, the result indicates that the end of the input was reached. <code>ib.i_pos</code> is set to point to the first available byte.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-read" class="anchored"><a href="#val-read" class="anchor"></a><code><span><span class="keyword">val</span> read : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>read ib n</code> makes at least <code>n</code> bytes available for reading or raises the <code>End_of_input</code> exception. The result is the position of the first available byte. <code>ib.i_pos</code> is moved to point to the next position after the <code>n</code> bytes.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">End_of_input</span> <p>if there is less than <code>n</code> bytes before the end of input.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-read_char" class="anchored"><a href="#val-read_char" class="anchor"></a><code><span><span class="keyword">val</span> read_char : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> char</span></code></div><div class="spec-doc"><p>Read just one byte.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">End_of_input</span> <p>if the end of input has already been reached.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-peek" class="anchored"><a href="#val-peek" class="anchor"></a><code><span><span class="keyword">val</span> peek : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> char</span></code></div><div class="spec-doc"><p>Return the next byte without moving forward.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">End_of_input</span> <p>if the end of input has already been reached.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-from_string" class="anchored"><a href="#val-from_string" class="anchor"></a><code><span><span class="keyword">val</span> from_string : <span>?pos:int <span class="arrow">&#45;&gt;</span></span> <span>?shrlen:int <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Create an input buffer from a string.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pos</span> <p>position to start from. Default: 0.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">shrlen</span> <p>initial length of the table used to store shared values.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-from_bytes" class="anchored"><a href="#val-from_bytes" class="anchor"></a><code><span><span class="keyword">val</span> from_bytes : <span>?pos:int <span class="arrow">&#45;&gt;</span></span> <span>?shrlen:int <span class="arrow">&#45;&gt;</span></span> <span>bytes <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Create an input buffer from bytes.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pos</span> <p>position to start from. Default: 0.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">shrlen</span> <p>initial length of the table used to store shared values.</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.2.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-from_channel" class="anchored"><a href="#val-from_channel" class="anchor"></a><code><span><span class="keyword">val</span> from_channel : <span>?len:int <span class="arrow">&#45;&gt;</span></span> <span>?shrlen:int <span class="arrow">&#45;&gt;</span></span> <span><a href="../../ocaml/Stdlib/index.html#type-in_channel">in_channel</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Create an input buffer from an in_channel. Such a buffer is not extensible and <code>read</code> requests may not exceed <code>len</code>.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">len</span> <p>buffer length.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">shrlen</span> <p>initial length of the table used to store shared values.</p></li></ul></div></div></div></body></html>