<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>B0_ocaml (b0.B0_ocaml)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">b0</a> &#x00BB; B0_ocaml</nav><header class="odoc-preamble"><h1>Module <code><span>B0_ocaml</span></code></h1><p>OCaml B0 file support.</p></header><nav class="odoc-toc"><ul><li><a href="#units">Units</a></li><li><a href="#build_conf">Build configuration</a><ul><li><a href="#code">Generated code</a></li></ul></li><li><a href="#frag">Build fragments</a></li><li><a href="#metadata">Metadata</a></li><li><a href="#lib">Library resolution</a></li></ul></nav><div class="odoc-content"><h2 id="units"><a href="#units" class="anchor"></a>Units</h2><p>A few high-level build units.</p><div class="odoc-spec"><div class="spec value" id="val-libname" class="anchored"><a href="#val-libname" class="anchor"></a><code><span><span class="keyword">val</span> libname : <span>string <span class="arrow">&#45;&gt;</span></span> <a href="../B00_ocaml/Lib/Name/index.html#type-t">B00_ocaml.Lib.Name.t</a></span></code></div><div class="spec-doc"><p><code>libname n</code> is <code>n</code> as an OCaml <a href="../B00_ocaml/Lib/Name/index.html">library name</a>. This is shortcut for <a href="../B00_ocaml/Lib/Name/index.html#val-v"><code>B00_ocaml.Lib.Name.v</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-exe" class="anchored"><a href="#val-exe" class="anchor"></a><code><span><span class="keyword">val</span> exe : <span>?wrap:<span>(<span><a href="../B0_unit/index.html#type-proc">B0_unit.proc</a> <span class="arrow">&#45;&gt;</span></span> <a href="../B0_unit/index.html#type-proc">B0_unit.proc</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span>?doc:string <span class="arrow">&#45;&gt;</span></span> <span>?meta:<a href="../B0_meta/index.html#type-t">B0_meta.t</a> <span class="arrow">&#45;&gt;</span></span> <span>?action:<a href="../B0_unit/index.html#type-action">B0_unit.action</a> <span class="arrow">&#45;&gt;</span></span> <span>?requires:<span><a href="../B00_ocaml/Lib/Name/index.html#type-t">B00_ocaml.Lib.Name.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
<span>?name:string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>srcs:<a href="../B0_srcs/index.html#type-sels">B0_srcs.sels</a> <span class="arrow">&#45;&gt;</span></span> <a href="../B0_unit/index.html#type-t">B0_unit.t</a></span></code></div><div class="spec-doc"><p><code>exe n</code> is a build unit for an executable named <code>n</code> (without the platform specific extension).</p><ul><li><code>doc</code> is the unit doc string.</li><li><code>meta</code> is the initial metadata.</li><li><code>requires</code> are the OCaml libraries required to compile the executable.</li><li><code>name</code> is the name of the unit (defaults to <code>n</code>).</li><li><code>srcs</code> are the executable sources. All files with extension <code>.ml</code>, <code>.mli</code>, <code>.c</code> and <code>.h</code> are considered for compiling and linking the executable.</li><li><code>wrap</code> allows to extend the build procedure you must call the given build procedure. TODO maybe remove once we have good <a href="#frag">Build fragments</a>.</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-lib" class="anchored"><a href="#val-lib" class="anchor"></a><code><span><span class="keyword">val</span> lib : <span>?wrap:<span>(<span><a href="../B0_unit/index.html#type-proc">B0_unit.proc</a> <span class="arrow">&#45;&gt;</span></span> <a href="../B0_unit/index.html#type-proc">B0_unit.proc</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span>?doc:string <span class="arrow">&#45;&gt;</span></span> <span>?meta:<a href="../B0_meta/index.html#type-t">B0_meta.t</a> <span class="arrow">&#45;&gt;</span></span> <span>?action:<a href="../B0_unit/index.html#type-action">B0_unit.action</a> <span class="arrow">&#45;&gt;</span></span> <span>?requires:<span><a href="../B00_ocaml/Lib/Name/index.html#type-t">B00_ocaml.Lib.Name.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
<span>?name:string <span class="arrow">&#45;&gt;</span></span> <span><a href="../B00_ocaml/Lib/Name/index.html#type-t">B00_ocaml.Lib.Name.t</a> <span class="arrow">&#45;&gt;</span></span> <span>srcs:<a href="../B0_srcs/index.html#type-sels">B0_srcs.sels</a> <span class="arrow">&#45;&gt;</span></span> <a href="../B0_unit/index.html#type-t">B0_unit.t</a></span></code></div><div class="spec-doc"><p><code>lib n ~srcs</code> is a built unit for a library named <code>l</code> made of sources <code>src</code>.</p><ul><li><code>doc</code> is the unit doc string.</li><li><code>meta</code> is the initial metadata.</li><li><code>requires</code> are the OCaml libraries required to compile the library.</li><li><code>name</code> is the name of the build unit (default to <code>n</code> with <code>.</code> substituted by <code>-</code>)</li><li><code>srcs</code> are the library sources. extension <code>.ml</code>, <code>.mli</code>, <code>.c</code> and <code>.h</code> are considered for compiling and linking the executable.</li><li><code>wrap</code> allows to extend the build procedure you must call the given build procedure. TODO maybe remove once we have good <a href="#frag">Build fragments</a>.</li></ul></div></div><h2 id="build_conf"><a href="#build_conf" class="anchor"></a>Build configuration</h2><div class="odoc-spec"><div class="spec value" id="val-conf" class="anchored"><a href="#val-conf" class="anchor"></a><code><span><span class="keyword">val</span> conf : <span><a href="../B00_ocaml/Conf/index.html#type-t">B00_ocaml.Conf.t</a> <a href="../B00/Store/index.html#type-key">B00.Store.key</a></span></span></code></div><div class="spec-doc"><p><code>conf</code> is a memo key store with the OCaml configuration.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-version" class="anchored"><a href="#val-version" class="anchor"></a><code><span><span class="keyword">val</span> version : <span><a href="../B0_build/index.html#type-t">B0_build.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(int * int * int * <span>string option</span>)</span> <a href="../B00_std/Fut/index.html#type-t">B00_std.Fut.t</a></span></span></code></div><div class="spec-doc"><p><code>ocaml_version b</code> gets <code>B00_ocaml</code>.Tool.Conf.version from <a href="#val-conf"><code>conf</code></a>.</p></div></div><h3 id="code"><a href="#code" class="anchor"></a>Generated code</h3><p>In a build it is desirable to know which code is being produced because if both are produced the compilers may compete to produce some of the shared build artefacts. The following store keys allow to express build code <a href="#val-wanted_code">desires</a> and determine the actual <a href="#val-built_code">decision</a>. Note the desires may actually be altered units that may build FIXME maybe we should stick to must.</p><div class="odoc-spec"><div class="spec type" id="type-built_code" class="anchored"><a href="#type-built_code" class="anchor"></a><code><span><span class="keyword">type</span> built_code</span><span> = </span><span>[ </span></code><table><tr id="type-built_code.Byte" class="anchored"><td class="def constructor"><a href="#type-built_code.Byte" class="anchor"></a><code><span>| </span></code><code><span>`Byte</span></code></td></tr><tr id="type-built_code.Native" class="anchored"><td class="def constructor"><a href="#type-built_code.Native" class="anchor"></a><code><span>| </span></code><code><span>`Native</span></code></td></tr><tr id="type-built_code.All" class="anchored"><td class="def constructor"><a href="#type-built_code.All" class="anchor"></a><code><span>| </span></code><code><span>`All</span></code></td></tr></table><code><span> ]</span></code></div><div class="spec-doc"><p>The type indicating which code is being built.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_built_code" class="anchored"><a href="#val-pp_built_code" class="anchor"></a><code><span><span class="keyword">val</span> pp_built_code : <span><a href="#type-built_code">built_code</a> <a href="../B00_std/Fmt/index.html#type-t">B00_std.Fmt.t</a></span></span></code></div><div class="spec-doc"><p><code>pp_built_code</code> formats <a href="#type-built_code"><code>built_code</code></a> values.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-wanted_code" class="anchored"><a href="#val-wanted_code" class="anchor"></a><code><span><span class="keyword">val</span> wanted_code : <span><span>[ <a href="#type-built_code">built_code</a> <span>| `Auto</span> ]</span> <a href="../B00/Store/index.html#type-key">B00.Store.key</a></span></span></code></div><div class="spec-doc"><p><code>wanted_code</code> indicates which code should be built, default determines to <code>`Auto</code>. If <code>`Auto</code> is used and no unit that may build has specific <a href="Meta/index.html#val-needs_code"><code>Meta.needs_code</code></a> then <code>`Native</code> is used if <code>ocamlopt</code> can be found in the memo environment and <code>`Byte</code> otherwise.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-built_code" class="anchored"><a href="#val-built_code" class="anchor"></a><code><span><span class="keyword">val</span> built_code : <span><a href="#type-built_code">built_code</a> <a href="../B00/Store/index.html#type-key">B00.Store.key</a></span></span></code></div><div class="spec-doc"><p><code>build_code</code> is a memo key indicating the built code. By default determines by consulting <code>wanted_code</code>.</p></div></div><h2 id="frag"><a href="#frag" class="anchor"></a>Build fragments</h2><p>See <span class="xref-unresolved">TODO</span>.</p><h2 id="metadata"><a href="#metadata" class="anchor"></a>Metadata</h2><div class="odoc-spec"><div class="spec value" id="val-tag" class="anchored"><a href="#val-tag" class="anchor"></a><code><span><span class="keyword">val</span> tag : <span>unit <a href="../B0_meta/index.html#type-key">B0_meta.key</a></span></span></code></div><div class="spec-doc"><p><code>tag</code> indicates the entity is related to OCaml.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Meta" class="anchored"><a href="#module-Meta" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Meta/index.html">Meta</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Metadata keys</p></div></div><h2 id="lib"><a href="#lib" class="anchor"></a>Library resolution</h2><div class="odoc-spec"><div class="spec value" id="val-lib_resolver" class="anchored"><a href="#val-lib_resolver" class="anchor"></a><code><span><span class="keyword">val</span> lib_resolver : <span><a href="../B00_ocaml/Lib/Resolver/index.html#type-t">B00_ocaml.Lib.Resolver.t</a> <a href="../B00/Store/index.html#type-key">B00.Store.key</a></span></span></code></div><div class="spec-doc"><p><code>lib_resolver</code> is the library resolver used by the build units defined by this module. See <a href="#val-default_lib_resolver"><code>default_lib_resolver</code></a> for the default.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-default_lib_resolver" class="anchored"><a href="#val-default_lib_resolver" class="anchor"></a><code><span><span class="keyword">val</span> default_lib_resolver : <span><a href="../B00/Store/index.html#type-t">B00.Store.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../B00/Memo/index.html#type-t">B00.Memo.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../B00_ocaml/Lib/Resolver/index.html#type-t">B00_ocaml.Lib.Resolver.t</a> <a href="../B00_std/Fut/index.html#type-t">B00_std.Fut.t</a></span></span></code></div><div class="spec-doc"><p><code>default_lib_resolver</code> determines the default value of <a href="#val-lib_resolver"><code>lib_resolver</code></a>. This resolver does the following:</p><ol><li>It first looks if the library name is <a href="Meta/index.html#val-library">defined</a> by a unit that <a href="../B0_build/index.html#val-may_build">may</a> be built. If that is the case it creates a library out of that build unit via <a href="#val-lib_of_unit"><code>lib_of_unit</code></a>.</li><li>It looks into the build environment via <a href="../B00_ocaml/Lib/Resolver/index.html#val-ocamlpath"><code>B00_ocaml.Lib.Resolver.ocamlpath</code></a> and <a href="../B00_ocaml/Lib/Resolver/index.html#val-ocamlfind"><code>B00_ocaml.Lib.Resolver.ocamlfind</code></a> using the <a href="../B0_build/index.html#val-shared_build_dir"><code>B0_build.shared_build_dir</code></a> directory of the build.</li></ol></div></div><div class="odoc-spec"><div class="spec value" id="val-lib_of_unit" class="anchored"><a href="#val-lib_of_unit" class="anchor"></a><code><span><span class="keyword">val</span> lib_of_unit : <span><a href="../B0_build/index.html#type-t">B0_build.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../B00_ocaml/Conf/index.html#type-t">B00_ocaml.Conf.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../B0_unit/index.html#type-t">B0_unit.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../B00_ocaml/Lib/index.html#type-t">B00_ocaml.Lib.t</a> option</span> <a href="../B00_std/Fut/index.html#type-t">B00_std.Fut.t</a></span></span></code></div><div class="spec-doc"><p><code>lib_of_unit b ocaml_conf u</code> defines a library from unit <code>u</code> by consulting <a href="Meta/index.html#val-requires"><code>Meta.requires</code></a>, <a href="Meta/index.html#val-library"><code>Meta.library</code></a> and <a href="Meta/index.html#val-mod_srcs"><code>Meta.mod_srcs</code></a>. As a side effect this <a href="../B0_build/index.html#val-require"><code>B0_build.require</code></a> <code>u</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-lib_resolver_build_scope" class="anchored"><a href="#val-lib_resolver_build_scope" class="anchor"></a><code><span><span class="keyword">val</span> lib_resolver_build_scope : <span><a href="../B0_build/index.html#type-t">B0_build.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../B00_ocaml/Conf/index.html#type-t">B00_ocaml.Conf.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../B00_ocaml/Lib/Resolver/index.html#type-scope">B00_ocaml.Lib.Resolver.scope</a></span></code></div><div class="spec-doc"><p><code>lib_resolver_build_scope b conf</code> is a library resolver scope for OCaml libraries that can be built in <code>b</code>. For a unit <code>u</code> to be recognized as such it has to:</p><ul><li>Be in the <a href="../B0_build/index.html#val-may_build"><code>B0_build.may_build</code></a> set of <code>b</code>.</li><li>Define the <a href="Meta/index.html#val-library"><code>Meta.library</code></a> and <a href="Meta/index.html#val-requires"><code>Meta.requires</code></a> in its metadata.</li></ul></div></div></div></body></html>