<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Jsonm (jsonm.Jsonm)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../index.html">jsonm</a> &#x00BB; Jsonm</nav><header class="odoc-preamble"><h1>Module <code><span>Jsonm</span></code></h1><p>Non-blocking streaming JSON codec.</p><p><code>Jsonm</code> is a non-blocking streaming codec to <a href="#decode">decode</a> and <a href="#encode">encode</a> the <a href="http://tools.ietf.org/html/rfc7159">JSON</a> data format. It can process JSON text without blocking on IO and without a complete in-memory representation of the data.</p><p>The <a href="Uncut/index.html">uncut codec</a> also processes whitespace and (non-standard) JSON with JavaScript comments.</p><p>Consult the <a href="#datamodel">data model</a>, <a href="#limitations">limitations</a> and <a href="#examples">examples</a> of use.</p><p><em>v1.0.1 - <a href="http://erratique.ch/software/jsonm">homepage</a></em></p></header><nav class="odoc-toc"><ul><li><a href="#references">References</a></li><li><a href="#datamodel">JSON data model</a></li><li><a href="#decode">Decode</a></li><li><a href="#encode">Encode</a></li><li><a href="#manual">Manual sources and destinations</a></li><li><a href="#uncut">Uncut codec</a></li><li><a href="#limitations">Limitations</a><ul><li><a href="#decode_3">Decode</a></li><li><a href="#encode_3">Encode</a></li></ul></li><li><a href="#errorrecovery">Error recovery</a></li><li><a href="#examples">Examples</a><ul><li><a href="#filter">Trip</a></li><li><a href="#memsel">Member selection</a></li><li><a href="#tree">Generic JSON representation</a></li></ul></li></ul></nav><div class="odoc-content"><h4 id="references"><a href="#references" class="anchor"></a>References</h4><ul><li>T. Bray Ed. <em><a href="http://tools.ietf.org/html/rfc7159">The JavaScript Object Notation (JSON) Data Interchange Format</a>, 2014</em></li></ul><h2 id="datamodel"><a href="#datamodel" class="anchor"></a>JSON data model</h2><div class="odoc-spec"><div class="spec type" id="type-lexeme" class="anchored"><a href="#type-lexeme" class="anchor"></a><code><span><span class="keyword">type</span> lexeme</span><span> = </span><span>[ </span></code><table><tr id="type-lexeme.Null" class="anchored"><td class="def constructor"><a href="#type-lexeme.Null" class="anchor"></a><code><span>| </span></code><code><span>`Null</span></code></td></tr><tr id="type-lexeme.Bool" class="anchored"><td class="def constructor"><a href="#type-lexeme.Bool" class="anchor"></a><code><span>| </span></code><code><span>`Bool <span class="keyword">of</span> bool</span></code></td></tr><tr id="type-lexeme.String" class="anchored"><td class="def constructor"><a href="#type-lexeme.String" class="anchor"></a><code><span>| </span></code><code><span>`String <span class="keyword">of</span> string</span></code></td></tr><tr id="type-lexeme.Float" class="anchored"><td class="def constructor"><a href="#type-lexeme.Float" class="anchor"></a><code><span>| </span></code><code><span>`Float <span class="keyword">of</span> float</span></code></td></tr><tr id="type-lexeme.Name" class="anchored"><td class="def constructor"><a href="#type-lexeme.Name" class="anchor"></a><code><span>| </span></code><code><span>`Name <span class="keyword">of</span> string</span></code></td></tr><tr id="type-lexeme.As" class="anchored"><td class="def constructor"><a href="#type-lexeme.As" class="anchor"></a><code><span>| </span></code><code><span>`As</span></code></td></tr><tr id="type-lexeme.Ae" class="anchored"><td class="def constructor"><a href="#type-lexeme.Ae" class="anchor"></a><code><span>| </span></code><code><span>`Ae</span></code></td></tr><tr id="type-lexeme.Os" class="anchored"><td class="def constructor"><a href="#type-lexeme.Os" class="anchor"></a><code><span>| </span></code><code><span>`Os</span></code></td></tr><tr id="type-lexeme.Oe" class="anchored"><td class="def constructor"><a href="#type-lexeme.Oe" class="anchor"></a><code><span>| </span></code><code><span>`Oe</span></code></td></tr></table><code><span> ]</span></code></div><div class="spec-doc"><p>The type for JSON lexemes. <code>`As</code> and <code>`Ae</code> start and end arrays and <code>`Os</code> and <code>`Oe</code> start and end objects. <code>`Name</code> is for the member names of objects.</p><p>A <em>well-formed</em> sequence of lexemes belongs to the language of the <code>json</code> grammar:</p><pre><code>  json = value 
object = `Os *member `Oe
member = (`Name s) value
 array = `As *value `Ae
 value = `Null / `Bool b / `Float f / `String s / object / array</code></pre><p>A <a href="#decode">decoder</a> returns only well-formed sequences of lexemes or <code>`Error</code>s are returned. The <a href="http://tools.ietf.org/html/rfc3629">UTF-8</a>, <a href="http://tools.ietf.org/html/rfc2781">UTF-16</a>, UTF-16LE and UTF-16BE encoding schemes are supported. The strings of decoded <code>`Name</code> and <code>`String</code> lexemes are however always UTF-8 encoded. In these strings, characters originally escaped in the input are in their unescaped representation.</p><p>An <a href="#encode">encoder</a> accepts only well-formed sequences of lexemes or <code>Invalid_argument</code> is raised. Only the UTF-8 encoding scheme is supported. The strings of encoded <code>`Name</code> and <code>`String</code> lexemes are assumed to be immutable and must be UTF-8 encoded, this is <b>not</b> checked by the module. In these strings, the delimiter characters <code>U+0022</code> and <code>U+005C</code> (<code>'&quot;'</code>, <code>'\'</code>) aswell as the control characters <code>U+0000-U+001F</code> are automatically escaped by the encoders, as mandated by the standard.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_lexeme" class="anchored"><a href="#val-pp_lexeme" class="anchor"></a><code><span><span class="keyword">val</span> pp_lexeme : <span><a href="../../ocaml/Stdlib/Format/index.html#type-formatter">Format.formatter</a> <span class="arrow">&#45;&gt;</span></span> <span><span>[&lt; <a href="#type-lexeme">lexeme</a> ]</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>pp_lexeme ppf l</code> prints a unspecified non-JSON representation of <code>l</code> on <code>ppf</code>.</p></div></div><h2 id="decode"><a href="#decode" class="anchor"></a>Decode</h2><div class="odoc-spec"><div class="spec type" id="type-error" class="anchored"><a href="#type-error" class="anchor"></a><code><span><span class="keyword">type</span> error</span><span> = </span><span>[ </span></code><table><tr id="type-error.Illegal_BOM" class="anchored"><td class="def constructor"><a href="#type-error.Illegal_BOM" class="anchor"></a><code><span>| </span></code><code><span>`Illegal_BOM</span></code></td></tr><tr id="type-error.Illegal_escape" class="anchored"><td class="def constructor"><a href="#type-error.Illegal_escape" class="anchor"></a><code><span>| </span></code><code><span>`Illegal_escape <span class="keyword">of</span> <span>[ <span>`Not_hex_uchar of <a href="../../ocaml/Stdlib/Uchar/index.html#type-t">Uchar.t</a></span> <span><span>| `Not_esc_uchar</span> of <a href="../../ocaml/Stdlib/Uchar/index.html#type-t">Uchar.t</a></span> <span><span>| `Not_lo_surrogate</span> of int</span> <span><span>| `Lone_lo_surrogate</span> of int</span> <span><span>| `Lone_hi_surrogate</span> of int</span> ]</span></span></code></td></tr><tr id="type-error.Illegal_string_uchar" class="anchored"><td class="def constructor"><a href="#type-error.Illegal_string_uchar" class="anchor"></a><code><span>| </span></code><code><span>`Illegal_string_uchar <span class="keyword">of</span> <a href="../../ocaml/Stdlib/Uchar/index.html#type-t">Uchar.t</a></span></code></td></tr><tr id="type-error.Illegal_bytes" class="anchored"><td class="def constructor"><a href="#type-error.Illegal_bytes" class="anchor"></a><code><span>| </span></code><code><span>`Illegal_bytes <span class="keyword">of</span> string</span></code></td></tr><tr id="type-error.Illegal_literal" class="anchored"><td class="def constructor"><a href="#type-error.Illegal_literal" class="anchor"></a><code><span>| </span></code><code><span>`Illegal_literal <span class="keyword">of</span> string</span></code></td></tr><tr id="type-error.Illegal_number" class="anchored"><td class="def constructor"><a href="#type-error.Illegal_number" class="anchor"></a><code><span>| </span></code><code><span>`Illegal_number <span class="keyword">of</span> string</span></code></td></tr><tr id="type-error.Unclosed" class="anchored"><td class="def constructor"><a href="#type-error.Unclosed" class="anchor"></a><code><span>| </span></code><code><span>`Unclosed <span class="keyword">of</span> <span>[ `As <span>| `Os</span> <span>| `String</span> <span>| `Comment</span> ]</span></span></code></td></tr><tr id="type-error.Expected" class="anchored"><td class="def constructor"><a href="#type-error.Expected" class="anchor"></a><code><span>| </span></code><code><span>`Expected <span class="keyword">of</span> <span>[ `Comment <span>| `Value</span> <span>| `Name</span> <span>| `Name_sep</span> <span>| `Json</span> <span>| `Eoi</span> <span><span>| `Aval</span> of bool</span> <span><span>| `Omem</span> of bool</span> ]</span></span></code></td></tr></table><code><span> ]</span></code></div></div><p>The type for decoding errors.</p><div class="odoc-spec"><div class="spec value" id="val-pp_error" class="anchored"><a href="#val-pp_error" class="anchor"></a><code><span><span class="keyword">val</span> pp_error : <span><a href="../../ocaml/Stdlib/Format/index.html#type-formatter">Format.formatter</a> <span class="arrow">&#45;&gt;</span></span> <span><span>[&lt; <a href="#type-error">error</a> ]</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>pp_error e</code> prints an unspecified UTF-8 representation of <code>e</code> on <code>ppf</code>.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-encoding" class="anchored"><a href="#type-encoding" class="anchor"></a><code><span><span class="keyword">type</span> encoding</span><span> = </span><span>[ </span></code><table><tr id="type-encoding.UTF_8" class="anchored"><td class="def constructor"><a href="#type-encoding.UTF_8" class="anchor"></a><code><span>| </span></code><code><span>`UTF_8</span></code></td></tr><tr id="type-encoding.UTF_16" class="anchored"><td class="def constructor"><a href="#type-encoding.UTF_16" class="anchor"></a><code><span>| </span></code><code><span>`UTF_16</span></code></td></tr><tr id="type-encoding.UTF_16BE" class="anchored"><td class="def constructor"><a href="#type-encoding.UTF_16BE" class="anchor"></a><code><span>| </span></code><code><span>`UTF_16BE</span></code></td></tr><tr id="type-encoding.UTF_16LE" class="anchored"><td class="def constructor"><a href="#type-encoding.UTF_16LE" class="anchor"></a><code><span>| </span></code><code><span>`UTF_16LE</span></code></td></tr></table><code><span> ]</span></code></div><div class="spec-doc"><p>The type for Unicode encoding schemes.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-src" class="anchored"><a href="#type-src" class="anchor"></a><code><span><span class="keyword">type</span> src</span><span> = </span><span>[ </span></code><table><tr id="type-src.Channel" class="anchored"><td class="def constructor"><a href="#type-src.Channel" class="anchor"></a><code><span>| </span></code><code><span>`Channel <span class="keyword">of</span> <a href="../../ocaml/Stdlib/index.html#type-in_channel">in_channel</a></span></code></td></tr><tr id="type-src.String" class="anchored"><td class="def constructor"><a href="#type-src.String" class="anchor"></a><code><span>| </span></code><code><span>`String <span class="keyword">of</span> string</span></code></td></tr><tr id="type-src.Manual" class="anchored"><td class="def constructor"><a href="#type-src.Manual" class="anchor"></a><code><span>| </span></code><code><span>`Manual</span></code></td></tr></table><code><span> ]</span></code></div><div class="spec-doc"><p>The type for input sources. With a <code>`Manual</code> source the client must provide input with <a href="Manual/index.html#val-src"><code>Manual.src</code></a>.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-decoder" class="anchored"><a href="#type-decoder" class="anchor"></a><code><span><span class="keyword">type</span> decoder</span></code></div><div class="spec-doc"><p>The type for JSON decoders.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-decoder" class="anchored"><a href="#val-decoder" class="anchor"></a><code><span><span class="keyword">val</span> decoder : <span>?encoding:<span>[&lt; <a href="#type-encoding">encoding</a> ]</span> <span class="arrow">&#45;&gt;</span></span> <span><span>[&lt; <a href="#type-src">src</a> ]</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-decoder">decoder</a></span></code></div><div class="spec-doc"><p><code>decoder encoding src</code> is a JSON decoder that inputs from <code>src</code>. <code>encoding</code> specifies the character encoding of the data. If unspecified the encoding is guessed as <a href="http://tools.ietf.org/html/rfc4627#section-3">suggested</a> by the old RFC4627 standard.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-decode" class="anchored"><a href="#val-decode" class="anchor"></a><code><span><span class="keyword">val</span> decode : <span><a href="#type-decoder">decoder</a> <span class="arrow">&#45;&gt;</span></span> <span>[&gt; `Await <span><span>| `Lexeme</span> of <a href="#type-lexeme">lexeme</a></span> <span>| `End</span> <span><span>| `Error</span> of <a href="#type-error">error</a></span> ]</span></span></code></div><div class="spec-doc"><p><code>decode d</code> is:</p><ul><li><code>`Await</code> if <code>d</code> has a <code>`Manual</code> source and awaits for more input. The client must use <a href="Manual/index.html#val-src"><code>Manual.src</code></a> to provide it.</li><li><code>`Lexeme l</code> if a lexeme <code>l</code> was decoded.</li><li><code>`End</code> if the end of input was reached.</li><li><code>`Error e</code> if a decoding error occured. If the client is interested in a best-effort decoding it can still continue to decode after an error (see <a href="#errorrecovery">Error recovery</a>) although the resulting sequence of <code>`Lexeme</code>s is undefined and may not be well-formed.</li></ul><p>The <a href="Uncut/index.html#val-pp_decode"><code>Uncut.pp_decode</code></a> function can be used to inspect decode results.</p><p><b>Note.</b> Repeated invocation always eventually returns <code>`End</code>, even in case of errors.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-decoded_range" class="anchored"><a href="#val-decoded_range" class="anchor"></a><code><span><span class="keyword">val</span> decoded_range : <span><a href="#type-decoder">decoder</a> <span class="arrow">&#45;&gt;</span></span> <span>(int * int)</span> * <span>(int * int)</span></span></code></div><div class="spec-doc"><p><code>decoded_range d</code> is the range of characters spanning the last <code>`Lexeme</code> or <code>`Error</code> (or <code>`White</code> or <code>`Comment</code> for an <a href="Uncut/index.html#decode"><code>decode</code></a>) decoded by <code>d</code>. A pair of line and column numbers respectively one and zero based.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-decoder_encoding" class="anchored"><a href="#val-decoder_encoding" class="anchor"></a><code><span><span class="keyword">val</span> decoder_encoding : <span><a href="#type-decoder">decoder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-encoding">encoding</a></span></code></div><div class="spec-doc"><p><code>decoder_encoding d</code> is <code>d</code>'s encoding.</p><p><b>Warning.</b> If the decoder guesses the encoding, rely on this value only after the first <code>`Lexeme</code> was decoded.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-decoder_src" class="anchored"><a href="#val-decoder_src" class="anchor"></a><code><span><span class="keyword">val</span> decoder_src : <span><a href="#type-decoder">decoder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-src">src</a></span></code></div><div class="spec-doc"><p><code>decoder_src d</code> is <code>d</code>'s input source.</p></div></div><h2 id="encode"><a href="#encode" class="anchor"></a>Encode</h2><div class="odoc-spec"><div class="spec type" id="type-dst" class="anchored"><a href="#type-dst" class="anchor"></a><code><span><span class="keyword">type</span> dst</span><span> = </span><span>[ </span></code><table><tr id="type-dst.Channel" class="anchored"><td class="def constructor"><a href="#type-dst.Channel" class="anchor"></a><code><span>| </span></code><code><span>`Channel <span class="keyword">of</span> <a href="../../ocaml/Stdlib/index.html#type-out_channel">out_channel</a></span></code></td></tr><tr id="type-dst.Buffer" class="anchored"><td class="def constructor"><a href="#type-dst.Buffer" class="anchor"></a><code><span>| </span></code><code><span>`Buffer <span class="keyword">of</span> <a href="../../ocaml/Stdlib/Buffer/index.html#type-t">Buffer.t</a></span></code></td></tr><tr id="type-dst.Manual" class="anchored"><td class="def constructor"><a href="#type-dst.Manual" class="anchor"></a><code><span>| </span></code><code><span>`Manual</span></code></td></tr></table><code><span> ]</span></code></div><div class="spec-doc"><p>The type for output destinations. With a <code>`Manual</code> destination the client must provide output storage with <a href="Manual/index.html#val-dst"><code>Manual.dst</code></a>.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-encoder" class="anchored"><a href="#type-encoder" class="anchor"></a><code><span><span class="keyword">type</span> encoder</span></code></div><div class="spec-doc"><p>The type for JSON encoders.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-encoder" class="anchored"><a href="#val-encoder" class="anchor"></a><code><span><span class="keyword">val</span> encoder : <span>?minify:bool <span class="arrow">&#45;&gt;</span></span> <span><span>[&lt; <a href="#type-dst">dst</a> ]</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-encoder">encoder</a></span></code></div><div class="spec-doc"><p><code>encoder minify dst</code> is an encoder that outputs to <code>dst</code>. If <code>minify</code> is <code>true</code> (default) the output is made as compact as possible, otherwise the output is indented. If you want better control on whitespace use <code>minify = true</code> and <a href="Uncut/index.html#encode"><code>encode</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-encode" class="anchored"><a href="#val-encode" class="anchor"></a><code><span><span class="keyword">val</span> encode : <span><a href="#type-encoder">encoder</a> <span class="arrow">&#45;&gt;</span></span> <span><span>[&lt; `Await <span>| `End</span> <span><span>| `Lexeme</span> of <a href="#type-lexeme">lexeme</a></span> ]</span> <span class="arrow">&#45;&gt;</span></span> <span>[ `Ok <span>| `Partial</span> ]</span></span></code></div><div class="spec-doc"><p><code>encode e v</code> is:</p><ul><li><code>`Partial</code> iff <code>e</code> has a <code>`Manual</code> destination and needs more output storage. The client must use <a href="Manual/index.html#val-dst"><code>Manual.dst</code></a> to provide a new buffer and then call <a href="#encode">Encode</a> with <code>`Await</code> until <code>`Ok</code> is returned.</li><li><code>`Ok</code> when the encoder is ready to encode a new <code>`Lexeme</code> or <code>`End</code>.</li></ul><p>For <code>`Manual</code> destinations, encoding <code>`End</code> always returns <code>`Partial</code>, the client should as usual use <a href="Manual/index.html#val-dst"><code>Manual.dst</code></a> and continue with <code>`Await</code> until <code>`Ok</code> is returned at which point <a href="Manual/index.html#val-dst_rem"><code>Manual.dst_rem</code></a> <code>e</code> is guaranteed to be the size of the last provided buffer (i.e. nothing was written).</p><p><b>Raises.</b> <code>Invalid_argument</code> if a non <a href="#datamodel">well-formed</a> sequence of lexemes is encoded or if <code>`Lexeme</code> or <code>`End</code> is encoded after a <code>`Partial</code> encode.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-encoder_dst" class="anchored"><a href="#val-encoder_dst" class="anchor"></a><code><span><span class="keyword">val</span> encoder_dst : <span><a href="#type-encoder">encoder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-dst">dst</a></span></code></div><div class="spec-doc"><p><code>encoder_dst e</code> is <code>e</code>'s output destination.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-encoder_minify" class="anchored"><a href="#val-encoder_minify" class="anchor"></a><code><span><span class="keyword">val</span> encoder_minify : <span><a href="#type-encoder">encoder</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>encoder_minify e</code> is <code>true</code> if <code>e</code>'s output is minified.</p></div></div><h2 id="manual"><a href="#manual" class="anchor"></a>Manual sources and destinations</h2><div class="odoc-spec"><div class="spec module" id="module-Manual" class="anchored"><a href="#module-Manual" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Manual/index.html">Manual</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Manual input sources and output destinations.</p></div></div><h2 id="uncut"><a href="#uncut" class="anchor"></a>Uncut codec</h2><div class="odoc-spec"><div class="spec module" id="module-Uncut" class="anchored"><a href="#module-Uncut" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Uncut/index.html">Uncut</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Codec with comments and whitespace.</p></div></div><h2 id="limitations"><a href="#limitations" class="anchor"></a>Limitations</h2><h3 id="decode_3"><a href="#decode_3" class="anchor"></a>Decode</h3><p>Decoders parse valid JSON with the following limitations:</p><ul><li>JSON numbers are represented with OCaml <code>float</code> values. This means that it can only represent integers exactly in the in the interval [-2<sup>53</sup>;2<sup>53</sup>]. This is equivalent to the contraints JavaScript has.</li><li>A superset of JSON numbers is parsed. After having seen a minus or a digit, including zero, <code>Pervasives</code>.float_of_string, is used. In particular this parses number with leading zeros, which are specifically prohibited by the standard.</li><li>Strings returned by <code>`String</code>, <code>`Name</code>, <code>`White</code> and <code>`Comment</code> are limited by <code>Sys</code>.max_string_length. There is no built-in protection against the fact that the internal OCaml <code>Buffer.t</code> value may raise <code>Failure</code> on <a href="#decode"><code>decode</code></a>. This should however only be a problem on 32-bits platforms if your strings are greater than 16Mo.</li></ul><p>Position tracking assumes that each decoded Unicode scalar value has a column width of 1. The same assumption may not be made by the display program (e.g. for <code>emacs</code>' compilation mode you need to set <code>compilation-error-screen-columns</code> to <code>nil</code>).</p><p>The newlines LF (<code>U+000A</code>), CR (<code>U+000D</code>), and CRLF are all normalized to LF internally. This may have an impact in some corner <code>`Error</code> cases. For example the invalid escape sequence <code>&lt;U+005C,U+000D&gt;</code> in a string will be reported as being <code>`Illegal_escape (`Not_esc_uchar
    0x000A)</code>.</p><h3 id="encode_3"><a href="#encode_3" class="anchor"></a>Encode</h3><p>Encoders produce valid JSON provided the <em>client</em> ensures that the following holds.</p><ul><li>All the strings given to the encoder must be valid UTF-8 and immutable. Characters that need to be escaped are automatically escaped by <code>Jsonm</code>.</li><li><code>`Float</code> lexemes must not be, <code>Pervasives</code>.nan, <code>Pervasives</code>.infinity or <code>Pervasives</code>.neg_infinity. They are encoded with the format string <code>&quot;%.16g&quot;</code>, this allows to roundtrip all the integers that can be precisely represented in OCaml <code>float</code> values, i.e. the integers in the interval [-2<sup>53</sup>;2<sup>53</sup>]. This is equivalent to the constraints JavaScript has.</li><li>If the <a href="Uncut/index.html">uncut</a> codec is used <code>`White</code> must be made of <span class="xref-unresolved">JSON whitespace</span> and <code>`Comment</code> must never be encoded.</li></ul><h2 id="errorrecovery"><a href="#errorrecovery" class="anchor"></a>Error recovery</h2><p>After a decoding error, if best-effort decoding is performed. The following happens before continuing:</p><ul><li><code>`Illegal_BOM</code>, the initial <a href="http://unicode.org/glossary/#byte_order_mark">BOM</a> is skipped.</li><li><code>`Illegal_bytes</code>, <code>`Illegal_escape</code>, <code>`Illegal_string_uchar</code>, a Unicode <a href="http://unicode.org/glossary/#replacement_character">replacement character</a> (<code>U+FFFD</code>) is substituted to the illegal sequence.</li><li><code>`Illegal_literal</code>, <code>`Illegal_number</code> the corresponding <code>`Lexeme</code> is skipped.</li><li><code>`Expected r</code>, input is discarded until a synchronyzing lexeme that depends on <code>r</code> is found.</li><li><code>`Unclosed</code>, the end of input is reached, further decodes will be <code>`End</code></li></ul><h2 id="examples"><a href="#examples" class="anchor"></a>Examples</h2><h3 id="filter"><a href="#filter" class="anchor"></a>Trip</h3><p>The result of <code>trip src dst</code> has the JSON from <code>src</code> written on <code>dst</code>.</p><pre><code>let trip ?encoding ?minify
    (src : [`Channel of in_channel | `String of string])
    (dst : [`Channel of out_channel | `Buffer of Buffer.t])
  =
  let rec loop d e = match Jsonm.decode d with
  | `Lexeme _ as v -&gt; ignore (Jsonm.encode e v); loop d e
  | `End -&gt; ignore (Jsonm.encode e `End); `Ok
  | `Error err -&gt; `Error (Jsonm.decoded_range d, err)
  | `Await -&gt; assert false
  in
  let d = Jsonm.decoder ?encoding src in
  let e = Jsonm.encoder ?minify dst in
  loop d e</code></pre><p>Using the <code>`Manual</code> interface, <code>trip_fd</code> does the same but between Unix file descriptors.</p><pre><code>let trip_fd ?encoding ?minify
    (fdi : Unix.file_descr)
    (fdo : Unix.file_descr)
  =
  let rec encode fd s e v = match Jsonm.encode e v with `Ok -&gt; ()
  | `Partial -&gt;
      let rec unix_write fd s j l =
        let rec write fd s j l = try Unix.single_write fd s j l with
        | Unix.Unix_error (Unix.EINTR, _, _) -&gt; write fd s j l
        in
        let wc = write fd s j l in
        if wc &lt; l then unix_write fd s (j + wc) (l - wc) else ()
      in
      unix_write fd s 0 (Bytes.length s - Jsonm.Manual.dst_rem e);
      Jsonm.Manual.dst e s 0 (String.length s);
      encode fd s e `Await
  in
  let rec loop fdi fdo ds es d e = match Jsonm.decode d with
  | `Lexeme _ as v -&gt; encode fdo es e v; loop fdi fdo ds es d e
  | `End -&gt; encode fdo es e `End; `Ok
  | `Error err -&gt; `Error (Jsonm.decoded_range d, err)
  | `Await -&gt;
      let rec unix_read fd s j l = try Unix.read fd s j l with
      | Unix.Unix_error (Unix.EINTR, _, _) -&gt; unix_read fd s j l
      in
      let rc = unix_read fdi ds 0 (Bytes.length ds) in
      Jsonm.Manual.src d ds 0 rc; loop fdi fdo ds es d e
  in
  let ds = Bytes.create 65536 (* UNIX_BUFFER_SIZE in 4.0.0 *) in
  let es = Bytes.create 65536 (* UNIX_BUFFER_SIZE in 4.0.0 *) in
  let d = Jsonm.decoder ?encoding `Manual in
  let e = Jsonm.encoder ?minify `Manual in
  Jsonm.Manual.dst e es 0 (Bytes.length es);
  loop fdi fdo ds es d e</code></pre><h3 id="memsel"><a href="#memsel" class="anchor"></a>Member selection</h3><p>The result of <code>memsel names src</code> is the list of string values of members of <code>src</code> that have their name in <code>names</code>. In this example, decoding errors are silently ignored.</p><pre><code>let memsel ?encoding names
    (src : [`Channel of in_channel | `String of string])
  =
  let rec loop acc names d = match Jsonm.decode d with
  | `Lexeme (`Name n) when List.mem n names -&gt;
      begin match Jsonm.decode d with
      | `Lexeme (`String s) -&gt; loop (s :: acc) names d
      | _ -&gt; loop acc names d
      end
  | `Lexeme _ | `Error _ -&gt; loop acc names d
  | `End -&gt; List.rev acc
  | `Await -&gt; assert false
  in
  loop [] names (Jsonm.decoder ?encoding src)</code></pre><h3 id="tree"><a href="#tree" class="anchor"></a>Generic JSON representation</h3><p>A generic OCaml representation of JSON text is the following one.</p><pre><code>type json =
  [ `Null | `Bool of bool | `Float of float| `String of string
  | `A of json list | `O of (string * json) list ]</code></pre><p>The result of <code>json_of_src src</code> is the JSON text from <code>src</code> in this representation. The function is tail recursive.</p><pre><code>exception Escape of ((int * int) * (int * int)) * Jsonm.error

let json_of_src ?encoding
    (src : [`Channel of in_channel | `String of string])
  =
  let dec d = match Jsonm.decode d with
  | `Lexeme l -&gt; l
  | `Error e -&gt; raise (Escape (Jsonm.decoded_range d, e))
  | `End | `Await -&gt; assert false
  in
  let rec value v k d = match v with
  | `Os -&gt; obj [] k d  | `As -&gt; arr [] k d
  | `Null | `Bool _ | `String _ | `Float _ as v -&gt; k v d
  | _ -&gt; assert false
  and arr vs k d = match dec d with
  | `Ae -&gt; k (`A (List.rev vs)) d
  | v -&gt; value v (fun v -&gt; arr (v :: vs) k) d
  and obj ms k d = match dec d with
  | `Oe -&gt; k (`O (List.rev ms)) d
  | `Name n -&gt; value (dec d) (fun v -&gt; obj ((n, v) :: ms) k) d
  | _ -&gt; assert false
  in
  let d = Jsonm.decoder ?encoding src in
  try `JSON (value (dec d) (fun v _ -&gt; v) d) with
  | Escape (r, e) -&gt; `Error (r, e)</code></pre><p>The result of <code>json_to_dst dst json</code> has the JSON text <code>json</code> written on <code>dst</code>. The function is tail recursive.</p><pre><code>let json_to_dst ~minify
    (dst : [`Channel of out_channel | `Buffer of Buffer.t ])
    (json : json)
  =
  let enc e l = ignore (Jsonm.encode e (`Lexeme l)) in
  let rec value v k e = match v with
  | `A vs -&gt; arr vs k e
  | `O ms -&gt; obj ms k e
  | `Null | `Bool _ | `Float _ | `String _ as v -&gt; enc e v; k e
  and arr vs k e = enc e `As; arr_vs vs k e
  and arr_vs vs k e = match vs with
  | v :: vs' -&gt; value v (arr_vs vs' k) e
  | [] -&gt; enc e `Ae; k e
  and obj ms k e = enc e `Os; obj_ms ms k e
  and obj_ms ms k e = match ms with
  | (n, v) :: ms -&gt; enc e (`Name n); value v (obj_ms ms k) e
  | [] -&gt; enc e `Oe; k e
  in
  let e = Jsonm.encoder ~minify dst in
  let finish e = ignore (Jsonm.encode e `End) in
  value json finish e</code></pre></div></body></html>