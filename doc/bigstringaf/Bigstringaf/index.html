<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Bigstringaf (bigstringaf.Bigstringaf)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../index.html">bigstringaf</a> &#x00BB; Bigstringaf</nav><header class="odoc-preamble"><h1>Module <code><span>Bigstringaf</span></code></h1><p>Bigstrings, but fast.</p><p>The OCaml compiler has a bunch of intrinsics for Bigstrings, but they're not widely-known, sometimes misused, and so programs that use Bigstrings are slower than they have to be. And even if a library got that part right and exposed the intrinsics properly, the compiler doesn't have any fast blits between Bigstrings and other string-like types.</p><p>So here they are. Go crazy.</p></header><nav class="odoc-toc"><ul><li><a href="#constructors">Constructors</a></li><li><a href="#memory-safe-operations">Memory-safe Operations</a><ul><li><a href="#little-endian-byte-order">Little-endian Byte Order</a></li><li><a href="#big-endian-byte-order">Big-endian Byte Order</a></li><li><a href="#blits">Blits</a></li><li><a href="#memcmp"><code>memcmp</code></a></li></ul></li><li><a href="#memory-unsafe-operations">Memory-unsafe Operations</a><ul><li><a href="#blits_2">Blits</a></li><li><a href="#memcmp_2"><code>memcmp</code></a></li></ul></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span><span> = <span><span>(char, <a href="../../bigarray-compat/Bigarray_compat/index.html#type-int8_unsigned_elt">Bigarray_compat.int8_unsigned_elt</a>, <a href="../../bigarray-compat/Bigarray_compat/index.html#type-c_layout">Bigarray_compat.c_layout</a>)</span> <a href="../../bigarray-compat/Bigarray_compat/Array1/index.html#type-t">Bigarray_compat.Array1.t</a></span></span></code></div></div><h3 id="constructors"><a href="#constructors" class="anchor"></a>Constructors</h3><div class="odoc-spec"><div class="spec value" id="val-create" class="anchored"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>create n</code> returns a bigstring of length <code>n</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-empty" class="anchored"><a href="#val-empty" class="anchor"></a><code><span><span class="keyword">val</span> empty : <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>empty</code> is the empty bigstring. It has length <code>0</code> and you can't really do much with it, but it's a good placeholder that only needs to be allocated once.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_string" class="anchored"><a href="#val-of_string" class="anchor"></a><code><span><span class="keyword">val</span> of_string : <span>off:int <span class="arrow">&#45;&gt;</span></span> <span>len:int <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_string ~off ~len s</code> returns a bigstring of length <code>len</code> that contains the contents of string from the range <code>[off, len)</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-copy" class="anchored"><a href="#val-copy" class="anchor"></a><code><span><span class="keyword">val</span> copy : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>off:int <span class="arrow">&#45;&gt;</span></span> <span>len:int <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>copy t ~off ~len</code> allocates a new bigstring of length <code>len</code> and copies the bytes from <code>t</code> copied into it starting from <code>off</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sub" class="anchored"><a href="#val-sub" class="anchor"></a><code><span><span class="keyword">val</span> sub : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>off:int <span class="arrow">&#45;&gt;</span></span> <span>len:int <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>sub t ~off ~len</code> does not allocate a bigstring, but instead returns a new view into <code>t</code> starting at <code>off</code>, and with length <code>len</code>.</p><p><b>Note</b> that this does not allocate a new buffer, but instead shares the buffer of <code>t</code> with the newly-returned bigstring.</p></div></div><h3 id="memory-safe-operations"><a href="#memory-safe-operations" class="anchor"></a>Memory-safe Operations</h3><div class="odoc-spec"><div class="spec value" id="val-length" class="anchored"><a href="#val-length" class="anchor"></a><code><span><span class="keyword">val</span> length : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>length t</code> is the length of the bigstring, in bytes.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-substring" class="anchored"><a href="#val-substring" class="anchor"></a><code><span><span class="keyword">val</span> substring : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>off:int <span class="arrow">&#45;&gt;</span></span> <span>len:int <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>substring t ~off ~len</code> returns a string of length <code>len</code> containing the bytes of <code>t</code> starting at <code>off</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_string" class="anchored"><a href="#val-to_string" class="anchor"></a><code><span><span class="keyword">val</span> to_string : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>to_string t</code> is equivalent to <code>substring t ~off:0 ~len:(length t)</code></p></div></div><div class="odoc-spec"><div class="spec value external" id="val-get" class="anchored"><a href="#val-get" class="anchor"></a><code><span><span class="keyword">val</span> get : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> char</span></code></div><div class="spec-doc"><p><code>get t i</code> returns the character at offset <code>i</code> in <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value external" id="val-set" class="anchored"><a href="#val-set" class="anchor"></a><code><span><span class="keyword">val</span> set : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set t i c</code> sets the character at offset <code>i</code> in <code>t</code> to be <code>c</code></p></div></div><h4 id="little-endian-byte-order"><a href="#little-endian-byte-order" class="anchor"></a>Little-endian Byte Order</h4><p>The following operations assume a little-endian byte ordering of the bigstring. If the machine-native byte ordering differs, then the get operations will reorder the bytes so that they are in machine-native byte order before returning the result, and the set operations will reorder the bytes so that they are written out in the appropriate order.</p><p>Most modern processor architectures are little-endian, so more likely than not, these operations will not do any byte reordering.</p><div class="odoc-spec"><div class="spec value" id="val-get_int16_le" class="anchored"><a href="#val-get_int16_le" class="anchor"></a><code><span><span class="keyword">val</span> get_int16_le : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>get_int16_le t i</code> returns the two bytes in <code>t</code> starting at offset <code>i</code>, interpreted as an unsigned integer.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_int16_sign_extended_le" class="anchored"><a href="#val-get_int16_sign_extended_le" class="anchor"></a><code><span><span class="keyword">val</span> get_int16_sign_extended_le : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>get_int16_sign_extended_le t i</code> returns the two bytes in <code>t</code> starting at offset <code>i</code>, interpreted as a signed integer and performing sign extension to the native word size before returning the result.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_int16_le" class="anchored"><a href="#val-set_int16_le" class="anchor"></a><code><span><span class="keyword">val</span> set_int16_le : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_int16_le t i v</code> sets the two bytes in <code>t</code> starting at offset <code>i</code> to the value <code>v</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_int32_le" class="anchored"><a href="#val-get_int32_le" class="anchor"></a><code><span><span class="keyword">val</span> get_int32_le : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int32</span></code></div><div class="spec-doc"><p><code>get_int32_le t i</code> returns the four bytes in <code>t</code> starting at offset <code>i</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_int32_le" class="anchored"><a href="#val-set_int32_le" class="anchor"></a><code><span><span class="keyword">val</span> set_int32_le : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int32 <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_int32_le t i v</code> sets the four bytes in <code>t</code> starting at offset <code>i</code> to the value <code>v</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_int64_le" class="anchored"><a href="#val-get_int64_le" class="anchor"></a><code><span><span class="keyword">val</span> get_int64_le : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int64</span></code></div><div class="spec-doc"><p><code>get_int64_le t i</code> returns the eight bytes in <code>t</code> starting at offset <code>i</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_int64_le" class="anchored"><a href="#val-set_int64_le" class="anchor"></a><code><span><span class="keyword">val</span> set_int64_le : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int64 <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_int64_le t i v</code> sets the eight bytes in <code>t</code> starting at offset <code>i</code> to the value <code>v</code>.</p></div></div><h4 id="big-endian-byte-order"><a href="#big-endian-byte-order" class="anchor"></a>Big-endian Byte Order</h4><p>The following operations assume a big-endian byte ordering of the bigstring. If the machine-native byte ordering differs, then the get operations will reorder the bytes so that they are in machine-native byte order before returning the result, and the set operations will reorder the bytes so that they are written out in the appropriate order.</p><p>Network byte order is big-endian, so you may need these operations when dealing with raw frames, for example, in a userland networking stack.</p><div class="odoc-spec"><div class="spec value" id="val-get_int16_be" class="anchored"><a href="#val-get_int16_be" class="anchor"></a><code><span><span class="keyword">val</span> get_int16_be : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>get_int16_be t i</code> returns the two bytes in <code>t</code> starting at offset <code>i</code>, interpreted as an unsigned integer.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_int16_sign_extended_be" class="anchored"><a href="#val-get_int16_sign_extended_be" class="anchor"></a><code><span><span class="keyword">val</span> get_int16_sign_extended_be : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>get_int16_sign_extended_be t i</code> returns the two bytes in <code>t</code> starting at offset <code>i</code>, interpreted as a signed integer and performing sign extension to the native word size before returning the result.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_int16_be" class="anchored"><a href="#val-set_int16_be" class="anchor"></a><code><span><span class="keyword">val</span> set_int16_be : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_int16_be t i v</code> sets the two bytes in <code>t</code> starting at offset <code>off</code> to the value <code>v</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_int32_be" class="anchored"><a href="#val-get_int32_be" class="anchor"></a><code><span><span class="keyword">val</span> get_int32_be : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int32</span></code></div><div class="spec-doc"><p><code>get_int32_be t i</code> returns the four bytes in <code>t</code> starting at offset <code>i</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_int32_be" class="anchored"><a href="#val-set_int32_be" class="anchor"></a><code><span><span class="keyword">val</span> set_int32_be : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int32 <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_int32_be t i v</code> sets the four bytes in <code>t</code> starting at offset <code>i</code> to the value <code>v</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_int64_be" class="anchored"><a href="#val-get_int64_be" class="anchor"></a><code><span><span class="keyword">val</span> get_int64_be : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int64</span></code></div><div class="spec-doc"><p><code>get_int64_be t i</code> returns the eight bytes in <code>t</code> starting at offset <code>i</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_int64_be" class="anchored"><a href="#val-set_int64_be" class="anchor"></a><code><span><span class="keyword">val</span> set_int64_be : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int64 <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_int64_be t i v</code> sets the eight bytes in <code>t</code> starting at offset <code>i</code> to the value <code>v</code>.</p></div></div><h4 id="blits"><a href="#blits" class="anchor"></a>Blits</h4><p>All the following blit operations do the same thing. They copy a given number of bytes from a source starting at some offset to a destination starting at some other offset. Forgetting for a moment that OCaml is a memory-safe language, these are all equivalent to:</p><pre><code>memcpy(dst + dst_off, src + src_off, len);</code></pre><p>And in fact, that's how they're implemented. Except that bounds checking is performed before performing the blit.</p><div class="odoc-spec"><div class="spec value" id="val-blit" class="anchored"><a href="#val-blit" class="anchor"></a><code><span><span class="keyword">val</span> blit : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>src_off:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>dst_off:int <span class="arrow">&#45;&gt;</span></span> <span>len:int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-blit_from_string" class="anchored"><a href="#val-blit_from_string" class="anchor"></a><code><span><span class="keyword">val</span> blit_from_string : <span>string <span class="arrow">&#45;&gt;</span></span> <span>src_off:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>dst_off:int <span class="arrow">&#45;&gt;</span></span> <span>len:int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-blit_from_bytes" class="anchored"><a href="#val-blit_from_bytes" class="anchor"></a><code><span><span class="keyword">val</span> blit_from_bytes : <span><a href="../../ocaml/Stdlib/Bytes/index.html#type-t">Bytes.t</a> <span class="arrow">&#45;&gt;</span></span> <span>src_off:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>dst_off:int <span class="arrow">&#45;&gt;</span></span> <span>len:int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-blit_to_bytes" class="anchored"><a href="#val-blit_to_bytes" class="anchor"></a><code><span><span class="keyword">val</span> blit_to_bytes : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>src_off:int <span class="arrow">&#45;&gt;</span></span> <span><a href="../../ocaml/Stdlib/Bytes/index.html#type-t">Bytes.t</a> <span class="arrow">&#45;&gt;</span></span> <span>dst_off:int <span class="arrow">&#45;&gt;</span></span> <span>len:int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><h4 id="memcmp"><a href="#memcmp" class="anchor"></a><code>memcmp</code></h4><p>Fast comparisons based on <code>memcmp</code>. Similar to the blits, these are implemented as C calls after performing bounds checks.</p><pre><code>memcmp(buf1 + off1, buf2 + off2, len);</code></pre><div class="odoc-spec"><div class="spec value" id="val-memcmp" class="anchored"><a href="#val-memcmp" class="anchor"></a><code><span><span class="keyword">val</span> memcmp : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-memcmp_string" class="anchored"><a href="#val-memcmp_string" class="anchor"></a><code><span><span class="keyword">val</span> memcmp_string : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><h3 id="memory-unsafe-operations"><a href="#memory-unsafe-operations" class="anchor"></a>Memory-unsafe Operations</h3><p>The following operations are not memory safe. However, they do compile down to just a couple instructions. Make sure when using them to perform your own bounds checking. Or don't. Just make sure you know what you're doing. You can do it, but only do it if you have to.</p><div class="odoc-spec"><div class="spec value external" id="val-unsafe_get" class="anchored"><a href="#val-unsafe_get" class="anchor"></a><code><span><span class="keyword">val</span> unsafe_get : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> char</span></code></div><div class="spec-doc"><p><code>unsafe_get t i</code> is like <a href="#val-get"><code>get</code></a> except no bounds checking is performed.</p></div></div><div class="odoc-spec"><div class="spec value external" id="val-unsafe_set" class="anchored"><a href="#val-unsafe_set" class="anchor"></a><code><span><span class="keyword">val</span> unsafe_set : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>unsafe_set t i c</code> is like <a href="#val-set"><code>set</code></a> except no bounds checking is performed.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unsafe_get_int16_le" class="anchored"><a href="#val-unsafe_get_int16_le" class="anchor"></a><code><span><span class="keyword">val</span> unsafe_get_int16_le : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>unsafe_get_int16_le t i</code> is like <a href="#val-get_int16_le"><code>get_int16_le</code></a> except no bounds checking is performed.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unsafe_get_int16_be" class="anchored"><a href="#val-unsafe_get_int16_be" class="anchor"></a><code><span><span class="keyword">val</span> unsafe_get_int16_be : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>unsafe_get_int16_be t i</code> is like <a href="#val-get_int16_be"><code>get_int16_be</code></a> except no bounds checking is performed.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unsafe_get_int16_sign_extended_le" class="anchored"><a href="#val-unsafe_get_int16_sign_extended_le" class="anchor"></a><code><span><span class="keyword">val</span> unsafe_get_int16_sign_extended_le : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>unsafe_get_int16_sign_extended_le t i</code> is like <a href="#val-get_int16_sign_extended_le"><code>get_int16_sign_extended_le</code></a> except no bounds checking is performed.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unsafe_get_int16_sign_extended_be" class="anchored"><a href="#val-unsafe_get_int16_sign_extended_be" class="anchor"></a><code><span><span class="keyword">val</span> unsafe_get_int16_sign_extended_be : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>unsafe_get_int16_sign_extended_be t i</code> is like <a href="#val-get_int16_sign_extended_be"><code>get_int16_sign_extended_be</code></a> except no bounds checking is performed.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unsafe_set_int16_le" class="anchored"><a href="#val-unsafe_set_int16_le" class="anchor"></a><code><span><span class="keyword">val</span> unsafe_set_int16_le : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>unsafe_set_int16_le t i v</code> is like <a href="#val-set_int16_le"><code>set_int16_le</code></a> except no bounds checking is performed.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unsafe_set_int16_be" class="anchored"><a href="#val-unsafe_set_int16_be" class="anchor"></a><code><span><span class="keyword">val</span> unsafe_set_int16_be : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>unsafe_set_int16_be t i v</code> is like <a href="#val-set_int16_be"><code>set_int16_be</code></a> except no bounds checking is performed.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unsafe_get_int32_le" class="anchored"><a href="#val-unsafe_get_int32_le" class="anchor"></a><code><span><span class="keyword">val</span> unsafe_get_int32_le : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int32</span></code></div><div class="spec-doc"><p><code>unsafe_get_int32_le t i</code> is like <a href="#val-get_int32_le"><code>get_int32_le</code></a> except no bounds checking is performed.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unsafe_get_int32_be" class="anchored"><a href="#val-unsafe_get_int32_be" class="anchor"></a><code><span><span class="keyword">val</span> unsafe_get_int32_be : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int32</span></code></div><div class="spec-doc"><p><code>unsafe_get_int32_be t i</code> is like <a href="#val-get_int32_be"><code>get_int32_be</code></a> except no bounds checking is performed.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unsafe_set_int32_le" class="anchored"><a href="#val-unsafe_set_int32_le" class="anchor"></a><code><span><span class="keyword">val</span> unsafe_set_int32_le : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int32 <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>unsafe_set_int32_le t i v</code> is like <a href="#val-set_int32_le"><code>set_int32_le</code></a> except no bounds checking is performed.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unsafe_set_int32_be" class="anchored"><a href="#val-unsafe_set_int32_be" class="anchor"></a><code><span><span class="keyword">val</span> unsafe_set_int32_be : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int32 <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>unsafe_set_int32_be t i v</code> is like <a href="#val-set_int32_be"><code>set_int32_be</code></a> except no bounds checking is performed.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unsafe_get_int64_le" class="anchored"><a href="#val-unsafe_get_int64_le" class="anchor"></a><code><span><span class="keyword">val</span> unsafe_get_int64_le : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int64</span></code></div><div class="spec-doc"><p><code>unsafe_get_int64_le t i</code> is like <a href="#val-get_int64_le"><code>get_int64_le</code></a> except no bounds checking is performed.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unsafe_get_int64_be" class="anchored"><a href="#val-unsafe_get_int64_be" class="anchor"></a><code><span><span class="keyword">val</span> unsafe_get_int64_be : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int64</span></code></div><div class="spec-doc"><p><code>unsafe_get_int64_be t i</code> is like <a href="#val-get_int64_be"><code>get_int64_be</code></a> except no bounds checking is performed.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unsafe_set_int64_le" class="anchored"><a href="#val-unsafe_set_int64_le" class="anchor"></a><code><span><span class="keyword">val</span> unsafe_set_int64_le : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int64 <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>unsafe_set_int64_le t i v</code> is like <a href="#val-set_int64_le"><code>set_int64_le</code></a> except no bounds checking is performed.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unsafe_set_int64_be" class="anchored"><a href="#val-unsafe_set_int64_be" class="anchor"></a><code><span><span class="keyword">val</span> unsafe_set_int64_be : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int64 <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>unsafe_set_int64_be t i v</code> is like <a href="#val-set_int64_be"><code>set_int64_be</code></a> except no bounds checking is performed.</p></div></div><h4 id="blits_2"><a href="#blits_2" class="anchor"></a>Blits</h4><p>All the following blit operations do the same thing. They copy a given number of bytes from a source starting at some offset to a destination starting at some other offset. Forgetting for a moment that OCaml is a memory-safe language, these are all equivalent to:</p><pre><code>memcpy(dst + dst_off, src + src_off, len);</code></pre><p>And in fact, that's how they're implemented. Except in the case of <code>unsafe_blit</code> which uses a <code>memmove</code> so that overlapping blits behave as expected. But in both cases, there's no bounds checking.</p><div class="odoc-spec"><div class="spec value" id="val-unsafe_blit" class="anchored"><a href="#val-unsafe_blit" class="anchor"></a><code><span><span class="keyword">val</span> unsafe_blit : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>src_off:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>dst_off:int <span class="arrow">&#45;&gt;</span></span> <span>len:int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-unsafe_blit_from_string" class="anchored"><a href="#val-unsafe_blit_from_string" class="anchor"></a><code><span><span class="keyword">val</span> unsafe_blit_from_string : <span>string <span class="arrow">&#45;&gt;</span></span> <span>src_off:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>dst_off:int <span class="arrow">&#45;&gt;</span></span> <span>len:int <span class="arrow">&#45;&gt;</span></span>
unit</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-unsafe_blit_from_bytes" class="anchored"><a href="#val-unsafe_blit_from_bytes" class="anchor"></a><code><span><span class="keyword">val</span> unsafe_blit_from_bytes : <span><a href="../../ocaml/Stdlib/Bytes/index.html#type-t">Bytes.t</a> <span class="arrow">&#45;&gt;</span></span> <span>src_off:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>dst_off:int <span class="arrow">&#45;&gt;</span></span> <span>len:int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-unsafe_blit_to_bytes" class="anchored"><a href="#val-unsafe_blit_to_bytes" class="anchor"></a><code><span><span class="keyword">val</span> unsafe_blit_to_bytes : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>src_off:int <span class="arrow">&#45;&gt;</span></span> <span><a href="../../ocaml/Stdlib/Bytes/index.html#type-t">Bytes.t</a> <span class="arrow">&#45;&gt;</span></span> <span>dst_off:int <span class="arrow">&#45;&gt;</span></span> <span>len:int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><h4 id="memcmp_2"><a href="#memcmp_2" class="anchor"></a><code>memcmp</code></h4><p>Fast comparisons based on <code>memcmp</code>. Similar to the blits, these are not memory safe and are implemented by the same C call:</p><pre><code>memcmp(buf1 + off1, buf2 + off2, len);</code></pre><div class="odoc-spec"><div class="spec value" id="val-unsafe_memcmp" class="anchored"><a href="#val-unsafe_memcmp" class="anchor"></a><code><span><span class="keyword">val</span> unsafe_memcmp : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-unsafe_memcmp_string" class="anchored"><a href="#val-unsafe_memcmp_string" class="anchor"></a><code><span><span class="keyword">val</span> unsafe_memcmp_string : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div></div></body></html>