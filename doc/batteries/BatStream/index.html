<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>BatStream (batteries.BatStream)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">batteries</a> &#x00BB; BatStream</nav><h1>Module <code>BatStream</code></h1><p>Streams and stream parsers</p><p>Streams are a read-and-forget data structure, comparable to enumerations. In Batteries Included, streams are deprecated in favor of enumerations, defined in module <a href="../BatEnum/index.html"><code>BatEnum</code></a>.</p><p><b>Note</b> This module is provided essentially for backwards-compatibility. If you feel like using <code>Stream.t</code>, please take a look at <code>BatEnum</code> or <code>LazyList</code>.</p><p>This module is based on <a href="http://www.pps.jussieu.fr/~li/software/sdflow/">Zheng Li's SDFlow</a></p><p>This module replaces Stdlib's <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Stream.html">Stream</a> module.</p><dl><dt>author</dt><dd>Zheng Li (SDFlow)</dd></dl><dl><dt>author</dt><dd>David Teller</dd></dl><p>@documents Stream</p><nav class="toc"><ul><li><a href="#stream-builders">Stream builders</a></li><li><a href="#other-stream-builders">Other Stream builders</a></li><li><a href="#stream-iterator">Stream iterator</a></li><li><a href="#predefined-parsers">Predefined parsers</a></li><li><a href="#useful-functions">Useful functions</a></li><li><a href="#conversion-functions">Conversion functions</a></li><li><a href="#stream-consumers">Stream consumers</a></li><li><a href="#computation-over-stream">Computation over stream</a></li><li><a href="#streams-pair-arithmetic">Streams pair arithmetic</a></li><li><a href="#stream-arithmetic">Stream arithmetic</a></li><li><a href="#predefined-parsers">Predefined parsers</a></li></ul></nav></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> 'a t</code><code> = <span class="type-var">'a</span> <a href="../../ocaml/Stdlib/Stream/index.html#type-t">Stdlib.Stream.t</a></code></dt></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../BatEnum/index.html#module-type-Enumerable">BatEnum.Enumerable</a> <span class="keyword">with</span> <span class="keyword">type</span> 'a <a href="../BatEnum/module-type-Enumerable/index.html#type-enumerable">enumerable</a> = <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></span></summary><dl><dt class="spec type" id="type-enumerable"><a href="#type-enumerable" class="anchor"></a><code><span class="keyword">type</span> 'a enumerable</code><code> = <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>The data structure, e.g. <code>'a List.t</code></p></dd></dl><dl><dt class="spec value" id="val-enum"><a href="#val-enum" class="anchor"></a><code><span class="keyword">val</span> enum : <span class="type-var">'a</span> <a href="index.html#type-enumerable">enumerable</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../BatEnum/index.html#type-t">BatEnum.t</a></code></dt><dd><p>Return an enumeration of the elements of the data structure</p></dd></dl><dl><dt class="spec value" id="val-of_enum"><a href="#val-of_enum" class="anchor"></a><code><span class="keyword">val</span> of_enum : <span class="type-var">'a</span> <a href="../BatEnum/index.html#type-t">BatEnum.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-enumerable">enumerable</a></code></dt><dd><p>Build a data structure from an enumeration</p></dd></dl></details></div></div></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../BatInterfaces/index.html#module-type-Mappable">BatInterfaces.Mappable</a> <span class="keyword">with</span> <span class="keyword">type</span> 'a <a href="../BatInterfaces/module-type-Mappable/index.html#type-mappable">mappable</a> = <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></span></summary><dl><dt class="spec type" id="type-mappable"><a href="#type-mappable" class="anchor"></a><code><span class="keyword">type</span> 'a mappable</code><code> = <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>The data structure, e.g. <code>'a List.t</code></p></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-mappable">mappable</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-mappable">mappable</a></code></dt><dd><p><code>map f e</code> applies <code>f</code> to every element of <code>e</code> and returns the corresponding data structure</p></dd></dl></details></div></div></div><aside><p>The type of streams holding values of type <code>'a</code>.</p></aside><dl><dt class="spec exception" id="exception-Failure"><a href="#exception-Failure" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Failure</span></code></dt><dd><p>Raised by parsers when none of the first components of the stream patterns is accepted.</p></dd></dl><dl><dt class="spec exception" id="exception-Error"><a href="#exception-Error" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Error</span> <span class="keyword">of</span> string</code></dt><dd><p>Raised by parsers when the first component of a stream pattern is accepted, but one of the following components is rejected.</p></dd></dl><section><header><h6 id="stream-builders"><a href="#stream-builders" class="anchor"></a>Stream builders</h6></header><dl><dt class="spec value" id="val-from"><a href="#val-from" class="anchor"></a><code><span class="keyword">val</span> from : (int <span>&#45;&gt;</span> <span class="type-var">'a</span> option) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>Stream.from f</code> returns a stream built from the function <code>f</code>. To create a new stream element, the function <code>f</code> is called with the current stream count. The user function <code>f</code> must return either <code>Some &lt;value&gt;</code> for a value or <code>None</code> to specify the end of the stream.</p></dd></dl><dl><dt class="spec value" id="val-of_list"><a href="#val-of_list" class="anchor"></a><code><span class="keyword">val</span> of_list : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Return the stream holding the elements of the list in the same order.</p></dd></dl><dl><dt class="spec value" id="val-of_string"><a href="#val-of_string" class="anchor"></a><code><span class="keyword">val</span> of_string : string <span>&#45;&gt;</span> char <a href="index.html#type-t">t</a></code></dt><dd><p>Return the stream of the characters of the string parameter.</p></dd></dl><dl><dt class="spec value" id="val-of_bytes"><a href="#val-of_bytes" class="anchor"></a><code><span class="keyword">val</span> of_bytes : <a href="../../ocaml/Stdlib/Bytes/index.html#type-t">Stdlib.Bytes.t</a> <span>&#45;&gt;</span> char <a href="index.html#type-t">t</a></code></dt><dd><p>Return the stream of the characters of the bytes parameter.</p><dl><dt>since</dt><dd>2.3.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-of_channel"><a href="#val-of_channel" class="anchor"></a><code><span class="keyword">val</span> of_channel : <a href="../../ocaml/Stdlib/index.html#type-in_channel">Stdlib.in_channel</a> <span>&#45;&gt;</span> char <a href="index.html#type-t">t</a></code></dt><dd><p>Return the stream of the characters read from the input channel.</p></dd></dl></section><section><header><h6 id="other-stream-builders"><a href="#other-stream-builders" class="anchor"></a>Other Stream builders</h6><p>Warning: these functions create streams with fast access; it is illegal to mix them with streams built with <code>[&lt; &gt;]</code>; would raise <code>Failure</code> when accessing such mixed streams.</p></header><dl><dt class="spec value" id="val-of_fun"><a href="#val-of_fun" class="anchor"></a><code><span class="keyword">val</span> of_fun : (unit <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>Stream.of_fun f</code> returns a stream built from the function <code>f</code>. To create a new stream element, the function <code>f</code> is called with the current stream count. The user function <code>f</code> must return either <code>Some &lt;value&gt;</code> for a value or <code>None</code> to specify the end of the stream.</p></dd></dl></section><section><header><h6 id="stream-iterator"><a href="#stream-iterator" class="anchor"></a>Stream iterator</h6></header><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : (<span class="type-var">'a</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>Stream.iter f s</code> scans the whole stream s, applying function <code>f</code> in turn to each stream element encountered.</p></dd></dl><dl><dt class="spec value" id="val-foldl"><a href="#val-foldl" class="anchor"></a><code><span class="keyword">val</span> foldl : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> * bool option) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>foldl f init stream</code> is a lazy fold_left. <code>f accu elt</code> should return <code>(new_accu, state)</code> where <code>new_accu</code> is normal accumulation result, and <code>state</code> is a flag representing whether the computation should continue and whether the last operation is valid: <code>None</code> means continue, <code>Some b</code> means stop where <code>b = true</code> means the last addition is still valid and <code>b
    = false</code> means the last addition is invalid and should be revert.</p></dd></dl><dl><dt class="spec value" id="val-foldr"><a href="#val-foldr" class="anchor"></a><code><span class="keyword">val</span> foldr : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> lazy_t <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p><code>foldr f init stream</code> is a lazy fold_right. Unlike the normal fold_right, the accumulation parameter of <code>f elt accu</code> is lazy, hence it can decide not to force the evaluation of <code>accu</code> if the current element <code>elt</code> can determin the result by itself.</p></dd></dl><dl><dt class="spec value" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span class="keyword">val</span> fold : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> * bool option) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>fold</code> is <code>foldl</code> without initialization value, where the first element of stream is taken as <code>init</code>. It raises <code>End_of_stream</code> exception when the input stream is empty.</p></dd></dl><dl><dt class="spec value" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span class="keyword">val</span> filter : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>filter test stream</code> picks all the elements satisfying <code>test</code> from <code>stream</code> and return the results in the same order as a stream.</p></dd></dl></section><section><header><h6 id="predefined-parsers"><a href="#predefined-parsers" class="anchor"></a>Predefined parsers</h6></header><dl><dt class="spec value" id="val-next"><a href="#val-next" class="anchor"></a><code><span class="keyword">val</span> next : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Return the first element of the stream and remove it from the stream. </p><dl><dt>raises Stream.Failure</dt><dd><p>if the stream is empty.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val</span> empty : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Return <code>()</code> if the stream is empty, else raise <code>Stream.Failure</code>.</p></dd></dl></section><section><header><h6 id="useful-functions"><a href="#useful-functions" class="anchor"></a>Useful functions</h6></header><dl><dt class="spec value" id="val-peek"><a href="#val-peek" class="anchor"></a><code><span class="keyword">val</span> peek : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt><dd><p>Return <code>Some</code> of &quot;the first element&quot; of the stream, or <code>None</code> if the stream is empty.</p></dd></dl><dl><dt class="spec value" id="val-junk"><a href="#val-junk" class="anchor"></a><code><span class="keyword">val</span> junk : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Remove the first element of the stream, possibly unfreezing it before.</p></dd></dl><dl><dt class="spec value" id="val-count"><a href="#val-count" class="anchor"></a><code><span class="keyword">val</span> count : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Return the current count of the stream elements, i.e. the number of the stream elements discarded.</p></dd></dl><dl><dt class="spec value" id="val-npeek"><a href="#val-npeek" class="anchor"></a><code><span class="keyword">val</span> npeek : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p><code>npeek n</code> returns the list of the <code>n</code> first elements of the stream, or all its remaining elements if less than <code>n</code> elements are available.</p></dd></dl></section><section><header><h6 id="conversion-functions"><a href="#conversion-functions" class="anchor"></a>Conversion functions</h6></header><dl><dt class="spec value" id="val-enum"><a href="#val-enum" class="anchor"></a><code><span class="keyword">val</span> enum : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../BatEnum/index.html#type-t">BatEnum.t</a></code></dt><dd><p>Convert a stream to an enumeration. Reading the resulting enumeration will consume elements from the stream. This is the preferred manner of converting from a stream to any other data structure.</p></dd></dl><dl><dt class="spec value" id="val-of_enum"><a href="#val-of_enum" class="anchor"></a><code><span class="keyword">val</span> of_enum : <span class="type-var">'a</span> <a href="../BatEnum/index.html#type-t">BatEnum.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Convert an enumeration to a stream. Reading the resulting stream will consume elements from the enumeration. This is the preferred manner of creating a stream.</p></dd></dl><dl><dt class="spec value" id="val-of_input"><a href="#val-of_input" class="anchor"></a><code><span class="keyword">val</span> of_input : <a href="../BatIO/index.html#type-input">BatIO.input</a> <span>&#45;&gt;</span> char <a href="index.html#type-t">t</a></code></dt><dd><p>Convert an <code>input</code> to a stream.</p></dd></dl><dl><dt class="spec value" id="val-to_list"><a href="#val-to_list" class="anchor"></a><code><span class="keyword">val</span> to_list : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>Convert a stream to a list</p></dd></dl><dl><dt class="spec value" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span class="keyword">val</span> to_string : char <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p>convert stream of chars to string, using buffer</p></dd></dl><dl><dt class="spec value" id="val-to_string_fmt"><a href="#val-to_string_fmt" class="anchor"></a><code><span class="keyword">val</span> to_string_fmt : (<span class="type-var">'a</span> <span>&#45;&gt;</span> string, unit, string) <a href="../../ocaml/Stdlib/index.html#type-format">Stdlib.format</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p>convert stream to string, using Printf with given format</p></dd></dl><dl><dt class="spec value" id="val-to_string_fun"><a href="#val-to_string_fun" class="anchor"></a><code><span class="keyword">val</span> to_string_fun : (<span class="type-var">'a</span> <span>&#45;&gt;</span> string) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p>convert stream to string, using given conversion function</p></dd></dl></section><section><header><h6 id="stream-consumers"><a href="#stream-consumers" class="anchor"></a>Stream consumers</h6></header><dl><dt class="spec value" id="val-on_output"><a href="#val-on_output" class="anchor"></a><code><span class="keyword">val</span> on_output : <span class="type-var">'a</span> <a href="../BatIO/index.html#type-output">BatIO.output</a> <span>&#45;&gt;</span> char <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Convert an <code>output</code> to a stream.</p></dd></dl></section><section><header><h6 id="computation-over-stream"><a href="#computation-over-stream" class="anchor"></a>Computation over stream</h6><p>All the functions in this part are lazy.</p></header><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>map f stream</code> applies <code>f</code> in turn to elements from <code>stream</code> and return the results as a stream in the same order.</p></dd></dl><dl><dt class="spec value" id="val-map2"><a href="#val-map2" class="anchor"></a><code><span class="keyword">val</span> map2 : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>map2 f streama streamb</code> applies <code>f</code> in turn to elements of corresponding positions from <code>streama</code> and <code>streamb</code>. The results are constructed in the same order as a stream. If one stream is short, excess elements of the longer stream are ignored.</p></dd></dl><dl><dt class="spec value" id="val-scanl"><a href="#val-scanl" class="anchor"></a><code><span class="keyword">val</span> scanl : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>scanl f init stream</code> returns a stream of successive reduced values from the left: <code>scanl f init [&lt; 'e0; 'e1; ... &gt;]</code> is equivalent to <code>[&lt; 'init; '(f init e0); '(f (f init e0) e1); ... &gt;]</code></p></dd></dl><dl><dt class="spec value" id="val-scan"><a href="#val-scan" class="anchor"></a><code><span class="keyword">val</span> scan : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>scan</code> is similar to <code>scanl</code> but without the <code>init</code> value: <code>scanl f init [&lt; 'e0; 'e1; 'e2; ... &gt;]</code> is equivalent to <code>[&lt; 'e0; '(f e0 e1); '(f (f e0 e1) e2); ... &gt;]</code></p></dd></dl><dl><dt class="spec value" id="val-concat"><a href="#val-concat" class="anchor"></a><code><span class="keyword">val</span> concat : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>concatenate a stream of streams</p></dd></dl><dl><dt class="spec value" id="val-concat_map"><a href="#val-concat_map" class="anchor"></a><code><span class="keyword">val</span> concat_map : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Composition of <a href="index.html#val-concat"><code>concat</code></a> and <a href="index.html#val-map"><code>map</code></a>. <code>concat_map f e</code> is the same as <code>concat (map f e)</code>.</p><dl><dt>since</dt><dd>2.3.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-take"><a href="#val-take" class="anchor"></a><code><span class="keyword">val</span> take : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>take n stream</code> returns the prefix of <code>stream</code> of length <code>n</code>, or <code>stream</code> itself if <code>n</code> is greater than the length of <code>stream</code></p></dd></dl><dl><dt class="spec value" id="val-drop"><a href="#val-drop" class="anchor"></a><code><span class="keyword">val</span> drop : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>drop n stream</code> returns the suffix of <code>stream</code> after the first <code>n</code> elements, or a empty stream if <code>n</code> is greater than the length of <code>stream</code></p></dd></dl><dl><dt class="spec value" id="val-take_while"><a href="#val-take_while" class="anchor"></a><code><span class="keyword">val</span> take_while : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>take_while test stream</code> returns the longest (possibly empty) prefix of <code>stream</code> of elements that satisfy <code>test</code>.</p></dd></dl><dl><dt class="spec value" id="val-drop_while"><a href="#val-drop_while" class="anchor"></a><code><span class="keyword">val</span> drop_while : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>drop_while test stream</code> returns the remaining suffix of <code>take_while test
    stream</code>.</p></dd></dl></section><section><header><h6 id="streams-pair-arithmetic"><a href="#streams-pair-arithmetic" class="anchor"></a>Streams pair arithmetic</h6><p>All the functions in this part are lazy.</p></header><dl><dt class="spec value" id="val-dup"><a href="#val-dup" class="anchor"></a><code><span class="keyword">val</span> dup : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> * <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>dup stream</code> returns a pair of streams which are identical to <code>stream</code>. Note that stream is a destructive data structure, the point of <code>dup</code> is to return two streams can be used independently.</p><p>NOT IMPLEMENTED CORRECTLY - WILL RAISE Failure UNTIL CORRECT IMPLEMENTATION FOUND</p></dd></dl><dl><dt class="spec value" id="val-comb"><a href="#val-comb" class="anchor"></a><code><span class="keyword">val</span> comb : (<span class="type-var">'a</span> <a href="index.html#type-t">t</a> * <span class="type-var">'b</span> <a href="index.html#type-t">t</a>) <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>comb</code> transform a pair of stream into a stream of pairs of corresponding elements. If one stream is short, excess elements of the longer stream are ignored.</p></dd></dl><dl><dt class="spec value" id="val-split"><a href="#val-split" class="anchor"></a><code><span class="keyword">val</span> split : (<span class="type-var">'a</span> * <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> * <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>split</code> is the opposite of <code>comb</code></p></dd></dl><dl><dt class="spec value" id="val-merge"><a href="#val-merge" class="anchor"></a><code><span class="keyword">val</span> merge : (bool <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> (<span class="type-var">'a</span> <a href="index.html#type-t">t</a> * <span class="type-var">'a</span> <a href="index.html#type-t">t</a>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>merge test (streama, streamb)</code> merge the elements from <code>streama</code> and <code>streamb</code> into a single stream. The <code>bool</code> type here represents the id of the two input streams where <code>true</code> is the first and <code>false</code> represents the second. The <code>test</code> function is applied to each element of the output stream together with the id of the input stream from which it was extracted, to decide which stream should the next element come from. The first element is always taken from <code>streama</code>. When a stream runs out of elements, the merge process will continue to take elements from the other stream until both streams reach their ends.</p></dd></dl><dl><dt class="spec value" id="val-switch"><a href="#val-switch" class="anchor"></a><code><span class="keyword">val</span> switch : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> * <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>switch test stream</code> split <code>stream</code> into two streams, where the first stream have all the elements satisfying <code>test</code>, the second stream is opposite. The order of elements in the source stream is preserved.</p></dd></dl></section><section><header><h6 id="stream-arithmetic"><a href="#stream-arithmetic" class="anchor"></a>Stream arithmetic</h6><p>All the functions in this part are lazy.</p></header><dl><dt class="spec value" id="val-cons"><a href="#val-cons" class="anchor"></a><code><span class="keyword">val</span> cons : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>cons x stream</code> equals <code>[&lt;'x; stream&gt;]</code>.</p></dd></dl><dl><dt class="spec value" id="val-apnd"><a href="#val-apnd" class="anchor"></a><code><span class="keyword">val</span> apnd : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>apnd fla flb</code> equals <code>[&lt;fla;flb&gt;]</code>.</p></dd></dl><dl><dt class="spec value" id="val-is_empty"><a href="#val-is_empty" class="anchor"></a><code><span class="keyword">val</span> is_empty : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_empty stream</code> tests whether <code>stream</code> is empty. But note that it forces the evaluation of the head element if any.</p></dd></dl></section><section><header><h6 id="predefined-parsers"><a href="#predefined-parsers" class="anchor"></a>Predefined parsers</h6></header><dl><dt class="spec value" id="val-next"><a href="#val-next" class="anchor"></a><code><span class="keyword">val</span> next : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Return the first element of the stream and remove it from the stream. </p><dl><dt>raises Stream.Failure</dt><dd><p>if the stream is empty.</p></dd></dl></dd></dl><div class="spec module" id="module-StreamLabels"><a href="#module-StreamLabels" class="anchor"></a><code><span class="keyword">module</span> <a href="StreamLabels/index.html">StreamLabels</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section></div></body></html>