<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Pcre (pcre.Pcre)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">pcre</a> &#x00BB; Pcre</nav><h1>Module <code>Pcre</code></h1><p>Perl Compatibility Regular Expressions</p><nav class="toc"><ul><li><a href="#exceptions">Exceptions</a></li><li><a href="#compilation-and-runtime-flags-and-their-conversion-functions">Compilation and runtime flags and their conversion functions</a></li><li><a href="#information-on-the-pcre-configuration-(build-time-options)">Information on the PCRE-configuration (build-time options)</a></li><li><a href="#information-on-patterns">Information on patterns</a></li><li><a href="#compilation-of-patterns">Compilation of patterns</a></li><li><a href="#subpattern-extraction">Subpattern extraction</a></li><li><a href="#callouts">Callouts</a></li><li><a href="#matching-of-patterns-and-subpattern-extraction">Matching of patterns and subpattern extraction</a></li><li><a href="#string-substitution">String substitution</a></li><li><a href="#splitting">Splitting</a></li><li><a href="#additional-convenience-functions">Additional convenience functions</a></li><li><a href="#unsafe-stuff---use-with-caution!"><b>UNSAFE STUFF - USE WITH CAUTION!</b></a></li></ul></nav></header><section><header><h6 id="exceptions"><a href="#exceptions" class="anchor"></a>Exceptions</h6></header><dl><dt class="spec type" id="type-error"><a href="#type-error" class="anchor"></a><code><span class="keyword">type </span>error</code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-error.Partial" class="anchored"><td class="def constructor"><a href="#type-error.Partial" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Partial</span></code></td><td class="doc"><p>String only matched the pattern partially</p></td></tr><tr id="type-error.BadPartial" class="anchored"><td class="def constructor"><a href="#type-error.BadPartial" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">BadPartial</span></code></td><td class="doc"><p>Pattern contains items that cannot be used together with partial matching.</p></td></tr><tr id="type-error.BadPattern" class="anchored"><td class="def constructor"><a href="#type-error.BadPattern" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">BadPattern</span><span class="keyword"> of </span>string<span class="keyword"> * </span>int</code></td><td class="doc"><p><code>BadPattern (msg, pos)</code> regular expression is malformed. The reason is in <code>msg</code>, the position of the error in the pattern in <code>pos</code>.</p></td></tr><tr id="type-error.BadUTF8" class="anchored"><td class="def constructor"><a href="#type-error.BadUTF8" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">BadUTF8</span></code></td><td class="doc"><p>UTF8 string being matched is invalid</p></td></tr><tr id="type-error.BadUTF8Offset" class="anchored"><td class="def constructor"><a href="#type-error.BadUTF8Offset" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">BadUTF8Offset</span></code></td><td class="doc"><p>Gets raised when a UTF8 string being matched with offset is invalid.</p></td></tr><tr id="type-error.MatchLimit" class="anchored"><td class="def constructor"><a href="#type-error.MatchLimit" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">MatchLimit</span></code></td><td class="doc"><p>Maximum allowed number of match attempts with backtracking or recursion is reached during matching. ALL FUNCTIONS CALLING THE MATCHING ENGINE MAY RAISE IT!!!</p></td></tr><tr id="type-error.RecursionLimit" class="anchored"><td class="def constructor"><a href="#type-error.RecursionLimit" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">RecursionLimit</span></code></td></tr><tr id="type-error.InternalError" class="anchored"><td class="def constructor"><a href="#type-error.InternalError" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">InternalError</span><span class="keyword"> of </span>string</code></td><td class="doc"><p><code>InternalError msg</code> C-library exhibits unknown/undefined behaviour. The reason is in <code>msg</code>.</p></td></tr></table></dt></dl><dl><dt class="spec exception" id="exception-Error"><a href="#exception-Error" class="anchor"></a><code><span class="keyword">exception </span></code><code><span class="exception">Error</span><span class="keyword"> of </span><a href="index.html#type-error">error</a></code></dt><dd><p>Exception indicating PCRE errors.</p></dd></dl><dl><dt class="spec exception" id="exception-Backtrack"><a href="#exception-Backtrack" class="anchor"></a><code><span class="keyword">exception </span></code><code><span class="exception">Backtrack</span></code></dt><dd><p><code>Backtrack</code> used in callout functions to force backtracking.</p></dd></dl><dl><dt class="spec exception" id="exception-Regexp_or"><a href="#exception-Regexp_or" class="anchor"></a><code><span class="keyword">exception </span></code><code><span class="exception">Regexp_or</span><span class="keyword"> of </span>string<span class="keyword"> * </span><a href="index.html#type-error">error</a></code></dt><dd><p><code>Regexp_or (pat, error)</code> gets raised for sub-pattern <code>pat</code> by <code>regexp_or</code> if it failed to compile.</p></dd></dl></section><section><header><h6 id="compilation-and-runtime-flags-and-their-conversion-functions"><a href="#compilation-and-runtime-flags-and-their-conversion-functions" class="anchor"></a>Compilation and runtime flags and their conversion functions</h6></header><dl><dt class="spec type" id="type-icflag"><a href="#type-icflag" class="anchor"></a><code><span class="keyword">type </span>icflag</code></dt><dd><p>Internal representation of compilation flags</p></dd></dl><dl><dt class="spec type" id="type-irflag"><a href="#type-irflag" class="anchor"></a><code><span class="keyword">and </span>irflag</code></dt><dd><p>Internal representation of runtime flags</p></dd></dl><dl><dt class="spec type" id="type-cflag"><a href="#type-cflag" class="anchor"></a><code><span class="keyword">and </span>cflag</code><span class="keyword"> = </span><code>[ </code><table class="variant"><tr id="type-cflag.CASELESS" class="anchored"><td class="def constructor"><a href="#type-cflag.CASELESS" class="anchor"></a><code><span class="keyword">| </span></code><code>`CASELESS</code></td><td class="doc"><p>Case insensitive matching</p></td></tr><tr id="type-cflag.MULTILINE" class="anchored"><td class="def constructor"><a href="#type-cflag.MULTILINE" class="anchor"></a><code><span class="keyword">| </span></code><code>`MULTILINE</code></td><td class="doc"><p>'^' and '$' match before/after newlines, not just at the beginning/end of a string</p></td></tr><tr id="type-cflag.DOTALL" class="anchored"><td class="def constructor"><a href="#type-cflag.DOTALL" class="anchor"></a><code><span class="keyword">| </span></code><code>`DOTALL</code></td><td class="doc"><p>'.' matches all characters (newlines, too)</p></td></tr><tr id="type-cflag.EXTENDED" class="anchored"><td class="def constructor"><a href="#type-cflag.EXTENDED" class="anchor"></a><code><span class="keyword">| </span></code><code>`EXTENDED</code></td><td class="doc"><p>Ignores whitespace and PERL-comments. Behaves like the '/x'-option in PERL</p></td></tr><tr id="type-cflag.ANCHORED" class="anchored"><td class="def constructor"><a href="#type-cflag.ANCHORED" class="anchor"></a><code><span class="keyword">| </span></code><code>`ANCHORED</code></td><td class="doc"><p>Pattern matches only at start of string</p></td></tr><tr id="type-cflag.DOLLAR_ENDONLY" class="anchored"><td class="def constructor"><a href="#type-cflag.DOLLAR_ENDONLY" class="anchor"></a><code><span class="keyword">| </span></code><code>`DOLLAR_ENDONLY</code></td><td class="doc"><p>'$' in pattern matches only at end of string</p></td></tr><tr id="type-cflag.EXTRA" class="anchored"><td class="def constructor"><a href="#type-cflag.EXTRA" class="anchor"></a><code><span class="keyword">| </span></code><code>`EXTRA</code></td><td class="doc"><p>Reserved for future extensions of PCRE</p></td></tr><tr id="type-cflag.UNGREEDY" class="anchored"><td class="def constructor"><a href="#type-cflag.UNGREEDY" class="anchor"></a><code><span class="keyword">| </span></code><code>`UNGREEDY</code></td><td class="doc"><p>Quantifiers not greedy anymore, only if followed by '?'</p></td></tr><tr id="type-cflag.UTF8" class="anchored"><td class="def constructor"><a href="#type-cflag.UTF8" class="anchor"></a><code><span class="keyword">| </span></code><code>`UTF8</code></td><td class="doc"><p>Treats patterns and strings as UTF8 characters.</p></td></tr><tr id="type-cflag.NO_UTF8_CHECK" class="anchored"><td class="def constructor"><a href="#type-cflag.NO_UTF8_CHECK" class="anchor"></a><code><span class="keyword">| </span></code><code>`NO_UTF8_CHECK</code></td><td class="doc"><p>Turns off validity checks on UTF8 strings for efficiency reasons. WARNING: invalid UTF8 strings may cause a crash then!</p></td></tr><tr id="type-cflag.NO_AUTO_CAPTURE" class="anchored"><td class="def constructor"><a href="#type-cflag.NO_AUTO_CAPTURE" class="anchor"></a><code><span class="keyword">| </span></code><code>`NO_AUTO_CAPTURE</code></td><td class="doc"><p>Disables the use of numbered capturing parentheses</p></td></tr><tr id="type-cflag.AUTO_CALLOUT" class="anchored"><td class="def constructor"><a href="#type-cflag.AUTO_CALLOUT" class="anchor"></a><code><span class="keyword">| </span></code><code>`AUTO_CALLOUT</code></td><td class="doc"><p>Automatically inserts callouts with id 255 before each pattern item</p></td></tr><tr id="type-cflag.FIRSTLINE" class="anchored"><td class="def constructor"><a href="#type-cflag.FIRSTLINE" class="anchor"></a><code><span class="keyword">| </span></code><code>`FIRSTLINE</code></td><td class="doc"><p>Unanchored patterns must match before/at first NL</p></td></tr></table><code> ]</code></dt><dd><p>Compilation flags</p></dd></dl><dl><dt class="spec value" id="val-cflags"><a href="#val-cflags" class="anchor"></a><code><span class="keyword">val </span>cflags : <a href="index.html#type-cflag">cflag</a> list <span>&#45;&gt;</span> <a href="index.html#type-icflag">icflag</a></code></dt><dd><p><code>cflags cflag_list</code> converts a list of compilation flags to their internal representation.</p></dd></dl><dl><dt class="spec value" id="val-cflag_list"><a href="#val-cflag_list" class="anchor"></a><code><span class="keyword">val </span>cflag_list : <a href="index.html#type-icflag">icflag</a> <span>&#45;&gt;</span> <a href="index.html#type-cflag">cflag</a> list</code></dt><dd><p><code>cflag_list cflags</code> converts internal representation of compilation flags to a list.</p></dd></dl><dl><dt class="spec type" id="type-rflag"><a href="#type-rflag" class="anchor"></a><code><span class="keyword">type </span>rflag</code><span class="keyword"> = </span><code>[ </code><table class="variant"><tr id="type-rflag.ANCHORED" class="anchored"><td class="def constructor"><a href="#type-rflag.ANCHORED" class="anchor"></a><code><span class="keyword">| </span></code><code>`ANCHORED</code></td><td class="doc"><p>Treats pattern as if it were anchored</p></td></tr><tr id="type-rflag.NOTBOL" class="anchored"><td class="def constructor"><a href="#type-rflag.NOTBOL" class="anchor"></a><code><span class="keyword">| </span></code><code>`NOTBOL</code></td><td class="doc"><p>Beginning of string is not treated as beginning of line</p></td></tr><tr id="type-rflag.NOTEOL" class="anchored"><td class="def constructor"><a href="#type-rflag.NOTEOL" class="anchor"></a><code><span class="keyword">| </span></code><code>`NOTEOL</code></td><td class="doc"><p>End of string is not treated as end of line</p></td></tr><tr id="type-rflag.NOTEMPTY" class="anchored"><td class="def constructor"><a href="#type-rflag.NOTEMPTY" class="anchor"></a><code><span class="keyword">| </span></code><code>`NOTEMPTY</code></td><td class="doc"><p>Empty strings are not considered to be a valid match</p></td></tr><tr id="type-rflag.PARTIAL" class="anchored"><td class="def constructor"><a href="#type-rflag.PARTIAL" class="anchor"></a><code><span class="keyword">| </span></code><code>`PARTIAL</code></td><td class="doc"><p>Turns on partial matching</p></td></tr></table><code> ]</code></dt><dd><p>Runtime flags</p></dd></dl><dl><dt class="spec value" id="val-rflags"><a href="#val-rflags" class="anchor"></a><code><span class="keyword">val </span>rflags : <a href="index.html#type-rflag">rflag</a> list <span>&#45;&gt;</span> <a href="index.html#type-irflag">irflag</a></code></dt><dd><p><code>rflags rflag_list</code> converts a list of runtime flags to their internal representation.</p></dd></dl><dl><dt class="spec value" id="val-rflag_list"><a href="#val-rflag_list" class="anchor"></a><code><span class="keyword">val </span>rflag_list : <a href="index.html#type-irflag">irflag</a> <span>&#45;&gt;</span> <a href="index.html#type-rflag">rflag</a> list</code></dt><dd><p><code>rflag_list rflags</code> converts internal representation of runtime flags to a list.</p></dd></dl></section><section><header><h6 id="information-on-the-pcre-configuration-(build-time-options)"><a href="#information-on-the-pcre-configuration-(build-time-options)" class="anchor"></a>Information on the PCRE-configuration (build-time options)</h6></header><dl><dt class="spec value" id="val-version"><a href="#val-version" class="anchor"></a><code><span class="keyword">val </span>version : string</code></dt><dd><p>Version information</p><p>Version of the PCRE-C-library</p></dd></dl><dl><dt class="spec value" id="val-config_utf8"><a href="#val-config_utf8" class="anchor"></a><code><span class="keyword">val </span>config_utf8 : bool</code></dt><dd><p>Indicates whether UTF8-support is enabled</p></dd></dl><dl><dt class="spec value" id="val-config_newline"><a href="#val-config_newline" class="anchor"></a><code><span class="keyword">val </span>config_newline : char</code></dt><dd><p>Character used as newline</p></dd></dl><dl><dt class="spec value" id="val-config_link_size"><a href="#val-config_link_size" class="anchor"></a><code><span class="keyword">val </span>config_link_size : int</code></dt><dd><p>Number of bytes used for internal linkage of regular expressions</p></dd></dl><dl><dt class="spec value" id="val-config_match_limit"><a href="#val-config_match_limit" class="anchor"></a><code><span class="keyword">val </span>config_match_limit : int</code></dt><dd><p>Default limit for calls to internal matching function</p></dd></dl><dl><dt class="spec value" id="val-config_match_limit_recursion"><a href="#val-config_match_limit_recursion" class="anchor"></a><code><span class="keyword">val </span>config_match_limit_recursion : int</code></dt><dd><p>Default limit recursion for calls to internal matching function</p></dd></dl><dl><dt class="spec value" id="val-config_stackrecurse"><a href="#val-config_stackrecurse" class="anchor"></a><code><span class="keyword">val </span>config_stackrecurse : bool</code></dt><dd><p>Indicates use of stack recursion in matching function</p></dd></dl></section><section><header><h6 id="information-on-patterns"><a href="#information-on-patterns" class="anchor"></a>Information on patterns</h6></header><dl><dt class="spec type" id="type-firstbyte_info"><a href="#type-firstbyte_info" class="anchor"></a><code><span class="keyword">type </span>firstbyte_info</code><span class="keyword"> = </span><code>[ </code><table class="variant"><tr id="type-firstbyte_info.Char" class="anchored"><td class="def constructor"><a href="#type-firstbyte_info.Char" class="anchor"></a><code><span class="keyword">| </span></code><code>`Char<span class="keyword"> of </span>char</code></td><td class="doc"><p>Fixed first character</p></td></tr><tr id="type-firstbyte_info.Start_only" class="anchored"><td class="def constructor"><a href="#type-firstbyte_info.Start_only" class="anchor"></a><code><span class="keyword">| </span></code><code>`Start_only</code></td><td class="doc"><p>Pattern matches at beginning and end of newlines</p></td></tr><tr id="type-firstbyte_info.ANCHORED" class="anchored"><td class="def constructor"><a href="#type-firstbyte_info.ANCHORED" class="anchor"></a><code><span class="keyword">| </span></code><code>`ANCHORED</code></td><td class="doc"><p>Pattern is anchored</p></td></tr></table><code> ]</code></dt><dd><p>Information on matching of &quot;first chars&quot; in patterns</p></dd></dl><dl><dt class="spec type" id="type-study_stat"><a href="#type-study_stat" class="anchor"></a><code><span class="keyword">type </span>study_stat</code><span class="keyword"> = </span><code>[ </code><table class="variant"><tr id="type-study_stat.Not_studied" class="anchored"><td class="def constructor"><a href="#type-study_stat.Not_studied" class="anchor"></a><code><span class="keyword">| </span></code><code>`Not_studied</code></td><td class="doc"><p>Pattern has not yet been studied</p></td></tr><tr id="type-study_stat.Studied" class="anchored"><td class="def constructor"><a href="#type-study_stat.Studied" class="anchor"></a><code><span class="keyword">| </span></code><code>`Studied</code></td><td class="doc"><p>Pattern has been studied successfully</p></td></tr><tr id="type-study_stat.Optimal" class="anchored"><td class="def constructor"><a href="#type-study_stat.Optimal" class="anchor"></a><code><span class="keyword">| </span></code><code>`Optimal</code></td><td class="doc"><p>Pattern could not be improved by studying</p></td></tr></table><code> ]</code></dt><dd><p>Information on the study status of patterns</p></dd></dl><dl><dt class="spec type" id="type-regexp"><a href="#type-regexp" class="anchor"></a><code><span class="keyword">type </span>regexp</code></dt><dd><p>Compiled regular expressions</p></dd></dl><dl><dt class="spec external" id="val-options"><a href="#val-options" class="anchor"></a><code><span class="keyword">val </span>options : <a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> <a href="index.html#type-icflag">icflag</a></code></dt><dd><p><code>options regexp</code> </p><dl><dt>returns</dt><dd><p>compilation flags of <code>regexp</code>.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-size"><a href="#val-size" class="anchor"></a><code><span class="keyword">val </span>size : <a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>size regexp</code> </p><dl><dt>returns</dt><dd><p>memory size of <code>regexp</code>.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-studysize"><a href="#val-studysize" class="anchor"></a><code><span class="keyword">val </span>studysize : <a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>studysize regexp</code> </p><dl><dt>returns</dt><dd><p>memory size of study information of <code>regexp</code>.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-capturecount"><a href="#val-capturecount" class="anchor"></a><code><span class="keyword">val </span>capturecount : <a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>capturecount regexp</code> </p><dl><dt>returns</dt><dd><p>number of capturing subpatterns in <code>regexp</code>.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-backrefmax"><a href="#val-backrefmax" class="anchor"></a><code><span class="keyword">val </span>backrefmax : <a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>backrefmax regexp</code> </p><dl><dt>returns</dt><dd><p>number of highest backreference in <code>regexp</code>.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-namecount"><a href="#val-namecount" class="anchor"></a><code><span class="keyword">val </span>namecount : <a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>namecount regexp</code> </p><dl><dt>returns</dt><dd><p>number of named subpatterns in <code>regexp</code>.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-names"><a href="#val-names" class="anchor"></a><code><span class="keyword">val </span>names : <a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> string array</code></dt><dd><p><code>names regex</code> </p><dl><dt>returns</dt><dd><p>array of names of named substrings in <code>regexp</code>.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-nameentrysize"><a href="#val-nameentrysize" class="anchor"></a><code><span class="keyword">val </span>nameentrysize : <a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>nameentrysize regexp</code> </p><dl><dt>returns</dt><dd><p>size of longest name of named subpatterns in <code>regexp</code> + 3.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-firstbyte"><a href="#val-firstbyte" class="anchor"></a><code><span class="keyword">val </span>firstbyte : <a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> <a href="index.html#type-firstbyte_info">firstbyte_info</a></code></dt><dd><p><code>firstbyte regexp</code> </p><dl><dt>returns</dt><dd><p>firstbyte info on <code>regexp</code>.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-firsttable"><a href="#val-firsttable" class="anchor"></a><code><span class="keyword">val </span>firsttable : <a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> string option</code></dt><dd><p><code>firsttable regexp</code> </p><dl><dt>returns</dt><dd><p>some 256-bit (32-byte) fixed set table in form of a string for <code>regexp</code> if available, <code>None</code> otherwise.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-lastliteral"><a href="#val-lastliteral" class="anchor"></a><code><span class="keyword">val </span>lastliteral : <a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> char option</code></dt><dd><p><code>lastliteral regexp</code> </p><dl><dt>returns</dt><dd><p>some last matching character of <code>regexp</code> if available, <code>None</code> otherwise.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-study_stat"><a href="#val-study_stat" class="anchor"></a><code><span class="keyword">val </span>study_stat : <a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> <a href="index.html#type-study_stat">study_stat</a></code></dt><dd><p><code>study_stat regexp</code> </p><dl><dt>returns</dt><dd><p>study status of <code>regexp</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-get_stringnumber"><a href="#val-get_stringnumber" class="anchor"></a><code><span class="keyword">val </span>get_stringnumber : <a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> int</code></dt><dd><p><code>get_stringnumber rex name</code> </p><dl><dt>returns</dt><dd><p>the index of the named substring <code>name</code> in regular expression <code>rex</code>. This index can then be used with <code>get_substring</code>.</p></dd></dl><dl><dt>raises Invalid_arg</dt><dd><p>if there is no such named substring.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-get_match_limit"><a href="#val-get_match_limit" class="anchor"></a><code><span class="keyword">val </span>get_match_limit : <a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> int option</code></dt><dd><p><code>get_match_limit rex</code> </p><dl><dt>returns</dt><dd><p>some match limit of regular expression <code>rex</code> or <code>None</code>.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-get_match_limit_recursion"><a href="#val-get_match_limit_recursion" class="anchor"></a><code><span class="keyword">val </span>get_match_limit_recursion : <a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> int option</code></dt><dd><p><code>get_match_limit_recursion rex</code> </p><dl><dt>returns</dt><dd><p>some recursion match limit of regular expression <code>rex</code> or <code>None</code>.</p></dd></dl></dd></dl></section><section><header><h6 id="compilation-of-patterns"><a href="#compilation-of-patterns" class="anchor"></a>Compilation of patterns</h6></header><dl><dt class="spec type" id="type-chtables"><a href="#type-chtables" class="anchor"></a><code><span class="keyword">type </span>chtables</code></dt><dd><p>Alternative set of char tables for pattern matching</p></dd></dl><dl><dt class="spec external" id="val-maketables"><a href="#val-maketables" class="anchor"></a><code><span class="keyword">val </span>maketables : unit <span>&#45;&gt;</span> <a href="index.html#type-chtables">chtables</a></code></dt><dd><p>Generates new set of char tables for the current locale.</p></dd></dl><dl><dt class="spec value" id="val-regexp"><a href="#val-regexp" class="anchor"></a><code><span class="keyword">val </span>regexp : ?&#8288;study:bool <span>&#45;&gt;</span> ?&#8288;limit:int <span>&#45;&gt;</span> ?&#8288;limit_recursion:int <span>&#45;&gt;</span> ?&#8288;iflags:<a href="index.html#type-icflag">icflag</a> <span>&#45;&gt;</span> ?&#8288;flags:<a href="index.html#type-cflag">cflag</a> list <span>&#45;&gt;</span> ?&#8288;chtables:<a href="index.html#type-chtables">chtables</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-regexp">regexp</a></code></dt><dd><p><code>regexp ?study ?limit ?limit_recursion ?iflags ?flags ?chtables pattern</code> compiles <code>pattern</code> with <code>flags</code> when given, with <code>iflags</code> otherwise, and with char tables <code>chtables</code>. If <code>study</code> is true, then the resulting regular expression will be studied. If <code>limit</code> is specified, this sets a limit to the amount of recursion and backtracking (only lower than the builtin default!). If this limit is exceeded, <code>MatchLimit</code> will be raised during matching.</p><dl><dt>parameter study</dt><dd><p>default = true</p></dd></dl><dl><dt>parameter limit</dt><dd><p>default = no extra limit other than default</p></dd></dl><dl><dt>parameter limit_recursion</dt><dd><p>default = no extra limit_recursion other than default</p></dd></dl><dl><dt>parameter iflags</dt><dd><p>default = no extra flags</p></dd></dl><dl><dt>parameter flags</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter chtables</dt><dd><p>default = builtin char tables</p></dd></dl><dl><dt>returns</dt><dd><p>the regular expression.</p><p>For detailed documentation on how you can specify PERL-style regular expressions (= patterns), please consult the PCRE-documentation (&quot;man pcrepattern&quot;) or PERL-manuals.</p></dd></dl><dl><dt>see <a href="http://www.perl.com">http://www.perl.com</a></dt><dd><p>www.perl.com</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-regexp_or"><a href="#val-regexp_or" class="anchor"></a><code><span class="keyword">val </span>regexp_or : ?&#8288;study:bool <span>&#45;&gt;</span> ?&#8288;limit:int <span>&#45;&gt;</span> ?&#8288;limit_recursion:int <span>&#45;&gt;</span> ?&#8288;iflags:<a href="index.html#type-icflag">icflag</a> <span>&#45;&gt;</span> ?&#8288;flags:<a href="index.html#type-cflag">cflag</a> list <span>&#45;&gt;</span> ?&#8288;chtables:<a href="index.html#type-chtables">chtables</a> <span>&#45;&gt;</span> string list <span>&#45;&gt;</span> <a href="index.html#type-regexp">regexp</a></code></dt><dd><p><code>regexp_or ?study ?limit ?limit_recursion ?iflags ?flags ?chtables patterns</code> like <a href="index.html#type-regexp"><code>regexp</code></a>, but combines <code>patterns</code> as alternatives (or-patterns) into one regular expression.</p></dd></dl><dl><dt class="spec value" id="val-quote"><a href="#val-quote" class="anchor"></a><code><span class="keyword">val </span>quote : string <span>&#45;&gt;</span> string</code></dt><dd><p><code>quote str</code> </p><dl><dt>returns</dt><dd><p>the quoted string of <code>str</code>.</p></dd></dl></dd></dl></section><section><header><h6 id="subpattern-extraction"><a href="#subpattern-extraction" class="anchor"></a>Subpattern extraction</h6></header><dl><dt class="spec type" id="type-substrings"><a href="#type-substrings" class="anchor"></a><code><span class="keyword">type </span>substrings</code></dt><dd><p>Information on substrings after pattern matching</p></dd></dl><dl><dt class="spec value" id="val-get_subject"><a href="#val-get_subject" class="anchor"></a><code><span class="keyword">val </span>get_subject : <a href="index.html#type-substrings">substrings</a> <span>&#45;&gt;</span> string</code></dt><dd><p><code>get_subject substrings</code> </p><dl><dt>returns</dt><dd><p>the subject string of <code>substrings</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-num_of_subs"><a href="#val-num_of_subs" class="anchor"></a><code><span class="keyword">val </span>num_of_subs : <a href="index.html#type-substrings">substrings</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>num_of_subs substrings</code> </p><dl><dt>returns</dt><dd><p>number of strings in <code>substrings</code> (whole match inclusive).</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-get_substring"><a href="#val-get_substring" class="anchor"></a><code><span class="keyword">val </span>get_substring : <a href="index.html#type-substrings">substrings</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> string</code></dt><dd><p><code>get_substring substrings n</code> </p><dl><dt>returns</dt><dd><p>the <code>n</code>th substring (0 is whole match) of <code>substrings</code>.</p></dd></dl><dl><dt>raises Invalid_argument</dt><dd><p>if <code>n</code> is not in the range of the number of substrings.</p></dd></dl><dl><dt>raises Not_found</dt><dd><p>if the corresponding subpattern did not capture a substring.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-get_substring_ofs"><a href="#val-get_substring_ofs" class="anchor"></a><code><span class="keyword">val </span>get_substring_ofs : <a href="index.html#type-substrings">substrings</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int<span class="keyword"> * </span>int</code></dt><dd><p><code>get_substring_ofs substrings n</code> </p><dl><dt>returns</dt><dd><p>the offset tuple of the <code>n</code>th substring of <code>substrings</code> (0 is whole match).</p></dd></dl><dl><dt>raises Invalid_argument</dt><dd><p>if <code>n</code> is not in the range of the number of substrings.</p></dd></dl><dl><dt>raises Not_found</dt><dd><p>if the corresponding subpattern did not capture a substring.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-get_substrings"><a href="#val-get_substrings" class="anchor"></a><code><span class="keyword">val </span>get_substrings : ?&#8288;full_match:bool <span>&#45;&gt;</span> <a href="index.html#type-substrings">substrings</a> <span>&#45;&gt;</span> string array</code></dt><dd><p><code>get_substrings ?full_match substrings</code> </p><dl><dt>returns</dt><dd><p>the array of substrings in <code>substrings</code>. It includes the full match at index 0 when <code>full_match</code> is <code>true</code>, the captured substrings only when it is <code>false</code>. If a subpattern did not capture a substring, the empty string is returned in the corresponding position instead.</p></dd></dl><dl><dt>parameter full_match</dt><dd><p>default = true</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-get_opt_substrings"><a href="#val-get_opt_substrings" class="anchor"></a><code><span class="keyword">val </span>get_opt_substrings : ?&#8288;full_match:bool <span>&#45;&gt;</span> <a href="index.html#type-substrings">substrings</a> <span>&#45;&gt;</span> string option array</code></dt><dd><p><code>get_opt_substrings ?full_match substrings</code> </p><dl><dt>returns</dt><dd><p>the array of optional substrings in <code>substrings</code>. It includes <code>Some full_match_str</code> at index 0 when <code>full_match</code> is <code>true</code>, <code>Some captured_substrings</code> only when it is <code>false</code>. If a subpattern did not capture a substring, <code>None</code> is returned in the corresponding position instead.</p></dd></dl><dl><dt>parameter full_match</dt><dd><p>default = true</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-get_named_substring"><a href="#val-get_named_substring" class="anchor"></a><code><span class="keyword">val </span>get_named_substring : <a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-substrings">substrings</a> <span>&#45;&gt;</span> string</code></dt><dd><p><code>get_named_substring rex name substrings</code> </p><dl><dt>returns</dt><dd><p>the named substring <code>name</code> in regular expression <code>rex</code> and <code>substrings</code>.</p></dd></dl><dl><dt>raises Invalid_argument</dt><dd><p>if there is no such named substring.</p></dd></dl><dl><dt>raises Not_found</dt><dd><p>if the corresponding subpattern did not capture a substring.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-get_named_substring_ofs"><a href="#val-get_named_substring_ofs" class="anchor"></a><code><span class="keyword">val </span>get_named_substring_ofs : <a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-substrings">substrings</a> <span>&#45;&gt;</span> int<span class="keyword"> * </span>int</code></dt><dd><p><code>get_named_substring_ofs rex name substrings</code> </p><dl><dt>returns</dt><dd><p>the offset tuple of the named substring <code>name</code> in regular expression <code>rex</code> and <code>substrings</code>.</p></dd></dl><dl><dt>raises Invalid_argument</dt><dd><p>if there is no such named substring.</p></dd></dl><dl><dt>raises Not_found</dt><dd><p>if the corresponding subpattern did not capture a substring.</p></dd></dl></dd></dl></section><section><header><h6 id="callouts"><a href="#callouts" class="anchor"></a>Callouts</h6></header><dl><dt class="spec type" id="type-callout_data"><a href="#type-callout_data" class="anchor"></a><code><span class="keyword">type </span>callout_data</code><code><span class="keyword"> = </span></code><code>{</code><table class="record"><tr id="type-callout_data.callout_number" class="anchored"><td class="def field"><a href="#type-callout_data.callout_number" class="anchor"></a><code>callout_number : int;</code></td><td class="doc"><p>Callout number</p></td></tr><tr id="type-callout_data.substrings" class="anchored"><td class="def field"><a href="#type-callout_data.substrings" class="anchor"></a><code>substrings : <a href="index.html#type-substrings">substrings</a>;</code></td><td class="doc"><p>Substrings matched so far</p></td></tr><tr id="type-callout_data.start_match" class="anchored"><td class="def field"><a href="#type-callout_data.start_match" class="anchor"></a><code>start_match : int;</code></td><td class="doc"><p>Subject start offset of current match attempt</p></td></tr><tr id="type-callout_data.current_position" class="anchored"><td class="def field"><a href="#type-callout_data.current_position" class="anchor"></a><code>current_position : int;</code></td><td class="doc"><p>Subject offset of current match pointer</p></td></tr><tr id="type-callout_data.capture_top" class="anchored"><td class="def field"><a href="#type-callout_data.capture_top" class="anchor"></a><code>capture_top : int;</code></td><td class="doc"><p>Number of the highest captured substring so far</p></td></tr><tr id="type-callout_data.capture_last" class="anchored"><td class="def field"><a href="#type-callout_data.capture_last" class="anchor"></a><code>capture_last : int;</code></td><td class="doc"><p>Number of the most recently captured substring</p></td></tr><tr id="type-callout_data.pattern_position" class="anchored"><td class="def field"><a href="#type-callout_data.pattern_position" class="anchor"></a><code>pattern_position : int;</code></td><td class="doc"><p>Offset of next match item in pattern string</p></td></tr><tr id="type-callout_data.next_item_length" class="anchored"><td class="def field"><a href="#type-callout_data.next_item_length" class="anchor"></a><code>next_item_length : int;</code></td><td class="doc"><p>Length of next match item in pattern string</p></td></tr></table><code>}</code></dt><dt class="spec type" id="type-callout"><a href="#type-callout" class="anchor"></a><code><span class="keyword">type </span>callout</code><code><span class="keyword"> = </span><a href="index.html#type-callout_data">callout_data</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Type of callout functions</p><p>Callouts are referred to in patterns as &quot;(?Cn)&quot; where &quot;n&quot; is a <code>callout_number</code> ranging from 0 to 255. Substrings captured so far are accessible as usual via <code>substrings</code>. You will have to consider <code>capture_top</code> and <code>capture_last</code> to know about the current state of valid substrings.</p><p>By raising exception <code>Backtrack</code> within a callout function, the user can force the pattern matching engine to backtrack to other possible solutions. Other exceptions will terminate matching immediately and return control to OCaml.</p></dd></dl></section><section><header><h6 id="matching-of-patterns-and-subpattern-extraction"><a href="#matching-of-patterns-and-subpattern-extraction" class="anchor"></a>Matching of patterns and subpattern extraction</h6></header><dl><dt class="spec value" id="val-pcre_exec"><a href="#val-pcre_exec" class="anchor"></a><code><span class="keyword">val </span>pcre_exec : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span>&#45;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span>&#45;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> ?&#8288;pat:string <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> int array</code></dt><dd><p><code>pcre_exec ?iflags ?flags ?rex ?pat ?pos ?callout subj</code> </p><dl><dt>returns</dt><dd><p>an array of offsets that describe the position of matched subpatterns in the string <code>subj</code> starting at position <code>pos</code> with pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise. The array also contains additional workspace needed by the match engine. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. Callouts are handled by <code>callout</code>.</p></dd></dl><dl><dt>parameter iflags</dt><dd><p>default = no extra flags</p></dd></dl><dl><dt>parameter flags</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter rex</dt><dd><p>default = matches whitespace</p></dd></dl><dl><dt>parameter pat</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter pos</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter callout</dt><dd><p>default = ignore callouts</p></dd></dl><dl><dt>raises Not_found</dt><dd><p>if pattern does not match.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-exec"><a href="#val-exec" class="anchor"></a><code><span class="keyword">val </span>exec : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span>&#45;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span>&#45;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> ?&#8288;pat:string <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-substrings">substrings</a></code></dt><dd><p><code>exec ?iflags ?flags ?rex ?pat ?pos ?callout subj</code> </p><dl><dt>returns</dt><dd><p>substring information on string <code>subj</code> starting at position <code>pos</code> with pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. Callouts are handled by <code>callout</code>.</p></dd></dl><dl><dt>parameter iflags</dt><dd><p>default = no extra flags</p></dd></dl><dl><dt>parameter flags</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter rex</dt><dd><p>default = matches whitespace</p></dd></dl><dl><dt>parameter pat</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter pos</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter callout</dt><dd><p>default = ignore callouts</p></dd></dl><dl><dt>raises Not_found</dt><dd><p>if pattern does not match.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-exec_all"><a href="#val-exec_all" class="anchor"></a><code><span class="keyword">val </span>exec_all : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span>&#45;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span>&#45;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> ?&#8288;pat:string <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-substrings">substrings</a> array</code></dt><dd><p><code>exec_all ?iflags ?flags ?rex ?pat ?pos ?callout subj</code> </p><dl><dt>returns</dt><dd><p>an array of substring information of all matching substrings in string <code>subj</code> starting at position <code>pos</code> with pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. Callouts are handled by <code>callout</code>.</p></dd></dl><dl><dt>parameter iflags</dt><dd><p>default = no extra flags</p></dd></dl><dl><dt>parameter flags</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter rex</dt><dd><p>default = matches whitespace</p></dd></dl><dl><dt>parameter pat</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter pos</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter callout</dt><dd><p>default = ignore callouts</p></dd></dl><dl><dt>raises Not_found</dt><dd><p>if pattern does not match.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-next_match"><a href="#val-next_match" class="anchor"></a><code><span class="keyword">val </span>next_match : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span>&#45;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span>&#45;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> ?&#8288;pat:string <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span>&#45;&gt;</span> <a href="index.html#type-substrings">substrings</a> <span>&#45;&gt;</span> <a href="index.html#type-substrings">substrings</a></code></dt><dd><p><code>next_match ?iflags ?flags ?rex ?pat ?pos ?callout substrs</code> </p><dl><dt>returns</dt><dd><p>substring information on the match that follows on the last match denoted by <code>substrs</code>, jumping over <code>pos</code> characters (also backwards!), using pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. Callouts are handled by <code>callout</code>.</p></dd></dl><dl><dt>parameter iflags</dt><dd><p>default = no extra flags</p></dd></dl><dl><dt>parameter flags</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter rex</dt><dd><p>default = matches whitespace</p></dd></dl><dl><dt>parameter pat</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter pos</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter callout</dt><dd><p>default = ignore callouts</p></dd></dl><dl><dt>raises Not_found</dt><dd><p>if pattern does not match.</p></dd></dl><dl><dt>raises Invalid_arg</dt><dd><p>if <code>pos</code> let matching start outside of the subject string.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-extract"><a href="#val-extract" class="anchor"></a><code><span class="keyword">val </span>extract : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span>&#45;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span>&#45;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> ?&#8288;pat:string <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;full_match:bool <span>&#45;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string array</code></dt><dd><p><code>extract ?iflags ?flags ?rex ?pat ?pos ?full_match ?callout subj</code></p><dl><dt>returns</dt><dd><p>the array of substrings that match <code>subj</code> starting at position <code>pos</code>, using pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. It includes the full match at index 0 when <code>full_match</code> is <code>true</code>, the captured substrings only when it is <code>false</code>. Callouts are handled by <code>callout</code>. If a subpattern did not capture a substring, the empty string is returned in the corresponding position instead.</p></dd></dl><dl><dt>parameter iflags</dt><dd><p>default = no extra flags</p></dd></dl><dl><dt>parameter flags</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter rex</dt><dd><p>default = matches whitespace</p></dd></dl><dl><dt>parameter pat</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter pos</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter full_match</dt><dd><p>default = true</p></dd></dl><dl><dt>parameter callout</dt><dd><p>default = ignore callouts</p></dd></dl><dl><dt>raises Not_found</dt><dd><p>if pattern does not match.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-extract_opt"><a href="#val-extract_opt" class="anchor"></a><code><span class="keyword">val </span>extract_opt : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span>&#45;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span>&#45;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> ?&#8288;pat:string <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;full_match:bool <span>&#45;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string option array</code></dt><dd><p><code>extract_opt ?iflags ?flags ?rex ?pat ?pos ?full_match ?callout subj</code></p><dl><dt>returns</dt><dd><p>the array of optional substrings that match <code>subj</code> starting at position <code>pos</code>, using pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. It includes <code>Some full_match_str</code> at index 0 when <code>full_match</code> is <code>true</code>, <code>Some captured-substrings</code> only when it is <code>false</code>. Callouts are handled by <code>callout</code>. If a subpattern did not capture a substring, <code>None</code> is returned in the corresponding position instead.</p></dd></dl><dl><dt>parameter iflags</dt><dd><p>default = no extra flags</p></dd></dl><dl><dt>parameter flags</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter rex</dt><dd><p>default = matches whitespace</p></dd></dl><dl><dt>parameter pat</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter pos</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter full_match</dt><dd><p>default = true</p></dd></dl><dl><dt>parameter callout</dt><dd><p>default = ignore callouts</p></dd></dl><dl><dt>raises Not_found</dt><dd><p>if pattern does not match.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-extract_all"><a href="#val-extract_all" class="anchor"></a><code><span class="keyword">val </span>extract_all : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span>&#45;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span>&#45;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> ?&#8288;pat:string <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;full_match:bool <span>&#45;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string array array</code></dt><dd><p><code>extract_all ?iflags ?flags ?rex ?pat ?pos ?full_match ?callout subj</code></p><dl><dt>returns</dt><dd><p>an array of arrays of all matching substrings that match <code>subj</code> starting at position <code>pos</code>, using pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. It includes the full match at index 0 of the extracted string arrays when <code>full_match</code> is <code>true</code>, the captured substrings only when it is <code>false</code>. Callouts are handled by <code>callout</code>.</p></dd></dl><dl><dt>parameter iflags</dt><dd><p>default = no extra flags</p></dd></dl><dl><dt>parameter flags</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter rex</dt><dd><p>default = matches whitespace</p></dd></dl><dl><dt>parameter pat</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter pos</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter full_match</dt><dd><p>default = true</p></dd></dl><dl><dt>parameter callout</dt><dd><p>default = ignore callouts</p></dd></dl><dl><dt>raises Not_found</dt><dd><p>if pattern does not match.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-extract_all_opt"><a href="#val-extract_all_opt" class="anchor"></a><code><span class="keyword">val </span>extract_all_opt : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span>&#45;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span>&#45;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> ?&#8288;pat:string <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;full_match:bool <span>&#45;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string option array array</code></dt><dd><p><code>extract_all_opt
      ?iflags ?flags ?rex ?pat ?pos ?full_match ?callout subj</code></p><dl><dt>returns</dt><dd><p>an array of arrays of all optional matching substrings that match <code>subj</code> starting at position <code>pos</code>, using pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. It includes <code>Some full_match_str</code> at index 0 of the extracted string arrays when <code>full_match</code> is <code>true</code>, <code>Some captured_substrings</code> only when it is <code>false</code>. Callouts are handled by <code>callout</code>. If a subpattern did not capture a substring, <code>None</code> is returned in the corresponding position instead.</p></dd></dl><dl><dt>parameter iflags</dt><dd><p>default = no extra flags</p></dd></dl><dl><dt>parameter flags</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter rex</dt><dd><p>default = matches whitespace</p></dd></dl><dl><dt>parameter pat</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter pos</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter full_match</dt><dd><p>default = true</p></dd></dl><dl><dt>parameter callout</dt><dd><p>default = ignore callouts</p></dd></dl><dl><dt>raises Not_found</dt><dd><p>if pattern does not match.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-pmatch"><a href="#val-pmatch" class="anchor"></a><code><span class="keyword">val </span>pmatch : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span>&#45;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span>&#45;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> ?&#8288;pat:string <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> bool</code></dt><dd><p><code>pmatch ?iflags ?flags ?rex ?pat ?pos ?callout subj</code> </p><dl><dt>returns</dt><dd><p><code>true</code> if <code>subj</code> is matched by pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise, starting at position <code>pos</code>. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. Callouts are handled by <code>callout</code>.</p></dd></dl><dl><dt>parameter iflags</dt><dd><p>default = no extra flags</p></dd></dl><dl><dt>parameter flags</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter rex</dt><dd><p>default = matches whitespace</p></dd></dl><dl><dt>parameter pat</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter pos</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter callout</dt><dd><p>default = ignore callouts</p></dd></dl></dd></dl></section><section><header><h6 id="string-substitution"><a href="#string-substitution" class="anchor"></a>String substitution</h6></header><dl><dt class="spec type" id="type-substitution"><a href="#type-substitution" class="anchor"></a><code><span class="keyword">type </span>substitution</code></dt><dd><p>Information on substitution patterns</p></dd></dl><dl><dt class="spec value" id="val-subst"><a href="#val-subst" class="anchor"></a><code><span class="keyword">val </span>subst : string <span>&#45;&gt;</span> <a href="index.html#type-substitution">substitution</a></code></dt><dd><p><code>subst str</code> converts the string <code>str</code> representing a substitution pattern to the internal representation</p><p>The contents of the substitution string <code>str</code> can be normal text mixed with any of the following (mostly as in PERL):</p><ul><li><em>$[0-9]+</em> - a &quot;$&quot; immediately followed by an arbitrary number. &quot;$0&quot; stands for the name of the executable, any other number for the n-th backreference.</li><li><em>$&amp;</em> - the whole matched pattern</li><li><em>$`</em> - the text before the match</li><li><em>$'</em> - the text after the match</li><li><em>$+</em> - the last group that matched</li><li><em>$$</em> - a single &quot;$&quot;</li><li><em>$!</em> - delimiter which does not appear in the substitution. Can be used to part &quot;$<code>0-9</code>+&quot; from an immediately following other number.</li></ul></dd></dl><dl><dt class="spec value" id="val-replace"><a href="#val-replace" class="anchor"></a><code><span class="keyword">val </span>replace : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span>&#45;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span>&#45;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> ?&#8288;pat:string <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;itempl:<a href="index.html#type-substitution">substitution</a> <span>&#45;&gt;</span> ?&#8288;templ:string <span>&#45;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt><dd><p><code>replace ?iflags ?flags ?rex ?pat ?pos ?itempl ?templ ?callout subj</code> replaces all substrings of <code>subj</code> matching pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise, starting at position <code>pos</code> with the substitution string <code>templ</code> when given, <code>itempl</code> otherwise. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. Callouts are handled by <code>callout</code>.</p><dl><dt>parameter iflags</dt><dd><p>default = no extra flags</p></dd></dl><dl><dt>parameter flags</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter rex</dt><dd><p>default = matches whitespace</p></dd></dl><dl><dt>parameter pat</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter pos</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter itempl</dt><dd><p>default = empty string</p></dd></dl><dl><dt>parameter templ</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter callout</dt><dd><p>default = ignore callouts</p></dd></dl><dl><dt>raises Failure</dt><dd><p>if there are backreferences to nonexistent subpatterns.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-qreplace"><a href="#val-qreplace" class="anchor"></a><code><span class="keyword">val </span>qreplace : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span>&#45;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span>&#45;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> ?&#8288;pat:string <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;templ:string <span>&#45;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt><dd><p><code>qreplace ?iflags ?flags ?rex ?pat ?pos ?templ ?callout subj</code> replaces all substrings of <code>subj</code> matching pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise, starting at position <code>pos</code> with the string <code>templ</code>. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. Callouts are handled by <code>callout</code>.</p><dl><dt>parameter iflags</dt><dd><p>default = no extra flags</p></dd></dl><dl><dt>parameter flags</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter rex</dt><dd><p>default = matches whitespace</p></dd></dl><dl><dt>parameter pat</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter pos</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter templ</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter callout</dt><dd><p>default = ignore callouts</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-substitute_substrings"><a href="#val-substitute_substrings" class="anchor"></a><code><span class="keyword">val </span>substitute_substrings : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span>&#45;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span>&#45;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> ?&#8288;pat:string <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span>&#45;&gt;</span> subst:(<a href="index.html#type-substrings">substrings</a> <span>&#45;&gt;</span> string) <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt><dd><p><code>substitute_substrings ?iflags ?flags ?rex ?pat ?pos ?callout ~subst subj</code> replaces all substrings of <code>subj</code> matching pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise, starting at position <code>pos</code> with the result of function <code>subst</code> applied to the substrings of the match. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. Callouts are handled by <code>callout</code>.</p><dl><dt>parameter iflags</dt><dd><p>default = no extra flags</p></dd></dl><dl><dt>parameter flags</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter rex</dt><dd><p>default = matches whitespace</p></dd></dl><dl><dt>parameter pat</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter pos</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter callout</dt><dd><p>default = ignore callouts</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-substitute"><a href="#val-substitute" class="anchor"></a><code><span class="keyword">val </span>substitute : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span>&#45;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span>&#45;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> ?&#8288;pat:string <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span>&#45;&gt;</span> subst:(string <span>&#45;&gt;</span> string) <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt><dd><p><code>substitute ?iflags ?flags ?rex ?pat ?pos ?callout ~subst subj</code> replaces all substrings of <code>subj</code> matching pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise, starting at position <code>pos</code> with the result of function <code>subst</code> applied to the match. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. Callouts are handled by <code>callout</code>.</p><dl><dt>parameter iflags</dt><dd><p>default = no extra flags</p></dd></dl><dl><dt>parameter flags</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter rex</dt><dd><p>default = matches whitespace</p></dd></dl><dl><dt>parameter pat</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter pos</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter callout</dt><dd><p>default = ignore callouts</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-replace_first"><a href="#val-replace_first" class="anchor"></a><code><span class="keyword">val </span>replace_first : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span>&#45;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span>&#45;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> ?&#8288;pat:string <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;itempl:<a href="index.html#type-substitution">substitution</a> <span>&#45;&gt;</span> ?&#8288;templ:string <span>&#45;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt><dd><p><code>replace_first ?iflags ?flags ?rex ?pat ?pos ?itempl ?templ ?callout subj</code> replaces the first substring of <code>subj</code> matching pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise, starting at position <code>pos</code> with the substitution string <code>templ</code> when given, <code>itempl</code> otherwise. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. Callouts are handled by <code>callout</code>.</p><dl><dt>parameter iflags</dt><dd><p>default = no extra flags</p></dd></dl><dl><dt>parameter flags</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter rex</dt><dd><p>default = matches whitespace</p></dd></dl><dl><dt>parameter pat</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter pos</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter itempl</dt><dd><p>default = empty string</p></dd></dl><dl><dt>parameter templ</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter callout</dt><dd><p>default = ignore callouts</p></dd></dl><dl><dt>raises Failure</dt><dd><p>if there are backreferences to nonexistent subpatterns.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-qreplace_first"><a href="#val-qreplace_first" class="anchor"></a><code><span class="keyword">val </span>qreplace_first : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span>&#45;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span>&#45;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> ?&#8288;pat:string <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;templ:string <span>&#45;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt><dd><p><code>qreplace_first ?iflags ?flags ?rex ?pat ?pos ?templ ?callout subj</code> replaces the first substring of <code>subj</code> matching pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise, starting at position <code>pos</code> with the string <code>templ</code>. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. Callouts are handled by <code>callout</code>.</p><dl><dt>parameter iflags</dt><dd><p>default = no extra flags</p></dd></dl><dl><dt>parameter flags</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter rex</dt><dd><p>default = matches whitespace</p></dd></dl><dl><dt>parameter pat</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter pos</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter templ</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter callout</dt><dd><p>default = ignore callouts</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-substitute_substrings_first"><a href="#val-substitute_substrings_first" class="anchor"></a><code><span class="keyword">val </span>substitute_substrings_first : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span>&#45;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span>&#45;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> ?&#8288;pat:string <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span>&#45;&gt;</span> subst:(<a href="index.html#type-substrings">substrings</a> <span>&#45;&gt;</span> string) <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt><dd><p><code>substitute_substrings_first
       ?iflags ?flags ?rex ?pat ?pos ?callout ~subst subj</code> replaces the first substring of <code>subj</code> matching pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise, starting at position <code>pos</code> with the result of function <code>subst</code> applied to the substrings of the match. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. Callouts are handled by <code>callout</code>.</p><dl><dt>parameter iflags</dt><dd><p>default = no extra flags</p></dd></dl><dl><dt>parameter flags</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter rex</dt><dd><p>default = matches whitespace</p></dd></dl><dl><dt>parameter pat</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter pos</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter callout</dt><dd><p>default = ignore callouts</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-substitute_first"><a href="#val-substitute_first" class="anchor"></a><code><span class="keyword">val </span>substitute_first : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span>&#45;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span>&#45;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> ?&#8288;pat:string <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span>&#45;&gt;</span> subst:(string <span>&#45;&gt;</span> string) <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt><dd><p><code>substitute_first ?iflags ?flags ?rex ?pat ?pos ?callout ~subst subj</code> replaces the first substring of <code>subj</code> matching pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise, starting at position <code>pos</code> with the result of function <code>subst</code> applied to the match. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. Callouts are handled by <code>callout</code>.</p><dl><dt>parameter iflags</dt><dd><p>default = no extra flags</p></dd></dl><dl><dt>parameter flags</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter rex</dt><dd><p>default = matches whitespace</p></dd></dl><dl><dt>parameter pat</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter pos</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter callout</dt><dd><p>default = ignore callouts</p></dd></dl></dd></dl></section><section><header><h6 id="splitting"><a href="#splitting" class="anchor"></a>Splitting</h6></header><dl><dt class="spec value" id="val-split"><a href="#val-split" class="anchor"></a><code><span class="keyword">val </span>split : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span>&#45;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span>&#45;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> ?&#8288;pat:string <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;max:int <span>&#45;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string list</code></dt><dd><p><code>split ?iflags ?flags ?rex ?pat ?pos ?max ?callout subj</code> splits <code>subj</code> into a list of at most <code>max</code> strings, using as delimiter pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise, starting at position <code>pos</code>. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. If <code>max</code> is zero, trailing empty fields are stripped. If it is negative, it is treated as arbitrarily large. If neither <code>pat</code> nor <code>rex</code> are specified, leading whitespace will be stripped! Should behave exactly as in PERL. Callouts are handled by <code>callout</code>.</p><dl><dt>parameter iflags</dt><dd><p>default = no extra flags</p></dd></dl><dl><dt>parameter flags</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter rex</dt><dd><p>default = matches whitespace</p></dd></dl><dl><dt>parameter pat</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter pos</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter max</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter callout</dt><dd><p>default = ignore callouts</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-asplit"><a href="#val-asplit" class="anchor"></a><code><span class="keyword">val </span>asplit : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span>&#45;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span>&#45;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> ?&#8288;pat:string <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;max:int <span>&#45;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string array</code></dt><dd><p><code>asplit ?iflags ?flags ?rex ?pat ?pos ?max ?callout subj</code> same as <a href="index.html#val-split"><code>Pcre.split</code></a> but </p><dl><dt>returns</dt><dd><p>an array instead of a list.</p></dd></dl></dd></dl><dl><dt class="spec type" id="type-split_result"><a href="#type-split_result" class="anchor"></a><code><span class="keyword">type </span>split_result</code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-split_result.Text" class="anchored"><td class="def constructor"><a href="#type-split_result.Text" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Text</span><span class="keyword"> of </span>string</code></td><td class="doc"><p>Text part of split string</p></td></tr><tr id="type-split_result.Delim" class="anchored"><td class="def constructor"><a href="#type-split_result.Delim" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Delim</span><span class="keyword"> of </span>string</code></td><td class="doc"><p>Delimiter part of split string</p></td></tr><tr id="type-split_result.Group" class="anchored"><td class="def constructor"><a href="#type-split_result.Group" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Group</span><span class="keyword"> of </span>int<span class="keyword"> * </span>string</code></td><td class="doc"><p>Subgroup of matched delimiter (subgroup_nr, subgroup_str)</p></td></tr><tr id="type-split_result.NoGroup" class="anchored"><td class="def constructor"><a href="#type-split_result.NoGroup" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">NoGroup</span></code></td><td class="doc"><p>Unmatched subgroup</p></td></tr></table></dt><dd><p>Result of a <a href="index.html#val-full_split"><code>Pcre.full_split</code></a></p></dd></dl><dl><dt class="spec value" id="val-full_split"><a href="#val-full_split" class="anchor"></a><code><span class="keyword">val </span>full_split : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span>&#45;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span>&#45;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> ?&#8288;pat:string <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;max:int <span>&#45;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-split_result">split_result</a> list</code></dt><dd><p><code>full_split ?iflags ?flags ?rex ?pat ?pos ?max ?callout subj</code> splits <code>subj</code> into a list of at most <code>max</code> elements of type &quot;split_result&quot;, using as delimiter pattern <code>pat</code> when given, regular expression <code>rex</code> otherwise, starting at position <code>pos</code>. Uses <code>flags</code> when given, the precompiled <code>iflags</code> otherwise. If <code>max</code> is zero, trailing empty fields are stripped. If it is negative, it is treated as arbitrarily large. Should behave exactly as in PERL. Callouts are handled by <code>callout</code>.</p><dl><dt>parameter iflags</dt><dd><p>default = no extra flags</p></dd></dl><dl><dt>parameter flags</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter rex</dt><dd><p>default = matches whitespace</p></dd></dl><dl><dt>parameter pat</dt><dd><p>default = ignored</p></dd></dl><dl><dt>parameter pos</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter max</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter callout</dt><dd><p>default = ignore callouts</p></dd></dl></dd></dl></section><section><header><h6 id="additional-convenience-functions"><a href="#additional-convenience-functions" class="anchor"></a>Additional convenience functions</h6></header><dl><dt class="spec value" id="val-foreach_line"><a href="#val-foreach_line" class="anchor"></a><code><span class="keyword">val </span>foreach_line : ?&#8288;ic:Pervasives.in_channel <span>&#45;&gt;</span> (string <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit</code></dt><dd><p><code>foreach_line ?ic f</code> applies <code>f</code> to each line in inchannel <code>ic</code> until the end-of-file is reached.</p><dl><dt>parameter ic</dt><dd><p>default = stdin</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-foreach_file"><a href="#val-foreach_file" class="anchor"></a><code><span class="keyword">val </span>foreach_file : string list <span>&#45;&gt;</span> (string <span>&#45;&gt;</span> Pervasives.in_channel <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit</code></dt><dd><p><code>foreach_file filenames f</code> opens each file in the list <code>filenames</code> for input and applies <code>f</code> to each filename and the corresponding channel. Channels are closed after each operation (even when exceptions occur - they get reraised afterwards!).</p></dd></dl></section><section><header><h6 id="unsafe-stuff---use-with-caution!"><a href="#unsafe-stuff---use-with-caution!" class="anchor"></a><b>UNSAFE STUFF - USE WITH CAUTION!</b></h6></header><dl><dt class="spec external" id="val-unsafe_pcre_exec"><a href="#val-unsafe_pcre_exec" class="anchor"></a><code><span class="keyword">val </span>unsafe_pcre_exec : <a href="index.html#type-irflag">irflag</a> <span>&#45;&gt;</span> <a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> pos:int <span>&#45;&gt;</span> subj_start:int <span>&#45;&gt;</span> subj:string <span>&#45;&gt;</span> int array <span>&#45;&gt;</span> <a href="index.html#type-callout">callout</a> option <span>&#45;&gt;</span> unit</code></dt><dd><p><code>unsafe_pcre_exec flags rex ~pos ~subj_start ~subj offset_vector</code>. You should read the C-source to know what happens. If you do not understand it - <b>don't use this function!</b></p></dd></dl><dl><dt class="spec value" id="val-make_ovector"><a href="#val-make_ovector" class="anchor"></a><code><span class="keyword">val </span>make_ovector : <a href="index.html#type-regexp">regexp</a> <span>&#45;&gt;</span> int<span class="keyword"> * </span>int array</code></dt><dd><p><code>make_ovector regexp</code> calculates the tuple (subgroups2, ovector) which is the number of subgroup offsets and the offset array.</p></dd></dl></section></div></body></html>