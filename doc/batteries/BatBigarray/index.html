<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>BatBigarray (batteries.BatBigarray)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">batteries</a> &#x00BB; BatBigarray</nav><h1>Module <code>BatBigarray</code></h1><p>Additional and modified functions for big arrays.</p><nav class="toc"><ul><li><a href="#element-kinds">Element kinds</a></li><li><a href="#array-layouts">Array layouts</a></li><li><a href="#supported-layouts">Supported layouts</a></li><li><a href="#one-dimensional-arrays">One-dimensional arrays</a></li><li><a href="#two-dimensional-arrays">Two-dimensional arrays</a></li><li><a href="#three-dimensional-arrays">Three-dimensional arrays</a></li><li><a href="#coercions-between-generic-big-arrays-and-fixed-dimension-big-arrays">Coercions between generic big arrays and fixed-dimension big arrays</a></li><li><a href="#re-shaping-big-arrays">Re-shaping big arrays</a></li></ul></nav></header><aside><p>Large, multi-dimensional, numerical arrays.</p><p>This module implements multi-dimensional arrays of integers and floating-point numbers, thereafter referred to as ``big arrays''. The implementation allows efficient sharing of large numerical arrays between OCaml code and C or Fortran numerical libraries.</p><p>Concerning the naming conventions, users of this module are encouraged to do <code>open Bigarray</code> in their source, then refer to array types and operations via short dot notation, e.g. <code>Array1.t</code> or <code>Array2.sub</code>.</p><p>Big arrays support all the OCaml ad-hoc polymorphic operations:</p><ul><li>comparisons (<code>=</code>, <code>&lt;&gt;</code>, <code>&lt;=</code>, etc, as well as <span class="xref-unresolved" title="unresolved reference to &quot;Pervasives.compare&quot;"><code>Pervasives</code>.compare</span>);</li><li>hashing (module <code>Hash</code>);</li><li>and structured input-output (<span class="xref-unresolved" title="unresolved reference to &quot;Pervasives.output_value&quot;"><code>Pervasives</code>.output_value</span> and <span class="xref-unresolved" title="unresolved reference to &quot;Pervasives.input_value&quot;"><code>Pervasives</code>.input_value</span>, as well as the functions from the <code>Marshal</code> module).</li></ul><p>This module replaces Stdlib's <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Bigarray.html">Bigarray</a> module.</p><dl><dt>author</dt><dd>Michel Serrano (Base library)</dd></dl><dl><dt>author</dt><dd>Xavier Leroy (Base library)</dd></dl><dl><dt>author</dt><dd>David Teller</dd></dl></aside><section><header><h6 id="element-kinds"><a href="#element-kinds" class="anchor"></a>Element kinds</h6></header><aside><p>Big arrays can contain elements of the following kinds:</p><ul><li>IEEE single precision (32 bits) floating-point numbers (<span class="xref-unresolved" title="unresolved reference to &quot;Bigarray.float32_elt&quot;"><code>Bigarray</code>.float32_elt</span>),</li><li>IEEE double precision (64 bits) floating-point numbers (<span class="xref-unresolved" title="unresolved reference to &quot;Bigarray.float64_elt&quot;"><code>Bigarray</code>.float64_elt</span>),</li><li>IEEE single precision (2 * 32 bits) floating-point complex numbers (<span class="xref-unresolved" title="unresolved reference to &quot;Bigarray.complex32_elt&quot;"><code>Bigarray</code>.complex32_elt</span>),</li><li>IEEE double precision (2 * 64 bits) floating-point complex numbers (<span class="xref-unresolved" title="unresolved reference to &quot;Bigarray.complex64_elt&quot;"><code>Bigarray</code>.complex64_elt</span>),</li><li>8-bit integers (signed or unsigned) (<span class="xref-unresolved" title="unresolved reference to &quot;Bigarray.int8_signed_elt&quot;"><code>Bigarray</code>.int8_signed_elt</span> or <span class="xref-unresolved" title="unresolved reference to &quot;Bigarray.int8_unsigned_elt&quot;"><code>Bigarray</code>.int8_unsigned_elt</span>),</li><li>16-bit integers (signed or unsigned) (<span class="xref-unresolved" title="unresolved reference to &quot;Bigarray.int16_signed_elt&quot;"><code>Bigarray</code>.int16_signed_elt</span> or <span class="xref-unresolved" title="unresolved reference to &quot;Bigarray.int16_unsigned_elt&quot;"><code>Bigarray</code>.int16_unsigned_elt</span>),</li><li>OCaml integers (signed, 31 bits on 32-bit architectures, 63 bits on 64-bit architectures) (<span class="xref-unresolved" title="unresolved reference to &quot;Bigarray.int_elt&quot;"><code>Bigarray</code>.int_elt</span>),</li><li>32-bit signed integer (<span class="xref-unresolved" title="unresolved reference to &quot;Bigarray.int32_elt&quot;"><code>Bigarray</code>.int32_elt</span>),</li><li>64-bit signed integers (<span class="xref-unresolved" title="unresolved reference to &quot;Bigarray.int64_elt&quot;"><code>Bigarray</code>.int64_elt</span>),</li><li>platform-native signed integers (32 bits on 32-bit architectures, 64 bits on 64-bit architectures) (<span class="xref-unresolved" title="unresolved reference to &quot;Bigarray.nativeint_elt&quot;"><code>Bigarray</code>.nativeint_elt</span>).</li></ul><p>Each element kind is represented at the type level by one of the abstract types defined below.</p></aside><dl><dt class="spec type" id="type-float32_elt"><a href="#type-float32_elt" class="anchor"></a><code><span class="keyword">type </span>float32_elt</code><code><span class="keyword"> = </span>Bigarray.float32_elt</code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-float32_elt.Float32_elt" class="anchored"><td class="def constructor"><a href="#type-float32_elt.Float32_elt" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Float32_elt</span></code></td></tr></table></dt><dt class="spec type" id="type-float64_elt"><a href="#type-float64_elt" class="anchor"></a><code><span class="keyword">type </span>float64_elt</code><code><span class="keyword"> = </span>Bigarray.float64_elt</code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-float64_elt.Float64_elt" class="anchored"><td class="def constructor"><a href="#type-float64_elt.Float64_elt" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Float64_elt</span></code></td></tr></table></dt><dt class="spec type" id="type-complex32_elt"><a href="#type-complex32_elt" class="anchor"></a><code><span class="keyword">type </span>complex32_elt</code><code><span class="keyword"> = </span>Bigarray.complex32_elt</code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-complex32_elt.Complex32_elt" class="anchored"><td class="def constructor"><a href="#type-complex32_elt.Complex32_elt" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Complex32_elt</span></code></td></tr></table></dt><dt class="spec type" id="type-complex64_elt"><a href="#type-complex64_elt" class="anchor"></a><code><span class="keyword">type </span>complex64_elt</code><code><span class="keyword"> = </span>Bigarray.complex64_elt</code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-complex64_elt.Complex64_elt" class="anchored"><td class="def constructor"><a href="#type-complex64_elt.Complex64_elt" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Complex64_elt</span></code></td></tr></table></dt><dt class="spec type" id="type-int8_signed_elt"><a href="#type-int8_signed_elt" class="anchor"></a><code><span class="keyword">type </span>int8_signed_elt</code><code><span class="keyword"> = </span>Bigarray.int8_signed_elt</code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-int8_signed_elt.Int8_signed_elt" class="anchored"><td class="def constructor"><a href="#type-int8_signed_elt.Int8_signed_elt" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Int8_signed_elt</span></code></td></tr></table></dt><dt class="spec type" id="type-int8_unsigned_elt"><a href="#type-int8_unsigned_elt" class="anchor"></a><code><span class="keyword">type </span>int8_unsigned_elt</code><code><span class="keyword"> = </span>Bigarray.int8_unsigned_elt</code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-int8_unsigned_elt.Int8_unsigned_elt" class="anchored"><td class="def constructor"><a href="#type-int8_unsigned_elt.Int8_unsigned_elt" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Int8_unsigned_elt</span></code></td></tr></table></dt><dt class="spec type" id="type-int16_signed_elt"><a href="#type-int16_signed_elt" class="anchor"></a><code><span class="keyword">type </span>int16_signed_elt</code><code><span class="keyword"> = </span>Bigarray.int16_signed_elt</code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-int16_signed_elt.Int16_signed_elt" class="anchored"><td class="def constructor"><a href="#type-int16_signed_elt.Int16_signed_elt" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Int16_signed_elt</span></code></td></tr></table></dt><dt class="spec type" id="type-int16_unsigned_elt"><a href="#type-int16_unsigned_elt" class="anchor"></a><code><span class="keyword">type </span>int16_unsigned_elt</code><code><span class="keyword"> = </span>Bigarray.int16_unsigned_elt</code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-int16_unsigned_elt.Int16_unsigned_elt" class="anchored"><td class="def constructor"><a href="#type-int16_unsigned_elt.Int16_unsigned_elt" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Int16_unsigned_elt</span></code></td></tr></table></dt><dt class="spec type" id="type-int_elt"><a href="#type-int_elt" class="anchor"></a><code><span class="keyword">type </span>int_elt</code><code><span class="keyword"> = </span>Bigarray.int_elt</code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-int_elt.Int_elt" class="anchored"><td class="def constructor"><a href="#type-int_elt.Int_elt" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Int_elt</span></code></td></tr></table></dt><dt class="spec type" id="type-int32_elt"><a href="#type-int32_elt" class="anchor"></a><code><span class="keyword">type </span>int32_elt</code><code><span class="keyword"> = </span>Bigarray.int32_elt</code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-int32_elt.Int32_elt" class="anchored"><td class="def constructor"><a href="#type-int32_elt.Int32_elt" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Int32_elt</span></code></td></tr></table></dt><dt class="spec type" id="type-int64_elt"><a href="#type-int64_elt" class="anchor"></a><code><span class="keyword">type </span>int64_elt</code><code><span class="keyword"> = </span>Bigarray.int64_elt</code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-int64_elt.Int64_elt" class="anchored"><td class="def constructor"><a href="#type-int64_elt.Int64_elt" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Int64_elt</span></code></td></tr></table></dt><dt class="spec type" id="type-nativeint_elt"><a href="#type-nativeint_elt" class="anchor"></a><code><span class="keyword">type </span>nativeint_elt</code><code><span class="keyword"> = </span>Bigarray.nativeint_elt</code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-nativeint_elt.Nativeint_elt" class="anchored"><td class="def constructor"><a href="#type-nativeint_elt.Nativeint_elt" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Nativeint_elt</span></code></td></tr></table></dt><dt class="spec type" id="type-kind"><a href="#type-kind" class="anchor"></a><code><span class="keyword">type </span>('a, 'b) kind</code><code><span class="keyword"> = </span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>) Bigarray.kind</code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-kind.Float32" class="anchored"><td class="def constructor"><a href="#type-kind.Float32" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Float32</span> <span class="keyword">:</span> (float, <a href="index.html#type-float32_elt">float32_elt</a>) <a href="index.html#type-kind">kind</a></code></td></tr><tr id="type-kind.Float64" class="anchored"><td class="def constructor"><a href="#type-kind.Float64" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Float64</span> <span class="keyword">:</span> (float, <a href="index.html#type-float64_elt">float64_elt</a>) <a href="index.html#type-kind">kind</a></code></td></tr><tr id="type-kind.Int8_signed" class="anchored"><td class="def constructor"><a href="#type-kind.Int8_signed" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Int8_signed</span> <span class="keyword">:</span> (int, <a href="index.html#type-int8_signed_elt">int8_signed_elt</a>) <a href="index.html#type-kind">kind</a></code></td></tr><tr id="type-kind.Int8_unsigned" class="anchored"><td class="def constructor"><a href="#type-kind.Int8_unsigned" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Int8_unsigned</span> <span class="keyword">:</span> (int, <a href="index.html#type-int8_unsigned_elt">int8_unsigned_elt</a>) <a href="index.html#type-kind">kind</a></code></td></tr><tr id="type-kind.Int16_signed" class="anchored"><td class="def constructor"><a href="#type-kind.Int16_signed" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Int16_signed</span> <span class="keyword">:</span> (int, <a href="index.html#type-int16_signed_elt">int16_signed_elt</a>) <a href="index.html#type-kind">kind</a></code></td></tr><tr id="type-kind.Int16_unsigned" class="anchored"><td class="def constructor"><a href="#type-kind.Int16_unsigned" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Int16_unsigned</span> <span class="keyword">:</span> (int, <a href="index.html#type-int16_unsigned_elt">int16_unsigned_elt</a>) <a href="index.html#type-kind">kind</a></code></td></tr><tr id="type-kind.Int32" class="anchored"><td class="def constructor"><a href="#type-kind.Int32" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Int32</span> <span class="keyword">:</span> (int32, <a href="index.html#type-int32_elt">int32_elt</a>) <a href="index.html#type-kind">kind</a></code></td></tr><tr id="type-kind.Int64" class="anchored"><td class="def constructor"><a href="#type-kind.Int64" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Int64</span> <span class="keyword">:</span> (int64, <a href="index.html#type-int64_elt">int64_elt</a>) <a href="index.html#type-kind">kind</a></code></td></tr><tr id="type-kind.Int" class="anchored"><td class="def constructor"><a href="#type-kind.Int" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Int</span> <span class="keyword">:</span> (int, <a href="index.html#type-int_elt">int_elt</a>) <a href="index.html#type-kind">kind</a></code></td></tr><tr id="type-kind.Nativeint" class="anchored"><td class="def constructor"><a href="#type-kind.Nativeint" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Nativeint</span> <span class="keyword">:</span> (nativeint, <a href="index.html#type-nativeint_elt">nativeint_elt</a>) <a href="index.html#type-kind">kind</a></code></td></tr><tr id="type-kind.Complex32" class="anchored"><td class="def constructor"><a href="#type-kind.Complex32" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Complex32</span> <span class="keyword">:</span> (Complex.t, <a href="index.html#type-complex32_elt">complex32_elt</a>) <a href="index.html#type-kind">kind</a></code></td></tr><tr id="type-kind.Complex64" class="anchored"><td class="def constructor"><a href="#type-kind.Complex64" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Complex64</span> <span class="keyword">:</span> (Complex.t, <a href="index.html#type-complex64_elt">complex64_elt</a>) <a href="index.html#type-kind">kind</a></code></td></tr><tr id="type-kind.Char" class="anchored"><td class="def constructor"><a href="#type-kind.Char" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Char</span> <span class="keyword">:</span> (char, <a href="index.html#type-int8_unsigned_elt">int8_unsigned_elt</a>) <a href="index.html#type-kind">kind</a></code></td><td class="doc"><p>To each element kind is associated an OCaml type, which is the type of OCaml values that can be stored in the big array or read back from it. This type is not necessarily the same as the type of the array elements proper: for instance, a big array whose elements are of kind <code>float32_elt</code> contains 32-bit single precision floats, but reading or writing one of its elements from OCaml uses the OCaml type <code>float</code>, which is 64-bit double precision floats.</p><p># 135 &quot;src/batBigarray.mliv&quot; # 136 &quot;src/batBigarray.mliv&quot; # 137 &quot;src/batBigarray.mliv&quot; # 138 &quot;src/batBigarray.mliv&quot; # 139 &quot;src/batBigarray.mliv&quot; # 140 &quot;src/batBigarray.mliv&quot; The GADT type <code>('a, 'b) kind</code> captures this association of an OCaml type <code>'a</code> for values read or written in the big array, and of an element kind <code>'b</code> which represents the actual contents of the big array. Its constructors list all possible associations of OCaml types with element kinds, and are re-exported below for backward-compatibility reasons.</p><p>Using a generalized algebraic datatype (GADT) here allows to write well-typed polymorphic functions whose return type depend on the argument type, such as:</p><pre><code class="ml">let zero : type a b. (a, b) kind -&gt; a = function
  | Float32 -&gt; 0.0 | Complex32 -&gt; Complex.zero
  | Float64 -&gt; 0.0 | Complex64 -&gt; Complex.zero
  | Int8_signed -&gt; 0 | Int8_unsigned -&gt; 0
  | Int16_signed -&gt; 0 | Int16_unsigned -&gt; 0
  | Int32 -&gt; 0l | Int64 -&gt; 0L
  | Int -&gt; 0 | Nativeint -&gt; 0n
  | Char -&gt; '\000'</code></pre></td></tr></table></dt></dl><dl><dt class="spec value" id="val-float32"><a href="#val-float32" class="anchor"></a><code><span class="keyword">val </span>float32 : (float, <a href="index.html#type-float32_elt">float32_elt</a>) <a href="index.html#type-kind">kind</a></code></dt><dd><p>See <span class="xref-unresolved" title="unresolved reference to &quot;Bigarray.char&quot;"><code>Bigarray</code>.char</span>.</p></dd></dl><dl><dt class="spec value" id="val-float64"><a href="#val-float64" class="anchor"></a><code><span class="keyword">val </span>float64 : (float, <a href="index.html#type-float64_elt">float64_elt</a>) <a href="index.html#type-kind">kind</a></code></dt><dd><p>See <span class="xref-unresolved" title="unresolved reference to &quot;Bigarray.char&quot;"><code>Bigarray</code>.char</span>.</p></dd></dl><dl><dt class="spec value" id="val-complex32"><a href="#val-complex32" class="anchor"></a><code><span class="keyword">val </span>complex32 : (Complex.t, <a href="index.html#type-complex32_elt">complex32_elt</a>) <a href="index.html#type-kind">kind</a></code></dt><dd><p>See <span class="xref-unresolved" title="unresolved reference to &quot;Bigarray.char&quot;"><code>Bigarray</code>.char</span>.</p></dd></dl><dl><dt class="spec value" id="val-complex64"><a href="#val-complex64" class="anchor"></a><code><span class="keyword">val </span>complex64 : (Complex.t, <a href="index.html#type-complex64_elt">complex64_elt</a>) <a href="index.html#type-kind">kind</a></code></dt><dd><p>See <span class="xref-unresolved" title="unresolved reference to &quot;Bigarray.char&quot;"><code>Bigarray</code>.char</span>.</p></dd></dl><dl><dt class="spec value" id="val-int8_signed"><a href="#val-int8_signed" class="anchor"></a><code><span class="keyword">val </span>int8_signed : (int, <a href="index.html#type-int8_signed_elt">int8_signed_elt</a>) <a href="index.html#type-kind">kind</a></code></dt><dd><p>See <span class="xref-unresolved" title="unresolved reference to &quot;Bigarray.char&quot;"><code>Bigarray</code>.char</span>.</p></dd></dl><dl><dt class="spec value" id="val-int8_unsigned"><a href="#val-int8_unsigned" class="anchor"></a><code><span class="keyword">val </span>int8_unsigned : (int, <a href="index.html#type-int8_unsigned_elt">int8_unsigned_elt</a>) <a href="index.html#type-kind">kind</a></code></dt><dd><p>See <span class="xref-unresolved" title="unresolved reference to &quot;Bigarray.char&quot;"><code>Bigarray</code>.char</span>.</p></dd></dl><dl><dt class="spec value" id="val-int16_signed"><a href="#val-int16_signed" class="anchor"></a><code><span class="keyword">val </span>int16_signed : (int, <a href="index.html#type-int16_signed_elt">int16_signed_elt</a>) <a href="index.html#type-kind">kind</a></code></dt><dd><p>See <span class="xref-unresolved" title="unresolved reference to &quot;Bigarray.char&quot;"><code>Bigarray</code>.char</span>.</p></dd></dl><dl><dt class="spec value" id="val-int16_unsigned"><a href="#val-int16_unsigned" class="anchor"></a><code><span class="keyword">val </span>int16_unsigned : (int, <a href="index.html#type-int16_unsigned_elt">int16_unsigned_elt</a>) <a href="index.html#type-kind">kind</a></code></dt><dd><p>See <span class="xref-unresolved" title="unresolved reference to &quot;Bigarray.char&quot;"><code>Bigarray</code>.char</span>.</p></dd></dl><dl><dt class="spec value" id="val-int"><a href="#val-int" class="anchor"></a><code><span class="keyword">val </span>int : (int, <a href="index.html#type-int_elt">int_elt</a>) <a href="index.html#type-kind">kind</a></code></dt><dd><p>See <span class="xref-unresolved" title="unresolved reference to &quot;Bigarray.char&quot;"><code>Bigarray</code>.char</span>.</p></dd></dl><dl><dt class="spec value" id="val-int32"><a href="#val-int32" class="anchor"></a><code><span class="keyword">val </span>int32 : (int32, <a href="index.html#type-int32_elt">int32_elt</a>) <a href="index.html#type-kind">kind</a></code></dt><dd><p>See <span class="xref-unresolved" title="unresolved reference to &quot;Bigarray.char&quot;"><code>Bigarray</code>.char</span>.</p></dd></dl><dl><dt class="spec value" id="val-int64"><a href="#val-int64" class="anchor"></a><code><span class="keyword">val </span>int64 : (int64, <a href="index.html#type-int64_elt">int64_elt</a>) <a href="index.html#type-kind">kind</a></code></dt><dd><p>See <span class="xref-unresolved" title="unresolved reference to &quot;Bigarray.char&quot;"><code>Bigarray</code>.char</span>.</p></dd></dl><dl><dt class="spec value" id="val-nativeint"><a href="#val-nativeint" class="anchor"></a><code><span class="keyword">val </span>nativeint : (nativeint, <a href="index.html#type-nativeint_elt">nativeint_elt</a>) <a href="index.html#type-kind">kind</a></code></dt><dd><p>See <span class="xref-unresolved" title="unresolved reference to &quot;Bigarray.char&quot;"><code>Bigarray</code>.char</span>.</p></dd></dl><dl><dt class="spec value" id="val-char"><a href="#val-char" class="anchor"></a><code><span class="keyword">val </span>char : (char, <a href="index.html#type-int8_unsigned_elt">int8_unsigned_elt</a>) <a href="index.html#type-kind">kind</a></code></dt><dd><p>As shown by the types of the values above, big arrays of kind <code>float32_elt</code> and <code>float64_elt</code> are accessed using the OCaml type <code>float</code>. Big arrays of complex kinds <code>complex32_elt</code>, <code>complex64_elt</code> are accessed with the OCaml type <span class="xref-unresolved" title="unresolved reference to &quot;Complex.t&quot;"><code>Complex</code>.t</span>. Big arrays of integer kinds are accessed using the smallest OCaml integer type large enough to represent the array elements: <code>int</code> for 8- and 16-bit integer bigarrays, as well as OCaml-integer bigarrays; <code>int32</code> for 32-bit integer bigarrays; <code>int64</code> for 64-bit integer bigarrays; and <code>nativeint</code> for platform-native integer bigarrays. Finally, big arrays of kind <code>int8_unsigned_elt</code> can also be accessed as arrays of characters instead of arrays of small integers, by using the kind value <code>char</code> instead of <code>int8_unsigned</code>.</p></dd></dl><dl><dt class="spec value" id="val-kind_size_in_bytes"><a href="#val-kind_size_in_bytes" class="anchor"></a><code><span class="keyword">val </span>kind_size_in_bytes : (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-kind">kind</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>kind_size_in_bytes k</code> is the number of bytes used to store an element of type <code>k</code>.</p><dl><dt>since</dt><dd>2.5.0</dd></dl></dd></dl></section><section><header><h6 id="array-layouts"><a href="#array-layouts" class="anchor"></a>Array layouts</h6></header><dl><dt class="spec type" id="type-c_layout"><a href="#type-c_layout" class="anchor"></a><code><span class="keyword">type </span>c_layout</code><code><span class="keyword"> = </span>Bigarray.c_layout</code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-c_layout.C_layout_typ" class="anchored"><td class="def constructor"><a href="#type-c_layout.C_layout_typ" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">C_layout_typ</span></code></td><td class="doc"><p>See <span class="xref-unresolved" title="unresolved reference to &quot;Bigarray.fortran_layout&quot;"><code>Bigarray</code>.fortran_layout</span>.</p></td></tr></table></dt><dt class="spec type" id="type-fortran_layout"><a href="#type-fortran_layout" class="anchor"></a><code><span class="keyword">type </span>fortran_layout</code><code><span class="keyword"> = </span>Bigarray.fortran_layout</code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-fortran_layout.Fortran_layout_typ" class="anchored"><td class="def constructor"><a href="#type-fortran_layout.Fortran_layout_typ" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Fortran_layout_typ</span></code></td><td class="doc"><p>To facilitate interoperability with existing C and Fortran code, this library supports two different memory layouts for big arrays, one compatible with the C conventions, the other compatible with the Fortran conventions.</p><p>In the C-style layout, array indices start at 0, and multi-dimensional arrays are laid out in row-major format. That is, for a two-dimensional array, all elements of row 0 are contiguous in memory, followed by all elements of row 1, etc. In other terms, the array elements at <code>(x,y)</code> and <code>(x, y+1)</code> are adjacent in memory.</p><p>In the Fortran-style layout, array indices start at 1, and multi-dimensional arrays are laid out in column-major format. That is, for a two-dimensional array, all elements of column 0 are contiguous in memory, followed by all elements of column 1, etc. In other terms, the array elements at <code>(x,y)</code> and <code>(x+1, y)</code> are adjacent in memory.</p><p>Each layout style is identified at the type level by the abstract types <span class="xref-unresolved" title="unresolved reference to &quot;Bigarray.c_layout&quot;"><code>Bigarray</code>.c_layout</span> and <code>fortran_layout</code> respectively.</p></td></tr></table></dt><dt class="spec type" id="type-layout"><a href="#type-layout" class="anchor"></a><code><span class="keyword">type </span>'a layout</code><code><span class="keyword"> = </span><span class="type-var">'a</span> Bigarray.layout</code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-layout.C_layout" class="anchored"><td class="def constructor"><a href="#type-layout.C_layout" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">C_layout</span> <span class="keyword">:</span> <a href="index.html#type-c_layout">c_layout</a> <a href="index.html#type-layout">layout</a></code></td></tr><tr id="type-layout.Fortran_layout" class="anchored"><td class="def constructor"><a href="#type-layout.Fortran_layout" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Fortran_layout</span> <span class="keyword">:</span> <a href="index.html#type-fortran_layout">fortran_layout</a> <a href="index.html#type-layout">layout</a></code></td><td class="doc"><p>The type <code>'a layout</code> represents one of the two supported memory layouts: C-style if <code>'a</code> is <span class="xref-unresolved" title="unresolved reference to &quot;Bigarray.c_layout&quot;"><code>Bigarray</code>.c_layout</span>, Fortran-style if <code>'a</code> is <span class="xref-unresolved" title="unresolved reference to &quot;Bigarray.fortran_layout&quot;"><code>Bigarray</code>.fortran_layout</span>.</p></td></tr></table></dt></dl></section><section><header><h6 id="supported-layouts"><a href="#supported-layouts" class="anchor"></a>Supported layouts</h6><p>The abstract values <code>c_layout</code> and <code>fortran_layout</code> represent the two supported layouts at the level of values.</p></header><dl><dt class="spec value" id="val-c_layout"><a href="#val-c_layout" class="anchor"></a><code><span class="keyword">val </span>c_layout : <a href="index.html#type-c_layout">c_layout</a> <a href="index.html#type-layout">layout</a></code></dt><dt class="spec value" id="val-fortran_layout"><a href="#val-fortran_layout" class="anchor"></a><code><span class="keyword">val </span>fortran_layout : <a href="index.html#type-fortran_layout">fortran_layout</a> <a href="index.html#type-layout">layout</a></code></dt></dl><dl><dt class="spec module" id="module-Genarray"><a href="#module-Genarray" class="anchor"></a><code><span class="keyword">module </span><a href="Genarray/index.html">Genarray</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Generic arrays (of arbitrarily many dimensions)</p></dd></dl></section><section><header><h6 id="one-dimensional-arrays"><a href="#one-dimensional-arrays" class="anchor"></a>One-dimensional arrays</h6></header><dl><dt class="spec module" id="module-Array1"><a href="#module-Array1" class="anchor"></a><code><span class="keyword">module </span><a href="Array1/index.html">Array1</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>One-dimensional arrays. The <code>Array1</code> structure provides operations similar to those of <span class="xref-unresolved" title="unresolved reference to &quot;Bigarray.Genarray&quot;"><code>Bigarray</code>.Genarray</span>, but specialized to the case of one-dimensional arrays. (The <code>Array2</code> and <code>Array3</code> structures below provide operations specialized for two- and three-dimensional arrays.) Statically knowing the number of dimensions of the array allows faster operations, and more precise static type-checking.</p></dd></dl></section><section><header><h6 id="two-dimensional-arrays"><a href="#two-dimensional-arrays" class="anchor"></a>Two-dimensional arrays</h6></header><dl><dt class="spec module" id="module-Array2"><a href="#module-Array2" class="anchor"></a><code><span class="keyword">module </span><a href="Array2/index.html">Array2</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Two-dimensional arrays. The <code>Array2</code> structure provides operations similar to those of <span class="xref-unresolved" title="unresolved reference to &quot;Bigarray.Genarray&quot;"><code>Bigarray</code>.Genarray</span>, but specialized to the case of two-dimensional arrays.</p></dd></dl></section><section><header><h6 id="three-dimensional-arrays"><a href="#three-dimensional-arrays" class="anchor"></a>Three-dimensional arrays</h6></header><dl><dt class="spec module" id="module-Array3"><a href="#module-Array3" class="anchor"></a><code><span class="keyword">module </span><a href="Array3/index.html">Array3</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Three-dimensional arrays. The <code>Array3</code> structure provides operations similar to those of <span class="xref-unresolved" title="unresolved reference to &quot;Bigarray.Genarray&quot;"><code>Bigarray</code>.Genarray</span>, but specialized to the case of three-dimensional arrays.</p></dd></dl></section><section><header><h6 id="coercions-between-generic-big-arrays-and-fixed-dimension-big-arrays"><a href="#coercions-between-generic-big-arrays-and-fixed-dimension-big-arrays" class="anchor"></a>Coercions between generic big arrays and fixed-dimension big arrays</h6></header><dl><dt class="spec external" id="val-genarray_of_array1"><a href="#val-genarray_of_array1" class="anchor"></a><code><span class="keyword">val </span>genarray_of_array1 : (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>) <a href="Array1/index.html#type-t">Array1.t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>) <a href="Genarray/index.html#type-t">Genarray.t</a></code></dt><dd><p>Return the generic big array corresponding to the given one-dimensional big array.</p></dd></dl><dl><dt class="spec external" id="val-genarray_of_array2"><a href="#val-genarray_of_array2" class="anchor"></a><code><span class="keyword">val </span>genarray_of_array2 : (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>) <a href="Array2/index.html#type-t">Array2.t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>) <a href="Genarray/index.html#type-t">Genarray.t</a></code></dt><dd><p>Return the generic big array corresponding to the given two-dimensional big array.</p></dd></dl><dl><dt class="spec external" id="val-genarray_of_array3"><a href="#val-genarray_of_array3" class="anchor"></a><code><span class="keyword">val </span>genarray_of_array3 : (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>) <a href="Array3/index.html#type-t">Array3.t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>) <a href="Genarray/index.html#type-t">Genarray.t</a></code></dt><dd><p>Return the generic big array corresponding to the given three-dimensional big array.</p></dd></dl><dl><dt class="spec value" id="val-array1_of_genarray"><a href="#val-array1_of_genarray" class="anchor"></a><code><span class="keyword">val </span>array1_of_genarray : (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>) <a href="Genarray/index.html#type-t">Genarray.t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>) <a href="Array1/index.html#type-t">Array1.t</a></code></dt><dd><p>Return the one-dimensional big array corresponding to the given generic big array. </p><dl><dt>raises Invalid_argument</dt><dd><p>if the generic big array does not have exactly one dimension.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-array2_of_genarray"><a href="#val-array2_of_genarray" class="anchor"></a><code><span class="keyword">val </span>array2_of_genarray : (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>) <a href="Genarray/index.html#type-t">Genarray.t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>) <a href="Array2/index.html#type-t">Array2.t</a></code></dt><dd><p>Return the two-dimensional big array corresponding to the given generic big array. </p><dl><dt>raises Invalid_argument</dt><dd><p>if the generic big array does not have exactly two dimensions.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-array3_of_genarray"><a href="#val-array3_of_genarray" class="anchor"></a><code><span class="keyword">val </span>array3_of_genarray : (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>) <a href="Genarray/index.html#type-t">Genarray.t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>) <a href="Array3/index.html#type-t">Array3.t</a></code></dt><dd><p>Return the three-dimensional big array corresponding to the given generic big array. </p><dl><dt>raises Invalid_argument</dt><dd><p>if the generic big array does not have exactly three dimensions.</p></dd></dl></dd></dl></section><section><header><h6 id="re-shaping-big-arrays"><a href="#re-shaping-big-arrays" class="anchor"></a>Re-shaping big arrays</h6></header><dl><dt class="spec value" id="val-reshape"><a href="#val-reshape" class="anchor"></a><code><span class="keyword">val </span>reshape : (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>) <a href="Genarray/index.html#type-t">Genarray.t</a> <span>&#45;&gt;</span> int array <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>) <a href="Genarray/index.html#type-t">Genarray.t</a></code></dt><dd><p><code>reshape b [|d1;...;dN|]</code> converts the big array <code>b</code> to a <code>N</code>-dimensional array of dimensions <code>d1</code>...<code>dN</code>. The returned array and the original array <code>b</code> share their data and have the same layout. For instance, assuming that <code>b</code> is a one-dimensional array of dimension 12, <code>reshape b [|3;4|]</code> returns a two-dimensional array <code>b'</code> of dimensions 3 and 4. If <code>b</code> has C layout, the element <code>(x,y)</code> of <code>b'</code> corresponds to the element <code>x * 3 + y</code> of <code>b</code>. If <code>b</code> has Fortran layout, the element <code>(x,y)</code> of <code>b'</code> corresponds to the element <code>x + (y - 1) * 4</code> of <code>b</code>. The returned big array must have exactly the same number of elements as the original big array <code>b</code>. That is, the product of the dimensions of <code>b</code> must be equal to <code>i1 * ... * iN</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>otherwise.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-reshape_1"><a href="#val-reshape_1" class="anchor"></a><code><span class="keyword">val </span>reshape_1 : (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>) <a href="Genarray/index.html#type-t">Genarray.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>) <a href="Array1/index.html#type-t">Array1.t</a></code></dt><dd><p>Specialized version of <span class="xref-unresolved" title="unresolved reference to &quot;Bigarray.reshape&quot;"><code>Bigarray</code>.reshape</span> for reshaping to one-dimensional arrays.</p></dd></dl><dl><dt class="spec value" id="val-reshape_2"><a href="#val-reshape_2" class="anchor"></a><code><span class="keyword">val </span>reshape_2 : (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>) <a href="Genarray/index.html#type-t">Genarray.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>) <a href="Array2/index.html#type-t">Array2.t</a></code></dt><dd><p>Specialized version of <span class="xref-unresolved" title="unresolved reference to &quot;Bigarray.reshape&quot;"><code>Bigarray</code>.reshape</span> for reshaping to two-dimensional arrays.</p></dd></dl><dl><dt class="spec value" id="val-reshape_3"><a href="#val-reshape_3" class="anchor"></a><code><span class="keyword">val </span>reshape_3 : (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>) <a href="Genarray/index.html#type-t">Genarray.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>) <a href="Array3/index.html#type-t">Array3.t</a></code></dt><dd><p>Specialized version of <span class="xref-unresolved" title="unresolved reference to &quot;Bigarray.reshape&quot;"><code>Bigarray</code>.reshape</span> for reshaping to three-dimensional arrays.</p></dd></dl></section></div></body></html>