<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Sexplib__Macro (sexplib.Sexplib__Macro)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">sexplib</a> &#x00BB; Sexplib__Macro</nav><h1>Module <code>Sexplib__Macro</code></h1><p>Support for variable expansion and templates within s-expressions. The functions in this module evaluate the following constructs within s-expressions:</p><ul><li><code>(:include filename)</code> is replaced with the list of s-expressions contained in <code>filename</code>, as if the contents of <code>filename</code> were directly inserted in place of <code>(:include filename)</code>. A relative <code>filename</code> is taken with respect to the file that contains the include macro.</li><li><code>(:let v (v1 ... vn) S1 ... Sm)</code> defines a template <code>v</code> with arguments <code>v1,
   ..., vn</code> and body <code>S1 ... Sm</code>. The definition itself is removed from the input. The variables <code>v1, ..., vn</code> must be exactly the free variables of <code>S1,
   ..., Sm</code> (see below for the meaning of &quot;free variable&quot;). In particular, since a macro argument cannot be a function, a let body cannot call a macro that is defined elsewhere, only a macro that is defined in the body itself. However if you want to use the same macro inside two macros, it is still possible to define it in a separate file and include it in both macros. The list <code>S1 ... Sm</code> may not be empty.</li><li><code>(:use v (v1 SS1) ... (vn SSn))</code> expands to the body of the template <code>v</code> with lists of s-expressions <code>SS1, ..., SSn</code> substituted for the arguments <code>v1, ..., vn</code> of <code>v</code>.</li><li><code>(:concat S1 ... Sn)</code> evaluates <code>S1 ... Sn</code> to atoms <code>C1, ..., Cn</code> when possible and is replaced by the string concatenation <code>C1 | ... | Cn</code>.</li></ul><p>Macros other than <code>:include</code> will be called 'local'. All <code>:include</code> macros are resolved before all the local macros, which means that included file names cannot contain variables.</p><p>The occurrence of variable <code>v</code> in <code>(:use v ...)</code> can be either free or bound, depending on the surrounding sexp. The occurrence is free iff it it's not bound, and it's bound iff one of the following two conditions apply:</p><ol><li>All occurrences of <code>v1</code>, ..., <code>vn</code> in the body of <code>(:let v (v1 ... vn) S1 ... Sm)</code> are bound.</li><li>All occurrences of <code>v</code> from the appearance of <code>(:let v (v1 ... vn) S1 ... Sm)</code> to the end of the sexp nesting level are bound.</li></ol><p>Trying to <code>:use</code> an unbound variable is an error. Neither the top level file nor any of the included files may contain unbound variables.</p><p>The <code>load...</code> functions of this module mirror the corresponding functions of the <code>Sexp</code> module except that they expand the macros in the loaded file and may throw additional exceptions.</p><p>Example -------</p><p>Assume that <code>input.sexp</code> contains</p><pre>   (:include defs.sexp)
   (:include template.sexp)
   (:use f (a (:use a)) (b (:use b)))</pre><p>the file <code>defs.sexp</code> contains</p><pre>   (:let a () hello)
   (:let b () &quot; world&quot;)</pre><p>and the file <code>template.sexp</code> contains</p><pre>   (:let f (a b) (:concat (:use a) (:use b)))</pre><p>Then <code>load_sexp &quot;input.sexp&quot;</code> will return &quot;hello world&quot;.</p><p>Formal Evaluation Rules -----------------------</p><p>In the following <code>v</code> denotes a variable (an atom), <code>S</code> denotes a sexp, and <code>SS</code> denotes a list of sexps. Given a map <code>V</code> we write <code>V(v ~&gt; a)</code> to update the map.</p><p>Evaluation rules are of the form <code>V : SS =&gt; SS'</code> where <code>V</code> is a set of bindings of the form <code>v ~&gt; SSv</code>, each binding defining a template <code>v</code> with body <code>SSv</code>.</p><p>First some boilerplate rules: a sexp without macros evaluates to itself:</p><pre>   V : &lt;empty sexp list&gt; =&gt; &lt;empty sexp list&gt;

   V : S  =&gt; SS1
   V : SS =&gt; SS2
   -------------------
   V : S SS =&gt; SS1 SS2

   C is an atom
   ------------
   V : C =&gt; C

   V : SS =&gt; SS'
   -----------------
   V : (SS) =&gt; (SS')</pre><p>Now the interesting rules.</p><pre>   free_vars(SSv) = {v1, ..., vn}
   V(v ~&gt; SSv) : SS =&gt; SS'
   --------------------------------------
   V : (:let v (v1 ... vn) SSv) SS =&gt; SS'

   V(v) = SS
   V : SSi =&gt; SSi' for each i
   V(v1 ~&gt; SS1', ..., vn ~&gt; SSn') : SS =&gt; SS'
   ------------------------------------------
   V : (:use v (v1 SS1) ... (vn SSn)) =&gt; SS'

   v not defined in V
   -----------------------
   V : (:use v ...) =&gt; _|_

   V : Si =&gt; Ci
   Each Ci is an atom
   -------------------------------------------------------
   V : (:concat S1 ... Sn) =&gt; String.concat [C1; ...; Cn]</pre><p>As follows from the let-rule, let definitions may only refer to the variables explicitly mentioned in the argument list. This avoids the complexities of variable capture and allows us to forego closure building.</p></header><dl><dt class="spec type" id="type-conv"><a href="#type-conv" class="anchor"></a><code><span class="keyword">type</span> 'a conv</code> = <code>[ </code><table class="variant"><tr id="type-conv.Result" class="anchored"><td class="def constructor"><a href="#type-conv.Result" class="anchor"></a><code>| </code><code>`Result <span class="keyword">of</span> <span class="type-var">'a</span></code></td></tr><tr id="type-conv.Error" class="anchored"><td class="def constructor"><a href="#type-conv.Error" class="anchor"></a><code>| </code><code>`Error <span class="keyword">of</span> exn * <a href="../Sexplib/Sexp/index.html#type-t">Sexplib.Sexp.t</a></code></td></tr></table><code> ]</code></dt></dl><dl><dt class="spec value" id="val-sexp_of_conv"><a href="#val-sexp_of_conv" class="anchor"></a><code><span class="keyword">val</span> sexp_of_conv : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../Sexplib/Sexp/index.html#type-t">Sexplib.Sexp.t</a>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-conv">conv</a> <span>&#45;&gt;</span> <a href="../Sexplib/Sexp/index.html#type-t">Sexplib.Sexp.t</a></code></dt></dl><dl><dt class="spec type" id="type-annot_conv"><a href="#type-annot_conv" class="anchor"></a><code><span class="keyword">type</span> 'a annot_conv</code><code> = [ `Result of <span class="type-var">'a</span> | `Error of exn * <a href="../Sexplib/Sexp/Annotated/index.html#type-t">Sexplib.Sexp.Annotated.t</a> ] <span class="keyword">as</span> body</code><code> <span class="keyword">constraint</span> <span class="type-var">'body</span> = <span class="type-var">'a</span> Sexplib.Sexp.Annotated.conv</code></dt></dl><dl><dt class="spec value" id="val-sexp_of_annot_conv"><a href="#val-sexp_of_annot_conv" class="anchor"></a><code><span class="keyword">val</span> sexp_of_annot_conv : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../Sexplib/Sexp/index.html#type-t">Sexplib.Sexp.t</a>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-annot_conv">annot_conv</a> <span>&#45;&gt;</span> <a href="../Sexplib/Sexp/index.html#type-t">Sexplib.Sexp.t</a></code></dt><dt class="spec value" id="val-load_sexp"><a href="#val-load_sexp" class="anchor"></a><code><span class="keyword">val</span> load_sexp : string <span>&#45;&gt;</span> <a href="../Sexplib/Sexp/index.html#type-t">Sexplib.Sexp.t</a></code></dt><dd><p><code>load_sexp file</code> like <code>{!Sexp.load_sexp} file</code>, but resolves the macros contained in <code>file</code>.</p></dd></dl><dl><dt class="spec value" id="val-load_sexps"><a href="#val-load_sexps" class="anchor"></a><code><span class="keyword">val</span> load_sexps : string <span>&#45;&gt;</span> <a href="../Sexplib/Sexp/index.html#type-t">Sexplib.Sexp.t</a> list</code></dt><dd><p><code>load_sexps file</code> like <code>{!Sexp.load_sexps} file</code>, but resolves the macros contained in <code>file</code>.</p></dd></dl><dl><dt class="spec value" id="val-load_sexp_conv"><a href="#val-load_sexp_conv" class="anchor"></a><code><span class="keyword">val</span> load_sexp_conv : string <span>&#45;&gt;</span> (<a href="../Sexplib/Sexp/index.html#type-t">Sexplib.Sexp.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-annot_conv">annot_conv</a></code></dt><dd><p><code>load_sexp_conv file f</code> uses <a href="index.html#val-load_sexp"><code>load_sexp</code></a> and converts the result using <code>f</code>.</p></dd></dl><dl><dt class="spec value" id="val-load_sexps_conv"><a href="#val-load_sexps_conv" class="anchor"></a><code><span class="keyword">val</span> load_sexps_conv : string <span>&#45;&gt;</span> (<a href="../Sexplib/Sexp/index.html#type-t">Sexplib.Sexp.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-annot_conv">annot_conv</a> list</code></dt><dd><p><code>load_sexps_conv file f</code> uses <a href="index.html#val-load_sexps"><code>load_sexps</code></a> and converts the result using <code>f</code>.</p></dd></dl><dl><dt class="spec value" id="val-load_sexp_conv_exn"><a href="#val-load_sexp_conv_exn" class="anchor"></a><code><span class="keyword">val</span> load_sexp_conv_exn : string <span>&#45;&gt;</span> (<a href="../Sexplib/Sexp/index.html#type-t">Sexplib.Sexp.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>load_sexp_conv_exn file f</code> like <a href="index.html#val-load_sexp_conv"><code>load_sexp_conv</code></a>, but raises an exception in case of conversion error.</p></dd></dl><dl><dt class="spec value" id="val-load_sexps_conv_exn"><a href="#val-load_sexps_conv_exn" class="anchor"></a><code><span class="keyword">val</span> load_sexps_conv_exn : string <span>&#45;&gt;</span> (<a href="../Sexplib/Sexp/index.html#type-t">Sexplib.Sexp.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p><code>load_sexps_conv_exn file f</code> like <a href="index.html#val-load_sexps_conv"><code>load_sexps_conv</code></a>, but raises an exception in case of conversion error.</p></dd></dl><dl><dt class="spec value" id="val-expand_local_macros"><a href="#val-expand_local_macros" class="anchor"></a><code><span class="keyword">val</span> expand_local_macros : <a href="../Sexplib/Sexp/index.html#type-t">Sexplib.Sexp.t</a> list <span>&#45;&gt;</span> <a href="../Sexplib/Sexp/index.html#type-t">Sexplib.Sexp.t</a> list <a href="index.html#type-conv">conv</a></code></dt><dd><p><code>expand_local_macros sexps</code> takes a list of sexps and performs macro-expansion on them, except that an error will be returned if an :include macro is found.</p></dd></dl><dl><dt class="spec module-type" id="module-type-Sexp_loader"><a href="#module-type-Sexp_loader" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Sexp_loader/index.html">Sexp_loader</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>A version of <code>load_sexps</code> that is functorized with respect to the functions that load the sexps from files and the corresponding monad.</p></dd></dl><div class="spec module" id="module-Loader"><a href="#module-Loader" class="anchor"></a><code><span class="keyword">module</span> <a href="Loader/index.html">Loader</a> : <span class="keyword">functor</span> (<a href="Loader/argument-1-S/index.html">S</a> : <a href="index.html#module-type-Sexp_loader">Sexp_loader</a>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-add_error_location"><a href="#val-add_error_location" class="anchor"></a><code><span class="keyword">val</span> add_error_location : string <span>&#45;&gt;</span> exn <span>&#45;&gt;</span> exn</code></dt></dl></div></body></html>