<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Sub (astring.Astring.String.Sub)</title><link rel="stylesheet" href="../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../../index.html">astring</a> &#x00BB; <a href="../../index.html">Astring</a> &#x00BB; <a href="../index.html">String</a> &#x00BB; Sub</nav><h1>Module <code>String.Sub</code></h1><p>Substrings.</p><p>A substring defines a possibly empty subsequence of bytes in a <em>base</em> string.</p><p>The positions of a string <code>s</code> of length <code>l</code> are the slits found before each byte and after the last byte of the string. They are labelled from left to right by increasing number in the range [<code>0</code>;<code>l</code>].</p><pre>positions  0   1   2   3   4    l-1    l
           +---+---+---+---+     +-----+
  indices  | 0 | 1 | 2 | 3 | ... | l-1 |
           +---+---+---+---+     +-----+</pre><p>The <code>i</code>th byte index is between positions <code>i</code> and <code>i+1</code>.</p><p>Formally we define a substring of <code>s</code> as being a subsequence of bytes defined by a <em>start</em> and a <em>stop</em> position. The former is always smaller or equal to the latter. When both positions are equal the substring is <em>empty</em>. Note that for a given base string there are as many empty substrings as there are positions in the string.</p><p>Like in strings, we index the bytes of a substring using zero-based indices.</p><p>See how to <a href="../../index.html#examples"><span>use</span></a> substrings to parse data.</p><nav class="toc"><ul><li><a href="#substrings">Substrings</a></li><li><a href="#stretch">Stretching substrings</a></li><li><a href="#append">Appending substrings</a></li><li><a href="#pred">Predicates</a></li><li><a href="#extract">Extracting substrings</a></li><li><a href="#traverse">Traversing substrings</a></li><li><a href="#pp">Pretty printing</a></li><li><a href="#convert">OCaml base type conversions</a></li><li><a href="#fig">Substring stretching graphical guide</a></li></ul></nav></header><section><header><h2 id="substrings"><a href="#substrings" class="anchor"></a>Substrings</h2></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code><code> = <a href="../index.html#type-sub">sub</a></code></dt><dd><p>The type for substrings.</p></dd></dl><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val</span> empty : <a href="../index.html#type-sub">sub</a></code></dt><dd><p><code>empty</code> is the empty substring of the empty string <a href="../index.html#val-empty"><code>String.empty</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-v"><a href="#val-v" class="anchor"></a><code><span class="keyword">val</span> v : ?&#8288;start:int <span>&#45;&gt;</span> ?&#8288;stop:int <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a></code></dt><dd><p><code>v ~start ~stop s</code> is the substring of <code>s</code> that starts at position <code>start</code> (defaults to <code>0</code>) and stops at position <code>stop</code> (defaults to <code>String.length s</code>).</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>start</code> or <code>stop</code> are not positions of <code>s</code> or if <code>stop &lt; start</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-start_pos"><a href="#val-start_pos" class="anchor"></a><code><span class="keyword">val</span> start_pos : <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>start_pos s</code> is <code>s</code>'s start position in the base string.</p></dd></dl><dl><dt class="spec value" id="val-stop_pos"><a href="#val-stop_pos" class="anchor"></a><code><span class="keyword">val</span> stop_pos : <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>stop_pos s</code> is <code>s</code>'s stop position in the base string.</p></dd></dl><dl><dt class="spec value" id="val-base_string"><a href="#val-base_string" class="anchor"></a><code><span class="keyword">val</span> base_string : <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> string</code></dt><dd><p><code>base_string s</code> is <code>s</code>'s base string.</p></dd></dl><dl><dt class="spec value" id="val-length"><a href="#val-length" class="anchor"></a><code><span class="keyword">val</span> length : <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>length s</code> is the number of bytes in <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-get"><a href="#val-get" class="anchor"></a><code><span class="keyword">val</span> get : <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> char</code></dt><dd><p><code>get s i</code> is the byte of <code>s</code> at its zero-based index <code>i</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>i</code> is not an index of <code>s</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-get_byte"><a href="#val-get_byte" class="anchor"></a><code><span class="keyword">val</span> get_byte : <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dd><p><code>get_byte s i</code> is <code>Char.to_int (get s i)</code>.</p></dd></dl><dl><dt class="spec value" id="val-head"><a href="#val-head" class="anchor"></a><code><span class="keyword">val</span> head : ?&#8288;rev:bool <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> char option</code></dt><dd><p><code>head s</code> is <code>Some (get s h)</code> with <code>h = 0</code> if <code>rev = false</code> (default) or <code>h = length s - 1</code> if <code>rev = true</code>. <code>None</code> is returned if <code>s</code> is empty.</p></dd></dl><dl><dt class="spec value" id="val-get_head"><a href="#val-get_head" class="anchor"></a><code><span class="keyword">val</span> get_head : ?&#8288;rev:bool <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> char</code></dt><dd><p><code>get_head s</code> is like <a href="index.html#val-head"><code>head</code></a> but </p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>s</code> is empty.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-of_string"><a href="#val-of_string" class="anchor"></a><code><span class="keyword">val</span> of_string : string <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a></code></dt><dd><p><code>of_string s</code> is <code>v s</code></p></dd></dl><dl><dt class="spec value" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span class="keyword">val</span> to_string : <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> string</code></dt><dd><p><code>to_string s</code> is the bytes of <code>s</code> as a string.</p></dd></dl><dl><dt class="spec value" id="val-rebase"><a href="#val-rebase" class="anchor"></a><code><span class="keyword">val</span> rebase : <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a></code></dt><dd><p><code>rebase s</code> is <code>v (to_string s)</code>. This puts <code>s</code> on a base string made solely of its bytes.</p></dd></dl><dl><dt class="spec value" id="val-hash"><a href="#val-hash" class="anchor"></a><code><span class="keyword">val</span> hash : <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>hash s</code> is <span class="xref-unresolved" title="unresolved reference to &quot;Hashtbl.hash s&quot;"><code>Hashtbl</code>.hash s</span>.</p></dd></dl></section><section><header><h2 id="stretch"><a href="#stretch" class="anchor"></a>Stretching substrings</h2><p>See the <a href="index.html#fig"><span>graphical guide</span></a>.</p></header><dl><dt class="spec value" id="val-start"><a href="#val-start" class="anchor"></a><code><span class="keyword">val</span> start : <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a></code></dt><dd><p><code>start s</code> is the empty substring at the start position of <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-stop"><a href="#val-stop" class="anchor"></a><code><span class="keyword">val</span> stop : <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a></code></dt><dd><p><code>stop s</code> is the empty substring at the stop position of <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-base"><a href="#val-base" class="anchor"></a><code><span class="keyword">val</span> base : <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a></code></dt><dd><p><code>base s</code> is a substring that spans the whole base string of <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-tail"><a href="#val-tail" class="anchor"></a><code><span class="keyword">val</span> tail : ?&#8288;rev:bool <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a></code></dt><dd><p><code>tail s</code> is <code>s</code> without its first (<code>rev</code> is <code>false</code>, default) or last (<code>rev</code> is <code>true</code>) byte or <code>s</code> if it is empty.</p></dd></dl><dl><dt class="spec value" id="val-extend"><a href="#val-extend" class="anchor"></a><code><span class="keyword">val</span> extend : ?&#8288;rev:bool <span>&#45;&gt;</span> ?&#8288;max:int <span>&#45;&gt;</span> ?&#8288;sat:(char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a></code></dt><dd><p><code>extend ~rev ~max ~sat s</code> extends <code>s</code> by at most <code>max</code> consecutive <code>sat</code> satisfiying bytes of the base string located after <code>stop s</code> (<code>rev</code> is <code>false</code>, default) or before <code>start s</code> (<code>rev</code> is <code>true</code>). If <code>max</code> is unspecified the extension is limited by the extents of the base string of <code>s</code>. <code>sat</code> defaults to <code>fun _ -&gt; true</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>max</code> is negative.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-reduce"><a href="#val-reduce" class="anchor"></a><code><span class="keyword">val</span> reduce : ?&#8288;rev:bool <span>&#45;&gt;</span> ?&#8288;max:int <span>&#45;&gt;</span> ?&#8288;sat:(char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a></code></dt><dd><p><code>reduce ~rev ~max ~sat s</code> reduces <code>s</code> by at most <code>max</code> consecutive <code>sat</code> satisfying bytes of <code>s</code> located before <code>stop
        s</code> (<code>rev</code> is <code>false</code>, default) or after <code>start s</code> (<code>rev</code> is <code>true</code>). If <code>max</code> is unspecified the reduction is limited by the extents of the substring <code>s</code>. <code>sat</code> defaults to <code>fun _ -&gt;
        true</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>max</code> is negative.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-extent"><a href="#val-extent" class="anchor"></a><code><span class="keyword">val</span> extent : <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a></code></dt><dd><p><code>extent s s'</code> is the smallest substring that includes all the positions of <code>s</code> and <code>s'</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>s</code> and <code>s'</code> are not on the same base string according to physical equality.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-overlap"><a href="#val-overlap" class="anchor"></a><code><span class="keyword">val</span> overlap : <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a> option</code></dt><dd><p><code>overlap s s'</code> is the smallest substring that includes all the positions common to <code>s</code> and <code>s'</code> or <code>None</code> if there are no such positions. Note that the overlap substring may be empty.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>s</code> and <code>s'</code> are not on the same base string according to physical equality.</p></dd></dl></dd></dl></section><section><header><h2 id="append"><a href="#append" class="anchor"></a>Appending substrings</h2></header><dl><dt class="spec value" id="val-append"><a href="#val-append" class="anchor"></a><code><span class="keyword">val</span> append : <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a></code></dt><dd><p><code>append s s'</code> is like <a href="../index.html#append"><span>Appending strings</span></a>. The substrings can be on different bases and the result is on a base string that holds exactly the appended bytes.</p></dd></dl><dl><dt class="spec value" id="val-concat"><a href="#val-concat" class="anchor"></a><code><span class="keyword">val</span> concat : ?&#8288;sep:<a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a> list <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a></code></dt><dd><p><code>concat ~sep ss</code> is like <a href="../index.html#val-concat"><code>String.concat</code></a>. The substrings can all be on different bases and the result is on a base string that holds exactly the concatenated bytes.</p></dd></dl></section><section><header><h2 id="pred"><a href="#pred" class="anchor"></a>Predicates</h2></header><dl><dt class="spec value" id="val-is_empty"><a href="#val-is_empty" class="anchor"></a><code><span class="keyword">val</span> is_empty : <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_empty s</code> is <code>length s = 0</code>.</p></dd></dl><dl><dt class="spec value" id="val-is_prefix"><a href="#val-is_prefix" class="anchor"></a><code><span class="keyword">val</span> is_prefix : affix:<a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_prefix</code> is like <a href="../index.html#val-is_prefix"><code>String.is_prefix</code></a>. Only bytes are compared, <code>affix</code> can be on a different base string.</p></dd></dl><dl><dt class="spec value" id="val-is_infix"><a href="#val-is_infix" class="anchor"></a><code><span class="keyword">val</span> is_infix : affix:<a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_infix</code> is like <a href="../index.html#val-is_infix"><code>String.is_infix</code></a>. Only bytes are compared, <code>affix</code> can be on a different base string.</p></dd></dl><dl><dt class="spec value" id="val-is_suffix"><a href="#val-is_suffix" class="anchor"></a><code><span class="keyword">val</span> is_suffix : affix:<a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_suffix</code> is like <a href="../index.html#val-is_suffix"><code>String.is_suffix</code></a>. Only bytes are compared, <code>affix</code> can be on a different base string.</p></dd></dl><dl><dt class="spec value" id="val-for_all"><a href="#val-for_all" class="anchor"></a><code><span class="keyword">val</span> for_all : (char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>for_all</code> is like <a href="../index.html#val-for_all"><code>String.for_all</code></a> on the substring.</p></dd></dl><dl><dt class="spec value" id="val-exists"><a href="#val-exists" class="anchor"></a><code><span class="keyword">val</span> exists : (char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>exists</code> is like <a href="../index.html#val-exists"><code>String.exists</code></a> on the substring.</p></dd></dl><dl><dt class="spec value" id="val-same_base"><a href="#val-same_base" class="anchor"></a><code><span class="keyword">val</span> same_base : <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>same_base s s'</code> is <code>true</code> iff the substrings <code>s</code> and <code>s'</code> have the same base string according to physical equality.</p></dd></dl><dl><dt class="spec value" id="val-equal_bytes"><a href="#val-equal_bytes" class="anchor"></a><code><span class="keyword">val</span> equal_bytes : <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>equal_bytes s s'</code> is <code>true</code> iff the substrings <code>s</code> and <code>s'</code> have exactly the same bytes. The substrings can be on a different base string.</p></dd></dl><dl><dt class="spec value" id="val-compare_bytes"><a href="#val-compare_bytes" class="anchor"></a><code><span class="keyword">val</span> compare_bytes : <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>compare_bytes s s'</code> compares the bytes of <code>s</code> and <code>s</code>' in lexicographical order. The substrings can be on a different base string.</p></dd></dl><dl><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val</span> equal : <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>equal s s'</code> is <code>true</code> iff <code>s</code> and <code>s'</code> have the same positions.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>s</code> and <code>s'</code> are not on the same base string according to physical equality.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val</span> compare : <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>compare s s'</code> compares the positions of <code>s</code> and <code>s'</code> in lexicographical order.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>s</code> and <code>s'</code> are not on the same base string according to physical equality.</p></dd></dl></dd></dl></section><section><header><h2 id="extract"><a href="#extract" class="anchor"></a>Extracting substrings</h2><p>Extracted substrings are always on the same base string as the substring <code>s</code> acted upon.</p></header><dl><dt class="spec value" id="val-with_range"><a href="#val-with_range" class="anchor"></a><code><span class="keyword">val</span> with_range : ?&#8288;first:int <span>&#45;&gt;</span> ?&#8288;len:int <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a></code></dt><dd><p><code>with_range</code> is like <a href="../index.html#val-sub_with_range"><code>String.sub_with_range</code></a>. The indices are the substring's zero-based ones, not those in the base string.</p></dd></dl><dl><dt class="spec value" id="val-with_index_range"><a href="#val-with_index_range" class="anchor"></a><code><span class="keyword">val</span> with_index_range : ?&#8288;first:int <span>&#45;&gt;</span> ?&#8288;last:int <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a></code></dt><dd><p><code>with_index_range</code> is like <a href="../index.html#val-sub_with_index_range"><code>String.sub_with_index_range</code></a>. The indices are the substring's zero-based ones, not those in the base string.</p></dd></dl><dl><dt class="spec value" id="val-trim"><a href="#val-trim" class="anchor"></a><code><span class="keyword">val</span> trim : ?&#8288;drop:(char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a></code></dt><dd><p><code>trim</code> is like <a href="../index.html#val-trim"><code>String.trim</code></a>. If all bytes are dropped returns an empty string located in the middle of the argument.</p></dd></dl><dl><dt class="spec value" id="val-span"><a href="#val-span" class="anchor"></a><code><span class="keyword">val</span> span : ?&#8288;rev:bool <span>&#45;&gt;</span> ?&#8288;min:int <span>&#45;&gt;</span> ?&#8288;max:int <span>&#45;&gt;</span> ?&#8288;sat:(char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a> * <a href="../index.html#type-sub">sub</a></code></dt><dd><p><code>span</code> is like <a href="../index.html#val-span"><code>String.span</code></a>. For a substring <code>s</code> a left empty span is <code>start s</code> and a right empty span is <code>stop s</code>.</p></dd></dl><dl><dt class="spec value" id="val-take"><a href="#val-take" class="anchor"></a><code><span class="keyword">val</span> take : ?&#8288;rev:bool <span>&#45;&gt;</span> ?&#8288;min:int <span>&#45;&gt;</span> ?&#8288;max:int <span>&#45;&gt;</span> ?&#8288;sat:(char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a></code></dt><dd><p><code>take</code> is like <a href="../index.html#val-take"><code>String.take</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-drop"><a href="#val-drop" class="anchor"></a><code><span class="keyword">val</span> drop : ?&#8288;rev:bool <span>&#45;&gt;</span> ?&#8288;min:int <span>&#45;&gt;</span> ?&#8288;max:int <span>&#45;&gt;</span> ?&#8288;sat:(char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a></code></dt><dd><p><code>drop</code> is like <a href="../index.html#val-drop"><code>String.drop</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-cut"><a href="#val-cut" class="anchor"></a><code><span class="keyword">val</span> cut : ?&#8288;rev:bool <span>&#45;&gt;</span> sep:<a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> (<a href="../index.html#type-sub">sub</a> * <a href="../index.html#type-sub">sub</a>) option</code></dt><dd><p><code>cut</code> is like <a href="../index.html#val-cut"><code>String.cut</code></a>. <code>sep</code> can be on a different base string</p></dd></dl><dl><dt class="spec value" id="val-cuts"><a href="#val-cuts" class="anchor"></a><code><span class="keyword">val</span> cuts : ?&#8288;rev:bool <span>&#45;&gt;</span> ?&#8288;empty:bool <span>&#45;&gt;</span> sep:<a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a> list</code></dt><dd><p><code>cuts</code> is like <a href="../index.html#val-cuts"><code>String.cuts</code></a>. <code>sep</code> can be on a different base string</p></dd></dl><dl><dt class="spec value" id="val-fields"><a href="#val-fields" class="anchor"></a><code><span class="keyword">val</span> fields : ?&#8288;empty:bool <span>&#45;&gt;</span> ?&#8288;is_sep:(char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a> list</code></dt><dd><p><code>fields</code> is like <a href="../index.html#val-fields"><code>String.fields</code></a>.</p></dd></dl></section><section><header><h2 id="traverse"><a href="#traverse" class="anchor"></a>Traversing substrings</h2></header><dl><dt class="spec value" id="val-find"><a href="#val-find" class="anchor"></a><code><span class="keyword">val</span> find : ?&#8288;rev:bool <span>&#45;&gt;</span> (char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a> option</code></dt><dd><p><code>find ~rev sat s</code> is the substring of <code>s</code> (if any) that spans the first byte that satisfies <code>sat</code> in <code>s</code> after position <code>start s</code> (<code>rev</code> is <code>false</code>, default) or before <code>stop s</code> (<code>rev</code> is <code>true</code>). <code>None</code> is returned if there is no matching byte in <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-find_sub"><a href="#val-find_sub" class="anchor"></a><code><span class="keyword">val</span> find_sub : ?&#8288;rev:bool <span>&#45;&gt;</span> sub:<a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a> option</code></dt><dd><p><code>find_sub ~rev ~sub s</code> is the substring of <code>s</code> (if any) that spans the first match of <code>sub</code> in <code>s</code> after position <code>start s</code> (<code>rev</code> is <code>false</code>, defaults) or before <code>stop s</code> (<code>rev</code> is <code>false</code>). Only bytes are compared and <code>sub</code> can be on a different base string. <code>None</code> is returned if there is no match of <code>sub</code> in <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span class="keyword">val</span> filter : (char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a></code></dt><dd><p><code>filter sat s</code> is like <a href="../index.html#val-filter"><code>String.filter</code></a>. The result is on a base string that holds only the filtered bytes.</p></dd></dl><dl><dt class="spec value" id="val-filter_map"><a href="#val-filter_map" class="anchor"></a><code><span class="keyword">val</span> filter_map : (char <span>&#45;&gt;</span> char option) <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a></code></dt><dd><p><code>filter_map f s</code> is like <a href="../index.html#val-filter_map"><code>String.filter_map</code></a>. The result is on a base string that holds only the filtered bytes.</p></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : (char <span>&#45;&gt;</span> char) <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a></code></dt><dd><p><code>map</code> is like <a href="../index.html#val-map"><code>String.map</code></a>. The result is on a base string that holds only the mapped bytes.</p></dd></dl><dl><dt class="spec value" id="val-mapi"><a href="#val-mapi" class="anchor"></a><code><span class="keyword">val</span> mapi : (int <span>&#45;&gt;</span> char <span>&#45;&gt;</span> char) <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a></code></dt><dd><p><code>mapi</code> is like <a href="../index.html#val-mapi"><code>String.mapi</code></a>. The result is on a base string that holds only the mapped bytes. The indices are the substring's zero-based ones, not those in the base string.</p></dd></dl><dl><dt class="spec value" id="val-fold_left"><a href="#val-fold_left" class="anchor"></a><code><span class="keyword">val</span> fold_left : (<span class="type-var">'a</span> <span>&#45;&gt;</span> char <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>fold_left</code> is like <a href="../index.html#val-fold_left"><code>String.fold_left</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-fold_right"><a href="#val-fold_right" class="anchor"></a><code><span class="keyword">val</span> fold_right : (char <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>fold_right</code> is like <a href="../index.html#val-fold_right"><code>String.fold_right</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : (char <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>iter</code> is like <a href="../index.html#val-iter"><code>String.iter</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-iteri"><a href="#val-iteri" class="anchor"></a><code><span class="keyword">val</span> iteri : (int <span>&#45;&gt;</span> char <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>iteri</code> is like <a href="../index.html#val-iteri"><code>String.iteri</code></a>. The indices are the substring's zero-based ones, not those in the base string.</p></dd></dl></section><section><header><h2 id="pp"><a href="#pp" class="anchor"></a>Pretty printing</h2></header><dl><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val</span> pp : <a href="../../../../ocaml/Stdlib/Format/index.html#type-formatter">Stdlib.Format.formatter</a> <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp ppf s</code> prints <code>s</code>'s bytes on <code>ppf</code>.</p></dd></dl><dl><dt class="spec value" id="val-dump"><a href="#val-dump" class="anchor"></a><code><span class="keyword">val</span> dump : <a href="../../../../ocaml/Stdlib/Format/index.html#type-formatter">Stdlib.Format.formatter</a> <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>dump ppf s</code> prints <code>s</code> as a syntactically valid OCaml string on <code>ppf</code> using <a href="../Ascii/index.html#val-escape_string"><code>Ascii.escape_string</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-dump_raw"><a href="#val-dump_raw" class="anchor"></a><code><span class="keyword">val</span> dump_raw : <a href="../../../../ocaml/Stdlib/Format/index.html#type-formatter">Stdlib.Format.formatter</a> <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>dump_raw ppf s</code> prints an unspecified raw internal representation of <code>s</code> on ppf.</p></dd></dl></section><section><header><h2 id="convert"><a href="#convert" class="anchor"></a>OCaml base type conversions</h2></header><dl><dt class="spec value" id="val-of_char"><a href="#val-of_char" class="anchor"></a><code><span class="keyword">val</span> of_char : char <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a></code></dt><dd><p><code>of_char c</code> is a string that contains the byte <code>c</code>.</p></dd></dl><dl><dt class="spec value" id="val-to_char"><a href="#val-to_char" class="anchor"></a><code><span class="keyword">val</span> to_char : <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> char option</code></dt><dd><p><code>to_char s</code> is the single byte in <code>s</code> or <code>None</code> if there is no byte or more than one in <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-of_bool"><a href="#val-of_bool" class="anchor"></a><code><span class="keyword">val</span> of_bool : bool <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a></code></dt><dd><p><code>of_bool b</code> is a string representation for <code>b</code>. Relies on <span class="xref-unresolved" title="unresolved reference to &quot;Pervasives.string_of_bool&quot;"><code>Pervasives</code>.string_of_bool</span>.</p></dd></dl><dl><dt class="spec value" id="val-to_bool"><a href="#val-to_bool" class="anchor"></a><code><span class="keyword">val</span> to_bool : <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> bool option</code></dt><dd><p><code>to_bool s</code> is a <code>bool</code> from <code>s</code>, if any. Relies on <span class="xref-unresolved" title="unresolved reference to &quot;Pervasives.bool_of_string&quot;"><code>Pervasives</code>.bool_of_string</span>.</p></dd></dl><dl><dt class="spec value" id="val-of_int"><a href="#val-of_int" class="anchor"></a><code><span class="keyword">val</span> of_int : int <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a></code></dt><dd><p><code>of_int i</code> is a string representation for <code>i</code>. Relies on <span class="xref-unresolved" title="unresolved reference to &quot;Pervasives.string_of_int&quot;"><code>Pervasives</code>.string_of_int</span>.</p></dd></dl><dl><dt class="spec value" id="val-to_int"><a href="#val-to_int" class="anchor"></a><code><span class="keyword">val</span> to_int : <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> int option</code></dt><dd><p><code>to_int</code> is an <code>int</code> from <code>s</code>, if any. Relies on <span class="xref-unresolved" title="unresolved reference to &quot;Pervasives.int_of_string&quot;"><code>Pervasives</code>.int_of_string</span>.</p></dd></dl><dl><dt class="spec value" id="val-of_nativeint"><a href="#val-of_nativeint" class="anchor"></a><code><span class="keyword">val</span> of_nativeint : nativeint <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a></code></dt><dd><p><code>of_nativeint i</code> is a string representation for <code>i</code>. Relies on <span class="xref-unresolved" title="unresolved reference to &quot;Nativeint.of_string&quot;"><code>Nativeint</code>.of_string</span>.</p></dd></dl><dl><dt class="spec value" id="val-to_nativeint"><a href="#val-to_nativeint" class="anchor"></a><code><span class="keyword">val</span> to_nativeint : <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> nativeint option</code></dt><dd><p><code>to_nativeint</code> is an <code>nativeint</code> from <code>s</code>, if any. Relies on <span class="xref-unresolved" title="unresolved reference to &quot;Nativeint.to_string&quot;"><code>Nativeint</code>.to_string</span>.</p></dd></dl><dl><dt class="spec value" id="val-of_int32"><a href="#val-of_int32" class="anchor"></a><code><span class="keyword">val</span> of_int32 : int32 <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a></code></dt><dd><p><code>of_int32 i</code> is a string representation for <code>i</code>. Relies on <span class="xref-unresolved" title="unresolved reference to &quot;Int32.of_string&quot;"><code>Int32</code>.of_string</span>.</p></dd></dl><dl><dt class="spec value" id="val-to_int32"><a href="#val-to_int32" class="anchor"></a><code><span class="keyword">val</span> to_int32 : <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> int32 option</code></dt><dd><p><code>to_int32</code> is an <code>int32</code> from <code>s</code>, if any. Relies on <span class="xref-unresolved" title="unresolved reference to &quot;Int32.to_string&quot;"><code>Int32</code>.to_string</span>.</p></dd></dl><dl><dt class="spec value" id="val-of_int64"><a href="#val-of_int64" class="anchor"></a><code><span class="keyword">val</span> of_int64 : int64 <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a></code></dt><dd><p><code>of_int64 i</code> is a string representation for <code>i</code>. Relies on <span class="xref-unresolved" title="unresolved reference to &quot;Int64.of_string&quot;"><code>Int64</code>.of_string</span>.</p></dd></dl><dl><dt class="spec value" id="val-to_int64"><a href="#val-to_int64" class="anchor"></a><code><span class="keyword">val</span> to_int64 : <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> int64 option</code></dt><dd><p><code>to_int64</code> is an <code>int64</code> from <code>s</code>, if any. Relies on <span class="xref-unresolved" title="unresolved reference to &quot;Int64.to_string&quot;"><code>Int64</code>.to_string</span>.</p></dd></dl><dl><dt class="spec value" id="val-of_float"><a href="#val-of_float" class="anchor"></a><code><span class="keyword">val</span> of_float : float <span>&#45;&gt;</span> <a href="../index.html#type-sub">sub</a></code></dt><dd><p><code>of_float f</code> is a string representation for <code>f</code>. Relies on <span class="xref-unresolved" title="unresolved reference to &quot;Pervasives.string_of_float&quot;"><code>Pervasives</code>.string_of_float</span>.</p></dd></dl><dl><dt class="spec value" id="val-to_float"><a href="#val-to_float" class="anchor"></a><code><span class="keyword">val</span> to_float : <a href="../index.html#type-sub">sub</a> <span>&#45;&gt;</span> float option</code></dt><dd><p><code>to_float s</code> is a <code>float</code> from <code>s</code>, if any. Relies on <span class="xref-unresolved" title="unresolved reference to &quot;Pervasives.float_of_string&quot;"><code>Pervasives</code>.float_of_string</span>.</p></dd></dl></section><section><header><h2 id="fig"><a href="#fig" class="anchor"></a>Substring stretching graphical guide</h2><pre>+---+---+---+---+---+---+---+---+---+---+---+
| R | e | v | o | l | t |   | n | o | w | ! |
+---+---+---+---+---+---+---+---+---+---+---+
        |---------------|                      a
        |                                      start a
                        |                      stop a
            |-----------|                      tail a
        |-----------|                          tail ~rev:true a
        |-----------------------------------|  extend a
|-----------------------|                      extend ~rev:true a
|-------------------------------------------|  base a
|-----------|                                  b
|                                              start b
            |                                  stop b
    |-------|                                  tail b
|-------|                                      tail ~rev:true b
|-------------------------------------------|  extend b
|-----------|                                  extend ~rev:true b
|-------------------------------------------|  base b
|-----------------------|                      extent a b
        |---|                                  overlap a b
                            |                  c
                            |                  start c
                            |                  stop c
                            |                  tail c
                            |                  tail ~rev:true c
                            |---------------|  extend c
|---------------------------|                  extend ~rev:true c
|-------------------------------------------|  base c
        |-------------------|                  extent a c
                                         None  overlap a c
                            |---------------|  d
                            |                  start d
                                            |  stop d
                                |-----------|  tail d
                            |-----------|      tail ~rev:true d
                            |---------------|  extend d
|-------------------------------------------|  extend ~rev:true d
|-------------------------------------------|  base d
                            |---------------|  extent d c
                            |                  overlap d c</pre></header></section></div></body></html>