<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Unbuffered (angstrom.Angstrom.Unbuffered)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../../index.html">angstrom</a> &#x00BB; <a href="../index.html">Angstrom</a> &#x00BB; Unbuffered</nav><header class="odoc-preamble"><h1>Module <code><span>Angstrom.Unbuffered</span></code></h1><p>Unbuffered parsing interface.</p><p>Use this module for total control over memory allocation and copying. Parsers run through this module perform no internal buffering. Instead, the user is responsible for managing a buffer containing the entirety of the input that has yet to be consumed by the parser. The <a href="#type-state.Partial"><code>Unbuffered.state.Partial</code></a> parser state reports to the user how much input the parser consumed during its last run, via the <a href="#type-partial.committed"><code>Unbuffered.partial.committed</code></a> field. This area of input must be discarded before parsing can resume. Once additional input has been collected, the unconsumed input as well as new input must be passed to the parser state via the <a href="#type-partial.continue"><code>Unbuffered.partial.continue</code></a> function, together with an indication of whether there is <a href="#type-more"><code>Unbuffered.more</code></a> input to come.</p><p>The logic that must be implemented in order to make proper use of this module is intricate and tied to your OS environment. It's advisable to use the <a href="../Buffered/index.html"><code>Buffered</code></a> module when initially developing and testing your parsers. For production use-cases, consider the Async and Lwt support that this library includes before attempting to use this module directly.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-more" class="anchored"><a href="#type-more" class="anchor"></a><code><span><span class="keyword">type</span> more</span><span> = </span></code><table><tr id="type-more.Complete" class="anchored"><td class="def variant constructor"><a href="#type-more.Complete" class="anchor"></a><code><span>| </span><span><span class="constructor">Complete</span></span></code></td></tr><tr id="type-more.Incomplete" class="anchored"><td class="def variant constructor"><a href="#type-more.Incomplete" class="anchor"></a><code><span>| </span><span><span class="constructor">Incomplete</span></span></code></td></tr></table></div></div><div class="odoc-spec"><div class="spec type" id="type-state" class="anchored"><a href="#type-state" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a state</span></span><span> = </span></code><table><tr id="type-state.Partial" class="anchored"><td class="def variant constructor"><a href="#type-state.Partial" class="anchor"></a><code><span>| </span><span><span class="constructor">Partial</span> <span class="keyword">of</span> <span><span class="type-var">'a</span> <a href="#type-partial">partial</a></span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The parser requires more input.</p><span class="comment-delim">*)</span></td></tr><tr id="type-state.Done" class="anchored"><td class="def variant constructor"><a href="#type-state.Done" class="anchor"></a><code><span>| </span><span><span class="constructor">Done</span> <span class="keyword">of</span> int * <span class="type-var">'a</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The parser succeeded, consuming specified bytes.</p><span class="comment-delim">*)</span></td></tr><tr id="type-state.Fail" class="anchored"><td class="def variant constructor"><a href="#type-state.Fail" class="anchor"></a><code><span>| </span><span><span class="constructor">Fail</span> <span class="keyword">of</span> int * <span>string list</span> * string</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The parser failed, consuming specified bytes.</p><span class="comment-delim">*)</span></td></tr></table></div></div><div class="odoc-spec"><div class="spec type" id="type-partial" class="anchored"><a href="#type-partial" class="anchor"></a><code><span><span class="keyword">and</span> <span>'a partial</span></span><span> = </span><span>{</span></code><table><tr id="type-partial.committed" class="anchored"><td class="def record field"><a href="#type-partial.committed" class="anchor"></a><code><span>committed : int;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The number of bytes committed during the last input feeding. Callers must drop this number of bytes from the beginning of the input on subsequent calls. See <a href="../index.html#val-commit"><code>commit</code></a> for additional details.</p><span class="comment-delim">*)</span></td></tr><tr id="type-partial.continue" class="anchored"><td class="def record field"><a href="#type-partial.continue" class="anchor"></a><code><span>continue : <span><a href="../index.html#type-bigstring">bigstring</a> <span class="arrow">&#45;&gt;</span></span> <span>off:int <span class="arrow">&#45;&gt;</span></span> <span>len:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-more">more</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-state">state</a></span>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>A continuation of a parse that requires additional input. The input should include all uncommitted input (as reported by previous partial states) in addition to any new input that has become available, as well as an indication of whether there is <a href="#type-more"><code>more</code></a> input to come.</p><span class="comment-delim">*)</span></td></tr></table><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-parse" class="anchored"><a href="#val-parse" class="anchor"></a><code><span><span class="keyword">val</span> parse : <span><span><span class="type-var">'a</span> <a href="../index.html#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-state">state</a></span></span></code></div><div class="spec-doc"><p><code>parse t</code> runs <code>t</code> and await input if needed.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-state_to_option" class="anchored"><a href="#val-state_to_option" class="anchor"></a><code><span><span class="keyword">val</span> state_to_option : <span><span><span class="type-var">'a</span> <a href="#type-state">state</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div></div><p><code>state_to_option state</code> returns <code>Some v</code> if the parser is in the <code>Done (bs, v)</code> state and <code>None</code> otherwise. This function has no effect on the current state of the parser.</p><div class="odoc-spec"><div class="spec value" id="val-state_to_result" class="anchored"><a href="#val-state_to_result" class="anchor"></a><code><span><span class="keyword">val</span> state_to_result : <span><span><span class="type-var">'a</span> <a href="#type-state">state</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, string)</span> <a href="../../../ocaml/Stdlib/index.html#type-result">result</a></span></span></code></div><div class="spec-doc"><p><code>state_to_result state</code> returns <code>Ok v</code> if the parser is in the <code>Done (bs, v)</code> state and <code>Error msg</code> if it is in the <code>Fail</code> or <code>Partial</code> state.</p><p>This function has no effect on the current state of the parser.</p></div></div></div></body></html>