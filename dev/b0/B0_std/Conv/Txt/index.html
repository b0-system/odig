<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Txt (b0.B0_std.Conv.Txt)</title><link rel="stylesheet" href="../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../../index.html">b0</a> &#x00BB; <a href="../../index.html">B0_std</a> &#x00BB; <a href="../index.html">Conv</a> &#x00BB; Txt</nav><h1>Module <code>Conv.Txt</code></h1><p>Textual codecs</p><nav class="toc"><ul><li><a href="#codec">Textual encoders and decoders</a></li><li><a href="#enc">Encoding</a></li><li><a href="#dec">Decoding</a></li></ul></nav></header><section><header><h2 id="codec"><a href="#codec" class="anchor"></a>Textual encoders and decoders</h2></header><dl><dt class="spec type" id="type-enc"><a href="#type-enc" class="anchor"></a><code><span class="keyword">type</span> 'a enc</code><code> = <a href="../../../../ocaml/Stdlib/Format/index.html#type-formatter">Stdlib.Format.formatter</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>The type for textual encoders. <code>enc ppf v</code> textually encodes the value <code>v</code> on <code>ppf</code>. Raises <a href="../index.html#exception-Error"><code>Error</code></a> in case of error.</p></dd></dl><dl><dt class="spec type" id="type-dec"><a href="#type-dec" class="anchor"></a><code><span class="keyword">type</span> 'a dec</code><code> = string <span>&#45;&gt;</span> start:int <span>&#45;&gt;</span> int * <span class="type-var">'a</span></code></dt><dd><p>The type for textual decoders. <code>dec s ~start</code> textually decodes a value at <code>start</code> in <code>s</code>. <code>start</code> is either the first textual input bytes to consider (which may be whitespace or a commenet) or the length of <code>s</code>. The function returns <code>(i, v)</code> with <code>v</code> the decoded value and <code>i</code> the first index after the decoded value or the lenght of <code>s</code> if there is no such index. Raises <a href="../index.html#exception-Error"><code>Error</code></a> in case of error.</p><p><b>XXX.</b> In the end this signature is showing its limits for error reporting. Maybe we should have an abstraction here.</p></dd></dl></section><section><header><h2 id="enc"><a href="#enc" class="anchor"></a>Encoding</h2></header><dl><dt class="spec value" id="val-enc_err"><a href="#val-enc_err" class="anchor"></a><code><span class="keyword">val</span> enc_err : kind:string <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <a href="../../../../ocaml/Stdlib/Format/index.html#type-formatter">Stdlib.Format.formatter</a>, unit, <span class="type-var">'b</span>) <a href="../../../../ocaml/Stdlib/index.html#type-format4">Stdlib.format4</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>enc_err ~kind fmt</code> raises a textual encoding error message for kind <code>kind</code> formatted according to <code>fmt</code>.</p></dd></dl><dl><dt class="spec value" id="val-enc_atom"><a href="#val-enc_atom" class="anchor"></a><code><span class="keyword">val</span> enc_atom : string <a href="index.html#type-enc">enc</a></code></dt><dd><p><code>enc_atom ppf s</code> encodes <code>s</code> as an <a href="../index.html#val-atom"><span>atom</span></a> on <code>ppf</code> quoting it as needed.</p></dd></dl><dl><dt class="spec value" id="val-enc_list"><a href="#val-enc_list" class="anchor"></a><code><span class="keyword">val</span> enc_list : <span class="type-var">'a</span> <a href="index.html#type-enc">enc</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <a href="index.html#type-enc">enc</a></code></dt><dd><p><code>enc_list enc_v</code> encodes a list of values encoded with <code>enc_v</code>.</p></dd></dl></section><section><header><h2 id="dec"><a href="#dec" class="anchor"></a>Decoding</h2></header><dl><dt class="spec type" id="type-lexeme"><a href="#type-lexeme" class="anchor"></a><code><span class="keyword">type</span> lexeme</code> = <code>[ </code><table class="variant"><tr id="type-lexeme.Ls" class="anchored"><td class="def constructor"><a href="#type-lexeme.Ls" class="anchor"></a><code>| </code><code>`Ls</code></td></tr><tr id="type-lexeme.Le" class="anchored"><td class="def constructor"><a href="#type-lexeme.Le" class="anchor"></a><code>| </code><code>`Le</code></td></tr><tr id="type-lexeme.Atom" class="anchored"><td class="def constructor"><a href="#type-lexeme.Atom" class="anchor"></a><code>| </code><code>`Atom <span class="keyword">of</span> string</code></td></tr></table><code> ]</code></dt><dd><p>The type for s-expressions lexemes.</p></dd></dl><dl><dt class="spec value" id="val-dec_err"><a href="#val-dec_err" class="anchor"></a><code><span class="keyword">val</span> dec_err : kind:string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <a href="../../../../ocaml/Stdlib/Format/index.html#type-formatter">Stdlib.Format.formatter</a>, unit, <span class="type-var">'b</span>) <a href="../../../../ocaml/Stdlib/index.html#type-format4">Stdlib.format4</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>dec_err ~kind i fmt</code> raises a textual decoding error message for kind <code>kind</code> at input byte index <code>i</code> formatted according to <code>fmt</code>.</p></dd></dl><dl><dt class="spec value" id="val-dec_err_eoi"><a href="#val-dec_err_eoi" class="anchor"></a><code><span class="keyword">val</span> dec_err_eoi : kind:string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>dec_err_eoi ~kind i</code> raises a textual error message for kind <code>kind</code> at input byte index <code>i</code> indicating an unexpected end of input.</p></dd></dl><dl><dt class="spec value" id="val-dec_err_lexeme"><a href="#val-dec_err_lexeme" class="anchor"></a><code><span class="keyword">val</span> dec_err_lexeme : kind:string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-lexeme">lexeme</a> <span>&#45;&gt;</span> exp:<a href="index.html#type-lexeme">lexeme</a> list <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>dec_err_case ~kind i</code> raises a textual error message for kind <code>kind</code> at input byte index <code>i</code> indicating one of <code>exp</code> was expected.</p></dd></dl><dl><dt class="spec value" id="val-dec_err_atom"><a href="#val-dec_err_atom" class="anchor"></a><code><span class="keyword">val</span> dec_err_atom : kind:string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> string <span>&#45;&gt;</span> exp:string list <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>dec_err_atom ~kind i a exp</code> raises a textual error message for kind <code>kind</code> at input byte index <code>i</code> and atom <code>a</code> indicating one of <code>exp</code> atoms was expected.</p></dd></dl><dl><dt class="spec value" id="val-dec_skip"><a href="#val-dec_skip" class="anchor"></a><code><span class="keyword">val</span> dec_skip : kind:string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> start:int <span>&#45;&gt;</span> int</code></dt><dd><p><code>dec_skip ~kind s ~start</code> starting at <code>start</code> (which can be out of bounds) is the first non-white, non-comment, byte index or the length of <code>s</code> if there is no such index.</p></dd></dl><dl><dt class="spec value" id="val-dec_lexeme"><a href="#val-dec_lexeme" class="anchor"></a><code><span class="keyword">val</span> dec_lexeme : kind:string <span>&#45;&gt;</span> (int * <a href="index.html#type-lexeme">lexeme</a>) <a href="index.html#type-dec">dec</a></code></dt><dd><p><code>dec_case ~kind s ~start</code> starting at <code>start</code> (which can be out of bounds), skips whitespace and comment, looks for either a left parenthesis, right parenthesis or an atom and returns the index of their first position. Errors if end of input is is found.</p></dd></dl><dl><dt class="spec value" id="val-dec_ls"><a href="#val-dec_ls" class="anchor"></a><code><span class="keyword">val</span> dec_ls : kind:string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> start:int <span>&#45;&gt;</span> int</code></dt><dd><p><code>dec_ls ~kind s ~start</code> starting at <code>start</code> (which can be out of bounds), skips whitespace and comments, parses a list start and returns the index after it or the length of <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-dec_le"><a href="#val-dec_le" class="anchor"></a><code><span class="keyword">val</span> dec_le : kind:string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> start:int <span>&#45;&gt;</span> int</code></dt><dd><p><code>dec_le ~kind s ~start</code> starting at <code>start</code> (which can be out of bounds), skips whitespace and comments, parses a list end and returns the index after it or the length of <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-dec_atom"><a href="#val-dec_atom" class="anchor"></a><code><span class="keyword">val</span> dec_atom : kind:string <span>&#45;&gt;</span> string <a href="index.html#type-dec">dec</a></code></dt><dd><p><code>dec_atom ~kind s ~start</code> starting at <code>start</code> (which can be out of bounds), skips whitespace and comments, parses an atom and returns the index after it or the length of <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-dec_list"><a href="#val-dec_list" class="anchor"></a><code><span class="keyword">val</span> dec_list : <span class="type-var">'a</span> <a href="index.html#type-dec">dec</a> <span>&#45;&gt;</span> kind:string <span>&#45;&gt;</span> <span class="type-var">'a</span> list <a href="index.html#type-dec">dec</a></code></dt><dd><p><code>dec_list dec_v ~kind</code> decodes a list of values decoded with <code>dec_v</code> for the given <code>kind</code>.</p></dd></dl><dl><dt class="spec value" id="val-dec_list_tail"><a href="#val-dec_list_tail" class="anchor"></a><code><span class="keyword">val</span> dec_list_tail : <span class="type-var">'a</span> <a href="index.html#type-dec">dec</a> <span>&#45;&gt;</span> kind:string <span>&#45;&gt;</span> ls:int <span>&#45;&gt;</span> <span class="type-var">'a</span> list <a href="index.html#type-dec">dec</a></code></dt><dd><p><code>dec_list_tail dec_v ~kind ~lstart</code> decodes list elements decoded with <code>dec_v</code> and an the end of list for the given <code>kind</code>, <code>ls</code> is the position of the list start.</p></dd></dl></section></div></body></html>