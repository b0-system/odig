<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Map (batteries.BatteriesExceptionless.Map)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../../index.html">batteries</a> &#x00BB; <a href="../index.html">BatteriesExceptionless</a> &#x00BB; Map</nav><header class="odoc-preamble"><h1>Module <code><span>BatteriesExceptionless.Map</span></code></h1></header><div class="odoc-content"><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> <a href="../../BatMap/index.html">BatMap</a> <span class="keyword">with</span> <span><span class="keyword">module</span> <a href="../../BatMap/PMap/index.html">PMap</a> := <a href="../../BatMap/PMap/index.html">BatMap.PMap</a></span></span></code></summary><div class="odoc-spec"><div class="spec module-type" id="module-type-S" class="anchored"><a href="#module-type-S" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span><a href="module-type-S/index.html">S</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Association tables over ordered types.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Make" class="anchored"><a href="#module-Make" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Make/index.html">Make</a></span><span> (<a href="Make/argument-1-Ord/index.html">Ord</a> : <a href="../../BatInterfaces/module-type-OrderedType/index.html">BatInterfaces.OrderedType</a>) : <a href="module-type-S/index.html">S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="module-type-S/index.html#type-key">key</a> = <a href="Make/argument-1-Ord/index.html#type-t">Ord.t</a></span></span></code></div><div class="spec-doc"><p>Functor building an implementation of the map structure given a totally ordered type.</p></div></div><h6 id="common-instantiations"><a href="#common-instantiations" class="anchor"></a>Common instantiations</h6><p>*</p><div class="odoc-spec"><div class="spec module" id="module-Int" class="anchored"><a href="#module-Int" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Int/index.html">Int</a></span><span> : <a href="module-type-S/index.html">S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="module-type-S/index.html#type-key">key</a> = int</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Int32" class="anchored"><a href="#module-Int32" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Int32/index.html">Int32</a></span><span> : <a href="module-type-S/index.html">S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="module-type-S/index.html#type-key">key</a> = int32</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Int64" class="anchored"><a href="#module-Int64" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Int64/index.html">Int64</a></span><span> : <a href="module-type-S/index.html">S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="module-type-S/index.html#type-key">key</a> = int64</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Nativeint" class="anchored"><a href="#module-Nativeint" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Nativeint/index.html">Nativeint</a></span><span> : <a href="module-type-S/index.html">S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="module-type-S/index.html#type-key">key</a> = nativeint</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Float" class="anchored"><a href="#module-Float" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Float/index.html">Float</a></span><span> : <a href="module-type-S/index.html">S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="module-type-S/index.html#type-key">key</a> = float</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Char" class="anchored"><a href="#module-Char" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Char/index.html">Char</a></span><span> : <a href="module-type-S/index.html">S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="module-type-S/index.html#type-key">key</a> = char</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-String" class="anchored"><a href="#module-String" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="String/index.html">String</a></span><span> : <a href="module-type-S/index.html">S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="module-type-S/index.html#type-key">key</a> = string</span></span></code></div></div><h5 id="polymorphic-maps"><a href="#polymorphic-maps" class="anchor"></a>Polymorphic maps</h5><p>The functions below present the manipulation of polymorphic maps, as were provided by the Extlib PMap module.</p><p>They are similar in functionality to the functorized <a href="Make/index.html"><code>Make</code></a> module, but only uses the <code>Pervasives.compare</code> function to compare elements. If you need to compare using a custom comparison function, it is recommended to use the functorized maps provided by <a href="Make/index.html"><code>Make</code></a>.</p><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 'b) t</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-empty" class="anchored"><a href="#val-empty" class="anchor"></a><code><span><span class="keyword">val</span> empty : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>The empty map, using <code>compare</code> as key comparison function.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_empty" class="anchored"><a href="#val-is_empty" class="anchor"></a><code><span><span class="keyword">val</span> is_empty : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Returns <code>true</code> if the map is empty.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-singleton" class="anchored"><a href="#val-singleton" class="anchor"></a><code><span><span class="keyword">val</span> singleton : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Creates a new map with a single binding.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-cardinal" class="anchored"><a href="#val-cardinal" class="anchor"></a><code><span><span class="keyword">val</span> cardinal : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Return the number of bindings of a map.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-add" class="anchored"><a href="#val-add" class="anchor"></a><code><span><span class="keyword">val</span> add : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>add x y m</code> returns a map containing the same bindings as <code>m</code>, plus a binding of <code>x</code> to <code>y</code>. If <code>x</code> was already bound in <code>m</code>, its previous binding disappears. If <code>x</code> was already bound to some <code>z</code> that is physically equal to <code>y</code>, then the returned map is physically equal to <code>m</code>.</p><ul class="at-tags"><li class="before"><span class="at-tag">before</span> <span class="value">3.3.0</span> <p>physical equality was not ensured.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-update" class="anchored"><a href="#val-update" class="anchor"></a><code><span><span class="keyword">val</span> update : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>update k1 k2 v2 m</code> replace the previous binding of <code>k1</code> in <code>m</code> by <code>k2</code> associated to <code>v2</code>. This is equivalent to <code>add k2 v2 (remove k1) m</code>, but more efficient in the case where <code>k1</code> and <code>k2</code> have the same key ordering. If <code>k1</code> and <code>k2</code> have the same key ordering and <code>v2</code> is physically equal to the value <code>k1</code> is bound to in <code>m</code> then the returned map will be physically equal to <code>m</code></p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Not_found</span> <p>if <code>k1</code> is not bound in <code>m</code>.</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.4.0</li></ul><ul class="at-tags"><li class="before"><span class="at-tag">before</span> <span class="value">3.3.0</span> <p>physical equality was not ensured.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-update_stdlib" class="anchored"><a href="#val-update_stdlib" class="anchor"></a><code><span><span class="keyword">val</span> update_stdlib : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span><span class="type-var">'b</span> option</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>update_stdlib k f m</code> returns a map containing the same bindings as <code>m</code>, except <code>k</code> has a new binding as determined by <code>f</code>: First, calculate <code>y</code> as <code>f (find_opt k m)</code>. If <code>y = Some v</code> then <code>k</code> will be bound to <code>v</code> in the resulting map. Else <code>k</code> will not be bound in the resulting map.</p><p>If <code>v</code> is physically equal to the value of the previous binding of <code>k</code> in <code>m</code>, then the returned map will be physically equal to <code>m</code>.</p><p>This function does the same thing as <code>update</code> in the stdlib, but has a different name for backwards compatibility reasons.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.3.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-find_opt" class="anchored"><a href="#val-find_opt" class="anchor"></a><code><span><span class="keyword">val</span> find_opt : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span></span></code></div><div class="spec-doc"><p><code>find_opt x m</code> returns Some b where b is the current binding * of <code>x</code> in <code>m</code>, or None if no such binding exists.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-find_default" class="anchored"><a href="#val-find_default" class="anchor"></a><code><span><span class="keyword">val</span> find_default : <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span></span></code></div><div class="spec-doc"><p><code>find_default d x m</code> returns the current binding of <code>x</code> in <code>m</code>, or the default value <code>d</code> if no such binding exists.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-find_first" class="anchored"><a href="#val-find_first" class="anchor"></a><code><span><span class="keyword">val</span> find_first : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> * <span class="type-var">'b</span></span></code></div><div class="spec-doc"><p><code>find_first f m</code> returns the first binding <code>(k, v)</code> for which <code>f k</code> is true or raises <code>Not_found</code> if there is no such binding. <code>f</code> must be monotonically increasing, i.e. if <code>k1 &lt; k2 &amp;&amp; f k1</code> is true then <code>f k2</code> must also be true.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.3.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-find_first_opt" class="anchored"><a href="#val-find_first_opt" class="anchor"></a><code><span><span class="keyword">val</span> find_first_opt : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> option</span></span></code></div><div class="spec-doc"><p><code>find_first_opt f m</code> returns <code>Some (k, v)</code> for the first binding <code>(k, v)</code> for which <code>f k</code> is true or returns <code>None</code> if there is no such binding. <code>f</code> must be monotonically increasing, i.e. if <code>k1 &lt; k2 &amp;&amp; f k1</code> is true then <code>f k2</code> must also be true.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.3.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-find_last" class="anchored"><a href="#val-find_last" class="anchor"></a><code><span><span class="keyword">val</span> find_last : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> * <span class="type-var">'b</span></span></code></div><div class="spec-doc"><p><code>find_last f m</code> returns the last binding <code>(k, v)</code> for which <code>f k</code> is true or raises <code>Not_found</code> if there is no such binding. <code>f</code> must be monotonically decreasing, i.e. if <code>k1 &lt; k2 &amp;&amp; f k2</code> is true then <code>f k1</code> must also be true.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.3.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-find_last_opt" class="anchored"><a href="#val-find_last_opt" class="anchor"></a><code><span><span class="keyword">val</span> find_last_opt : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> option</span></span></code></div><div class="spec-doc"><p><code>find_last_opt f m</code> returns <code>Some (k, v)</code> for the last binding <code>(k, v)</code> for which <code>f k</code> is true or returns <code>None</code> if there is no such binding. <code>f</code> must be monotonically decreasing, i.e. if <code>k1 &lt; k2 &amp;&amp; f k2</code> is true then <code>f k1</code> must also be true.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.3.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-remove" class="anchored"><a href="#val-remove" class="anchor"></a><code><span><span class="keyword">val</span> remove : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>remove x m</code> returns a map containing the same bindings as <code>m</code>, except for <code>x</code> which is unbound in the returned map. The returned map is physically equal to the passed one if <code>x</code> was already unbound.</p><ul class="at-tags"><li class="before"><span class="at-tag">before</span> <span class="value">3.3.0</span> <p>physical equality was not ensured</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-remove_exn" class="anchored"><a href="#val-remove_exn" class="anchor"></a><code><span><span class="keyword">val</span> remove_exn : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>remove_exn x m</code> behaves like <code>remove x m</code> except that it raises an exception if <code>x</code> is unbound in <code>m</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Not_found</span> <p>if <code>x</code> is unbound in <code>m</code></p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.2.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-mem" class="anchored"><a href="#val-mem" class="anchor"></a><code><span><span class="keyword">val</span> mem : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>mem x m</code> returns <code>true</code> if <code>m</code> contains a binding for <code>x</code>, and <code>false</code> otherwise.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-iter" class="anchored"><a href="#val-iter" class="anchor"></a><code><span><span class="keyword">val</span> iter : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>iter f m</code> applies <code>f</code> to all bindings in map <code>m</code>. <code>f</code> receives the key as first argument, and the associated value as second argument. The order in which the bindings are passed to <code>f</code> is unspecified. Only current bindings are presented to <code>f</code>: bindings hidden by more recent bindings are not passed to <code>f</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-map" class="anchored"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span><span>(<span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'c</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>map f m</code> returns a map with same domain as <code>m</code>, where the associated value <code>a</code> of all bindings of <code>m</code> has been replaced by the result of the application of <code>f</code> to <code>a</code>. The order in which the associated values are passed to <code>f</code> is unspecified.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mapi" class="anchored"><a href="#val-mapi" class="anchor"></a><code><span><span class="keyword">val</span> mapi : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'c</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Same as <code>map</code>, but the function receives as arguments both the key and the associated value for each binding of the map.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold" class="anchored"><a href="#val-fold" class="anchor"></a><code><span><span class="keyword">val</span> fold : <span><span>(<span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span></span></code></div><div class="spec-doc"><p><code>fold f m a</code> computes <code>(f kN dN ... (f k1 d1 (f k0 d0 a))...)</code>, where <code>k0,k1..kN</code> are the keys of all bindings in <code>m</code>, and <code>d0,d1..dN</code> are the associated data. The order in which the bindings are presented to <code>f</code> is unspecified.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-foldi" class="anchored"><a href="#val-foldi" class="anchor"></a><code><span><span class="keyword">val</span> foldi : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span></span></code></div><div class="spec-doc"><p>Same as <code>fold</code>, but the function receives as arguments both the key and the associated value for each binding of the map.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-at_rank_exn" class="anchored"><a href="#val-at_rank_exn" class="anchor"></a><code><span><span class="keyword">val</span> at_rank_exn : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'key</span>, <span class="type-var">'a</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'key</span> * <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>at_rank_exn i m</code> returns the <code>(key,value)</code> pair whose key is at rank <code>i</code> in <code>m</code>, that is the <code>i</code>-th element in increasing order of the keys (the <code>0</code>-th element being the smallest key in <code>m</code> with its associated value).</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Not_found</span> <p>if <code>m = empty</code>.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>error_message if <code>i &lt; 0 || i &gt;= cardinal m</code></p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.4</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-filterv" class="anchored"><a href="#val-filterv" class="anchor"></a><code><span><span class="keyword">val</span> filterv : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'key</span>, <span class="type-var">'a</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'key</span>, <span class="type-var">'a</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>filterv f m</code> returns a map where only the values <code>a</code> of <code>m</code> such that <code>f a = true</code> remain. The bindings are passed to <code>f</code> in increasing order with respect to the ordering over the type of the keys.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-filter" class="anchored"><a href="#val-filter" class="anchor"></a><code><span><span class="keyword">val</span> filter : <span><span>(<span><span class="type-var">'key</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'key</span>, <span class="type-var">'a</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'key</span>, <span class="type-var">'a</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>filter f m</code> returns a map where only the <code>(key, value)</code> pairs of <code>m</code> such that <code>f key value = true</code> remain. The bindings are passed to <code>f</code> in increasing order with respect to the ordering over the type of the keys. If <code>f</code> returns <code>true</code> for all bindings of <code>m</code> the returned map is physically equal to <code>m</code>.</p><ul class="at-tags"><li class="before"><span class="at-tag">before</span> <span class="value">3.3.0</span> <p>physical equality was not ensured.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-filter_map" class="anchored"><a href="#val-filter_map" class="anchor"></a><code><span><span class="keyword">val</span> filter_map : <span><span>(<span><span class="type-var">'key</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'key</span>, <span class="type-var">'a</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'key</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>filter_map f m</code> combines the features of <code>filter</code> and <code>map</code>. It calls calls <code>f key0 a0</code>, <code>f key1 a1</code>, <code>f keyn an</code> where <code>a0..an</code> are the elements of <code>m</code> and <code>key0..keyn</code> the respective corresponding keys. It returns the map of <code>(keyi, bi)</code> pairs such as <code>f keyi ai = Some bi</code> (when <code>f</code> returns <code>None</code>, the corresponding element of <code>m</code> is discarded).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-choose_opt" class="anchored"><a href="#val-choose_opt" class="anchor"></a><code><span><span class="keyword">val</span> choose_opt : <span><span><span>(<span class="type-var">'key</span>, <span class="type-var">'a</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'key</span> * <span class="type-var">'a</span>)</span> option</span></span></code></div><div class="spec-doc"><p>Return <code>Some (k, v)</code> for one binding <code>(k, v)</code> of the given map, if the map is not empty. Else, return None. Which binding is chosen is unspecified, but equal bindings will be chosen for equal maps.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.3.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-split" class="anchored"><a href="#val-split" class="anchor"></a><code><span><span class="keyword">val</span> split : <span><span class="type-var">'key</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'key</span>, <span class="type-var">'a</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'key</span>, <span class="type-var">'a</span>)</span> <a href="#type-t">t</a></span> * <span><span class="type-var">'a</span> option</span> * <span><span>(<span class="type-var">'key</span>, <span class="type-var">'a</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>split x m</code> returns a triple <code>(l, data, r)</code>, where <code>l</code> is the map with all the bindings of <code>m</code> whose key is strictly less than <code>x</code>; <code>r</code> is the map with all the bindings of <code>m</code> whose key is strictly greater than <code>x</code>; <code>data</code> is <code>None</code> if <code>m</code> contains no binding for <code>x</code>, or <code>Some v</code> if <code>m</code> binds <code>v</code> to <code>x</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-min_binding" class="anchored"><a href="#val-min_binding" class="anchor"></a><code><span><span class="keyword">val</span> min_binding : <span><span><span>(<span class="type-var">'key</span>, <span class="type-var">'a</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'key</span> * <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Returns the binding with the smallest key. Raises Not_found if the map is empty.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-min_binding_opt" class="anchored"><a href="#val-min_binding_opt" class="anchor"></a><code><span><span class="keyword">val</span> min_binding_opt : <span><span><span>(<span class="type-var">'key</span>, <span class="type-var">'a</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'key</span> * <span class="type-var">'a</span>)</span> option</span></span></code></div><div class="spec-doc"><p>Return <code>Some (key, value)</code> for the <code>key, value</code> pair with the smallest key, or <code>None</code> if the map is empty.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.3.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-pop_min_binding" class="anchored"><a href="#val-pop_min_binding" class="anchor"></a><code><span><span class="keyword">val</span> pop_min_binding : <span><span><span>(<span class="type-var">'key</span>, <span class="type-var">'a</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>(<span class="type-var">'key</span> * <span class="type-var">'a</span>)</span> * <span><span>(<span class="type-var">'key</span>, <span class="type-var">'a</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Returns the binding with the smallest key along with the rest of the map.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-max_binding" class="anchored"><a href="#val-max_binding" class="anchor"></a><code><span><span class="keyword">val</span> max_binding : <span><span><span>(<span class="type-var">'key</span>, <span class="type-var">'a</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'key</span> * <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Return the <code>(key, value)</code> pair with the largest key. Raises Not_found if the map is empty.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-max_binding_opt" class="anchored"><a href="#val-max_binding_opt" class="anchor"></a><code><span><span class="keyword">val</span> max_binding_opt : <span><span><span>(<span class="type-var">'key</span>, <span class="type-var">'a</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'key</span> * <span class="type-var">'a</span>)</span> option</span></span></code></div><div class="spec-doc"><p>Return <code>Some (key, value)</code> for the <code>key, value</code> pair with the largest key, or <code>None</code> if the map is empty.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.3.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-pop_max_binding" class="anchored"><a href="#val-pop_max_binding" class="anchor"></a><code><span><span class="keyword">val</span> pop_max_binding : <span><span><span>(<span class="type-var">'key</span>, <span class="type-var">'a</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>(<span class="type-var">'key</span> * <span class="type-var">'a</span>)</span> * <span><span>(<span class="type-var">'key</span>, <span class="type-var">'a</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Returns the binding with the largest key along with the rest of the map.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-enum" class="anchored"><a href="#val-enum" class="anchor"></a><code><span><span class="keyword">val</span> enum : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="../../BatEnum/index.html#type-t">BatEnum.t</a></span></span></code></div><div class="spec-doc"><p>Creates an enumeration for this map, enumerating <code>(key, value)</code> pairs with the keys in increasing order.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-backwards" class="anchored"><a href="#val-backwards" class="anchor"></a><code><span><span class="keyword">val</span> backwards : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="../../BatEnum/index.html#type-t">BatEnum.t</a></span></span></code></div><div class="spec-doc"><p>Creates an enumeration for this map, enumerating <code>(key, value)</code> pairs with the keys in decreasing order.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-keys" class="anchored"><a href="#val-keys" class="anchor"></a><code><span><span class="keyword">val</span> keys : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../../BatEnum/index.html#type-t">BatEnum.t</a></span></span></code></div><div class="spec-doc"><p>Return an enumeration of all the keys of a map.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-values" class="anchored"><a href="#val-values" class="anchor"></a><code><span><span class="keyword">val</span> values : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="../../BatEnum/index.html#type-t">BatEnum.t</a></span></span></code></div><div class="spec-doc"><p>Return an enumeration of all the values of a map.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_enum" class="anchored"><a href="#val-of_enum" class="anchor"></a><code><span><span class="keyword">val</span> of_enum : <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="../../BatEnum/index.html#type-t">BatEnum.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Creates a map from an enumeration.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-for_all" class="anchored"><a href="#val-for_all" class="anchor"></a><code><span><span class="keyword">val</span> for_all : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Tests whether all <code>(key, value)</code> pairs satisfy a predicate function.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-exists" class="anchored"><a href="#val-exists" class="anchor"></a><code><span><span class="keyword">val</span> exists : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Tests whether some <code>(key, value)</code> pair satisfies a predicate function.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-partition" class="anchored"><a href="#val-partition" class="anchor"></a><code><span><span class="keyword">val</span> partition : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> * <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>partition p m</code> returns a pair of maps <code>(m1, m2)</code>, where <code>m1</code> contains all the bindings of <code>s</code> that satisfy the predicate <code>p</code>, and <code>m2</code> is the map with all the bindings of <code>s</code> that do not satisfy <code>p</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-add_carry" class="anchored"><a href="#val-add_carry" class="anchor"></a><code><span><span class="keyword">val</span> add_carry : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> * <span><span class="type-var">'b</span> option</span></span></code></div><div class="spec-doc"><p><code>add_carry k v m</code> adds the binding <code>(k, v)</code> to <code>m</code>, returning the new map and optionally the previous value bound to <code>k</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-modify" class="anchored"><a href="#val-modify" class="anchor"></a><code><span><span class="keyword">val</span> modify : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>modify k f m</code> replaces the previous binding for <code>k</code> with <code>f</code> applied to that value. If <code>k</code> is unbound in <code>m</code> or <code>Not_found</code> is raised during the search, <code>Not_found</code> is raised.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.2.0</li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Not_found</span> <p>if <code>k</code> is unbound in <code>m</code> (or <code>f</code> raises <code>Not_found</code>)</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-modify_def" class="anchored"><a href="#val-modify_def" class="anchor"></a><code><span><span class="keyword">val</span> modify_def : <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>modify_def v0 k f m</code> replaces the previous binding for <code>k</code> with <code>f</code> applied to that value. If <code>k</code> is unbound in <code>m</code> or <code>Not_found</code> is raised during the search, <code>f v0</code> is inserted (as if the value found were <code>v0</code>).</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.3.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-modify_opt" class="anchored"><a href="#val-modify_opt" class="anchor"></a><code><span><span class="keyword">val</span> modify_opt : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span><span class="type-var">'b</span> option</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>modify_opt k f m</code> allow to modify the binding for <code>k</code> in <code>m</code> or absence thereof.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.1</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-extract" class="anchored"><a href="#val-extract" class="anchor"></a><code><span><span class="keyword">val</span> extract : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> * <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>extract k m</code> removes the current binding of <code>k</code> from <code>m</code>, returning the value <code>k</code> was bound to and the updated <code>m</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pop" class="anchored"><a href="#val-pop" class="anchor"></a><code><span><span class="keyword">val</span> pop : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> * <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>pop m</code> returns a binding from <code>m</code> and <code>m</code> without that binding.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-union" class="anchored"><a href="#val-union" class="anchor"></a><code><span><span class="keyword">val</span> union : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>union m1 m2</code> merges two maps, using the comparison function of <code>m1</code>. In case of conflicted bindings, <code>m2</code>'s bindings override <code>m1</code>'s. Equivalent to <code>foldi add m2 m1</code>. The resulting map uses the comparison function of <code>m1</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-union_stdlib" class="anchored"><a href="#val-union_stdlib" class="anchor"></a><code><span><span class="keyword">val</span> union_stdlib : <span><span>(<span><span class="type-var">'key</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'key</span>, <span class="type-var">'a</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'key</span>, <span class="type-var">'a</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'key</span>, <span class="type-var">'a</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>union_stdlib f m1 m2</code> computes a map whose keys are a subset of the keys of <code>m1</code> and of <code>m2</code>. When the same binding is defined in both arguments, the function f is used to combine them. This function is similar to <code>merge</code>, except <code>f</code> is only called if a key is present in both <code>m1</code> and <code>m2</code>. If a key is present in either <code>m1</code> or <code>m2</code> but not in both, it (and the corresponding value) will be present in the resulting map.</p><p>This is the union method from the stdlib map, renamed for backwards compatibility.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.3.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-to_seq" class="anchored"><a href="#val-to_seq" class="anchor"></a><code><span><span class="keyword">val</span> to_seq : <span><span><span>(<span class="type-var">'key</span>, <span class="type-var">'a</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'key</span> * <span class="type-var">'a</span>)</span> <a href="../../BatSeq/index.html#type-t">BatSeq.t</a></span></span></code></div><div class="spec-doc"><p>Iterate on the whole map, in ascending order of keys.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.3.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-to_rev_seq" class="anchored"><a href="#val-to_rev_seq" class="anchor"></a><code><span><span class="keyword">val</span> to_rev_seq : <span><span><span>(<span class="type-var">'key</span>, <span class="type-var">'a</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'key</span> * <span class="type-var">'a</span>)</span> <a href="../../BatSeq/index.html#type-t">BatSeq.t</a></span></span></code></div><div class="spec-doc"><p>Iterate on the whole map, in descending order of keys.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.3.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-to_seq_from" class="anchored"><a href="#val-to_seq_from" class="anchor"></a><code><span><span class="keyword">val</span> to_seq_from : <span><span class="type-var">'key</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'key</span>, <span class="type-var">'a</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'key</span> * <span class="type-var">'a</span>)</span> <a href="../../BatSeq/index.html#type-t">BatSeq.t</a></span></span></code></div><div class="spec-doc"><p><code>to_seq_from k m</code> iterates on a subset of the bindings in <code>m</code>, namely those bindings greater or equal to <code>k</code>, in ascending order.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.3.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-add_seq" class="anchored"><a href="#val-add_seq" class="anchor"></a><code><span><span class="keyword">val</span> add_seq : <span><span><span>(<span class="type-var">'key</span> * <span class="type-var">'a</span>)</span> <a href="../../BatSeq/index.html#type-t">BatSeq.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'key</span>, <span class="type-var">'a</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'key</span>, <span class="type-var">'a</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>add the given bindings to the map, in order.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.3.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-of_seq" class="anchored"><a href="#val-of_seq" class="anchor"></a><code><span><span class="keyword">val</span> of_seq : <span><span><span>(<span class="type-var">'key</span> * <span class="type-var">'a</span>)</span> <a href="../../BatSeq/index.html#type-t">BatSeq.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'key</span>, <span class="type-var">'a</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>build a map from the given bindings</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.3.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-diff" class="anchored"><a href="#val-diff" class="anchor"></a><code><span><span class="keyword">val</span> diff : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>diff m1 m2</code> removes all bindings of keys found in <code>m2</code> from <code>m1</code>, using the comparison function of <code>m1</code>. Equivalent to <code>foldi (fun k _v m -&gt; remove k m) m2 m1</code>. The resulting map uses the comparison function of <code>m1</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-intersect" class="anchored"><a href="#val-intersect" class="anchor"></a><code><span><span class="keyword">val</span> intersect : <span><span>(<span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'d</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'c</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'d</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>intersect merge_f m1 m2</code> returns a map with bindings only for keys bound in both <code>m1</code> and <code>m2</code>, and with <code>k</code> bound to <code>merge_f
    v1 v2</code>, where <code>v1</code> and <code>v2</code> are <code>k</code>'s bindings in <code>m1</code> and <code>m2</code>. The resulting map uses the comparison function of <code>m1</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-merge" class="anchored"><a href="#val-merge" class="anchor"></a><code><span><span class="keyword">val</span> merge : <span><span>(<span><span class="type-var">'key</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> option</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> option</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'key</span>, <span class="type-var">'a</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'key</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'key</span>, <span class="type-var">'c</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>merge f m1 m2</code> computes a map whose keys is a subset of keys of <code>m1</code> and of <code>m2</code>. The presence of each such binding, and the corresponding value, is determined with the function <code>f</code>. The resulting map uses the comparison function of <code>m1</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-compare" class="anchored"><a href="#val-compare" class="anchor"></a><code><span><span class="keyword">val</span> compare : <span><span>(<span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-equal" class="anchored"><a href="#val-equal" class="anchor"></a><code><span><span class="keyword">val</span> equal : <span><span>(<span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Construct a comparison or equality function for maps based on a value comparison or equality function. Uses the key comparison function to compare keys</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Exceptionless" class="anchored"><a href="#module-Exceptionless" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Exceptionless/index.html">Exceptionless</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Exceptionless versions of functions</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Infix" class="anchored"><a href="#module-Infix" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Infix/index.html">Infix</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Infix operators over a <code>BatPMap</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-(--&gt;)" class="anchored"><a href="#val-(--&gt;)" class="anchor"></a><code><span><span class="keyword">val</span> (--&gt;) : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span></span></code></div><div class="spec-doc"><p>Map find and insert from Infix</p></div></div><div class="odoc-spec"><div class="spec value" id="val-(&lt;--)" class="anchored"><a href="#val-(&lt;--)" class="anchor"></a><code><span><span class="keyword">val</span> (&lt;--) : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-bindings" class="anchored"><a href="#val-bindings" class="anchor"></a><code><span><span class="keyword">val</span> bindings : <span><span><span>(<span class="type-var">'key</span>, <span class="type-var">'a</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'key</span> * <span class="type-var">'a</span>)</span> list</span></span></code></div><div class="spec-doc"><p>Return the list of all bindings of the given map. The returned list is sorted in increasing key order.</p><p>Added for compatibility with stdlib 3.12</p></div></div><h6 id="boilerplate-code_10"><a href="#boilerplate-code_10" class="anchor"></a>Boilerplate code</h6><h6 id="printing_10"><a href="#printing_10" class="anchor"></a>Printing</h6><div class="odoc-spec"><div class="spec value" id="val-print" class="anchored"><a href="#val-print" class="anchor"></a><code><span><span class="keyword">val</span> print : <span>?first:string <span class="arrow">&#45;&gt;</span></span> <span>?last:string <span class="arrow">&#45;&gt;</span></span> <span>?sep:string <span class="arrow">&#45;&gt;</span></span> <span>?kvsep:string <span class="arrow">&#45;&gt;</span></span>
<span><span>(<span><span><span class="type-var">'a</span> <a href="../../BatInnerIO/index.html#type-output">BatInnerIO.output</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span><span class="type-var">'a</span> <a href="../../BatInnerIO/index.html#type-output">BatInnerIO.output</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="../../BatInnerIO/index.html#type-output">BatInnerIO.output</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'b</span>, <span class="type-var">'c</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div></details></div><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> <span class="keyword">struct</span> <span class="keyword">include</span> <a href="Exceptionless/index.html">Exceptionless</a> <span class="keyword">end</span></span></code></summary><div class="odoc-spec"><div class="spec value" id="val-find" class="anchored"><a href="#val-find" class="anchor"></a><code><span><span class="keyword">val</span> find : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-choose" class="anchored"><a href="#val-choose" class="anchor"></a><code><span><span class="keyword">val</span> choose : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> option</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-any" class="anchored"><a href="#val-any" class="anchor"></a><code><span><span class="keyword">val</span> any : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> option</span></span></code></div></div></details></div><div class="odoc-spec"><div class="spec module" id="module-PMap" class="anchored"><a href="#module-PMap" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="PMap/index.html">PMap</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div></div></body></html>