<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Core_kernel__Gc (core_kernel.Core_kernel__Gc)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">core_kernel</a> &#x00BB; Core_kernel__Gc</nav><h1>Module <code>Core_kernel__Gc</code></h1><p>This is a wrapper around INRIA's standard <code>Gc</code> module. Provides memory management control and statistics, and finalized values.</p></header><div class="spec module" id="module-Stat"><a href="#module-Stat" class="anchor"></a><code><span class="keyword">module</span> <a href="Stat/index.html">Stat</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec type" id="type-stat"><a href="#type-stat" class="anchor"></a><code><span class="keyword">type</span> stat</code><code> = <a href="Stat/index.html#type-t">Stat.t</a></code></dt></dl><aside><p>The memory management counters are returned in a <code>stat</code> record.</p><p>The total amount of memory allocated by the program since it was started is (in words) <code>minor_words + major_words - promoted_words</code>. Multiply by the word size (4 on a 32-bit machine, 8 on a 64-bit machine) to get the number of bytes.</p></aside><div class="spec module" id="module-Control"><a href="#module-Control" class="anchor"></a><code><span class="keyword">module</span> <a href="Control/index.html">Control</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec type" id="type-control"><a href="#type-control" class="anchor"></a><code><span class="keyword">type</span> control</code><code> = <a href="Control/index.html#type-t">Control.t</a></code></dt></dl><aside><p>The GC parameters are given as a <code>control</code> record. Note that these parameters can also be initialised by setting the OCAMLRUNPARAM environment variable. See the documentation of ocamlrun.</p></aside><dl><dt class="spec external" id="val-stat"><a href="#val-stat" class="anchor"></a><code><span class="keyword">val</span> stat : <a href="../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a> <span>&#45;&gt;</span> <a href="index.html#type-stat">stat</a></code></dt><dd><p>Return the current values of the memory management counters in a <code>stat</code> record. This function examines every heap block to get the statistics.</p></dd></dl><dl><dt class="spec external" id="val-quick_stat"><a href="#val-quick_stat" class="anchor"></a><code><span class="keyword">val</span> quick_stat : <a href="../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a> <span>&#45;&gt;</span> <a href="index.html#type-stat">stat</a></code></dt><dd><p>Same as <code>stat</code> except that <code>live_words</code>, <code>live_blocks</code>, <code>free_words</code>, <code>free_blocks</code>, <code>largest_free</code>, and <code>fragments</code> are set to 0. This function is much faster than <code>stat</code> because it does not need to go through the heap.</p></dd></dl><dl><dt class="spec external" id="val-counters"><a href="#val-counters" class="anchor"></a><code><span class="keyword">val</span> counters : <a href="../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a> <span>&#45;&gt;</span> <a href="../Core_kernel__/Import/index.html#type-float">Core_kernel__.Import.float</a> * <a href="../Core_kernel__/Import/index.html#type-float">Core_kernel__.Import.float</a> * <a href="../Core_kernel__/Import/index.html#type-float">Core_kernel__.Import.float</a></code></dt><dd><p>Return <code>(minor_words, promoted_words, major_words)</code>. This function is as fast at <code>quick_stat</code>.</p></dd></dl><dl><dt class="spec external" id="val-minor_words"><a href="#val-minor_words" class="anchor"></a><code><span class="keyword">val</span> minor_words : <a href="../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a> <span>&#45;&gt;</span> <a href="../Core_kernel__/Import/index.html#type-int">Core_kernel__.Import.int</a></code></dt><dd><p>The following functions return the same as <code>(Gc.quick_stat ()).Stat.f</code>, avoiding any allocation (of the <code>stat</code> record or a float). On 32-bit machines the <code>int</code> may overflow.</p><p>Note that <code>minor_words</code> does not allocate, but we do not annotate it as <code>noalloc</code> because we want the compiler to save the value of the allocation pointer register (%r15 on x86-64) to the global variable <code>caml_young_ptr</code> before the C stub tries to read its value.</p></dd></dl><dl><dt class="spec external" id="val-major_words"><a href="#val-major_words" class="anchor"></a><code><span class="keyword">val</span> major_words : <a href="../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a> <span>&#45;&gt;</span> <a href="../Core_kernel__/Import/index.html#type-int">Core_kernel__.Import.int</a></code></dt><dt class="spec external" id="val-promoted_words"><a href="#val-promoted_words" class="anchor"></a><code><span class="keyword">val</span> promoted_words : <a href="../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a> <span>&#45;&gt;</span> <a href="../Core_kernel__/Import/index.html#type-int">Core_kernel__.Import.int</a></code></dt><dt class="spec external" id="val-minor_collections"><a href="#val-minor_collections" class="anchor"></a><code><span class="keyword">val</span> minor_collections : <a href="../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a> <span>&#45;&gt;</span> <a href="../Core_kernel__/Import/index.html#type-int">Core_kernel__.Import.int</a></code></dt><dt class="spec external" id="val-major_collections"><a href="#val-major_collections" class="anchor"></a><code><span class="keyword">val</span> major_collections : <a href="../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a> <span>&#45;&gt;</span> <a href="../Core_kernel__/Import/index.html#type-int">Core_kernel__.Import.int</a></code></dt><dt class="spec external" id="val-heap_words"><a href="#val-heap_words" class="anchor"></a><code><span class="keyword">val</span> heap_words : <a href="../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a> <span>&#45;&gt;</span> <a href="../Core_kernel__/Import/index.html#type-int">Core_kernel__.Import.int</a></code></dt><dt class="spec external" id="val-heap_chunks"><a href="#val-heap_chunks" class="anchor"></a><code><span class="keyword">val</span> heap_chunks : <a href="../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a> <span>&#45;&gt;</span> <a href="../Core_kernel__/Import/index.html#type-int">Core_kernel__.Import.int</a></code></dt><dt class="spec external" id="val-compactions"><a href="#val-compactions" class="anchor"></a><code><span class="keyword">val</span> compactions : <a href="../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a> <span>&#45;&gt;</span> <a href="../Core_kernel__/Import/index.html#type-int">Core_kernel__.Import.int</a></code></dt><dt class="spec external" id="val-top_heap_words"><a href="#val-top_heap_words" class="anchor"></a><code><span class="keyword">val</span> top_heap_words : <a href="../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a> <span>&#45;&gt;</span> <a href="../Core_kernel__/Import/index.html#type-int">Core_kernel__.Import.int</a></code></dt><dt class="spec external" id="val-major_plus_minor_words"><a href="#val-major_plus_minor_words" class="anchor"></a><code><span class="keyword">val</span> major_plus_minor_words : <a href="../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a> <span>&#45;&gt;</span> <a href="../Core_kernel__/Import/index.html#type-int">Core_kernel__.Import.int</a></code></dt><dd><p>This function returns <code>major_words () + minor_words ()</code>. It exists purely for speed (one call into C rather than two). Like <code>major_words</code> and <code>minor_words</code>, <code>major_plus_minor_words</code> avoids allocating a <code>stat</code> record or a float, and may overflow on 32-bit machines.</p><p>This function is not marked <code>[@@noalloc]</code> to ensure that the allocation pointer is up-to-date when the minor-heap measurement is made.</p></dd></dl><dl><dt class="spec external" id="val-get"><a href="#val-get" class="anchor"></a><code><span class="keyword">val</span> get : <a href="../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a> <span>&#45;&gt;</span> <a href="index.html#type-control">control</a></code></dt><dd><p>Return the current values of the GC parameters in a <code>control</code> record.</p></dd></dl><dl><dt class="spec external" id="val-set"><a href="#val-set" class="anchor"></a><code><span class="keyword">val</span> set : <a href="index.html#type-control">control</a> <span>&#45;&gt;</span> <a href="../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a></code></dt><dd><p><code>set r</code> changes the GC parameters according to the <code>control</code> record <code>r</code>. The normal usage is: <code>Gc.set { (Gc.get()) with Gc.Control.verbose = 0x00d }</code></p></dd></dl><dl><dt class="spec external" id="val-minor"><a href="#val-minor" class="anchor"></a><code><span class="keyword">val</span> minor : <a href="../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a> <span>&#45;&gt;</span> <a href="../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a></code></dt><dd><p>Trigger a minor collection.</p></dd></dl><dl><dt class="spec external" id="val-major_slice"><a href="#val-major_slice" class="anchor"></a><code><span class="keyword">val</span> major_slice : <a href="../Core_kernel__/Import/index.html#type-int">Core_kernel__.Import.int</a> <span>&#45;&gt;</span> <a href="../Core_kernel__/Import/index.html#type-int">Core_kernel__.Import.int</a></code></dt><dd><p>Do a minor collection and a slice of major collection. The argument is the size of the slice, 0 to use the automatically-computed slice size. In all cases, the result is the computed slice size.</p></dd></dl><dl><dt class="spec external" id="val-major"><a href="#val-major" class="anchor"></a><code><span class="keyword">val</span> major : <a href="../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a> <span>&#45;&gt;</span> <a href="../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a></code></dt><dd><p>Do a minor collection and finish the current major collection cycle.</p></dd></dl><dl><dt class="spec external" id="val-full_major"><a href="#val-full_major" class="anchor"></a><code><span class="keyword">val</span> full_major : <a href="../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a> <span>&#45;&gt;</span> <a href="../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a></code></dt><dd><p>Do a minor collection, finish the current major collection cycle, and perform a complete new cycle. This will collect all currently unreachable blocks.</p></dd></dl><dl><dt class="spec external" id="val-compact"><a href="#val-compact" class="anchor"></a><code><span class="keyword">val</span> compact : <a href="../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a> <span>&#45;&gt;</span> <a href="../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a></code></dt><dd><p>Perform a full major collection and compact the heap. Note that heap compaction is a lengthy operation.</p></dd></dl><dl><dt class="spec value" id="val-print_stat"><a href="#val-print_stat" class="anchor"></a><code><span class="keyword">val</span> print_stat : <a href="../../ocaml/Stdlib/index.html#type-out_channel">Stdlib.out_channel</a> <span>&#45;&gt;</span> <a href="../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a></code></dt><dd><p>Print the current values of the memory management counters (in human-readable form) into the channel argument.</p></dd></dl><dl><dt class="spec value" id="val-allocated_bytes"><a href="#val-allocated_bytes" class="anchor"></a><code><span class="keyword">val</span> allocated_bytes : <a href="../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a> <span>&#45;&gt;</span> <a href="../Core_kernel__/Import/index.html#type-float">Core_kernel__.Import.float</a></code></dt><dd><p>Return the total number of bytes allocated since the program was started. It is returned as a <code>float</code> to avoid overflow problems with <code>int</code> on 32-bit machines.</p></dd></dl><dl><dt class="spec value" id="val-keep_alive"><a href="#val-keep_alive" class="anchor"></a><code><span class="keyword">val</span> keep_alive : <span class="type-var">_</span> <span>&#45;&gt;</span> <a href="../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a></code></dt><dd><p><code>keep_alive a</code> ensures that <code>a</code> is live at the point where <code>keep_alive a</code> is called. It is like <code>ignore a</code>, except that the compiler won't be able to simplify it and potentially collect <code>a</code> too soon.</p></dd></dl><dl><dt class="spec value" id="val-tune"><a href="#val-tune" class="anchor"></a><code><span class="keyword">val</span> tune : ?&#8288;logger:(<a href="../Core_kernel__/Import/index.html#type-string">Core_kernel__.Import.string</a> <span>&#45;&gt;</span> <a href="../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a>) <span>&#45;&gt;</span> ?&#8288;minor_heap_size:<a href="../Core_kernel__/Import/index.html#type-int">Core_kernel__.Import.int</a> <span>&#45;&gt;</span> ?&#8288;major_heap_increment:<a href="../Core_kernel__/Import/index.html#type-int">Core_kernel__.Import.int</a> <span>&#45;&gt;</span> ?&#8288;space_overhead:<a href="../Core_kernel__/Import/index.html#type-int">Core_kernel__.Import.int</a> <span>&#45;&gt;</span> ?&#8288;verbose:<a href="../Core_kernel__/Import/index.html#type-int">Core_kernel__.Import.int</a> <span>&#45;&gt;</span> ?&#8288;max_overhead:<a href="../Core_kernel__/Import/index.html#type-int">Core_kernel__.Import.int</a> <span>&#45;&gt;</span> ?&#8288;stack_limit:<a href="../Core_kernel__/Import/index.html#type-int">Core_kernel__.Import.int</a> <span>&#45;&gt;</span> ?&#8288;allocation_policy:<a href="../Core_kernel__/Import/index.html#type-int">Core_kernel__.Import.int</a> <span>&#45;&gt;</span> ?&#8288;window_size:<a href="../Core_kernel__/Import/index.html#type-int">Core_kernel__.Import.int</a> <span>&#45;&gt;</span> <a href="../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a> <span>&#45;&gt;</span> <a href="../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a></code></dt><dd><p>Adjust the specified GC parameters.</p></dd></dl><dl><dt class="spec module" id="module-Allocation_policy"><a href="#module-Allocation_policy" class="anchor"></a><code><span class="keyword">module</span> <a href="Allocation_policy/index.html">Allocation_policy</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The policy used for allocating in the heap.</p></dd></dl><dl><dt class="spec value" id="val-disable_compaction"><a href="#val-disable_compaction" class="anchor"></a><code><span class="keyword">val</span> disable_compaction : ?&#8288;logger:(<a href="../Core_kernel__/Import/index.html#type-string">Core_kernel__.Import.string</a> <span>&#45;&gt;</span> <a href="../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a>) <span>&#45;&gt;</span> allocation_policy:[ `Don't_change | `Set_to of <a href="Allocation_policy/index.html#type-t">Allocation_policy.t</a> ] <span>&#45;&gt;</span> <a href="../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a> <span>&#45;&gt;</span> <a href="../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a></code></dt></dl><dl><dt class="spec module" id="module-Expert"><a href="#module-Expert" class="anchor"></a><code><span class="keyword">module</span> <a href="Expert/index.html">Expert</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The <code>Expert</code> module contains functions that novice users should not use, due to their complexity.</p></dd></dl></div></body></html>