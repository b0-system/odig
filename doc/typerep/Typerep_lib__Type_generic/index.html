<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Typerep_lib__Type_generic (typerep.Typerep_lib__Type_generic)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">typerep</a> &#x00BB; Typerep_lib__Type_generic</nav><h1>Module <code>Typerep_lib__Type_generic</code></h1><p>A computation is the type of an operation that can be applied to various different kind of types. It is expressed as a type with one parameter:</p><p>type 'a computation</p><p>Examples of computation:</p><p>type sexp_of_t = ('a -&gt; Sexp.t) computation</p><p>The term <code>generic</code> is used to refer to a specific implementation of a computation whose concrete implementation is programmed using the type representation of values.</p><p>For example, when one uses <code>with sexp</code> as a way to implement the <code>sexp_of_t</code> computation, the technique used is code generation at compile time. Another approach is to define a generic function <code>sexp_of_t</code> that inspects the representation of the type at runtime.</p><p>This module offers an abstraction over type rep in order to implement generics in a efficient way.</p><p>Provided from a user enough pieces of implementation regarding a particular computation, this module returns essentially the following function:</p><p>(** main function : get the computation from the typerep *) val of_typerep : 'a Typerep.t -&gt; <code> `generic of 'a computation </code></p><p>that allows one to get the generic computation operating on a given type <code>'a</code>.</p></header><div class="spec module" id="module-Variant_and_record_intf"><a href="#module-Variant_and_record_intf" class="anchor"></a><code><span class="keyword">module</span> <a href="Variant_and_record_intf/index.html">Variant_and_record_intf</a> : <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> <a href="../Typerep_lib/index.html#module-Variant_and_record_intf">Typerep_lib.Variant_and_record_intf</a></code></div><div class="spec module" id="module-Helper"><a href="#module-Helper" class="anchor"></a><code><span class="keyword">module</span> <a href="Helper/index.html">Helper</a> : <span class="keyword">functor</span> (<a href="Helper/argument-1-A/index.html">A</a> : <a href="../Typerep_lib/Variant_and_record_intf/index.html#module-type-S">Variant_and_record_intf.S</a>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="Helper/argument-2-B/index.html">B</a> : <a href="../Typerep_lib/Variant_and_record_intf/index.html#module-type-S">Variant_and_record_intf.S</a>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module-type" id="module-type-Named"><a href="#module-type-Named" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Named/index.html">Named</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module-type" id="module-type-Computation"><a href="#module-type-Computation" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Computation/index.html">Computation</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec module" id="module-Make_named_for_closure"><a href="#module-Make_named_for_closure" class="anchor"></a><code><span class="keyword">module</span> <a href="Make_named_for_closure/index.html">Make_named_for_closure</a> : <span class="keyword">functor</span> (<a href="Make_named_for_closure/argument-1-X/index.html">X</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) <span>&#45;&gt;</span> <a href="index.html#module-type-Named">Named</a> <span class="keyword">with</span> <span class="keyword">type</span> 'a <a href="Make_named_for_closure/index.html#type-computation">computation</a> := <span class="type-var">'a</span> <a href="Make_named_for_closure/argument-1-X/index.html#type-t">X.t</a></code></dt><dd><p>Not all computations are arrow types. For example:</p></dd></dl><div class="spec module" id="module-Ident"><a href="#module-Ident" class="anchor"></a><code><span class="keyword">module</span> <a href="Ident/index.html">Ident</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module-type" id="module-type-S"><a href="#module-type-S" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-S/index.html">S</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec module" id="module-Make"><a href="#module-Make" class="anchor"></a><code><span class="keyword">module</span> <a href="Make/index.html">Make</a> : <span class="keyword">functor</span> (<a href="Make/argument-1-X/index.html">X</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) <span>&#45;&gt;</span> <a href="index.html#module-type-S">S</a> <span class="keyword">with</span> <span class="keyword">type</span> 'a <a href="Make/index.html#type-t">t</a> = <span class="type-var">'a</span> <a href="Make/argument-1-X/index.html#type-t">X.t</a></code></dt><dd><p>The <code>name</code> is used for debug information only in case of Broken_dependency. The <code>required</code> is to handle dependencies between generics at runtime. Example: if <code>X</code> is the module given to build a generic computation <code>G</code> that depends on three other computation <code>A,B,C</code> then X.required shall be <code> A.ident ; B.ident ; C.ident </code></p></dd></dl></div></body></html>