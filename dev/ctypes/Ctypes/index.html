<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Ctypes (ctypes.Ctypes)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">ctypes</a> &#x00BB; Ctypes</nav><h1>Module <code>Ctypes</code></h1><p>The core ctypes module.</p><p>The main points of interest are the set of functions for describing C types (see <code>types</code>) and the set of functions for accessing C values (see <a href="index.html#values"><span>Values representing C values</span></a>). The <a href="../Foreign/index.html#val-foreign"><code>Foreign.foreign</code></a> function uses C type descriptions to bind external C values.</p><nav class="toc"><ul><li><a href="#pointer_types">Pointer types</a></li><li><a href="#c-compatible-pointers">C-compatible pointers</a></li><li><a href="#c-array-types">C array types</a></li><li><a href="#bigarray-types">Bigarray types</a></li><li><a href="#struct-and-union-types">Struct and union types</a></li><li><a href="#operations-on-types">Operations on types</a></li><li><a href="#values">Values representing C values</a><ul><li><a href="#pointer-values">Pointer values</a></li><li><a href="#array-values">Array values</a><ul><li><a href="#c-array-values">C array values</a></li><li><a href="#bigarray-values">Bigarray values</a></li></ul></li><li><a href="#struct-and-union-values">Struct and union values</a></li><li><a href="#coercions">Coercions</a></li></ul></li><li><a href="#binding-interfaces">binding interfaces</a></li><li><a href="#exceptions">Exceptions</a></li></ul></nav></header><section><header><h5 id="pointer_types"><a href="#pointer_types" class="anchor"></a>Pointer types</h5></header><dl><dt class="spec type" id="type-pointer"><a href="#type-pointer" class="anchor"></a><code><span class="keyword">type</span> ('a, 'b) pointer</code><code> = (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="../Ctypes_static/index.html#type-pointer">Ctypes_static.pointer</a></code></dt><dd><p>The type of pointer values. A value of type <code>('a, [`C]) pointer</code> contains a C-compatible pointer, and a value of type <code>('a, [`OCaml]) pointer</code> contains a pointer to a value that can be moved by OCaml runtime.</p></dd></dl></section><section><header><h5 id="c-compatible-pointers"><a href="#c-compatible-pointers" class="anchor"></a>C-compatible pointers</h5></header><dl><dt class="spec type" id="type-ptr"><a href="#type-ptr" class="anchor"></a><code><span class="keyword">type</span> 'a ptr</code><code> = (<span class="type-var">'a</span>, [ `C ]) <a href="index.html#type-pointer">pointer</a></code></dt><dd><p>The type of C-compatible pointer values. A value of type <code>t ptr</code> can be used to read and write values of type <code>t</code> at particular addresses.</p></dd></dl><dl><dt class="spec type" id="type-ocaml"><a href="#type-ocaml" class="anchor"></a><code><span class="keyword">type</span> 'a ocaml</code><code> = <span class="type-var">'a</span> <a href="../Ctypes_static/index.html#type-ocaml">Ctypes_static.ocaml</a></code></dt><dd><p>The type of pointer values pointing directly into OCaml values. <b>Pointers of this type should never be captured by external code</b>. In particular, functions accepting <code>'a ocaml</code> pointers must not invoke any OCaml code.</p></dd></dl></section><section><header><h5 id="c-array-types"><a href="#c-array-types" class="anchor"></a>C array types</h5></header><dl><dt class="spec type" id="type-carray"><a href="#type-carray" class="anchor"></a><code><span class="keyword">type</span> 'a carray</code><code> = <span class="type-var">'a</span> <a href="../Ctypes_static/index.html#type-carray">Ctypes_static.carray</a></code></dt><dd><p>The type of C array values. A value of type <code>t carray</code> can be used to read and write array objects in C-managed storage.</p></dd></dl></section><section><header><h5 id="bigarray-types"><a href="#bigarray-types" class="anchor"></a>Bigarray types</h5></header><dl><dt class="spec type" id="type-bigarray_class"><a href="#type-bigarray_class" class="anchor"></a><code><span class="keyword">type</span> 'a bigarray_class</code><code> = <span class="type-var">'a</span> <a href="../Ctypes_static/index.html#type-bigarray_class">Ctypes_static.bigarray_class</a></code></dt><dd><p>The type of Bigarray classes. There are four instances, one for each of the Bigarray submodules.</p></dd></dl><dl><dt class="spec value" id="val-genarray"><a href="#val-genarray" class="anchor"></a><code><span class="keyword">val</span> genarray : &lt; element : <span class="type-var">'a</span>; layout : <span class="type-var">'l</span>; ba_repr : <span class="type-var">'b</span>; bigarray : (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'l</span>) <a href="../../ocaml/Bigarray/Genarray/index.html#type-t">Bigarray.Genarray.t</a>; carray : <span class="type-var">'a</span> <a href="index.html#type-carray">carray</a>; dims : int array; &gt; <a href="index.html#type-bigarray_class">bigarray_class</a></code></dt><dd><p>The class of <a href="../../ocaml/Stdlib__bigarray/Genarray/index.html#type-t"><code>Bigarray.Genarray.t</code></a> values</p></dd></dl><dl><dt class="spec value" id="val-array1"><a href="#val-array1" class="anchor"></a><code><span class="keyword">val</span> array1 : &lt; element : <span class="type-var">'a</span>; layout : <span class="type-var">'l</span>; ba_repr : <span class="type-var">'b</span>; bigarray : (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'l</span>) <a href="../../ocaml/Bigarray/Array1/index.html#type-t">Bigarray.Array1.t</a>; carray : <span class="type-var">'a</span> <a href="index.html#type-carray">carray</a>; dims : int; &gt; <a href="index.html#type-bigarray_class">bigarray_class</a></code></dt><dd><p>The class of <a href="../../ocaml/Stdlib__bigarray/Array1/index.html#type-t"><code>Bigarray.Array1.t</code></a> values</p></dd></dl><dl><dt class="spec value" id="val-array2"><a href="#val-array2" class="anchor"></a><code><span class="keyword">val</span> array2 : &lt; element : <span class="type-var">'a</span>; layout : <span class="type-var">'l</span>; ba_repr : <span class="type-var">'b</span>; bigarray : (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'l</span>) <a href="../../ocaml/Bigarray/Array2/index.html#type-t">Bigarray.Array2.t</a>; carray : <span class="type-var">'a</span> <a href="index.html#type-carray">carray</a> <a href="index.html#type-carray">carray</a>; dims : int * int; &gt; <a href="index.html#type-bigarray_class">bigarray_class</a></code></dt><dd><p>The class of <a href="../../ocaml/Stdlib__bigarray/Array2/index.html#type-t"><code>Bigarray.Array2.t</code></a> values</p></dd></dl><dl><dt class="spec value" id="val-array3"><a href="#val-array3" class="anchor"></a><code><span class="keyword">val</span> array3 : &lt; element : <span class="type-var">'a</span>; layout : <span class="type-var">'l</span>; ba_repr : <span class="type-var">'b</span>; bigarray : (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'l</span>) <a href="../../ocaml/Bigarray/Array3/index.html#type-t">Bigarray.Array3.t</a>; carray : <span class="type-var">'a</span> <a href="index.html#type-carray">carray</a> <a href="index.html#type-carray">carray</a> <a href="index.html#type-carray">carray</a>; dims : int * int * int; &gt; <a href="index.html#type-bigarray_class">bigarray_class</a></code></dt><dd><p>The class of <a href="../../ocaml/Stdlib__bigarray/Array3/index.html#type-t"><code>Bigarray.Array3.t</code></a> values</p></dd></dl></section><section><header><h4 id="struct-and-union-types"><a href="#struct-and-union-types" class="anchor"></a>Struct and union types</h4></header><dl><dt class="spec type" id="type-structured"><a href="#type-structured" class="anchor"></a><code><span class="keyword">type</span> ('a, 'kind) structured</code><code> = (<span class="type-var">'a</span>, <span class="type-var">'kind</span>) <a href="../Ctypes_static/index.html#type-structured">Ctypes_static.structured</a></code></dt><dd><p>The base type of values representing C struct and union types. The <code>'kind</code> parameter is a polymorphic variant type indicating whether the type represents a struct (<code>`Struct</code>) or a union (<code>`Union</code>).</p></dd></dl><dl><dt class="spec type" id="type-structure"><a href="#type-structure" class="anchor"></a><code><span class="keyword">type</span> 'a structure</code><code> = (<span class="type-var">'a</span>, [ `Struct ]) <a href="index.html#type-structured">structured</a></code></dt><dd><p>The type of values representing C struct types.</p></dd></dl><dl><dt class="spec type" id="type-union"><a href="#type-union" class="anchor"></a><code><span class="keyword">type</span> 'a union</code><code> = (<span class="type-var">'a</span>, [ `Union ]) <a href="index.html#type-structured">structured</a></code></dt><dd><p>The type of values representing C union types.</p></dd></dl><dl><dt class="spec type" id="type-field"><a href="#type-field" class="anchor"></a><code><span class="keyword">type</span> ('a, 't) field</code><code> = (<span class="type-var">'a</span>, <span class="type-var">'t</span>) <a href="../Ctypes_static/index.html#type-field">Ctypes_static.field</a></code></dt><dd><p>The type of values representing C struct or union members (called &quot;fields&quot; here). A value of type <code>(a, s) field</code> represents a field of type <code>a</code> in a struct or union of type <code>s</code>.</p></dd></dl><dl><dt class="spec type" id="type-abstract"><a href="#type-abstract" class="anchor"></a><code><span class="keyword">type</span> 'a abstract</code><code> = <span class="type-var">'a</span> <a href="../Ctypes_static/index.html#type-abstract">Ctypes_static.abstract</a></code></dt><dd><p>The type of abstract values. The purpose of the <code>abstract</code> type is to represent values whose type varies from platform to platform.</p><p>For example, the type <code>pthread_t</code> is a pointer on some platforms, an integer on other platforms, and a struct on a third set of platforms. One way to deal with this kind of situation is to have possibly-platform-specific code which interrogates the C type in some way to help determine an appropriate representation. Another way is to use <code>abstract</code>, leaving the representation opaque.</p><p>(Note, however, that although <code>pthread_t</code> is a convenient example, since the type used to implement it varies significantly across platforms, it's not actually a good match for <code>abstract</code>, since values of type <code>pthread_t</code> are passed and returned by value.)</p></dd></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../Ctypes_types/index.html#module-type-TYPE">Ctypes_types.TYPE</a> <span class="keyword">with</span> <span class="keyword">type</span> 'a <a href="../Ctypes_types/module-type-TYPE/index.html#type-typ">typ</a> = <span class="type-var">'a</span> <a href="../Ctypes_static/index.html#type-typ">Ctypes_static.typ</a> <span class="keyword">and</span> <span class="keyword">type</span> ('a, 's) <a href="../Ctypes_types/module-type-TYPE/index.html#type-field">field</a> := (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-field">field</a></code></span></summary><dl><dt class="spec type" id="type-typ"><a href="#type-typ" class="anchor"></a><code><span class="keyword">type</span> 'a typ</code><code> = <span class="type-var">'a</span> <a href="../Ctypes_static/index.html#type-typ">Ctypes_static.typ</a></code></dt><dd><p>The type of values representing C types. There are two types associated with each <code>typ</code> value: the C type used to store and pass values, and the corresponding OCaml type. The type parameter indicates the OCaml type, so a value of type <code>t typ</code> is used to read and write OCaml values of type <code>t</code>. There are various uses of <code>typ</code> values, including</p><ul><li>constructing function types for binding native functions using <a href="../Foreign/index.html#val-foreign"><code>Foreign.foreign</code></a></li></ul><ul><li>constructing pointers for reading and writing locations in C-managed storage using <a href="index.html#val-ptr"><code>ptr</code></a></li></ul><ul><li>describing the fields of structured types built with <a href="index.html#val-structure"><code>structure</code></a> and <a href="index.html#val-union"><code>union</code></a>.</li></ul></dd></dl><section><header><h4 id="the-void-type"><a href="#the-void-type" class="anchor"></a>The void type</h4></header><dl><dt class="spec value" id="val-void"><a href="#val-void" class="anchor"></a><code><span class="keyword">val</span> void : unit <a href="index.html#type-typ">typ</a></code></dt><dd><p>Value representing the C void type. Void values appear in OCaml as the unit type, so using void in an argument or result type specification produces a function which accepts or returns unit.</p><p>Dereferencing a pointer to void is an error, as in C, and will raise <a href="index.html#exception-IncompleteType"><code>IncompleteType</code></a>.</p></dd></dl></section><section><header><h4 id="scalar-types"><a href="#scalar-types" class="anchor"></a>Scalar types</h4><p>The scalar types consist of the <a href="index.html#arithmetic_types"><span>Arithmetic types</span></a> and the <a href="index.html#pointer_types"><span>Pointer types</span></a>.</p></header><section><header><h5 id="arithmetic_types"><a href="#arithmetic_types" class="anchor"></a>Arithmetic types</h5><p>The arithmetic types consist of the signed and unsigned integer types (including character types) and the floating types. There are values representing both exact-width integer types (of 8, 16, 32 and 64 bits) and types whose size depend on the platform (signed and unsigned short, int, long, long long).</p></header><dl><dt class="spec value" id="val-char"><a href="#val-char" class="anchor"></a><code><span class="keyword">val</span> char : char <a href="index.html#type-typ">typ</a></code></dt><dd><p>Value representing the C type <code>char</code>.</p></dd></dl><section><header><h6 id="signed-integer-types"><a href="#signed-integer-types" class="anchor"></a>Signed integer types</h6></header><dl><dt class="spec value" id="val-schar"><a href="#val-schar" class="anchor"></a><code><span class="keyword">val</span> schar : int <a href="index.html#type-typ">typ</a></code></dt><dd><p>Value representing the C type <code>signed char</code>.</p></dd></dl><dl><dt class="spec value" id="val-short"><a href="#val-short" class="anchor"></a><code><span class="keyword">val</span> short : int <a href="index.html#type-typ">typ</a></code></dt><dd><p>Value representing the C type (<code>signed</code>) <code>short</code>.</p></dd></dl><dl><dt class="spec value" id="val-int"><a href="#val-int" class="anchor"></a><code><span class="keyword">val</span> int : int <a href="index.html#type-typ">typ</a></code></dt><dd><p>Value representing the C type (<code>signed</code>) <code>int</code>.</p></dd></dl><dl><dt class="spec value" id="val-long"><a href="#val-long" class="anchor"></a><code><span class="keyword">val</span> long : <a href="../../integers/Signed/index.html#type-long">Signed.long</a> <a href="index.html#type-typ">typ</a></code></dt><dd><p>Value representing the C type (<code>signed</code>) <code>long</code>.</p></dd></dl><dl><dt class="spec value" id="val-llong"><a href="#val-llong" class="anchor"></a><code><span class="keyword">val</span> llong : <a href="../../integers/Signed/index.html#type-llong">Signed.llong</a> <a href="index.html#type-typ">typ</a></code></dt><dd><p>Value representing the C type (<code>signed</code>) <code>long long</code>.</p></dd></dl><dl><dt class="spec value" id="val-nativeint"><a href="#val-nativeint" class="anchor"></a><code><span class="keyword">val</span> nativeint : nativeint <a href="index.html#type-typ">typ</a></code></dt><dd><p>Value representing the C type (<code>signed</code>) <code>int</code>.</p></dd></dl><dl><dt class="spec value" id="val-int8_t"><a href="#val-int8_t" class="anchor"></a><code><span class="keyword">val</span> int8_t : int <a href="index.html#type-typ">typ</a></code></dt><dd><p>Value representing an 8-bit signed integer C type.</p></dd></dl><dl><dt class="spec value" id="val-int16_t"><a href="#val-int16_t" class="anchor"></a><code><span class="keyword">val</span> int16_t : int <a href="index.html#type-typ">typ</a></code></dt><dd><p>Value representing a 16-bit signed integer C type.</p></dd></dl><dl><dt class="spec value" id="val-int32_t"><a href="#val-int32_t" class="anchor"></a><code><span class="keyword">val</span> int32_t : int32 <a href="index.html#type-typ">typ</a></code></dt><dd><p>Value representing a 32-bit signed integer C type.</p></dd></dl><dl><dt class="spec value" id="val-int64_t"><a href="#val-int64_t" class="anchor"></a><code><span class="keyword">val</span> int64_t : int64 <a href="index.html#type-typ">typ</a></code></dt><dd><p>Value representing a 64-bit signed integer C type.</p></dd></dl><div class="spec module" id="module-Intptr"><a href="#module-Intptr" class="anchor"></a><code><span class="keyword">module</span> <a href="Intptr/index.html">Intptr</a> : <a href="../../integers/Signed/index.html#module-type-S">Signed.S</a></code></div><dl><dt class="spec value" id="val-intptr_t"><a href="#val-intptr_t" class="anchor"></a><code><span class="keyword">val</span> intptr_t : <a href="Intptr/index.html#type-t">Intptr.t</a> <a href="index.html#type-typ">typ</a></code></dt><dd><p>Value representing the C type <code>intptr_t</code>.</p></dd></dl><div class="spec module" id="module-Ptrdiff"><a href="#module-Ptrdiff" class="anchor"></a><code><span class="keyword">module</span> <a href="Ptrdiff/index.html">Ptrdiff</a> : <a href="../../integers/Signed/index.html#module-type-S">Signed.S</a></code></div><dl><dt class="spec value" id="val-ptrdiff_t"><a href="#val-ptrdiff_t" class="anchor"></a><code><span class="keyword">val</span> ptrdiff_t : <a href="Ptrdiff/index.html#type-t">Ptrdiff.t</a> <a href="index.html#type-typ">typ</a></code></dt><dd><p>Value representing the C type <code>ptrdiff_t</code>.</p></dd></dl><dl><dt class="spec value" id="val-camlint"><a href="#val-camlint" class="anchor"></a><code><span class="keyword">val</span> camlint : int <a href="index.html#type-typ">typ</a></code></dt><dd><p>Value representing an integer type with the same storage requirements as an OCaml <code>int</code>.</p></dd></dl></section><section><header><h6 id="unsigned-integer-types"><a href="#unsigned-integer-types" class="anchor"></a>Unsigned integer types</h6></header><dl><dt class="spec value" id="val-uchar"><a href="#val-uchar" class="anchor"></a><code><span class="keyword">val</span> uchar : <a href="../../integers/Unsigned/index.html#type-uchar">Unsigned.uchar</a> <a href="index.html#type-typ">typ</a></code></dt><dd><p>Value representing the C type <code>unsigned char</code>.</p></dd></dl><dl><dt class="spec value" id="val-bool"><a href="#val-bool" class="anchor"></a><code><span class="keyword">val</span> bool : bool <a href="index.html#type-typ">typ</a></code></dt><dd><p>Value representing the C type <code>bool</code>.</p></dd></dl><dl><dt class="spec value" id="val-uint8_t"><a href="#val-uint8_t" class="anchor"></a><code><span class="keyword">val</span> uint8_t : <a href="../../integers/Unsigned/index.html#type-uint8">Unsigned.uint8</a> <a href="index.html#type-typ">typ</a></code></dt><dd><p>Value representing an 8-bit unsigned integer C type.</p></dd></dl><dl><dt class="spec value" id="val-uint16_t"><a href="#val-uint16_t" class="anchor"></a><code><span class="keyword">val</span> uint16_t : <a href="../../integers/Unsigned/index.html#type-uint16">Unsigned.uint16</a> <a href="index.html#type-typ">typ</a></code></dt><dd><p>Value representing a 16-bit unsigned integer C type.</p></dd></dl><dl><dt class="spec value" id="val-uint32_t"><a href="#val-uint32_t" class="anchor"></a><code><span class="keyword">val</span> uint32_t : <a href="../../integers/Unsigned/index.html#type-uint32">Unsigned.uint32</a> <a href="index.html#type-typ">typ</a></code></dt><dd><p>Value representing a 32-bit unsigned integer C type.</p></dd></dl><dl><dt class="spec value" id="val-uint64_t"><a href="#val-uint64_t" class="anchor"></a><code><span class="keyword">val</span> uint64_t : <a href="../../integers/Unsigned/index.html#type-uint64">Unsigned.uint64</a> <a href="index.html#type-typ">typ</a></code></dt><dd><p>Value representing a 64-bit unsigned integer C type.</p></dd></dl><dl><dt class="spec value" id="val-size_t"><a href="#val-size_t" class="anchor"></a><code><span class="keyword">val</span> size_t : <a href="../../integers/Unsigned/index.html#type-size_t">Unsigned.size_t</a> <a href="index.html#type-typ">typ</a></code></dt><dd><p>Value representing the C type <code>size_t</code>, an alias for one of the unsigned integer types. The actual size and alignment requirements for <code>size_t</code> vary between platforms.</p></dd></dl><dl><dt class="spec value" id="val-ushort"><a href="#val-ushort" class="anchor"></a><code><span class="keyword">val</span> ushort : <a href="../../integers/Unsigned/index.html#type-ushort">Unsigned.ushort</a> <a href="index.html#type-typ">typ</a></code></dt><dd><p>Value representing the C type <code>unsigned short</code>.</p></dd></dl><dl><dt class="spec value" id="val-sint"><a href="#val-sint" class="anchor"></a><code><span class="keyword">val</span> sint : <a href="../../integers/Signed/index.html#type-sint">Signed.sint</a> <a href="index.html#type-typ">typ</a></code></dt><dd><p>Value representing the C type <code>int</code>.</p></dd></dl><dl><dt class="spec value" id="val-uint"><a href="#val-uint" class="anchor"></a><code><span class="keyword">val</span> uint : <a href="../../integers/Unsigned/index.html#type-uint">Unsigned.uint</a> <a href="index.html#type-typ">typ</a></code></dt><dd><p>Value representing the C type <code>unsigned int</code>.</p></dd></dl><dl><dt class="spec value" id="val-ulong"><a href="#val-ulong" class="anchor"></a><code><span class="keyword">val</span> ulong : <a href="../../integers/Unsigned/index.html#type-ulong">Unsigned.ulong</a> <a href="index.html#type-typ">typ</a></code></dt><dd><p>Value representing the C type <code>unsigned long</code>.</p></dd></dl><dl><dt class="spec value" id="val-ullong"><a href="#val-ullong" class="anchor"></a><code><span class="keyword">val</span> ullong : <a href="../../integers/Unsigned/index.html#type-ullong">Unsigned.ullong</a> <a href="index.html#type-typ">typ</a></code></dt><dd><p>Value representing the C type <code>unsigned long long</code>.</p></dd></dl><div class="spec module" id="module-Uintptr"><a href="#module-Uintptr" class="anchor"></a><code><span class="keyword">module</span> <a href="Uintptr/index.html">Uintptr</a> : <a href="../../integers/Unsigned/index.html#module-type-S">Unsigned.S</a></code></div><dl><dt class="spec value" id="val-uintptr_t"><a href="#val-uintptr_t" class="anchor"></a><code><span class="keyword">val</span> uintptr_t : <a href="Uintptr/index.html#type-t">Uintptr.t</a> <a href="index.html#type-typ">typ</a></code></dt><dd><p>Value representing the C type <code>uintptr_t</code>.</p></dd></dl></section><section><header><h6 id="floating-types"><a href="#floating-types" class="anchor"></a>Floating types</h6></header><dl><dt class="spec value" id="val-float"><a href="#val-float" class="anchor"></a><code><span class="keyword">val</span> float : float <a href="index.html#type-typ">typ</a></code></dt><dd><p>Value representing the C single-precision <code>float</code> type.</p></dd></dl><dl><dt class="spec value" id="val-double"><a href="#val-double" class="anchor"></a><code><span class="keyword">val</span> double : float <a href="index.html#type-typ">typ</a></code></dt><dd><p>Value representing the C type <code>double</code>.</p></dd></dl><dl><dt class="spec value" id="val-ldouble"><a href="#val-ldouble" class="anchor"></a><code><span class="keyword">val</span> ldouble : <a href="../LDouble/index.html#type-t">LDouble.t</a> <a href="index.html#type-typ">typ</a></code></dt><dd><p>Value representing the C type <code>long double</code>.</p></dd></dl></section><section><header><h6 id="complex-types"><a href="#complex-types" class="anchor"></a>Complex types</h6></header><dl><dt class="spec value" id="val-complex32"><a href="#val-complex32" class="anchor"></a><code><span class="keyword">val</span> complex32 : <a href="../../ocaml/Stdlib/Complex/index.html#type-t">Stdlib.Complex.t</a> <a href="index.html#type-typ">typ</a></code></dt><dd><p>Value representing the C99 single-precision <code>float complex</code> type.</p></dd></dl><dl><dt class="spec value" id="val-complex64"><a href="#val-complex64" class="anchor"></a><code><span class="keyword">val</span> complex64 : <a href="../../ocaml/Stdlib/Complex/index.html#type-t">Stdlib.Complex.t</a> <a href="index.html#type-typ">typ</a></code></dt><dd><p>Value representing the C99 double-precision <code>double complex</code> type.</p></dd></dl><dl><dt class="spec value" id="val-complexld"><a href="#val-complexld" class="anchor"></a><code><span class="keyword">val</span> complexld : <a href="../ComplexL/index.html#type-t">ComplexL.t</a> <a href="index.html#type-typ">typ</a></code></dt><dd><p>Value representing the C99 long-double-precision <code>long double complex</code> type.</p></dd></dl></section></section><section><header><h5 id="pointer_types"><a href="#pointer_types" class="anchor"></a>Pointer types</h5></header><section><header><h6 id="c-compatible-pointers"><a href="#c-compatible-pointers" class="anchor"></a>C-compatible pointers</h6></header><dl><dt class="spec value" id="val-ptr"><a href="#val-ptr" class="anchor"></a><code><span class="keyword">val</span> ptr : <span class="type-var">'a</span> <a href="index.html#type-typ">typ</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../Ctypes_static/index.html#type-ptr">Ctypes_static.ptr</a> <a href="index.html#type-typ">typ</a></code></dt><dd><p>Construct a pointer type from an existing type (called the <i>reference type</i>).</p></dd></dl><dl><dt class="spec value" id="val-ptr_opt"><a href="#val-ptr_opt" class="anchor"></a><code><span class="keyword">val</span> ptr_opt : <span class="type-var">'a</span> <a href="index.html#type-typ">typ</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../Ctypes_static/index.html#type-ptr">Ctypes_static.ptr</a> option <a href="index.html#type-typ">typ</a></code></dt><dd><p>Construct a pointer type from an existing type (called the <i>reference type</i>). This behaves like <a href="index.html#val-ptr"><code>ptr</code></a>, except that null pointers appear in OCaml as <code>None</code>.</p></dd></dl><dl><dt class="spec value" id="val-string"><a href="#val-string" class="anchor"></a><code><span class="keyword">val</span> string : string <a href="index.html#type-typ">typ</a></code></dt><dd><p>A high-level representation of the string type.</p><p>On the C side this behaves like <code>char *</code>; on the OCaml side values read and written using <a href="index.html#val-string"><code>string</code></a> are simply native OCaml strings.</p><p>To avoid problems with the garbage collector, values passed using <a href="index.html#val-string"><code>string</code></a> are copied into immovable C-managed storage before being passed to C.</p><p>When the memory is not owned by the C code, -- i.e. when creating or initializing a struct in OCaml before passing it to C -- then the <a href="index.html#val-string"><code>string</code></a> view isn't a good choice, because there's no way to manage the lifetime of the C copy of the generated OCaml string.</p></dd></dl><dl><dt class="spec value" id="val-string_opt"><a href="#val-string_opt" class="anchor"></a><code><span class="keyword">val</span> string_opt : string option <a href="index.html#type-typ">typ</a></code></dt><dd><p>A high-level representation of the string type. This behaves like <a href="index.html#val-string"><code>string</code></a>, except that null pointers appear in OCaml as <code>None</code>.</p></dd></dl></section><section><header><h6 id="ocaml-pointers"><a href="#ocaml-pointers" class="anchor"></a>OCaml pointers</h6></header><dl><dt class="spec value" id="val-ocaml_string"><a href="#val-ocaml_string" class="anchor"></a><code><span class="keyword">val</span> ocaml_string : string <a href="../Ctypes_static/index.html#type-ocaml">Ctypes_static.ocaml</a> <a href="index.html#type-typ">typ</a></code></dt><dd><p>Value representing the directly mapped storage of an OCaml string.</p></dd></dl><dl><dt class="spec value" id="val-ocaml_bytes"><a href="#val-ocaml_bytes" class="anchor"></a><code><span class="keyword">val</span> ocaml_bytes : <a href="../../ocaml/Stdlib/Bytes/index.html#type-t">Stdlib.Bytes.t</a> <a href="../Ctypes_static/index.html#type-ocaml">Ctypes_static.ocaml</a> <a href="index.html#type-typ">typ</a></code></dt><dd><p>Value representing the directly mapped storage of an OCaml byte array.</p></dd></dl></section></section></section><section><header><h4 id="array-types"><a href="#array-types" class="anchor"></a>Array types</h4></header><section><header><h5 id="c-array-types"><a href="#c-array-types" class="anchor"></a>C array types</h5></header><dl><dt class="spec value" id="val-array"><a href="#val-array" class="anchor"></a><code><span class="keyword">val</span> array : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-typ">typ</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../Ctypes_static/index.html#type-carray">Ctypes_static.carray</a> <a href="index.html#type-typ">typ</a></code></dt><dd><p>Construct a sized array type from a length and an existing type (called the <i>element type</i>).</p></dd></dl></section><section><header><h5 id="bigarray-types"><a href="#bigarray-types" class="anchor"></a>Bigarray types</h5></header><dl><dt class="spec value" id="val-bigarray"><a href="#val-bigarray" class="anchor"></a><code><span class="keyword">val</span> bigarray : &lt; element : <span class="type-var">'a</span>; layout : <a href="../../ocaml/Bigarray/index.html#type-c_layout">Bigarray.c_layout</a>; ba_repr : <span class="type-var">'b</span>; dims : <span class="type-var">'dims</span>; bigarray : <span class="type-var">'bigarray</span>; carray : <span class="type-var">_</span>; &gt; <a href="../Ctypes_static/index.html#type-bigarray_class">Ctypes_static.bigarray_class</a> <span>&#45;&gt;</span> <span class="type-var">'dims</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="../../ocaml/Bigarray/index.html#type-kind">Bigarray.kind</a> <span>&#45;&gt;</span> <span class="type-var">'bigarray</span> <a href="index.html#type-typ">typ</a></code></dt><dd><p>Construct a sized C-layout bigarray type representation from a bigarray class, the dimensions, and the <a href="../../ocaml/Bigarray/index.html#type-kind"><code>Bigarray.kind</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-fortran_bigarray"><a href="#val-fortran_bigarray" class="anchor"></a><code><span class="keyword">val</span> fortran_bigarray : &lt; element : <span class="type-var">'a</span>; layout : <a href="../../ocaml/Bigarray/index.html#type-fortran_layout">Bigarray.fortran_layout</a>; ba_repr : <span class="type-var">'b</span>; dims : <span class="type-var">'dims</span>; bigarray : <span class="type-var">'bigarray</span>; carray : <span class="type-var">_</span>; &gt; <a href="../Ctypes_static/index.html#type-bigarray_class">Ctypes_static.bigarray_class</a> <span>&#45;&gt;</span> <span class="type-var">'dims</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="../../ocaml/Bigarray/index.html#type-kind">Bigarray.kind</a> <span>&#45;&gt;</span> <span class="type-var">'bigarray</span> <a href="index.html#type-typ">typ</a></code></dt><dd><p>Construct a sized Fortran-layout bigarray type representation from a bigarray class, the dimensions, and the <a href="../../ocaml/Bigarray/index.html#type-kind"><code>Bigarray.kind</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-typ_of_bigarray_kind"><a href="#val-typ_of_bigarray_kind" class="anchor"></a><code><span class="keyword">val</span> typ_of_bigarray_kind : (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="../../ocaml/Bigarray/index.html#type-kind">Bigarray.kind</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-typ">typ</a></code></dt><dd><p><code>typ_of_bigarray_kind k</code> is the type corresponding to the Bigarray kind <code>k</code>.</p></dd></dl></section></section><section><header><h4 id="struct-and-union-types"><a href="#struct-and-union-types" class="anchor"></a>Struct and union types</h4></header><dl><dt class="spec type" id="type-field"><a href="#type-field" class="anchor"></a><code><span class="keyword">type</span> ('a, 't) field</code></dt></dl><dl><dt class="spec value" id="val-structure"><a href="#val-structure" class="anchor"></a><code><span class="keyword">val</span> structure : string <span>&#45;&gt;</span> <span class="type-var">'s</span> <a href="../Ctypes_static/index.html#type-structure">Ctypes_static.structure</a> <a href="index.html#type-typ">typ</a></code></dt><dd><p>Construct a new structure type. The type value returned is incomplete and can be updated using <a href="index.html#type-field"><code>field</code></a> until it is passed to <a href="index.html#val-seal"><code>seal</code></a>, at which point the set of fields is fixed.</p><p>The type (<code>'_s structure typ</code>) of the expression returned by the call <code>structure tag</code> includes a weak type variable, which can be explicitly instantiated to ensure that the OCaml values representing different C structure types have incompatible types. Typical usage is as follows:</p><p><code>type tagname</code></p><p><code>let tagname : tagname structure typ = structure &quot;tagname&quot;</code></p></dd></dl><dl><dt class="spec value" id="val-union"><a href="#val-union" class="anchor"></a><code><span class="keyword">val</span> union : string <span>&#45;&gt;</span> <span class="type-var">'s</span> <a href="../Ctypes_static/index.html#type-union">Ctypes_static.union</a> <a href="index.html#type-typ">typ</a></code></dt><dd><p>Construct a new union type. This behaves analogously to <a href="index.html#val-structure"><code>structure</code></a>; fields are added with <a href="index.html#type-field"><code>field</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-field"><a href="#val-field" class="anchor"></a><code><span class="keyword">val</span> field : <span class="type-var">'t</span> <a href="index.html#type-typ">typ</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-typ">typ</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, (<span class="type-var">'s</span>, [&lt; `Struct | `Union ]) <a href="../Ctypes_static/index.html#type-structured">Ctypes_static.structured</a> <span class="keyword">as</span> t) <a href="index.html#type-field">field</a></code></dt><dd><p><code>field ty label ty'</code> adds a field of type <code>ty'</code> with label <code>label</code> to the structure or union type <code>ty</code> and returns a field value that can be used to read and write the field in structure or union instances (e.g. using <a href="index.html#val-getf"><code>getf</code></a> and <a href="index.html#val-setf"><code>setf</code></a>).</p><p>Attempting to add a field to a union type that has been sealed with <code>seal</code> is an error, and will raise <a href="index.html#exception-ModifyingSealedType"><code>ModifyingSealedType</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-seal"><a href="#val-seal" class="anchor"></a><code><span class="keyword">val</span> seal : (<span class="type-var">_</span>, [&lt; `Struct | `Union ]) <a href="../Ctypes_static/index.html#type-structured">Ctypes_static.structured</a> <a href="index.html#type-typ">typ</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>seal t</code> completes the struct or union type <code>t</code> so that no further fields can be added. Struct and union types must be sealed before they can be used in a way that involves their size or alignment; see the documentation for <a href="index.html#exception-IncompleteType"><code>IncompleteType</code></a> for further details.</p></dd></dl></section><section><header><h4 id="view-types"><a href="#view-types" class="anchor"></a>View types</h4></header><dl><dt class="spec value" id="val-view"><a href="#val-view" class="anchor"></a><code><span class="keyword">val</span> view : ?&#8288;format_typ:((<a href="../../ocaml/Stdlib/Format/index.html#type-formatter">Stdlib.Format.formatter</a> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <a href="../../ocaml/Stdlib/Format/index.html#type-formatter">Stdlib.Format.formatter</a> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> ?&#8288;format:(<a href="../../ocaml/Stdlib/Format/index.html#type-formatter">Stdlib.Format.formatter</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> read:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> write:(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-typ">typ</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-typ">typ</a></code></dt><dd><p><code>view ~read:r ~write:w t</code> creates a C type representation <code>t'</code> which behaves like <code>t</code> except that values read using <code>t'</code> are subsequently transformed using the function <code>r</code> and values written using <code>t'</code> are first transformed using the function <code>w</code>.</p><p>For example, given suitable definitions of <code>string_of_char_ptr</code> and <code>char_ptr_of_string</code>, the type representation</p><p><code>view ~read:string_of_char_ptr ~write:char_ptr_of_string (ptr char)</code></p><p>can be used to pass OCaml strings directly to and from bound C functions, or to read and write string members in structs and arrays. (In fact, the <a href="index.html#val-string"><code>string</code></a> type representation is defined in exactly this way.)</p><p>The optional argument <code>format_typ</code> is used by the <a href="index.html#val-format_typ"><code>Ctypes.format_typ</code></a> and <a href="index.html#val-string_of_typ"><code>string_of_typ</code></a> functions to print the type at the top level and elsewhere. If <code>format_typ</code> is not supplied the printer for <code>t</code> is used instead.</p><p>The optional argument <code>format</code> is used by the <a href="index.html#val-format"><code>Ctypes.format</code></a> and <a href="index.html#val-string_of"><code>string_of</code></a> functions to print the values. If <code>format_val</code> is not supplied the printer for <code>t</code> is used instead.</p></dd></dl><dl><dt class="spec value" id="val-typedef"><a href="#val-typedef" class="anchor"></a><code><span class="keyword">val</span> typedef : <span class="type-var">'a</span> <a href="index.html#type-typ">typ</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-typ">typ</a></code></dt><dd><p><code>typedef t name</code> creates a C type representation <code>t'</code> which is equivalent to <code>t</code> except its name is printed as <code>name</code>.</p><p>This is useful when generating C stubs involving &quot;anonymous&quot; types, for example: <code>typedef struct { int f } typedef_name;</code></p></dd></dl></section><section><header><h4 id="abstract-types"><a href="#abstract-types" class="anchor"></a>Abstract types</h4></header><dl><dt class="spec value" id="val-abstract"><a href="#val-abstract" class="anchor"></a><code><span class="keyword">val</span> abstract : name:string <span>&#45;&gt;</span> size:int <span>&#45;&gt;</span> alignment:int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../Ctypes_static/index.html#type-abstract">Ctypes_static.abstract</a> <a href="index.html#type-typ">typ</a></code></dt><dd><p>Create an abstract type specification from the size and alignment requirements for the type.</p></dd></dl></section><section><header><h4 id="injection-of-concrete-types"><a href="#injection-of-concrete-types" class="anchor"></a>Injection of concrete types</h4></header><dl><dt class="spec value" id="val-lift_typ"><a href="#val-lift_typ" class="anchor"></a><code><span class="keyword">val</span> lift_typ : <span class="type-var">'a</span> <a href="../Ctypes_static/index.html#type-typ">Ctypes_static.typ</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-typ">typ</a></code></dt><dd><p><code>lift_typ t</code> turns a concrete type representation into an abstract type representation.</p><p>For example, retrieving struct layout from C involves working with an abstract representation of types which do not support operations such as <code>sizeof</code>. The <code>lift_typ</code> function makes it possible to use concrete type representations wherever such abstract type representations are needed.</p></dd></dl></section><section><header><h4 id="function-types"><a href="#function-types" class="anchor"></a>Function types</h4></header><aside><p>Abstract interface to C function type descriptions</p></aside><dl><dt class="spec type" id="type-fn"><a href="#type-fn" class="anchor"></a><code><span class="keyword">type</span> 'a fn</code><code> = <span class="type-var">'a</span> <a href="../Ctypes_static/index.html#type-fn">Ctypes_static.fn</a></code></dt><dd><p>The type of values representing C function types. A value of type <code>t fn</code> can be used to bind to C functions and to describe type of OCaml functions passed to C.</p></dd></dl><dl><dt class="spec value" id="val-(@-&gt;)"><a href="#val-(@-&gt;)" class="anchor"></a><code><span class="keyword">val</span> (@-&gt;) : <span class="type-var">'a</span> <a href="index.html#type-typ">typ</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-fn">fn</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <a href="index.html#type-fn">fn</a></code></dt><dd><p>Construct a function type from a type and an existing function type. This corresponds to prepending a parameter to a C function parameter list. For example,</p><p><code>int @-&gt; ptr void @-&gt; returning float</code></p><p>describes a function type that accepts two arguments -- an integer and a pointer to void -- and returns a float.</p></dd></dl><dl><dt class="spec value" id="val-returning"><a href="#val-returning" class="anchor"></a><code><span class="keyword">val</span> returning : <span class="type-var">'a</span> <a href="index.html#type-typ">typ</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-fn">fn</a></code></dt><dd><p>Give the return type of a C function. Note that <code>returning</code> is intended to be used together with <a href="index.html#val-(@-&gt;)"><code>(@-&gt;)</code></a>; see the documentation for <a href="index.html#val-(@-&gt;)"><code>(@-&gt;)</code></a> for an example.</p></dd></dl><dl><dt class="spec type" id="type-static_funptr"><a href="#type-static_funptr" class="anchor"></a><code><span class="keyword">type</span> 'a static_funptr</code><code> = <span class="type-var">'a</span> <a href="../Ctypes_static/index.html#type-static_funptr">Ctypes_static.static_funptr</a></code></dt><dd><h4 id="function-pointer-types"><a href="#function-pointer-types" class="anchor"></a>Function pointer types</h4><p>The type of values representing C function pointer types.</p></dd></dl><dl><dt class="spec value" id="val-static_funptr"><a href="#val-static_funptr" class="anchor"></a><code><span class="keyword">val</span> static_funptr : <span class="type-var">'a</span> <a href="index.html#type-fn">fn</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../Ctypes_static/index.html#type-static_funptr">Ctypes_static.static_funptr</a> <a href="index.html#type-typ">typ</a></code></dt><dd><p>Construct a function pointer type from an existing function type (called the <i>reference type</i>).</p></dd></dl></section></details></div></div></div></section><section><header><h4 id="operations-on-types"><a href="#operations-on-types" class="anchor"></a>Operations on types</h4></header><dl><dt class="spec value" id="val-sizeof"><a href="#val-sizeof" class="anchor"></a><code><span class="keyword">val</span> sizeof : <span class="type-var">'a</span> <a href="index.html#type-typ">typ</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>sizeof t</code> computes the size in bytes of the type <code>t</code>. The exception <a href="index.html#exception-IncompleteType"><code>IncompleteType</code></a> is raised if <code>t</code> is incomplete.</p></dd></dl><dl><dt class="spec value" id="val-alignment"><a href="#val-alignment" class="anchor"></a><code><span class="keyword">val</span> alignment : <span class="type-var">'a</span> <a href="index.html#type-typ">typ</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>alignment t</code> computes the alignment requirements of the type <code>t</code>. The exception <a href="index.html#exception-IncompleteType"><code>IncompleteType</code></a> is raised if <code>t</code> is incomplete.</p></dd></dl><dl><dt class="spec value" id="val-format_typ"><a href="#val-format_typ" class="anchor"></a><code><span class="keyword">val</span> format_typ : ?&#8288;name:string <span>&#45;&gt;</span> <a href="../../ocaml/Stdlib/Format/index.html#type-formatter">Stdlib.Format.formatter</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-typ">typ</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Pretty-print a C representation of the type to the specified formatter.</p></dd></dl><dl><dt class="spec value" id="val-format_fn"><a href="#val-format_fn" class="anchor"></a><code><span class="keyword">val</span> format_fn : ?&#8288;name:string <span>&#45;&gt;</span> <a href="../../ocaml/Stdlib/Format/index.html#type-formatter">Stdlib.Format.formatter</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-fn">fn</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Pretty-print a C representation of the function type to the specified formatter.</p></dd></dl><dl><dt class="spec value" id="val-string_of_typ"><a href="#val-string_of_typ" class="anchor"></a><code><span class="keyword">val</span> string_of_typ : ?&#8288;name:string <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-typ">typ</a> <span>&#45;&gt;</span> string</code></dt><dd><p>Return a C representation of the type.</p></dd></dl><dl><dt class="spec value" id="val-string_of_fn"><a href="#val-string_of_fn" class="anchor"></a><code><span class="keyword">val</span> string_of_fn : ?&#8288;name:string <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-fn">fn</a> <span>&#45;&gt;</span> string</code></dt><dd><p>Return a C representation of the function type.</p></dd></dl></section><section><header><h3 id="values"><a href="#values" class="anchor"></a>Values representing C values</h3></header><dl><dt class="spec value" id="val-format"><a href="#val-format" class="anchor"></a><code><span class="keyword">val</span> format : <span class="type-var">'a</span> <a href="index.html#type-typ">typ</a> <span>&#45;&gt;</span> <a href="../../ocaml/Stdlib/Format/index.html#type-formatter">Stdlib.Format.formatter</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Pretty-print a representation of the C value to the specified formatter.</p></dd></dl><dl><dt class="spec value" id="val-string_of"><a href="#val-string_of" class="anchor"></a><code><span class="keyword">val</span> string_of : <span class="type-var">'a</span> <a href="index.html#type-typ">typ</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> string</code></dt><dd><p>Return a string representation of the C value.</p></dd></dl><section><header><h4 id="pointer-values"><a href="#pointer-values" class="anchor"></a>Pointer values</h4></header><dl><dt class="spec value" id="val-null"><a href="#val-null" class="anchor"></a><code><span class="keyword">val</span> null : unit <a href="index.html#type-ptr">ptr</a></code></dt><dd><p>A null pointer.</p></dd></dl><dl><dt class="spec value" id="val-(!@)"><a href="#val-(!@)" class="anchor"></a><code><span class="keyword">val</span> (!@) : <span class="type-var">'a</span> <a href="index.html#type-ptr">ptr</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>!@ p</code> dereferences the pointer <code>p</code>. If the reference type is a scalar type then dereferencing constructs a new value. If the reference type is an aggregate type then dereferencing returns a value that references the memory pointed to by <code>p</code>.</p></dd></dl><dl><dt class="spec value" id="val-(&lt;-@)"><a href="#val-(&lt;-@)" class="anchor"></a><code><span class="keyword">val</span> (&lt;-@) : <span class="type-var">'a</span> <a href="index.html#type-ptr">ptr</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>p &lt;-@ v</code> writes the value <code>v</code> to the address <code>p</code>.</p></dd></dl><dl><dt class="spec value" id="val-(+@)"><a href="#val-(+@)" class="anchor"></a><code><span class="keyword">val</span> (+@) : (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-pointer">pointer</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-pointer">pointer</a></code></dt><dd><p>If <code>p</code> is a pointer to an array element then <code>p +@ n</code> computes the address of the <code>n</code>th next element.</p></dd></dl><dl><dt class="spec value" id="val-(-@)"><a href="#val-(-@)" class="anchor"></a><code><span class="keyword">val</span> (-@) : (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-pointer">pointer</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-pointer">pointer</a></code></dt><dd><p>If <code>p</code> is a pointer to an array element then <code>p -@ n</code> computes the address of the nth previous element.</p></dd></dl><dl><dt class="spec value" id="val-ptr_diff"><a href="#val-ptr_diff" class="anchor"></a><code><span class="keyword">val</span> ptr_diff : (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-pointer">pointer</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-pointer">pointer</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>ptr_diff p q</code> computes <code>q - p</code>. As in C, both <code>p</code> and <code>q</code> must point into the same array, and the result value is the difference of the subscripts of the two array elements.</p></dd></dl><dl><dt class="spec value" id="val-from_voidp"><a href="#val-from_voidp" class="anchor"></a><code><span class="keyword">val</span> from_voidp : <span class="type-var">'a</span> <a href="index.html#type-typ">typ</a> <span>&#45;&gt;</span> unit <a href="index.html#type-ptr">ptr</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-ptr">ptr</a></code></dt><dd><p>Conversion from <code>void *</code>.</p></dd></dl><dl><dt class="spec value" id="val-to_voidp"><a href="#val-to_voidp" class="anchor"></a><code><span class="keyword">val</span> to_voidp : <span class="type-var">_</span> <a href="index.html#type-ptr">ptr</a> <span>&#45;&gt;</span> unit <a href="index.html#type-ptr">ptr</a></code></dt><dd><p>Conversion to <code>void *</code>.</p></dd></dl><dl><dt class="spec value" id="val-allocate"><a href="#val-allocate" class="anchor"></a><code><span class="keyword">val</span> allocate : ?&#8288;finalise:(<span class="type-var">'a</span> <a href="index.html#type-ptr">ptr</a> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-typ">typ</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-ptr">ptr</a></code></dt><dd><p><code>allocate t v</code> allocates a fresh value of type <code>t</code>, initialises it with <code>v</code> and returns its address. The argument <code>?finalise</code>, if present, will be called just before the memory is freed. The value will be automatically freed after no references to the pointer remain within the calling OCaml program.</p></dd></dl><dl><dt class="spec value" id="val-allocate_n"><a href="#val-allocate_n" class="anchor"></a><code><span class="keyword">val</span> allocate_n : ?&#8288;finalise:(<span class="type-var">'a</span> <a href="index.html#type-ptr">ptr</a> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-typ">typ</a> <span>&#45;&gt;</span> count:int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-ptr">ptr</a></code></dt><dd><p><code>allocate_n t ~count:n</code> allocates a fresh array with element type <code>t</code> and length <code>n</code>, and returns its address. The argument <code>?finalise</code>, if present, will be called just before the memory is freed. The array will be automatically freed after no references to the pointer remain within the calling OCaml program. The memory is allocated with libc's <code>calloc</code> and is guaranteed to be zero-filled.</p></dd></dl><dl><dt class="spec value" id="val-ptr_compare"><a href="#val-ptr_compare" class="anchor"></a><code><span class="keyword">val</span> ptr_compare : <span class="type-var">'a</span> <a href="index.html#type-ptr">ptr</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-ptr">ptr</a> <span>&#45;&gt;</span> int</code></dt><dd><p>If <code>p</code> and <code>q</code> are pointers to elements <code>i</code> and <code>j</code> of the same array then <code>ptr_compare p q</code> compares the indexes of the elements. The result is negative if <code>i</code> is less than <code>j</code>, positive if <code>i</code> is greater than <code>j</code>, and zero if <code>i</code> and <code>j</code> are equal.</p></dd></dl><dl><dt class="spec value" id="val-is_null"><a href="#val-is_null" class="anchor"></a><code><span class="keyword">val</span> is_null : <span class="type-var">'a</span> <a href="index.html#type-ptr">ptr</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_null p</code> is true when <code>p</code> is a null pointer.</p></dd></dl><dl><dt class="spec value" id="val-reference_type"><a href="#val-reference_type" class="anchor"></a><code><span class="keyword">val</span> reference_type : <span class="type-var">'a</span> <a href="index.html#type-ptr">ptr</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-typ">typ</a></code></dt><dd><p>Retrieve the reference type of a pointer.</p></dd></dl><dl><dt class="spec value" id="val-ptr_of_raw_address"><a href="#val-ptr_of_raw_address" class="anchor"></a><code><span class="keyword">val</span> ptr_of_raw_address : nativeint <span>&#45;&gt;</span> unit <a href="index.html#type-ptr">ptr</a></code></dt><dd><p>Convert the numeric representation of an address to a pointer</p></dd></dl><dl><dt class="spec value" id="val-funptr_of_raw_address"><a href="#val-funptr_of_raw_address" class="anchor"></a><code><span class="keyword">val</span> funptr_of_raw_address : nativeint <span>&#45;&gt;</span> (unit <span>&#45;&gt;</span> unit) <a href="../Ctypes_static/index.html#type-static_funptr">Ctypes_static.static_funptr</a></code></dt><dd><p>Convert the numeric representation of an address to a function pointer</p></dd></dl><dl><dt class="spec value" id="val-raw_address_of_ptr"><a href="#val-raw_address_of_ptr" class="anchor"></a><code><span class="keyword">val</span> raw_address_of_ptr : unit <a href="index.html#type-ptr">ptr</a> <span>&#45;&gt;</span> nativeint</code></dt><dd><p><code>raw_address_of_ptr p</code> returns the numeric representation of p.</p><p>Note that the return value remains valid only as long as the pointed-to object is alive. If <code>p</code> is a managed object (e.g. a value returned by <a href="index.html#val-make"><code>make</code></a>) then unless the caller retains a reference to <code>p</code>, the object may be collected, invalidating the returned address.</p></dd></dl><dl><dt class="spec value" id="val-string_from_ptr"><a href="#val-string_from_ptr" class="anchor"></a><code><span class="keyword">val</span> string_from_ptr : char <a href="index.html#type-ptr">ptr</a> <span>&#45;&gt;</span> length:int <span>&#45;&gt;</span> string</code></dt><dd><p><code>string_from_ptr p ~length</code> creates a string initialized with the <code>length</code> characters at address <code>p</code>.</p><p>Raise <code>Invalid_argument &quot;Ctypes.string_from_ptr&quot;</code> if <code>length</code> is negative.</p></dd></dl><dl><dt class="spec value" id="val-ocaml_string_start"><a href="#val-ocaml_string_start" class="anchor"></a><code><span class="keyword">val</span> ocaml_string_start : string <span>&#45;&gt;</span> string <a href="index.html#type-ocaml">ocaml</a></code></dt><dd><p><code>ocaml_string_start s</code> allows to pass a pointer to the contents of an OCaml string directly to a C function.</p></dd></dl><dl><dt class="spec value" id="val-ocaml_bytes_start"><a href="#val-ocaml_bytes_start" class="anchor"></a><code><span class="keyword">val</span> ocaml_bytes_start : <a href="../../ocaml/Stdlib/Bytes/index.html#type-t">Stdlib.Bytes.t</a> <span>&#45;&gt;</span> <a href="../../ocaml/Stdlib/Bytes/index.html#type-t">Stdlib.Bytes.t</a> <a href="index.html#type-ocaml">ocaml</a></code></dt><dd><p><code>ocaml_bytes_start s</code> allows to pass a pointer to the contents of an OCaml byte array directly to a C function.</p></dd></dl></section><section><header><h4 id="array-values"><a href="#array-values" class="anchor"></a>Array values</h4></header><section><header><h5 id="c-array-values"><a href="#c-array-values" class="anchor"></a>C array values</h5></header><dl><dt class="spec module" id="module-CArray"><a href="#module-CArray" class="anchor"></a><code><span class="keyword">module</span> <a href="CArray/index.html">CArray</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Operations on C arrays.</p></dd></dl></section><section><header><h5 id="bigarray-values"><a href="#bigarray-values" class="anchor"></a>Bigarray values</h5></header><dl><dt class="spec value" id="val-bigarray_start"><a href="#val-bigarray_start" class="anchor"></a><code><span class="keyword">val</span> bigarray_start : &lt; element : <span class="type-var">'a</span>; layout : <span class="type-var">'l</span>; ba_repr : <span class="type-var">_</span>; bigarray : <span class="type-var">'b</span>; carray : <span class="type-var">_</span>; dims : <span class="type-var">_</span>; &gt; <a href="index.html#type-bigarray_class">bigarray_class</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-ptr">ptr</a></code></dt><dd><p>Return the address of the first element of the given Bigarray value.</p></dd></dl><dl><dt class="spec value" id="val-bigarray_of_ptr"><a href="#val-bigarray_of_ptr" class="anchor"></a><code><span class="keyword">val</span> bigarray_of_ptr : &lt; element : <span class="type-var">'a</span>; layout : <a href="../../ocaml/Bigarray/index.html#type-c_layout">Bigarray.c_layout</a>; ba_repr : <span class="type-var">'f</span>; bigarray : <span class="type-var">'b</span>; carray : <span class="type-var">_</span>; dims : <span class="type-var">'i</span>; &gt; <a href="index.html#type-bigarray_class">bigarray_class</a> <span>&#45;&gt;</span> <span class="type-var">'i</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'f</span>) <a href="../../ocaml/Bigarray/index.html#type-kind">Bigarray.kind</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-ptr">ptr</a> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p><code>bigarray_of_ptr c dims k p</code> converts the C pointer <code>p</code> to a C-layout bigarray value. No copy is made; the bigarray references the memory pointed to by <code>p</code>.</p></dd></dl><dl><dt class="spec value" id="val-fortran_bigarray_of_ptr"><a href="#val-fortran_bigarray_of_ptr" class="anchor"></a><code><span class="keyword">val</span> fortran_bigarray_of_ptr : &lt; element : <span class="type-var">'a</span>; layout : <a href="../../ocaml/Bigarray/index.html#type-fortran_layout">Bigarray.fortran_layout</a>; ba_repr : <span class="type-var">'f</span>; bigarray : <span class="type-var">'b</span>; carray : <span class="type-var">_</span>; dims : <span class="type-var">'i</span>; &gt; <a href="index.html#type-bigarray_class">bigarray_class</a> <span>&#45;&gt;</span> <span class="type-var">'i</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'f</span>) <a href="../../ocaml/Bigarray/index.html#type-kind">Bigarray.kind</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-ptr">ptr</a> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p><code>fortran_bigarray_of_ptr c dims k p</code> converts the C pointer <code>p</code> to a Fortran-layout bigarray value. No copy is made; the bigarray references the memory pointed to by <code>p</code>.</p></dd></dl><dl><dt class="spec value" id="val-array_of_bigarray"><a href="#val-array_of_bigarray" class="anchor"></a><code><span class="keyword">val</span> array_of_bigarray : &lt; element : <span class="type-var">_</span>; layout : <a href="../../ocaml/Bigarray/index.html#type-c_layout">Bigarray.c_layout</a>; ba_repr : <span class="type-var">_</span>; bigarray : <span class="type-var">'b</span>; carray : <span class="type-var">'c</span>; dims : <span class="type-var">_</span>; &gt; <a href="index.html#type-bigarray_class">bigarray_class</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span></code></dt><dd><p><code>array_of_bigarray c b</code> converts the bigarray value <code>b</code> to a value of type <a href="CArray/index.html#type-t"><code>CArray.t</code></a>. No copy is made; the result occupies the same memory as <code>b</code>.</p></dd></dl><aside><p>Convert a Bigarray value to a C array.</p></aside><dl><dt class="spec value" id="val-bigarray_of_array"><a href="#val-bigarray_of_array" class="anchor"></a><code><span class="keyword">val</span> bigarray_of_array : &lt; element : <span class="type-var">'a</span>; layout : <a href="../../ocaml/Bigarray/index.html#type-c_layout">Bigarray.c_layout</a>; ba_repr : <span class="type-var">'f</span>; bigarray : <span class="type-var">'b</span>; carray : <span class="type-var">'c</span> <a href="index.html#type-carray">carray</a>; dims : <span class="type-var">'i</span>; &gt; <a href="index.html#type-bigarray_class">bigarray_class</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'f</span>) <a href="../../ocaml/Bigarray/index.html#type-kind">Bigarray.kind</a> <span>&#45;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-carray">carray</a> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p><code>bigarray_of_array c k a</code> converts the <a href="CArray/index.html#type-t"><code>CArray.t</code></a> value <code>a</code> to a C-layout bigarray value. No copy is made; the result occupies the same memory as <code>a</code>.</p></dd></dl></section></section><section><header><h4 id="struct-and-union-values"><a href="#struct-and-union-values" class="anchor"></a>Struct and union values</h4></header><dl><dt class="spec value" id="val-make"><a href="#val-make" class="anchor"></a><code><span class="keyword">val</span> make : ?&#8288;finalise:(<span class="type-var">'s</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> (<span class="type-var">_</span>, <span class="type-var">_</span>) <a href="index.html#type-structured">structured</a> <span class="keyword">as</span> s <a href="index.html#type-typ">typ</a> <span>&#45;&gt;</span> <span class="type-var">'s</span></code></dt><dd><p>Allocate a fresh, uninitialised structure or union value. The argument <code>?finalise</code>, if present, will be called just before the underlying memory is freed.</p></dd></dl><dl><dt class="spec value" id="val-setf"><a href="#val-setf" class="anchor"></a><code><span class="keyword">val</span> setf : (<span class="type-var">_</span>, <span class="type-var">_</span>) <a href="index.html#type-structured">structured</a> <span class="keyword">as</span> s <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-field">field</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>setf s f v</code> overwrites the value of the field <code>f</code> in the structure or union <code>s</code> with <code>v</code>.</p></dd></dl><dl><dt class="spec value" id="val-getf"><a href="#val-getf" class="anchor"></a><code><span class="keyword">val</span> getf : (<span class="type-var">_</span>, <span class="type-var">_</span>) <a href="index.html#type-structured">structured</a> <span class="keyword">as</span> s <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-field">field</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>getf s f</code> retrieves the value of the field <code>f</code> in the structure or union <code>s</code>. The semantics for non-scalar types are non-copying, as for <a href="index.html#val-(!@)"><code>(!@)</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-(@.)"><a href="#val-(@.)" class="anchor"></a><code><span class="keyword">val</span> (@.) : (<span class="type-var">_</span>, <span class="type-var">_</span>) <a href="index.html#type-structured">structured</a> <span class="keyword">as</span> s <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-field">field</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-ptr">ptr</a></code></dt><dd><p><code>s @. f</code> computes the address of the field <code>f</code> in the structure or union value <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-(|-&gt;)"><a href="#val-(|-&gt;)" class="anchor"></a><code><span class="keyword">val</span> (|-&gt;) : (<span class="type-var">_</span>, <span class="type-var">_</span>) <a href="index.html#type-structured">structured</a> <span class="keyword">as</span> s <a href="index.html#type-ptr">ptr</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-field">field</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-ptr">ptr</a></code></dt><dd><p><code>p |-&gt; f</code> computes the address of the field <code>f</code> in the structure or union value pointed to by <code>p</code>.</p></dd></dl><dl><dt class="spec value" id="val-offsetof"><a href="#val-offsetof" class="anchor"></a><code><span class="keyword">val</span> offsetof : (<span class="type-var">_</span>, <span class="type-var">_</span> <a href="index.html#type-structure">structure</a>) <a href="index.html#type-field">field</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>offsetof f</code> returns the offset, in bytes, of the field <code>f</code> from the beginning of the associated struct type.</p></dd></dl><dl><dt class="spec value" id="val-field_type"><a href="#val-field_type" class="anchor"></a><code><span class="keyword">val</span> field_type : (<span class="type-var">'a</span>, <span class="type-var">_</span>) <a href="index.html#type-field">field</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-typ">typ</a></code></dt><dd><p><code>field_type f</code> returns the type of the field <code>f</code>.</p></dd></dl><dl><dt class="spec value" id="val-field_name"><a href="#val-field_name" class="anchor"></a><code><span class="keyword">val</span> field_name : (<span class="type-var">_</span>, <span class="type-var">_</span>) <a href="index.html#type-field">field</a> <span>&#45;&gt;</span> string</code></dt><dd><p><code>field_name f</code> returns the name of the field <code>f</code>.</p></dd></dl><dl><dt class="spec value" id="val-addr"><a href="#val-addr" class="anchor"></a><code><span class="keyword">val</span> addr : (<span class="type-var">_</span>, <span class="type-var">_</span>) <a href="index.html#type-structured">structured</a> <span class="keyword">as</span> s <span>&#45;&gt;</span> <span class="type-var">'s</span> <a href="index.html#type-ptr">ptr</a></code></dt><dd><p><code>addr s</code> returns the address of the structure or union <code>s</code>.</p></dd></dl></section><section><header><h4 id="coercions"><a href="#coercions" class="anchor"></a>Coercions</h4></header><dl><dt class="spec value" id="val-coerce"><a href="#val-coerce" class="anchor"></a><code><span class="keyword">val</span> coerce : <span class="type-var">'a</span> <a href="index.html#type-typ">typ</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-typ">typ</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p><code>coerce t1 t2</code> returns a coercion function between the types represented by <code>t1</code> and <code>t2</code>. If <code>t1</code> cannot be coerced to <code>t2</code>, <code>coerce</code> raises <a href="index.html#exception-Uncoercible"><code>Uncoercible</code></a>.</p><p>The following coercions are currently supported:</p><ul><li>All function and object pointer types are intercoercible.</li><li>Any type may be coerced to <a href="index.html#val-void"><code>void</code></a></li><li>There is a coercion between a <a href="index.html#val-view"><code>view</code></a> and another type <code>t</code> (in either direction) if there is a coercion between the representation type underlying the view and <code>t</code>.</li><li>Coercion is transitive: if <code>t1</code> is coercible to <code>t2</code> and <code>t2</code> is coercible to <code>t3</code>, then <code>t1</code> is directly coercible to <code>t3</code>.</li></ul><p>The set of supported coercions is subject to change. Future versions of ctypes may both add new types of coercion and restrict the existing coercions.</p></dd></dl><dl><dt class="spec value" id="val-coerce_fn"><a href="#val-coerce_fn" class="anchor"></a><code><span class="keyword">val</span> coerce_fn : <span class="type-var">'a</span> <a href="index.html#type-fn">fn</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-fn">fn</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p><code>coerce_fn f1 f2</code> returns a coercion function between the function types represented by <code>f1</code> and <code>f2</code>. If <code>f1</code> cannot be coerced to <code>f2</code>, <code>coerce_fn</code> raises <a href="index.html#exception-Uncoercible"><code>Uncoercible</code></a>.</p><p>A function type <code>f1</code> may be coerced to another function type <code>f2</code> if all of the following hold:</p><ul><li>the C types described by <code>f1</code> and <code>f2</code> have the same arity</li></ul><ul><li>each argument of <code>f2</code> may be coerced to the corresponding argument of <code>f1</code></li></ul><ul><li>the return type of <code>f1</code> may be coerced to the return type of <code>f2</code></li></ul><p>The set of supported coercions is subject to change. Future versions of ctypes may both add new types of coercion and restrict the existing coercions.</p></dd></dl></section></section><section><header><h3 id="binding-interfaces"><a href="#binding-interfaces" class="anchor"></a>binding interfaces</h3><p>.</p></header><dl><dt class="spec module-type" id="module-type-FOREIGN"><a href="#module-type-FOREIGN" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-FOREIGN/index.html">FOREIGN</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Foreign function binding interface.</p></dd></dl><dl><dt class="spec module-type" id="module-type-TYPE"><a href="#module-type-TYPE" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-TYPE/index.html">TYPE</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Foreign types binding interface.</p></dd></dl><dl><dt class="spec module" id="module-Root"><a href="#module-Root" class="anchor"></a><code><span class="keyword">module</span> <a href="Root/index.html">Root</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd></dd></dl></section><section><header><h3 id="exceptions"><a href="#exceptions" class="anchor"></a>Exceptions</h3></header><dl><dt class="spec exception" id="exception-Unsupported"><a href="#exception-Unsupported" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Unsupported</span> <span class="keyword">of</span> string</code></dt><dd><p>An attempt was made to use a feature not currently supported by ctypes. In practice this refers to attempts to use an union, array or abstract type as an argument or return type of a function.</p></dd></dl><dl><dt class="spec exception" id="exception-ModifyingSealedType"><a href="#exception-ModifyingSealedType" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">ModifyingSealedType</span> <span class="keyword">of</span> string</code></dt><dd><p>An attempt was made to modify a sealed struct or union type description.</p></dd></dl><dl><dt class="spec exception" id="exception-IncompleteType"><a href="#exception-IncompleteType" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">IncompleteType</span></code></dt><dd><p>An attempt was made to compute the size or alignment of an incomplete type.</p><p>The incomplete types are struct and union types that have not been sealed, and the void type.</p><p>It is not permitted to compute the size or alignment requirements of an incomplete type, to use it as a struct or union member, to read or write a value of the type through a pointer or to use it as the referenced type in pointer arithmetic. Additionally, incomplete struct and union types cannot be used as argument or return types.</p></dd></dl><dl><dt class="spec type" id="type-uncoercible_info"><a href="#type-uncoercible_info" class="anchor"></a><code><span class="keyword">type</span> uncoercible_info</code></dt></dl><dl><dt class="spec exception" id="exception-Uncoercible"><a href="#exception-Uncoercible" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Uncoercible</span> <span class="keyword">of</span> <a href="index.html#type-uncoercible_info">uncoercible_info</a></code></dt><dd><p>An attempt was made to coerce between uncoercible types.</p></dd></dl></section></div></body></html>