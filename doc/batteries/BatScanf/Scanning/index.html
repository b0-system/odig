<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Scanning (batteries.BatScanf.Scanning)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">batteries</a> &#x00BB; <a href="../index.html">BatScanf</a> &#x00BB; Scanning</nav><header class="odoc-preamble"><h1>Module <code><span>BatScanf.Scanning</span></code></h1></header><nav class="odoc-toc"><ul><li><a href="#scanning-buffers">Scanning buffers</a></li><li><a href="#obsolete">Obsolete</a></li></ul></nav><div class="odoc-content"><h6 id="scanning-buffers"><a href="#scanning-buffers" class="anchor"></a>Scanning buffers</h6><div class="odoc-spec"><div class="spec type" id="type-scanbuf" class="anchored"><a href="#type-scanbuf" class="anchor"></a><code><span><span class="keyword">type</span> scanbuf</span><span> = <a href="../../../ocaml/Stdlib/Scanf/Scanning/index.html#type-scanbuf">Scanf.Scanning.scanbuf</a></span></code></div><div class="spec-doc"><p>The type of scanning buffers. A scanning buffer is the source from which a formatted input function gets characters. The scanning buffer holds the current state of the scan, plus a function to get the next char from the input, and a token buffer to store the string matched so far.</p><p>Note: a scan may often require to examine one character in advance; when this ``lookahead'' character does not belong to the token read, it is stored back in the scanning buffer and becomes the next character read.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-stdib" class="anchored"><a href="#val-stdib" class="anchor"></a><code><span><span class="keyword">val</span> stdib : <a href="#type-scanbuf">scanbuf</a></span></code></div><div class="spec-doc"><p>The scanning buffer reading from <code>stdin</code>. <code>stdib</code> is equivalent to <code>Scanning.from_input stdin</code>.</p><p>Note: when input is read interactively from <code>stdin</code>, the newline character that triggers the evaluation is incorporated in the input; thus, scanning specifications must properly skip this character (simply add a <code>'\n'</code> as the last character of the format string).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-from_string" class="anchored"><a href="#val-from_string" class="anchor"></a><code><span><span class="keyword">val</span> from_string : <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-scanbuf">scanbuf</a></span></code></div><div class="spec-doc"><p><code>Scanning.from_string s</code> returns a scanning buffer which reads from the given string. Reading starts from the first character in the string. The end-of-input condition is set when the end of the string is reached.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-from_file" class="anchored"><a href="#val-from_file" class="anchor"></a><code><span><span class="keyword">val</span> from_file : <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-scanbuf">scanbuf</a></span></code></div><div class="spec-doc"><p>Bufferized file reading in text mode. The efficient and usual way to scan text mode files (in effect, <code>from_file</code> returns a scanning buffer that reads characters in large chunks, rather than one character at a time as buffers returned by <code>from_channel</code> do). <code>Scanning.from_file fname</code> returns a scanning buffer which reads from the given file <code>fname</code> in text mode.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-from_file_bin" class="anchored"><a href="#val-from_file_bin" class="anchor"></a><code><span><span class="keyword">val</span> from_file_bin : <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-scanbuf">scanbuf</a></span></code></div><div class="spec-doc"><p>Bufferized file reading in binary mode.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-from_function" class="anchored"><a href="#val-from_function" class="anchor"></a><code><span><span class="keyword">val</span> from_function : <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> char)</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-scanbuf">scanbuf</a></span></code></div><div class="spec-doc"><p><code>Scanning.from_function f</code> returns a scanning buffer with the given function as its reading method.</p><p>When scanning needs one more character, the given function is called.</p><p>When the function has no more character to provide, it must signal an end-of-input condition by raising the exception <code>End_of_file</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-from_input" class="anchored"><a href="#val-from_input" class="anchor"></a><code><span><span class="keyword">val</span> from_input : <span><a href="../../BatIO/index.html#type-input">BatIO.input</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-scanbuf">scanbuf</a></span></code></div><div class="spec-doc"><p><code>Scanning.from_input ic</code> returns a scanning buffer which reads from the input channel <code>ic</code>, starting at the current reading position.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-end_of_input" class="anchored"><a href="#val-end_of_input" class="anchor"></a><code><span><span class="keyword">val</span> end_of_input : <span><a href="#type-scanbuf">scanbuf</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>Scanning.end_of_input ib</code> tests the end-of-input condition of the given scanning buffer.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-beginning_of_input" class="anchored"><a href="#val-beginning_of_input" class="anchor"></a><code><span><span class="keyword">val</span> beginning_of_input : <span><a href="#type-scanbuf">scanbuf</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>Scanning.beginning_of_input ib</code> tests the beginning of input condition of the given scanning buffer.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-name_of_input" class="anchored"><a href="#val-name_of_input" class="anchor"></a><code><span><span class="keyword">val</span> name_of_input : <span><a href="#type-scanbuf">scanbuf</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>Scanning.name_of_input ib</code> returns the name of the character source for the scanning buffer <code>ib</code>.</p></div></div><h6 id="obsolete"><a href="#obsolete" class="anchor"></a>Obsolete</h6><div class="odoc-spec"><div class="spec value" id="val-from_channel" class="anchored"><a href="#val-from_channel" class="anchor"></a><code><span><span class="keyword">val</span> from_channel : <span><a href="../../BatIO/index.html#type-input">BatIO.input</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-scanbuf">scanbuf</a></span></code></div><div class="spec-doc"><p>@obsolete use <a href="#val-from_input"><code>from_input</code></a></p></div></div></div></body></html>