<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Fpath (b0.B00_std.Fpath)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../../index.html">b0</a> &#x00BB; <a href="../index.html">B00_std</a> &#x00BB; Fpath</nav><header class="odoc-preamble"><h1>Module <code><span>B00_std.Fpath</span></code></h1><p>File paths.</p><p>A file system <em>path</em> specifies a file or a directory in a file system hierarchy. It is made of three parts:</p><ol><li>An optional, platform-dependent, volume.</li><li>An optional root directory separator <code>dir_sep</code> whose presence distinguishes absolute paths (<code>&quot;/a&quot;</code>) from <em>relative</em> ones (<code>&quot;a&quot;</code>)</li><li>A non-empty list of <code>dir_sep</code> separated segments. <em>Segments</em> are non empty strings except for maybe the last one. The latter syntactically distinguishes <em>directory paths</em> (<code>&quot;a/b/&quot;</code>) from file paths (<code>&quot;a/b&quot;</code>).</li></ol><p>The paths segments <code>&quot;.&quot;</code> and <code>&quot;..&quot;</code> are relative path segments that respectively denote the current and parent directory. The <span class="xref-unresolved">basename</span> of a path is its last non-empty segment if it is not a relative path segment or the empty string otherwise (e.g. on <code>&quot;/&quot;</code> or <code>&quot;..&quot;</code>).</p></header><nav class="odoc-toc"><ul><li><a href="#segments">Separators and segments</a></li><li><a href="#paths">Paths</a></li><li><a href="#famous">Famous file paths</a></li><li><a href="#dirpaths">Directory paths</a></li><li><a href="#baseparent">Basename and parent directory</a></li><li><a href="#prefix">Strict prefixes and roots</a></li><li><a href="#preds">Predicates and comparison</a></li><li><a href="#file_exts">File extensions</a></li><li><a href="#converting">Converting</a></li><li><a href="#unique">Uniqueness</a></li><li><a href="#setmap">Paths map and sets</a></li><li><a href="#sorts">Sorts</a></li><li><a href="#sp">Search paths</a></li></ul></nav><div class="odoc-content"><h2 id="segments"><a href="#segments" class="anchor"></a>Separators and segments</h2><div class="odoc-spec"><div class="spec value" id="val-dir_sep_char" class="anchored"><a href="#val-dir_sep_char" class="anchor"></a><code><span><span class="keyword">val</span> dir_sep_char : char</span></code></div><div class="spec-doc"><p><code>dir_sep_char</code> is the platform dependent natural directory separator. This is / on POSIX and \ on Windows.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-dir_sep" class="anchored"><a href="#val-dir_sep" class="anchor"></a><code><span><span class="keyword">val</span> dir_sep : string</span></code></div><div class="spec-doc"><p><code>dir_sep</code> is <a href="#val-dir_sep_char"><code>dir_sep_char</code></a> as a string.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-has_dir_sep" class="anchored"><a href="#val-has_dir_sep" class="anchor"></a><code><span><span class="keyword">val</span> has_dir_sep : <span>string <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>has_dir_sep s</code> is <code>true</code> iff <code>s</code> contains <a href="#val-dir_sep_char"><code>dir_sep_char</code></a> (on Windows also if it contains <code>'/'</code>).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_seg" class="anchored"><a href="#val-is_seg" class="anchor"></a><code><span><span class="keyword">val</span> is_seg : <span>string <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_seg s</code> is <code>true</code> iff <code>s</code> does not contain a <a href="#val-dir_sep_char"><code>dir_sep_char</code></a> (on Windows also that it does not contain <code>'/'</code>) or a null byte.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_rel_seg" class="anchored"><a href="#val-is_rel_seg" class="anchor"></a><code><span><span class="keyword">val</span> is_rel_seg : <span>string <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_rel_seg s</code> is <code>true</code> iff <code>s</code> is a relative segment in other words either <code>&quot;.&quot;</code> or <code>&quot;..&quot;</code>.</p></div></div><h2 id="paths"><a href="#paths" class="anchor"></a>Paths</h2><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div><div class="spec-doc"><p>The type for paths</p></div></div><div class="odoc-spec"><div class="spec value" id="val-v" class="anchored"><a href="#val-v" class="anchor"></a><code><span><span class="keyword">val</span> v : <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>v s</code> is the string <code>s</code> as a path.</p><p><b>Warning.</b> In code only use <code>&quot;/&quot;</code> as the directory separator even on Windows platforms (don't be upset, the module gives them back to you with backslashes).</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if <code>s</code> is not a <span class="xref-unresolved">valid path</span>. Use <code>of_string</code> to deal with untrusted input.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-add_seg" class="anchored"><a href="#val-add_seg" class="anchor"></a><code><span><span class="keyword">val</span> add_seg : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>add_seg p seg</code> if <code>p</code>'s last segment is non-empty this is <code>p</code> with <code>seg</code> added. If <code>p</code>'s last segment is empty, this is <code>p</code> with the empty segment replaced by <code>seg</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if <code>is_seg seg</code> is <code>false</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-append" class="anchored"><a href="#val-append" class="anchor"></a><code><span><span class="keyword">val</span> append : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>append p q</code> appends <code>q</code> to <code>p</code> as follows:</p><ul><li>If <code>q</code> is <a href="#val-is_abs">absolute</a> or has a non-empty volume then <code>q</code> is returned.</li><li>Otherwise appends <code>q</code>'s segments to <code>p</code> using <a href="#val-add_seg"><code>add_seg</code></a>.</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-(/)" class="anchored"><a href="#val-(/)" class="anchor"></a><code><span><span class="keyword">val</span> (/) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>p / seg</code> is <code>add_seg p seg</code>. Left associative.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-(//)" class="anchored"><a href="#val-(//)" class="anchor"></a><code><span><span class="keyword">val</span> (//) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>p // p'</code> is <code>append p p'</code>. Left associative.</p></div></div><h2 id="famous"><a href="#famous" class="anchor"></a>Famous file paths</h2><div class="odoc-spec"><div class="spec value" id="val-null" class="anchored"><a href="#val-null" class="anchor"></a><code><span><span class="keyword">val</span> null : <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>null</code> represents a file on the OS that discards all writes and returns end of file on reads.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-dash" class="anchored"><a href="#val-dash" class="anchor"></a><code><span><span class="keyword">val</span> dash : <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>dash</code> is <code>&quot;-&quot;</code>. This value is used in cli interface to respectively denote standard input and output.</p></div></div><h2 id="dirpaths"><a href="#dirpaths" class="anchor"></a>Directory paths</h2><p><b>Note.</b> The following functions use syntactic semantic properties of paths. Given a path, these properties can be different from the ones your file system attributes to it.</p><div class="odoc-spec"><div class="spec value" id="val-is_dir_path" class="anchored"><a href="#val-is_dir_path" class="anchor"></a><code><span><span class="keyword">val</span> is_dir_path : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_dir_path p</code> is <code>true</code> iff <code>p</code> syntactically represents a directory. This means that <code>p</code> is <code>.</code>, <code>..</code> or ends with <code>/</code>, <code>/.</code> or <code>/..</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-add_dir_sep" class="anchored"><a href="#val-add_dir_sep" class="anchor"></a><code><span><span class="keyword">val</span> add_dir_sep : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>add_dir_sep p</code> is <code>add_seg p &quot;&quot;</code>. It ensures that the resulting path syntactically represents a <a href="#val-is_dir_path">directory</a> and thus, if converted to a string, that it ends with a <a href="#val-dir_sep"><code>dir_sep</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-strip_dir_sep" class="anchored"><a href="#val-strip_dir_sep" class="anchor"></a><code><span><span class="keyword">val</span> strip_dir_sep : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>strip_dir_sep p</code> is <code>p</code> without an existing last empty segment when <code>p</code> is not a root path, ensuring the result has no trailing <a href="#val-dir_sep"><code>dir_sep</code></a> when converted to a string.</p></div></div><h2 id="baseparent"><a href="#baseparent" class="anchor"></a>Basename and parent directory</h2><p><b>Note.</b> The following functions use syntactic semantic properties of paths. Given a path, these properties can be different from the ones your file system attributes to it.</p><div class="odoc-spec"><div class="spec value" id="val-basename" class="anchored"><a href="#val-basename" class="anchor"></a><code><span><span class="keyword">val</span> basename : <span>?no_ext:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>basename p</code> is the last non-empty segment of <code>p</code> or the empty string otherwise. The latter occurs only on root paths and on paths whose last non-empty segment is a <a href="#val-is_rel_seg">relative segment</a>. If <code>no_ext</code> is <code>true</code> (default to <code>false</code>) the basename's <a href="#file_exts">multiple extension</a>, if any, is removed from the result.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-parent" class="anchored"><a href="#val-parent" class="anchor"></a><code><span><span class="keyword">val</span> parent : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>parent p</code> is a <a href="#val-is_dir_path">directory path</a> that contains <code>p</code>. If <code>p</code> is a <a href="#val-is_root">root path</a> this is <code>p</code> itself. If <code>p</code> is in the current directory this is <code>./</code>.</p></div></div><h2 id="prefix"><a href="#prefix" class="anchor"></a>Strict prefixes and roots</h2><div class="odoc-spec"><div class="spec value" id="val-is_prefix" class="anchored"><a href="#val-is_prefix" class="anchor"></a><code><span><span class="keyword">val</span> is_prefix : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_prefix prefix p</code> is <code>true</code> iff <code>prefix</code> is a strict prefix of <code>p</code> that respects path segments. More formally iff the following two conditions hold:</p><ol><li><code>not Fpath.(equal (to_dir_path prefix) (to_dir_path p))</code></li><li><code>Fpath.(String.is_prefix (to_string (to_dir_path prefix)
         (to_string p)))</code> is <code>true</code></li></ol><p><b>Warning.</b> By definition <code>is_prefix p p</code> is <code>false</code>. Note also that the prefix relation does not entail directory containement; for example <code>is_prefix (v &quot;..&quot;)  (v &quot;../..&quot;)</code> holds.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-strip_prefix" class="anchored"><a href="#val-strip_prefix" class="anchor"></a><code><span><span class="keyword">val</span> strip_prefix : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> option</span></span></code></div><div class="spec-doc"><p><code>strip_prefix prefix p</code> is:</p><ul><li><code>None</code> if <a href="#val-is_prefix"><code>is_prefix</code></a><code> prefix p</code> is <code>false</code>.</li><li><code>Some q</code> otherwise where <code>q</code> is <code>p</code> without the string prefix <code>Fpath.to_dir_path prefix</code>. This means that <code>q</code> is always relative, that it preserves <code>p</code>'s <a href="#val-is_dir_path">directoryness</a> and that <code>Fpath.(equal (prefix
         // q) p)</code> holds.</li></ul><p><b>Warning.</b> By definition <code>strip_prefix p p</code> is <code>None</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-drop_prefixed" class="anchored"><a href="#val-drop_prefixed" class="anchor"></a><code><span><span class="keyword">val</span> drop_prefixed : <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> list</span></span></code></div><div class="spec-doc"><p><code>drop_prefixed ps</code> is <code>ps</code> without elements that have a <a href="#val-is_prefix">strict prefixes</a> in <code>ps</code>. The list order is preserved. Duplicates are not removed use <a href="#val-uniquify"><code>uniquify</code></a> for this.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-reroot" class="anchored"><a href="#val-reroot" class="anchor"></a><code><span><span class="keyword">val</span> reroot : <span>root:<a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>dst:<a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>reroot ~root ~dst p</code> assumes <code>root</code> <a href="#val-is_prefix">prefixes</a> <code>p</code> removes the prefix and prepends <code>dst</code> to the result.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if <code>root</code> is not a prefix of <code>src</code>. In particular note that <code>p</code> cannot be <code>root</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-relative" class="anchored"><a href="#val-relative" class="anchor"></a><code><span><span class="keyword">val</span> relative : <span>to_dir:<a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>relative to_dir p</code> is <code>q</code> such that <code>to_dir // q</code> represents the same path as <code>p</code>. Note that <code>q</code> is not necessarily relative: if <code>to_dir</code> is relative and <code>p</code> is absolute <code>p</code> is returned.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if path <code>to_dir</code> contains &quot;..&quot;.</p></li></ul></div></div><h2 id="preds"><a href="#preds" class="anchor"></a>Predicates and comparison</h2><div class="odoc-spec"><div class="spec value" id="val-is_rel" class="anchored"><a href="#val-is_rel" class="anchor"></a><code><span><span class="keyword">val</span> is_rel : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_rel p</code> is <code>true</code> iff <code>p</code> is a relative path, i.e. the root directory separator is missing in <code>p</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_abs" class="anchored"><a href="#val-is_abs" class="anchor"></a><code><span><span class="keyword">val</span> is_abs : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_abs p</code> is <code>true</code> iff <code>p</code> is an absolute path, i.e. the root directory separator is present in <code>p</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_root" class="anchored"><a href="#val-is_root" class="anchor"></a><code><span><span class="keyword">val</span> is_root : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_root p</code> is <code>true</code> iff <code>p</code> is a root directory, i.e. <code>p</code> has the root directory separator and a single, empty, segment.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_current_dir" class="anchored"><a href="#val-is_current_dir" class="anchor"></a><code><span><span class="keyword">val</span> is_current_dir : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_current_dir p</code> is <code>true</code> iff <code>p</code> is either <code>&quot;.&quot;</code> or <code>&quot;./&quot;</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_parent_dir" class="anchored"><a href="#val-is_parent_dir" class="anchor"></a><code><span><span class="keyword">val</span> is_parent_dir : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_parent_dir p</code> is <code>true</code> iff <code>p</code> is either <code>&quot;..&quot;</code> or <code>&quot;../&quot;</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-equal" class="anchored"><a href="#val-equal" class="anchor"></a><code><span><span class="keyword">val</span> equal : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>equal p0 p1</code> is true iff <code>p0</code> and <code>p1</code> are stringwise equal.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-equal_basename" class="anchored"><a href="#val-equal_basename" class="anchor"></a><code><span><span class="keyword">val</span> equal_basename : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>equal_basename p0 p1</code> is <code>String.equal (basename p0) (basename p1)</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-compare" class="anchored"><a href="#val-compare" class="anchor"></a><code><span><span class="keyword">val</span> compare : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>compare p0 p1</code> is a total order on paths compatible with <a href="#val-equal"><code>equal</code></a>.</p></div></div><h2 id="file_exts"><a href="#file_exts" class="anchor"></a>File extensions</h2><p>The <em>file extension</em> (resp. <em>multiple file extension</em>) of a path segment is the suffix that starts at the last (resp. first) occurence of a <code>'.'</code> that is preceeded by at least one non <code>'.'</code> character. If there is no such occurence in the segment, the extension is empty. With these definitions, <code>&quot;.&quot;</code>, <code>&quot;..&quot;</code>, <code>&quot;...&quot;</code> and dot files like <code>&quot;.ocamlinit&quot;</code> or <code>&quot;..ocamlinit&quot;</code> have no extension, but <code>&quot;.emacs.d&quot;</code> and <code>&quot;..emacs.d&quot;</code> do have one.</p><div class="odoc-spec"><div class="spec type" id="type-ext" class="anchored"><a href="#type-ext" class="anchor"></a><code><span><span class="keyword">type</span> ext</span><span> = string</span></code></div><div class="spec-doc"><p>The type for file extensions, <code>'.'</code> separator included.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_ext" class="anchored"><a href="#val-get_ext" class="anchor"></a><code><span><span class="keyword">val</span> get_ext : <span>?multi:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ext">ext</a></span></code></div><div class="spec-doc"><p><code>get_ext p</code> is <code>p</code>'s <a href="#val-basename">basename</a> file extension or the empty string if there is no extension. If <code>multi</code> is <code>true</code> (defaults to <code>false</code>), returns the multiple file extension.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-has_ext" class="anchored"><a href="#val-has_ext" class="anchor"></a><code><span><span class="keyword">val</span> has_ext : <span><a href="#type-ext">ext</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>has_ext ext p</code> is <code>true</code> iff <code>String.equal (get_ext p) e || String.equal (get_ext ~multi:true p) e</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mem_ext" class="anchored"><a href="#val-mem_ext" class="anchor"></a><code><span><span class="keyword">val</span> mem_ext : <span><span><a href="#type-ext">ext</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>mem_ext exts p</code> is <code>List.exists (fun e -&gt; has_ext e p) exts</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-add_ext" class="anchored"><a href="#val-add_ext" class="anchor"></a><code><span><span class="keyword">val</span> add_ext : <span><a href="#type-ext">ext</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>add_ext ext p</code> is <code>p</code> with <code>ext</code> concatenated to <code>p</code>'s <a href="#val-basename">basename</a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-strip_ext" class="anchored"><a href="#val-strip_ext" class="anchor"></a><code><span><span class="keyword">val</span> strip_ext : <span>?multi:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>strip_ext ?multi p</code> is <code>p</code> with the extension of <code>p</code>'s <a href="#val-basename">basename</a> removed. If <code>multi</code> is <code>true</code> (defaults to <code>false</code>), the multiple file extension is removed.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_ext" class="anchored"><a href="#val-set_ext" class="anchor"></a><code><span><span class="keyword">val</span> set_ext : <span>?multi:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-ext">ext</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>set_ext ?multi p</code> is <code>add_ext ext (strip_ext ?multi p)</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-cut_ext" class="anchored"><a href="#val-cut_ext" class="anchor"></a><code><span><span class="keyword">val</span> cut_ext : <span>?multi:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a> * <a href="#type-ext">ext</a></span></code></div><div class="spec-doc"><p><code>cut_ext ?multi p</code> is <code>(strip_ext ?multi p, get_ext ?multi p)</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-(+)" class="anchored"><a href="#val-(+)" class="anchor"></a><code><span><span class="keyword">val</span> (+) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-ext">ext</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>p + ext</code> is <code>add_ext p ext</code>. Left associative.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-(-+)" class="anchored"><a href="#val-(-+)" class="anchor"></a><code><span><span class="keyword">val</span> (-+) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-ext">ext</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>p -+ ext</code> is <code>set_ext p ext</code>. Left associative.</p></div></div><h2 id="converting"><a href="#converting" class="anchor"></a>Converting</h2><div class="odoc-spec"><div class="spec value" id="val-of_string" class="anchored"><a href="#val-of_string" class="anchor"></a><code><span><span class="keyword">val</span> of_string : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-t">t</a>, string)</span> <a href="../../../ocaml/Stdlib/index.html#type-result">result</a></span></span></code></div><div class="spec-doc"><p><code>of_string s</code> is the string <code>s</code> as a path. The following transformations are performed on the string:</p><ul><li>On Windows any / (<code>0x2F</code>) occurence is converted to \ (<code>0x5C</code>)</li><li>Non initial empty segments are suppressed; &quot;a//b&quot; becomes &quot;a/b&quot;, &quot;//a////b//&quot; becomes &quot;//a/b/&quot;, etc</li></ul><p>An error returned if <code>s</code> is <code>&quot;&quot;</code> or if it contains a null byte. The error string mentions <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_string" class="anchored"><a href="#val-to_string" class="anchor"></a><code><span><span class="keyword">val</span> to_string : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>to_string p</code> is the path <code>p</code> as a string. The result can be safely converted back with <a href="#val-v"><code>v</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_uri_path" class="anchored"><a href="#val-to_uri_path" class="anchor"></a><code><span><span class="keyword">val</span> to_uri_path : <span>?escape_space:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>to_uri_path p</code> is the path <code>p</code> as an URI path. This is <code>p</code> with the system specific <a href="#val-dir_sep_char"><code>dir_sep_char</code></a> directory separator replaced by <code>'/'</code> and with the following characters percent encoded: <code>'%'</code>, <code>'?'</code>, <code>'#'</code>, <code>' '</code> (unless <code>escape_space</code> is <code>false</code>, defaults to <code>true</code>), and the US-ASCII <a href="../Char/Ascii/index.html#val-is_control">control characters</a>.</p><p><b>Note.</b> In 2019, the standard definition of URIs is in a sorry state. Assuming <code>p</code> is UTF-8 encoded. It is <em>believed</em> the above function should lead to an URI path component that can be parsed by HTML5's <a href="https://dev.w3.org/html5/spec-LC/urls.html#parsing-urls">definition</a> of URI parsing.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_quoted" class="anchored"><a href="#val-pp_quoted" class="anchor"></a><code><span><span class="keyword">val</span> pp_quoted : <span><a href="#type-t">t</a> <a href="../Fmt/index.html#type-t">Fmt.t</a></span></span></code></div><div class="spec-doc"><p><code>pp_quoted ppf p</code> prints path <code>p</code> on <code>ppf</code> using <code>Filename</code>.quote.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_unquoted" class="anchored"><a href="#val-pp_unquoted" class="anchor"></a><code><span><span class="keyword">val</span> pp_unquoted : <span><a href="#type-t">t</a> <a href="../Fmt/index.html#type-t">Fmt.t</a></span></span></code></div><div class="spec-doc"><p><code>pp_unquoted p</code> prints path <code>p</code> on <code>ppf</code> using <a href="#val-to_string"><code>to_string</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_dump" class="anchored"><a href="#val-pp_dump" class="anchor"></a><code><span><span class="keyword">val</span> pp_dump : <span><a href="#type-t">t</a> <a href="../Fmt/index.html#type-t">Fmt.t</a></span></span></code></div><div class="spec-doc"><p><code>pp_dump ppf p</code> prints path <code>p</code> on <code>ppf</code> using <code>String</code>.dump.</p></div></div><h2 id="unique"><a href="#unique" class="anchor"></a>Uniqueness</h2><div class="odoc-spec"><div class="spec value" id="val-uniquify" class="anchored"><a href="#val-uniquify" class="anchor"></a><code><span><span class="keyword">val</span> uniquify : <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> list</span></span></code></div><div class="spec-doc"><p><code>uniquify ps</code> is <code>ps</code> without duplicates, the list order is preserved.</p></div></div><h2 id="setmap"><a href="#setmap" class="anchor"></a>Paths map and sets</h2><div class="odoc-spec"><div class="spec type" id="type-path" class="anchored"><a href="#type-path" class="anchor"></a><code><span><span class="keyword">type</span> path</span><span> = <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Set" class="anchored"><a href="#module-Set" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Set/index.html">Set</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Path sets.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Map" class="anchored"><a href="#module-Map" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Map/index.html">Map</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Path maps.</p></div></div><h2 id="sorts"><a href="#sorts" class="anchor"></a>Sorts</h2><div class="odoc-spec"><div class="spec value" id="val-sort_by_parent" class="anchored"><a href="#val-sort_by_parent" class="anchor"></a><code><span><span class="keyword">val</span> sort_by_parent : <span><a href="Set/index.html#type-t">Set.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="Set/index.html#type-t">Set.t</a> <a href="Map/index.html#type-t">Map.t</a></span></span></code></div><div class="spec-doc"><p><code>sort_by_parent ps</code> maps elements of <code>ps</code> by their <a href="#val-parent"><code>Fpath.parent</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sort_by_ext" class="anchored"><a href="#val-sort_by_ext" class="anchor"></a><code><span><span class="keyword">val</span> sort_by_ext : <span>?multi:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="Set/index.html#type-t">Set.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="Set/index.html#type-t">Set.t</a> <a href="../String/Map/index.html#type-t">String.Map.t</a></span></span></code></div><div class="spec-doc"><p><code>sort_by_ext ~multi ps</code> maps elements of <code>ps</code> by their extension as determined by <a href="#val-get_ext"><code>Fpath.get_ext</code></a><code> ~multi</code>.</p></div></div><h2 id="sp"><a href="#sp" class="anchor"></a>Search paths</h2><p>A <em>search path</em> is a list of paths separated by a designated separator. A well known search path is <code>PATH</code> in which executable binaries are looked up.</p><div class="odoc-spec"><div class="spec value" id="val-search_path_sep" class="anchored"><a href="#val-search_path_sep" class="anchor"></a><code><span><span class="keyword">val</span> search_path_sep : string</span></code></div><div class="spec-doc"><p><code>search_path_sep</code> is the default platform specific separator for search paths, this is <code>&quot;;&quot;</code> if <code>Sys</code>.win32 is <code>true</code> and <code>&quot;:&quot;</code> otherwise.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-list_of_search_path" class="anchored"><a href="#val-list_of_search_path" class="anchor"></a><code><span><span class="keyword">val</span> list_of_search_path : <span>?sep:string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><a href="#type-t">t</a> list</span>, string)</span> <a href="../../../ocaml/Stdlib/index.html#type-result">result</a></span></span></code></div><div class="spec-doc"><p><code>list_of_search_path ~sep s</code> parses <code>sep</code> separated file paths from <code>s</code>. <code>sep</code> is not allowed to appear in the file paths, it defaults to <a href="#val-search_path_sep"><code>search_path_sep</code></a>. The order in the list matches the order from left to right in <code>s</code>.</p></div></div></div></body></html>