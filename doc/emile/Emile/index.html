<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Emile (emile.Emile)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">emile</a> &#x00BB; Emile</nav><h1>Module <code>Emile</code></h1><p>Emile module, parser of e-mail address.</p><nav class="toc"><ul><li><a href="#pretty-printer">Pretty-printer</a></li><li><a href="#equal-&amp;-compare">Equal &amp; Compare</a></li><li><a href="#parsers">Parsers</a></li><li><a href="#decoders">Decoders</a></li></ul></nav></header><dl><dt class="spec type" id="type-raw"><a href="#type-raw" class="anchor"></a><code><span class="keyword">type</span> raw</code><code> = </code><table class="variant"><tr id="type-raw.Quoted_printable" class="anchored"><td class="def constructor"><a href="#type-raw.Quoted_printable" class="anchor"></a><code>| </code><code><span class="constructor">Quoted_printable</span> <span class="keyword">of</span> string</code></td></tr><tr id="type-raw.Base64" class="anchored"><td class="def constructor"><a href="#type-raw.Base64" class="anchor"></a><code>| </code><code><span class="constructor">Base64</span> <span class="keyword">of</span> [ `Dirty of string | `Clean of string | `Wrong_padding ]</code></td></tr></table></dt><dd><p>An e-mail address can contain as a part of a <a href="index.html#type-phrase"><code>phrase</code></a> (identifier) an encoded string. Standards describe 2 kinds of encoding:</p><ul><li>Quoted Printable: used to insert hexadecimal value with the <code>=</code> operator.</li><li>Base 64: string encoded in MIME's Base64</li></ul><p>Parser already decodes encoded <a href="index.html#type-raw"><code>raw</code></a>, the client can use it as is.</p></dd></dl><dl><dt class="spec type" id="type-word"><a href="#type-word" class="anchor"></a><code><span class="keyword">type</span> word</code> = <code>[ </code><table class="variant"><tr id="type-word.Atom" class="anchored"><td class="def constructor"><a href="#type-word.Atom" class="anchor"></a><code>| </code><code>`Atom <span class="keyword">of</span> string</code></td></tr><tr id="type-word.String" class="anchored"><td class="def constructor"><a href="#type-word.String" class="anchor"></a><code>| </code><code>`String <span class="keyword">of</span> string</code></td></tr></table><code> ]</code></dt><dd><p>The local part of an e-mail address is composed by two kinds of <i>word</i>s:</p><ul><li><code>`Atom</code> is string as is.</li><li><code>`String</code> is a string surrounded by double-quote to allow white-space.</li></ul><p>The second kind is sanitized — we deleted double-quote which surround <code>string</code>.</p></dd></dl><dl><dt class="spec type" id="type-local"><a href="#type-local" class="anchor"></a><code><span class="keyword">type</span> local</code><code> = <a href="index.html#type-word">word</a> list</code></dt><dd><p>Local part of e-mail address.</p></dd></dl><dl><dt class="spec type" id="type-addr"><a href="#type-addr" class="anchor"></a><code><span class="keyword">type</span> addr</code><code> = </code><table class="variant"><tr id="type-addr.IPv4" class="anchored"><td class="def constructor"><a href="#type-addr.IPv4" class="anchor"></a><code>| </code><code><span class="constructor">IPv4</span> <span class="keyword">of</span> <a href="../../ipaddr/Ipaddr/V4/index.html#type-t">Ipaddr.V4.t</a></code></td></tr><tr id="type-addr.IPv6" class="anchored"><td class="def constructor"><a href="#type-addr.IPv6" class="anchor"></a><code>| </code><code><span class="constructor">IPv6</span> <span class="keyword">of</span> <a href="../../ipaddr/Ipaddr/V6/index.html#type-t">Ipaddr.V6.t</a></code></td></tr><tr id="type-addr.Ext" class="anchored"><td class="def constructor"><a href="#type-addr.Ext" class="anchor"></a><code>| </code><code><span class="constructor">Ext</span> <span class="keyword">of</span> string * string</code></td></tr></table></dt><dd><p>Subset of domain described by RFC5321 which contains 3 kinds of address:</p><ul><li><code>IPv4</code>: a valid IPv4 address</li><li><code>IPv6</code>: a valid IPv6 address</li><li><code>Ext (ldh, value)</code>: an extended kind of domain recognized by <code>ldh</code> identifier which valus is <code>value</code></li></ul><p>Parser of <code>IPv4</code> and <code>IPv6</code> was done by <code>Ipaddr</code>. An extended kind <code>Ext</code> needs to be resolved by the client.</p></dd></dl><dl><dt class="spec type" id="type-domain"><a href="#type-domain" class="anchor"></a><code><span class="keyword">type</span> domain</code> = <code>[ </code><table class="variant"><tr id="type-domain.Domain" class="anchored"><td class="def constructor"><a href="#type-domain.Domain" class="anchor"></a><code>| </code><code>`Domain <span class="keyword">of</span> string list</code></td></tr><tr id="type-domain.Addr" class="anchored"><td class="def constructor"><a href="#type-domain.Addr" class="anchor"></a><code>| </code><code>`Addr <span class="keyword">of</span> <a href="index.html#type-addr">addr</a></code></td></tr><tr id="type-domain.Literal" class="anchored"><td class="def constructor"><a href="#type-domain.Literal" class="anchor"></a><code>| </code><code>`Literal <span class="keyword">of</span> string</code></td></tr></table><code> ]</code></dt><dd><p>Domain part of e-mail address. A domain integrate kinds from RFC5321 (see <a href="index.html#type-addr"><code>addr</code></a>), a domain described by RFC5322 and a <code>`Literal</code> which is the last <i>best-effort</i> value possible as a domain.</p><p><code>Emile</code> <b>does not</b> resolve domain.</p></dd></dl><dl><dt class="spec type" id="type-phrase"><a href="#type-phrase" class="anchor"></a><code><span class="keyword">type</span> phrase</code><code> = [ `Dot | `Word of <a href="index.html#type-word">word</a> | `Encoded of string * <a href="index.html#type-raw">raw</a> ] list</code></dt><dd><p>A phrase is a sentence to associate a name with an e-mail address or a group of e-mail addresses. <code>`Encoded</code> value <b>is not</b> normalized on the <i>charset</i> specified. The encoded's string is decoded as is only. For example, <code>`Encoded</code> can inform to use KOI-8 encoding (cyrillic charset). However, <code>Emile</code> does not check if value is a valid KOI-8 string, nor normalizes to unicode. <code>Emile</code> just decodes it as is.</p></dd></dl><dl><dt class="spec type" id="type-mailbox"><a href="#type-mailbox" class="anchor"></a><code><span class="keyword">type</span> mailbox</code><code> = </code><code>{</code><table class="record"><tr id="type-mailbox.name" class="anchored"><td class="def field"><a href="#type-mailbox.name" class="anchor"></a><code>name : <a href="index.html#type-phrase">phrase</a> option;</code></td></tr><tr id="type-mailbox.local" class="anchored"><td class="def field"><a href="#type-mailbox.local" class="anchor"></a><code>local : <a href="index.html#type-local">local</a>;</code></td></tr><tr id="type-mailbox.domain" class="anchored"><td class="def field"><a href="#type-mailbox.domain" class="anchor"></a><code>domain : <a href="index.html#type-domain">domain</a> * <a href="index.html#type-domain">domain</a> list;</code></td></tr></table><code>}</code></dt><dd><p>A mailbox is an e-mail address. It contains an optional name (see <a href="index.html#type-phrase"><code>phrase</code></a>), a local-part <code>see {!local</code></p><p>}</p><p>and one or more <a href="index.html#type-domain"><code>domain</code></a>(s).</p></dd></dl><dl><dt class="spec type" id="type-group"><a href="#type-group" class="anchor"></a><code><span class="keyword">type</span> group</code><code> = </code><code>{</code><table class="record"><tr id="type-group.group" class="anchored"><td class="def field"><a href="#type-group.group" class="anchor"></a><code>group : <a href="index.html#type-phrase">phrase</a>;</code></td></tr><tr id="type-group.mailboxes" class="anchored"><td class="def field"><a href="#type-group.mailboxes" class="anchor"></a><code>mailboxes : <a href="index.html#type-mailbox">mailbox</a> list;</code></td></tr></table><code>}</code></dt><dd><p>A group is a named set of <a href="index.html#type-mailbox"><code>mailbox</code></a>.</p></dd></dl><dl><dt class="spec type" id="type-address"><a href="#type-address" class="anchor"></a><code><span class="keyword">type</span> address</code><code> = <a href="index.html#type-local">local</a> * (<a href="index.html#type-domain">domain</a> * <a href="index.html#type-domain">domain</a> list)</code></dt><dd><p>A basic e-mail address.</p></dd></dl><dl><dt class="spec type" id="type-set"><a href="#type-set" class="anchor"></a><code><span class="keyword">type</span> set</code> = <code>[ </code><table class="variant"><tr id="type-set.Mailbox" class="anchored"><td class="def constructor"><a href="#type-set.Mailbox" class="anchor"></a><code>| </code><code>`Mailbox <span class="keyword">of</span> <a href="index.html#type-mailbox">mailbox</a></code></td></tr><tr id="type-set.Group" class="anchored"><td class="def constructor"><a href="#type-set.Group" class="anchor"></a><code>| </code><code>`Group <span class="keyword">of</span> <a href="index.html#type-group">group</a></code></td></tr></table><code> ]</code></dt><dd><p>The <i>Emile</i>'s set type which is a <i>singleton</i> (only one <a href="index.html#type-mailbox"><code>mailbox</code></a>) or a <i>set</i> of e-mail addresses (a <a href="index.html#type-group"><code>group</code></a>).</p></dd></dl><section><header><h3 id="pretty-printer"><a href="#pretty-printer" class="anchor"></a>Pretty-printer</h3></header><dl><dt class="spec value" id="val-pp_addr"><a href="#val-pp_addr" class="anchor"></a><code><span class="keyword">val</span> pp_addr : <a href="index.html#type-addr">addr</a> <a href="../../fmt/Fmt/index.html#type-t">Fmt.t</a></code></dt><dt class="spec value" id="val-pp_domain"><a href="#val-pp_domain" class="anchor"></a><code><span class="keyword">val</span> pp_domain : <a href="index.html#type-domain">domain</a> <a href="../../fmt/Fmt/index.html#type-t">Fmt.t</a></code></dt><dt class="spec value" id="val-pp_word"><a href="#val-pp_word" class="anchor"></a><code><span class="keyword">val</span> pp_word : <a href="index.html#type-word">word</a> <a href="../../fmt/Fmt/index.html#type-t">Fmt.t</a></code></dt><dt class="spec value" id="val-pp_local"><a href="#val-pp_local" class="anchor"></a><code><span class="keyword">val</span> pp_local : <a href="index.html#type-local">local</a> <a href="../../fmt/Fmt/index.html#type-t">Fmt.t</a></code></dt><dt class="spec value" id="val-pp_raw"><a href="#val-pp_raw" class="anchor"></a><code><span class="keyword">val</span> pp_raw : <a href="index.html#type-raw">raw</a> <a href="../../fmt/Fmt/index.html#type-t">Fmt.t</a></code></dt><dt class="spec value" id="val-pp_phrase"><a href="#val-pp_phrase" class="anchor"></a><code><span class="keyword">val</span> pp_phrase : <a href="index.html#type-phrase">phrase</a> <a href="../../fmt/Fmt/index.html#type-t">Fmt.t</a></code></dt><dt class="spec value" id="val-pp_mailbox"><a href="#val-pp_mailbox" class="anchor"></a><code><span class="keyword">val</span> pp_mailbox : <a href="index.html#type-mailbox">mailbox</a> <a href="../../fmt/Fmt/index.html#type-t">Fmt.t</a></code></dt><dt class="spec value" id="val-pp_group"><a href="#val-pp_group" class="anchor"></a><code><span class="keyword">val</span> pp_group : <a href="index.html#type-group">group</a> <a href="../../fmt/Fmt/index.html#type-t">Fmt.t</a></code></dt><dt class="spec value" id="val-pp_address"><a href="#val-pp_address" class="anchor"></a><code><span class="keyword">val</span> pp_address : <a href="index.html#type-address">address</a> <a href="../../fmt/Fmt/index.html#type-t">Fmt.t</a></code></dt><dt class="spec value" id="val-pp_set"><a href="#val-pp_set" class="anchor"></a><code><span class="keyword">val</span> pp_set : <a href="index.html#type-set">set</a> <a href="../../fmt/Fmt/index.html#type-t">Fmt.t</a></code></dt></dl></section><section><header><h3 id="equal-&amp;-compare"><a href="#equal-&amp;-compare" class="anchor"></a>Equal &amp; Compare</h3></header><dl><dt class="spec type" id="type-equal"><a href="#type-equal" class="anchor"></a><code><span class="keyword">type</span> 'a equal</code><code> = <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool</code></dt><dt class="spec type" id="type-compare"><a href="#type-compare" class="anchor"></a><code><span class="keyword">type</span> 'a compare</code><code> = <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int</code></dt></dl><dl><dt class="spec value" id="val-case_sensitive"><a href="#val-case_sensitive" class="anchor"></a><code><span class="keyword">val</span> case_sensitive : string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> int</code></dt><dd><p>Alias of <span class="xref-unresolved" title="unresolved reference to &quot;String.compare&quot;"><code>String</code>.compare</span>.</p></dd></dl><dl><dt class="spec value" id="val-case_insensitive"><a href="#val-case_insensitive" class="anchor"></a><code><span class="keyword">val</span> case_insensitive : string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> int</code></dt><dd><p><code>case_insensitive a b</code> maps values with <code>lowercase_ascii</code> and compare them with <span class="xref-unresolved" title="unresolved reference to &quot;String.compare&quot;"><code>String</code>.compare</span>. We <b>do not</b> map UTF8 value.</p></dd></dl><dl><dt class="spec value" id="val-equal_word"><a href="#val-equal_word" class="anchor"></a><code><span class="keyword">val</span> equal_word : compare:string <a href="index.html#type-compare">compare</a> <span>&#45;&gt;</span> <a href="index.html#type-word">word</a> <a href="index.html#type-equal">equal</a></code></dt><dd><p><code>equal ~compare a b</code> tests if <a href="index.html#type-word"><code>word</code></a> <code>a</code> and <a href="index.html#type-word"><code>word</code></a> <code>b</code> are semantically equal. <code>compare</code> specifies implementation to compare two <code>string</code> (i.e. to be case-sensitive or not).</p></dd></dl><dl><dt class="spec value" id="val-compare_word"><a href="#val-compare_word" class="anchor"></a><code><span class="keyword">val</span> compare_word : ?&#8288;case_sensitive:bool <span>&#45;&gt;</span> <a href="index.html#type-word">word</a> <a href="index.html#type-compare">compare</a></code></dt><dd><p><code>compare_word ?case_sensitive a b</code> compares <a href="index.html#type-word"><code>word</code></a> <code>a</code> and <a href="index.html#type-word"><code>word</code></a> <code>b</code> semantically. From standards, <a href="index.html#type-word"><code>word</code></a> SHOULD be case-sensitive, the client can notice this behaviour by <code>?case_sensitive</code> (default is <code>true</code>).</p></dd></dl><dl><dt class="spec value" id="val-equal_raw"><a href="#val-equal_raw" class="anchor"></a><code><span class="keyword">val</span> equal_raw : compare:string <a href="index.html#type-compare">compare</a> <span>&#45;&gt;</span> <a href="index.html#type-raw">raw</a> <a href="index.html#type-equal">equal</a></code></dt><dd><p><code>equal_raw a b</code> tests if <a href="index.html#type-raw"><code>raw</code></a> <code>a</code> and <a href="index.html#type-raw"><code>raw</code></a> <code>b</code> are semantically equal. <i>Semantically equal</i> means we compare raw's content, by this way, a <code>Base64</code> raw could be equal to a <code>Quoted_printable</code> raw if and only if <code>string</code> are equal.</p></dd></dl><dl><dt class="spec value" id="val-compare_raw"><a href="#val-compare_raw" class="anchor"></a><code><span class="keyword">val</span> compare_raw : compare:string <a href="index.html#type-compare">compare</a> <span>&#45;&gt;</span> <a href="index.html#type-raw">raw</a> <a href="index.html#type-compare">compare</a></code></dt><dd><p><code>compare_raw a b</code> compares <a href="index.html#type-raw"><code>raw</code></a> <code>a</code> and <a href="index.html#type-raw"><code>raw</code></a> <code>b</code> semantically.</p></dd></dl><dl><dt class="spec value" id="val-equal_phrase"><a href="#val-equal_phrase" class="anchor"></a><code><span class="keyword">val</span> equal_phrase : <a href="index.html#type-phrase">phrase</a> <a href="index.html#type-equal">equal</a></code></dt><dd><p><code>equal_phrase a b</code> tests if <a href="index.html#type-phrase"><code>phrase</code></a> <code>a</code> and <a href="index.html#type-phrase"><code>phrase</code></a> <code>b</code> are semantically equal. In this case, the comparison is case-insensitive between elements in <a href="index.html#type-phrase"><code>phrase</code></a>. The order of elements is important.</p></dd></dl><dl><dt class="spec value" id="val-compare_phrase"><a href="#val-compare_phrase" class="anchor"></a><code><span class="keyword">val</span> compare_phrase : <a href="index.html#type-phrase">phrase</a> <a href="index.html#type-compare">compare</a></code></dt><dd><p><code>compare_phrase a b</code> compares <a href="index.html#type-phrase"><code>phrase</code></a> <code>a</code> and <a href="index.html#type-phrase"><code>phrase</code></a> <code>b</code> semantically.</p></dd></dl><dl><dt class="spec value" id="val-equal_addr"><a href="#val-equal_addr" class="anchor"></a><code><span class="keyword">val</span> equal_addr : <a href="index.html#type-addr">addr</a> <a href="index.html#type-equal">equal</a></code></dt><dd><p><code>equal_addr a b</code> tests if <a href="index.html#type-addr"><code>addr</code></a> <code>a</code> and <a href="index.html#type-addr"><code>addr</code></a> <code>b</code> are semantically equal. An <code>IPv4</code> should be equal with an <code>IPv6</code> address. Then, for extended kind, we strictly compare (<span class="xref-unresolved" title="unresolved reference to &quot;Pervasives.compare&quot;"><code>Pervasives</code>.compare</span>) kind and value.</p></dd></dl><dl><dt class="spec value" id="val-compare_addr"><a href="#val-compare_addr" class="anchor"></a><code><span class="keyword">val</span> compare_addr : <a href="index.html#type-addr">addr</a> <a href="index.html#type-compare">compare</a></code></dt><dd><p><code>compare_addr a b</code> compares <a href="index.html#type-addr"><code>addr</code></a> <code>a</code> and <a href="index.html#type-addr"><code>addr</code></a> <code>b</code>, we prioritize <code>IPv6</code>, <code>IPv4</code> and finally <code>Ext</code>.</p></dd></dl><dl><dt class="spec value" id="val-equal_domain"><a href="#val-equal_domain" class="anchor"></a><code><span class="keyword">val</span> equal_domain : <a href="index.html#type-domain">domain</a> <a href="index.html#type-equal">equal</a></code></dt><dd><p><code>equal_addr a b</code> tests if <a href="index.html#type-domain"><code>domain</code></a> <code>a</code> and <a href="index.html#type-domain"><code>domain</code></a> <code>b</code> are semantically equal. We <b>do not</b> resolve domain, a <code>`Domain</code> could be semantically equal to another <code>`Domain</code> if they point to the same <code>IPv4</code>/<code>IPv6</code>.</p></dd></dl><dl><dt class="spec value" id="val-compare_domain"><a href="#val-compare_domain" class="anchor"></a><code><span class="keyword">val</span> compare_domain : <a href="index.html#type-domain">domain</a> <a href="index.html#type-compare">compare</a></code></dt><dd><p><code>comapre_domain a b</code> compares <a href="index.html#type-domain"><code>domain</code></a> <code>a</code> and <a href="index.html#type-domain"><code>domain</code></a> <code>b</code>, we prioritize <code>`Domain</code>, <code>`Literal</code> and finally <code>`Addr</code>. The comparison between two <code>`Literal</code> and between part of <code>`Domain</code> are case-insensitive.</p></dd></dl><dl><dt class="spec value" id="val-equal_domains"><a href="#val-equal_domains" class="anchor"></a><code><span class="keyword">val</span> equal_domains : (<a href="index.html#type-domain">domain</a> * <a href="index.html#type-domain">domain</a> list) <a href="index.html#type-equal">equal</a></code></dt><dd><p><code>equal_domains a b</code> apply <a href="index.html#val-equal_domain"><code>equal_domain</code></a> to ordered domains (see <a href="index.html#val-compare_domain"><code>compare_domain</code></a>) between <code>a</code> and <code>b</code>.</p></dd></dl><dl><dt class="spec value" id="val-compare_domains"><a href="#val-compare_domains" class="anchor"></a><code><span class="keyword">val</span> compare_domains : (<a href="index.html#type-domain">domain</a> * <a href="index.html#type-domain">domain</a> list) <a href="index.html#type-compare">compare</a></code></dt><dd><p><code>compare_domains a b</code> compares ordered list of <a href="index.html#type-domain"><code>domain</code></a> <code>a</code> and ordered list of <a href="index.html#type-domain"><code>domain</code></a> <code>b</code>.</p></dd></dl><dl><dt class="spec value" id="val-equal_local"><a href="#val-equal_local" class="anchor"></a><code><span class="keyword">val</span> equal_local : ?&#8288;case_sensitive:bool <span>&#45;&gt;</span> <a href="index.html#type-local">local</a> <a href="index.html#type-equal">equal</a></code></dt><dd><p><code>equal_local ?case_sensitive a b</code> tests if <a href="index.html#type-local"><code>local</code></a> <code>a</code> and <a href="index.html#type-local"><code>local</code></a> <code>b</code> are semantically equal. Standards notices local-part SHOULD be case-sensitive, the client can choose this behaviour with <code>case_sensitive</code>.</p></dd></dl><dl><dt class="spec value" id="val-compare_local"><a href="#val-compare_local" class="anchor"></a><code><span class="keyword">val</span> compare_local : ?&#8288;case_sensitive:bool <span>&#45;&gt;</span> <a href="index.html#type-local">local</a> <a href="index.html#type-compare">compare</a></code></dt><dd><p><code>compare_local ?case_sensitive a b</code> compares <a href="index.html#type-local"><code>local</code></a> <code>a</code> and <a href="index.html#type-local"><code>local</code></a> <code>b</code> semantically. The user can decide if the comparison is case-sensitive or not (with <code>case_sensitive</code>).</p></dd></dl><dl><dt class="spec value" id="val-equal_mailbox"><a href="#val-equal_mailbox" class="anchor"></a><code><span class="keyword">val</span> equal_mailbox : ?&#8288;case_sensitive:bool <span>&#45;&gt;</span> <a href="index.html#type-mailbox">mailbox</a> <a href="index.html#type-equal">equal</a></code></dt><dd><p><code>equal_mailbox ?case_sensitive a b</code> tests if <a href="index.html#type-mailbox"><code>mailbox</code></a> <code>a</code> and <a href="index.html#type-mailbox"><code>mailbox</code></a> <code>b</code> are semantically equal. The user can define if the local-part need to be case-sensitive or not (by <code>case_sensitive</code>). If <code>a</code> xor <code>b</code> has a name, we consider <code>a = b</code> if we have the same local-part and same domain(s). Otherwise, we compare identifier/<a href="index.html#type-phrase"><code>phrase</code></a> between them.</p></dd></dl><dl><dt class="spec value" id="val-compare_mailbox"><a href="#val-compare_mailbox" class="anchor"></a><code><span class="keyword">val</span> compare_mailbox : ?&#8288;case_sensitive:bool <span>&#45;&gt;</span> <a href="index.html#type-mailbox">mailbox</a> <a href="index.html#type-compare">compare</a></code></dt><dd><p><code>compare ?case_sensitive a b</code> compares <a href="index.html#type-mailbox"><code>mailbox</code></a> <code>a</code> and <code>mailbxo</code> <code>b</code> semantically. We prioritize local-part, domain-part and finally optionnal name.</p></dd></dl><dl><dt class="spec value" id="val-compare_group"><a href="#val-compare_group" class="anchor"></a><code><span class="keyword">val</span> compare_group : <a href="index.html#type-group">group</a> <a href="index.html#type-compare">compare</a></code></dt><dd><p><code>comapre_group a b</code> compares <a href="index.html#type-group"><code>group</code></a> <code>a</code> and <a href="index.html#type-group"><code>group</code></a> <code>b</code>. We compare the group name first and compare ordered <a href="index.html#type-mailbox"><code>mailbox</code></a>es list then.</p></dd></dl><dl><dt class="spec value" id="val-equal_group"><a href="#val-equal_group" class="anchor"></a><code><span class="keyword">val</span> equal_group : <a href="index.html#type-group">group</a> <a href="index.html#type-equal">equal</a></code></dt><dd><p><code>equal_group a b</code> tests if <a href="index.html#type-group"><code>group</code></a> <code>a</code> and <a href="index.html#type-group"><code>group</code></a> <code>b</code> are semantically equal. We compare first group name and ordered <a href="index.html#type-mailbox"><code>mailbox</code></a>es list then.</p></dd></dl><dl><dt class="spec value" id="val-compare_address"><a href="#val-compare_address" class="anchor"></a><code><span class="keyword">val</span> compare_address : <a href="index.html#type-address">address</a> <a href="index.html#type-compare">compare</a></code></dt><dd><p><code>compare_address a b</code> compares semantically <a href="index.html#type-address"><code>address</code></a> <code>a</code>* and <a href="index.html#type-address"><code>address</code></a> <code>b</code>.</p></dd></dl><dl><dt class="spec value" id="val-equal_address"><a href="#val-equal_address" class="anchor"></a><code><span class="keyword">val</span> equal_address : <a href="index.html#type-address">address</a> <a href="index.html#type-equal">equal</a></code></dt><dd><p><code>equal_address a b</code> tests semantically <a href="index.html#type-address"><code>address</code></a> <code>a</code> and <a href="index.html#type-address"><code>address</code></a> <code>b</code>.</p></dd></dl><dl><dt class="spec value" id="val-equal_set"><a href="#val-equal_set" class="anchor"></a><code><span class="keyword">val</span> equal_set : <a href="index.html#type-set">set</a> <a href="index.html#type-equal">equal</a></code></dt><dd><p><code>equal a b</code> tests semantically <a href="index.html#type-set"><code>set</code></a> <code>a</code> and <a href="index.html#type-set"><code>set</code></a> <code>b</code>.</p></dd></dl><dl><dt class="spec value" id="val-compare_set"><a href="#val-compare_set" class="anchor"></a><code><span class="keyword">val</span> compare_set : <a href="index.html#type-set">set</a> <a href="index.html#type-compare">compare</a></code></dt><dd><p><code>compare a b</code> compares <a href="index.html#type-set"><code>set</code></a> <code>a</code> and <a href="index.html#type-set"><code>set</code></a> <code>b</code>.</p></dd></dl><dl><dt class="spec value" id="val-strictly_equal_set"><a href="#val-strictly_equal_set" class="anchor"></a><code><span class="keyword">val</span> strictly_equal_set : <a href="index.html#type-set">set</a> <a href="index.html#type-equal">equal</a></code></dt><dd><p>A structurally equal function on <a href="index.html#type-set"><code>set</code></a>.</p></dd></dl></section><section><header><h3 id="parsers"><a href="#parsers" class="anchor"></a>Parsers</h3><p>If you don't want a headache, you should move on.</p></header><div class="spec module" id="module-Parser"><a href="#module-Parser" class="anchor"></a><code><span class="keyword">module</span> <a href="Parser/index.html">Parser</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section><section><header><h3 id="decoders"><a href="#decoders" class="anchor"></a>Decoders</h3><p>We have 4 kinds of parsers for e-mail address:</p><ul><li><p><code>List.of_string*</code> is the most general parser which used as the parser of <code>To:</code> field into an e-mail. Indeed, this value is a list of <a href="index.html#type-set"><code>set</code></a> which can contain only one e-mail address or a named group of e-mail addresses.</p><p>This parser is used into tests of <code>Emile</code>.</p></li><li><code>address_of_string*</code> is the parser of e-mail address like <code>local-part@domain</code>. This is the most common (in your mind) case for the client to parse an e-mail address. This parser does not handle a named e-mail address or a multiple domains e-mail address however.</li><li><code>set_of_string*</code> is the parser which performs a named group of e-mail addresses (<a href="index.html#type-group"><code>group</code></a>) or an optionaly named e-mail address (<a href="index.html#type-mailbox"><code>mailbox</code></a>). In constrast to <a href="index.html#val-address_of_string"><code>address_of_string</code></a>, this parser handles multiple domains e-mail address.</li><li><code>of_string*</code> is the most general unit parser of e-mail address. That means, this parser is like <a href="index.html#val-set_of_string"><code>set_of_string</code></a> <b>without</b> a named group of e-mail addresses. It handles named e-mail address and multiple domains e-mail address. The client should use this function if he does not know exactly the format of input.</li></ul><p>For each parser, you have the common <code>of_string</code> function, the <code>of_string_with_crlf</code> function and finally the <code>of_string_raw</code> function. The first one is the most easy to understand, it takes your string and try to extract an e-mail address (or a set or a list of set).</p><p>Then, the second is a more general parser. The delimiter of an e-mail address into an e-mail context is a double CRLF code (to stop the <i>folding whitespace</i> rule). Indeed, an e-mail can be encoded on multiple lines... So, <code>of_string</code> function is a special case of <code>of_string_with_crlf</code> where we put a double CRLF code at the end of your string to ensure to stop parser somewhere.</p><p>The final function, <code>of_string_raw</code> could be interesting client who wants to integrate <code>Emile</code> inside a parser. This function compute only a slice of your string and returns how many bytes it consumed to extract e-mail address. Internal stuff put CRLF code too to stop parser and uncount CRLF code when it returns how many byte(s) it consumed.</p><p>For client who wants to use <code>Emile</code> into an existing parser, your e-mail address should be delimited or surrounded by characters. For example, you can have an e-mail in this form: <code>&lt;local@domain&gt;</code>. In this example, e-mail address is surrounded by <code>&lt;</code> and <code>&gt;</code>. Your goal is to extract string inside them and use <a href="index.html#val-address_of_string"><code>address_of_string</code></a> which does not allow <code>&lt;</code> and <code>&gt;</code> into e-mail address.</p><p>In other case, your e-mail address can have this form: <code>John
   &lt;local@domain&gt;\n</code>. In this case, your e-mail address is delimited by <code>\n</code> and you should use <a href="index.html#val-of_string"><code>of_string</code></a> which will compute name (<code>John</code>) and associated e-mail address.</p><p>By these examples, extract an e-mail address is clearly not easy because it can take different forms and client needs to figure out what he clearly needs. Then, these parsers can fail for different non-obvious reasons - and, in this case, client needs to understand standards sadly to understand where is specially the problem.</p><p>In other way, if client is comfortable with <a href="../../angstrom/Angstrom/index.html"><code>Angstrom</code></a>, <code>Emile</code> provides indigestible parsers (see <a href="Parser/index.html"><code>Parser</code></a>).</p></header><dl><dt class="spec type" id="type-error"><a href="#type-error" class="anchor"></a><code><span class="keyword">type</span> error</code> = <code>[ </code><table class="variant"><tr id="type-error.Invalid" class="anchored"><td class="def constructor"><a href="#type-error.Invalid" class="anchor"></a><code>| </code><code>`Invalid <span class="keyword">of</span> string * string list</code></td></tr><tr id="type-error.Incomplete" class="anchored"><td class="def constructor"><a href="#type-error.Incomplete" class="anchor"></a><code>| </code><code>`Incomplete</code></td></tr></table><code> ]</code></dt></dl><dl><dt class="spec value" id="val-pp_error"><a href="#val-pp_error" class="anchor"></a><code><span class="keyword">val</span> pp_error : <a href="index.html#type-error">error</a> <a href="../../fmt/Fmt/index.html#type-t">Fmt.t</a></code></dt><dd><p><code>pp_error ppf err</code> prints an <a href="index.html#type-error"><code>error</code></a>.</p></dd></dl><div class="spec module" id="module-List"><a href="#module-List" class="anchor"></a><code><span class="keyword">module</span> <a href="List/index.html">List</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-address_of_string_with_crlf"><a href="#val-address_of_string_with_crlf" class="anchor"></a><code><span class="keyword">val</span> address_of_string_with_crlf : string <span>&#45;&gt;</span> (<a href="index.html#type-address">address</a>, <a href="index.html#type-error">error</a>) <a href="../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></code></dt><dt class="spec value" id="val-address_of_string"><a href="#val-address_of_string" class="anchor"></a><code><span class="keyword">val</span> address_of_string : string <span>&#45;&gt;</span> (<a href="index.html#type-address">address</a>, <a href="index.html#type-error">error</a>) <a href="../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></code></dt><dt class="spec value" id="val-address_of_string_raw"><a href="#val-address_of_string_raw" class="anchor"></a><code><span class="keyword">val</span> address_of_string_raw : string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> (<a href="index.html#type-address">address</a> * int, <a href="index.html#type-error">error</a>) <a href="../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></code></dt><dt class="spec value" id="val-set_of_string_with_crlf"><a href="#val-set_of_string_with_crlf" class="anchor"></a><code><span class="keyword">val</span> set_of_string_with_crlf : string <span>&#45;&gt;</span> (<a href="index.html#type-set">set</a>, <a href="index.html#type-error">error</a>) <a href="../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></code></dt><dt class="spec value" id="val-set_of_string"><a href="#val-set_of_string" class="anchor"></a><code><span class="keyword">val</span> set_of_string : string <span>&#45;&gt;</span> (<a href="index.html#type-set">set</a>, <a href="index.html#type-error">error</a>) <a href="../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></code></dt><dt class="spec value" id="val-set_of_string_raw"><a href="#val-set_of_string_raw" class="anchor"></a><code><span class="keyword">val</span> set_of_string_raw : string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> (<a href="index.html#type-set">set</a> * int, <a href="index.html#type-error">error</a>) <a href="../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></code></dt><dt class="spec value" id="val-of_string_with_crlf"><a href="#val-of_string_with_crlf" class="anchor"></a><code><span class="keyword">val</span> of_string_with_crlf : string <span>&#45;&gt;</span> (<a href="index.html#type-mailbox">mailbox</a>, <a href="index.html#type-error">error</a>) <a href="../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></code></dt><dt class="spec value" id="val-of_string"><a href="#val-of_string" class="anchor"></a><code><span class="keyword">val</span> of_string : string <span>&#45;&gt;</span> (<a href="index.html#type-mailbox">mailbox</a>, <a href="index.html#type-error">error</a>) <a href="../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></code></dt><dt class="spec value" id="val-of_string_raw"><a href="#val-of_string_raw" class="anchor"></a><code><span class="keyword">val</span> of_string_raw : string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> (<a href="index.html#type-mailbox">mailbox</a> * int, <a href="index.html#type-error">error</a>) <a href="../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></code></dt></dl></section></div></body></html>