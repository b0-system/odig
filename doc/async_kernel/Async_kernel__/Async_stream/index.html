<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Async_stream (async_kernel.Async_kernel__.Async_stream)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">async_kernel</a> &#x00BB; <a href="../index.html">Async_kernel__</a> &#x00BB; Async_stream</nav><h1>Module <code>Async_kernel__.Async_stream</code></h1></header><aside><p>An immutable sequence of values, with a possibly incomplete tail that may be extended asynchronously.</p><p>For most applications one should use <a href="../Pipe/index.html"><code>Pipe</code></a> instead of Stream. One justifiable usage of <code>Stream</code> rather than <code>Pipe</code> is in single-writer, multi-consumer (multicast) scenarios where pushback is not required.</p><p>The basic primitive operation for getting the next element out of stream is <code>Stream.next</code>, which (asynchronously) returns the element and the rest of the stream.</p></aside><div class="spec module" id="module-Deferred"><a href="#module-Deferred" class="anchor"></a><code><span class="keyword">module</span> Deferred = <a href="../index.html#module-Deferred1">Async_kernel__.Deferred1</a></code></div><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> 'a t</code><code> = <span class="type-var">'a</span> <a href="../../Async_kernel/Tail/Stream/index.html#type-t">Async_kernel.Tail.Stream.t</a></code></dt><dd><p><code>sexp_of_t t f</code> returns a sexp of all of the elements currently available in the stream. It is just for display purposes. There is no <code>t_of_sexp</code>.</p></dd></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></span></summary><dl><dt class="spec value" id="val-sexp_of_t"><a href="#val-sexp_of_t" class="anchor"></a><code><span class="keyword">val</span> sexp_of_t : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a></code></dt></dl></details></div></div></div><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : (<span class="type-var">'a</span> <a href="../../Async_kernel/Tail/index.html#type-t">Async_kernel.Tail.t</a> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>create f</code> returns a stream <code>t</code> and calls <code>f tail</code>, where the elements of the stream are determined as the tail is extended, and the end of the stream is reached when the tail is closed.</p></dd></dl><dl><dt class="spec type" id="type-next"><a href="#type-next" class="anchor"></a><code><span class="keyword">type</span> 'a next</code><code> = </code><table class="variant"><tr id="type-next.Nil" class="anchored"><td class="def constructor"><a href="#type-next.Nil" class="anchor"></a><code>| </code><code><span class="constructor">Nil</span></code></td></tr><tr id="type-next.Cons" class="anchored"><td class="def constructor"><a href="#type-next.Cons" class="anchor"></a><code>| </code><code><span class="constructor">Cons</span> <span class="keyword">of</span> <span class="type-var">'a</span> * <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></td></tr></table></dt><dd><p><code>next t</code> returns a deferred that will become determined when the next part of the stream is determined. This is <code>Cons (v, t')</code>, where v is the next element of the stream and t' is the rest of the stream, or with Nil at the end of the stream.</p></dd></dl><dl><dt class="spec value" id="val-next"><a href="#val-next" class="anchor"></a><code><span class="keyword">val</span> next : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-next">next</a> <a href="../Deferred1/index.html#type-t">Deferred.t</a></code></dt><dt class="spec value" id="val-first_exn"><a href="#val-first_exn" class="anchor"></a><code><span class="keyword">val</span> first_exn : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../Deferred1/index.html#type-t">Deferred.t</a></code></dt><dd><p><code>first_exn t</code> returns a deferred that becomes determined with the first element of <code>t</code>.</p></dd></dl><aside><p>Streams can be converted to and from lists. Although, conversion to a list returns a deferred, because the stream is determined asynchronously.</p></aside><dl><dt class="spec value" id="val-of_list"><a href="#val-of_list" class="anchor"></a><code><span class="keyword">val</span> of_list : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>of_list l</code> returns a stream with the elements of list l.</p></dd></dl><dl><dt class="spec value" id="val-to_list"><a href="#val-to_list" class="anchor"></a><code><span class="keyword">val</span> to_list : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <a href="../Deferred1/index.html#type-t">Deferred.t</a></code></dt><dd><p><code>to_list t</code> returns a deferred that will become determined with the list of elements in t, if the end of t is reached.</p></dd></dl><dl><dt class="spec value" id="val-of_fun"><a href="#val-of_fun" class="anchor"></a><code><span class="keyword">val</span> of_fun : (unit <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../Deferred1/index.html#type-t">Deferred.t</a>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>of_fun f</code> returns a stream whose elements are determined by calling <code>f</code> forever.</p></dd></dl><dl><dt class="spec value" id="val-copy_to_tail"><a href="#val-copy_to_tail" class="anchor"></a><code><span class="keyword">val</span> copy_to_tail : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../Async_kernel/Tail/index.html#type-t">Async_kernel.Tail.t</a> <span>&#45;&gt;</span> unit <a href="../Deferred1/index.html#type-t">Deferred.t</a></code></dt><dd><p><code>copy_to_tail t tail</code> reads elements from <code>t</code> and puts them in <code>tail</code>, until the end of <code>t</code> is reached.</p></dd></dl><aside><p>Sequence operations ---------------------------------------------------------------------- There are the usual sequence operations:</p><pre>      append, fold, iter, map, filter_map, take</pre><p>There are also deferred variants:</p><pre>      iter', map', filter_map'</pre><p>These take anonymous functions that return deferreds generalizing the usual sequence operation and allowing the client to control the rate at which the sequence is processed.</p></aside><dl><dt class="spec value" id="val-append"><a href="#val-append" class="anchor"></a><code><span class="keyword">val</span> append : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>append t1 t2</code> returns a stream with all the values of t1, in order, and if t1 ends, these values are followed by all the values of t2.</p></dd></dl><dl><dt class="spec value" id="val-concat"><a href="#val-concat" class="anchor"></a><code><span class="keyword">val</span> concat : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>concat t</code> takes a stream of streams and produces a stream that is the concatenation of each stream in order (you see all of stream 1, then all of stream 2... etc.)</p></dd></dl><dl><dt class="spec value" id="val-available_now"><a href="#val-available_now" class="anchor"></a><code><span class="keyword">val</span> available_now : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list * <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>available_now t</code> returns t prefix of t that is available now, along with the rest of the stream.</p></dd></dl><dl><dt class="spec value" id="val-filter_deprecated"><a href="#val-filter_deprecated" class="anchor"></a><code><span class="keyword">val</span> filter_deprecated : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>filter_deprecated s ~f</code> returns a stream with one element, v, for each v in s such with f v = true.</p><p>Using <code>filter_deprecated</code> can easily lead to space leaks. It is better to use <code>Async.Pipe</code> than <code>Async.Stream</code>.</p></dd></dl><dl><dt class="spec value" id="val-filter_map_deprecated"><a href="#val-filter_map_deprecated" class="anchor"></a><code><span class="keyword">val</span> filter_map_deprecated : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> option) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>filter_map_deprecated s ~f</code> returns a stream with one element, v', for each v in s such with f v = Some v'.</p><p>Using <code>filter_map_deprecated</code> can easily lead to space leaks. It is better to use <code>Async.Pipe</code> than <code>Async.Stream</code>.</p></dd></dl><dl><dt class="spec value" id="val-fold'"><a href="#val-fold'" class="anchor"></a><code><span class="keyword">val</span> fold' : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> init:<span class="type-var">'b</span> <span>&#45;&gt;</span> f:(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="../Deferred1/index.html#type-t">Deferred.t</a>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="../Deferred1/index.html#type-t">Deferred.t</a></code></dt><dd><p><code>fold' t ~init ~f</code> is like list fold, walking over the elements of the stream in order, as they become available. <code>fold'</code> returns a deferred that will yield the final value of the accumulator, if the end of the stream is reached.</p></dd></dl><dl><dt class="spec value" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span class="keyword">val</span> fold : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> init:<span class="type-var">'b</span> <span>&#45;&gt;</span> f:(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="../Deferred1/index.html#type-t">Deferred.t</a></code></dt><dd><p><code>fold t ~init ~f</code> is a variant of <code>fold'</code> in which <code>f</code> does not return a deferred.</p></dd></dl><dl><dt class="spec value" id="val-iter'"><a href="#val-iter'" class="anchor"></a><code><span class="keyword">val</span> iter' : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> unit <a href="../Deferred1/index.html#type-t">Deferred.t</a>) <span>&#45;&gt;</span> unit <a href="../Deferred1/index.html#type-t">Deferred.t</a></code></dt><dd><p><code>iter' t ~f</code> applies <code>f</code> to each element of the stream in turn, as they become available. It continues onto the next element only after the deferred returned by <code>f</code> becomes determined.</p></dd></dl><dl><dt class="spec value" id="val-closed"><a href="#val-closed" class="anchor"></a><code><span class="keyword">val</span> closed : <span class="type-var">_</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit <a href="../Deferred1/index.html#type-t">Deferred.t</a></code></dt><dd><p><code>closed t</code> returns a deferred that becomes determined when the end of <code>t</code> is reached.</p></dd></dl><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit</code></dt><dd><p><code>iter t ~f</code> = <code>don't_wait_for (iter' t ~f:(fun a -&gt; f a; return ()))</code></p></dd></dl><dl><dt class="spec value" id="val-take_until"><a href="#val-take_until" class="anchor"></a><code><span class="keyword">val</span> take_until : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit <a href="../Deferred1/index.html#type-t">Deferred.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>take_until t d</code> returns a stream <code>t'</code> that has the same elements as <code>t</code> up until <code>d</code> becomes determined.</p></dd></dl><dl><dt class="spec value" id="val-iter_durably'"><a href="#val-iter_durably'" class="anchor"></a><code><span class="keyword">val</span> iter_durably' : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> unit <a href="../Deferred1/index.html#type-t">Deferred.t</a>) <span>&#45;&gt;</span> unit <a href="../Deferred1/index.html#type-t">Deferred.t</a></code></dt><dd><p><code>iter_durably' t ~f</code> is like <code>iter' t ~f</code>, except if <code>f</code> raises an exception it continues with the next element of the stream *and* reraises the exception (to the monitor in scope when iter_durably was called).</p><p><code>iter_durably t ~f</code> is like <code>iter t ~f</code>, except if <code>f</code> raises an exception it continues with the next element of the stream *and* reraises the exception (to the monitor in scope when iter_durably was called).</p><p><code>iter_durably_report_end t ~f</code> is equivalent to <code>iter_durably' t ~f:(fun x -&gt; return
    (f x))</code> but it is more efficient</p></dd></dl><dl><dt class="spec value" id="val-iter_durably"><a href="#val-iter_durably" class="anchor"></a><code><span class="keyword">val</span> iter_durably : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-iter_durably_report_end"><a href="#val-iter_durably_report_end" class="anchor"></a><code><span class="keyword">val</span> iter_durably_report_end : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit <a href="../Deferred1/index.html#type-t">Deferred.t</a></code></dt><dt class="spec value" id="val-length"><a href="#val-length" class="anchor"></a><code><span class="keyword">val</span> length : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <a href="../Deferred1/index.html#type-t">Deferred.t</a></code></dt><dd><p><code>length s</code> returns a deferred that is determined when the end of s is reached, taking the value of the number of elements in s</p></dd></dl><dl><dt class="spec value" id="val-map'"><a href="#val-map'" class="anchor"></a><code><span class="keyword">val</span> map' : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="../Deferred1/index.html#type-t">Deferred.t</a>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>map' t f</code> creates a new stream that with one element, (f v), for each element v of t.</p></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>map t ~f</code> creates a new stream that with one element, (f v), for each element v of t. <code>map t f</code> = <code>map' t ~f:(fun a -&gt; return (f a))</code>.</p></dd></dl><dl><dt class="spec value" id="val-first_n"><a href="#val-first_n" class="anchor"></a><code><span class="keyword">val</span> first_n : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>first_n t n</code> returns a stream with the first n elements of t, if t has n or more elements, or it returns t.</p></dd></dl><aside><p>Stream generation ----------------------------------------------------------------------</p></aside><dl><dt class="spec value" id="val-unfold"><a href="#val-unfold" class="anchor"></a><code><span class="keyword">val</span> unfold : <span class="type-var">'b</span> <span>&#45;&gt;</span> f:(<span class="type-var">'b</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) option <a href="../Deferred1/index.html#type-t">Deferred.t</a>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>unfold b f</code> returns a stream <code>a1; a2; ...; an</code> whose elements are determined by the equations:</p><pre>      b0 = b
      Some (a1, b1) = f b0
      Some (a2, b2) = f b1
      ...
      None = f bn</pre></dd></dl><aside><p>Miscellaneous operations ----------------------------------------------------------------------</p></aside><dl><dt class="spec value" id="val-split"><a href="#val-split" class="anchor"></a><code><span class="keyword">val</span> split : ?&#8288;stop:unit <a href="../Deferred1/index.html#type-t">Deferred.t</a> <span>&#45;&gt;</span> ?&#8288;f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> [ `Continue | `Found of <span class="type-var">'b</span> ]) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> * [ `End_of_stream | `Stopped of <span class="type-var">'a</span> <a href="index.html#type-t">t</a> | `Found of <span class="type-var">'b</span> * <span class="type-var">'a</span> <a href="index.html#type-t">t</a> ] <a href="../Deferred1/index.html#type-t">Deferred.t</a></code></dt><dd><p><code>split ~stop ~f t</code> returns a pair <code>(p, d)</code>, where <code>p</code> is a prefix of <code>t</code> that ends for one of three reasons:</p><pre>      1. [t] ends
      2. stop becomes determined
      3. f returns `Found</pre><p>The deferred <code>d</code> describes why the prefix ended, and returns the suffix of the stream in case (2) or (3).</p></dd></dl><dl><dt class="spec value" id="val-find"><a href="#val-find" class="anchor"></a><code><span class="keyword">val</span> find : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> [ `End_of_stream | `Found of <span class="type-var">'a</span> * <span class="type-var">'a</span> <a href="index.html#type-t">t</a> ] <a href="../Deferred1/index.html#type-t">Deferred.t</a></code></dt><dd><p><code>find ~f t</code> returns a deferred that becomes determined when <code>f x</code> is true for some element of <code>t</code>, or if the end of the stream is reached</p></dd></dl><dl><dt class="spec value" id="val-ungroup"><a href="#val-ungroup" class="anchor"></a><code><span class="keyword">val</span> ungroup : <span class="type-var">'a</span> list <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>ungroup t</code> takes a stream of lists and unpacks the items from each list into a single stream</p></dd></dl><dl><dt class="spec value" id="val-interleave"><a href="#val-interleave" class="anchor"></a><code><span class="keyword">val</span> interleave : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>interleave list</code> takes a stream of streams and returns a stream of their items interleaved as they become determined. The interleaved stream will be closed when the outer stream and all of the inner streams have been closed.</p></dd></dl></div></body></html>