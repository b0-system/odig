<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>BatStream (batteries.BatStream)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../index.html">batteries</a> &#x00BB; BatStream</nav><header class="odoc-preamble"><h1>Module <code><span>BatStream</span></code></h1><p>Streams and stream parsers</p><p>Streams are a read-and-forget data structure, comparable to enumerations. In Batteries Included, streams are deprecated in favor of enumerations, defined in module <a href="../BatEnum/index.html"><code>BatEnum</code></a>.</p><p><b>Note</b> This module is provided essentially for backwards-compatibility. If you feel like using <code>Stream.t</code>, please take a look at <code>BatEnum</code> or <code>LazyList</code>.</p><p>This module is based on <a href="http://www.pps.jussieu.fr/~li/software/sdflow/">Zheng Li's SDFlow</a></p><p>This module replaces Stdlib's <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Stream.html">Stream</a> module.</p><ul class="at-tags"><li class="author"><span class="at-tag">author</span> Zheng Li (SDFlow)</li></ul><ul class="at-tags"><li class="author"><span class="at-tag">author</span> David Teller</li></ul><p>@documents Stream</p></header><nav class="odoc-toc"><ul><li><a href="#stream-builders">Stream builders</a></li><li><a href="#other-stream-builders">Other Stream builders</a></li><li><a href="#stream-iterator">Stream iterator</a></li><li><a href="#predefined-parsers">Predefined parsers</a></li><li><a href="#useful-functions">Useful functions</a></li><li><a href="#conversion-functions">Conversion functions</a></li><li><a href="#stream-consumers">Stream consumers</a></li><li><a href="#computation-over-stream">Computation over stream</a></li><li><a href="#streams-pair-arithmetic">Streams pair arithmetic</a></li><li><a href="#stream-arithmetic">Stream arithmetic</a></li><li><a href="#predefined-parsers_2">Predefined parsers</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a t</span></span><span> = <span><span class="type-var">'a</span> <a href="../../ocaml/Stdlib/Stream/index.html#type-t">Stream.t</a></span></span></code></div></div><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../BatEnum/module-type-Enumerable/index.html">BatEnum.Enumerable</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="../BatEnum/module-type-Enumerable/index.html#type-enumerable">enumerable</a></span> = <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></span></code></summary><div class="odoc-spec"><div class="spec type" id="type-enumerable" class="anchored"><a href="#type-enumerable" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a enumerable</span></span><span> = <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>The data structure, e.g. <code>'a List.t</code></p></div></div></details></div><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../BatInterfaces/module-type-Mappable/index.html">BatInterfaces.Mappable</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="../BatInterfaces/module-type-Mappable/index.html#type-mappable">mappable</a></span> = <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></span></code></summary><div class="odoc-spec"><div class="spec type" id="type-mappable" class="anchored"><a href="#type-mappable" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a mappable</span></span><span> = <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>The data structure, e.g. <code>'a List.t</code></p></div></div></details></div><p>The type of streams holding values of type <code>'a</code>.</p><div class="odoc-spec"><div class="spec exception" id="exception-Failure" class="anchored"><a href="#exception-Failure" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Failure</span></span></code></div><div class="spec-doc"><p>Raised by parsers when none of the first components of the stream patterns is accepted.</p></div></div><div class="odoc-spec"><div class="spec exception" id="exception-Error" class="anchored"><a href="#exception-Error" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Error</span> <span class="keyword">of</span> string</span></code></div><div class="spec-doc"><p>Raised by parsers when the first component of a stream pattern is accepted, but one of the following components is rejected.</p></div></div><h6 id="stream-builders"><a href="#stream-builders" class="anchor"></a>Stream builders</h6><div class="odoc-spec"><div class="spec value" id="val-from" class="anchored"><a href="#val-from" class="anchor"></a><code><span><span class="keyword">val</span> from : <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>Stream.from f</code> returns a stream built from the function <code>f</code>. To create a new stream element, the function <code>f</code> is called with the current stream count. The user function <code>f</code> must return either <code>Some &lt;value&gt;</code> for a value or <code>None</code> to specify the end of the stream.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_list" class="anchored"><a href="#val-of_list" class="anchor"></a><code><span><span class="keyword">val</span> of_list : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Return the stream holding the elements of the list in the same order.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_string" class="anchored"><a href="#val-of_string" class="anchor"></a><code><span><span class="keyword">val</span> of_string : <span>string <span class="arrow">&#45;&gt;</span></span> <span>char <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Return the stream of the characters of the string parameter.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_bytes" class="anchored"><a href="#val-of_bytes" class="anchor"></a><code><span><span class="keyword">val</span> of_bytes : <span><a href="../../ocaml/Stdlib/Bytes/index.html#type-t">Bytes.t</a> <span class="arrow">&#45;&gt;</span></span> <span>char <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Return the stream of the characters of the bytes parameter.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.3.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-of_channel" class="anchored"><a href="#val-of_channel" class="anchor"></a><code><span><span class="keyword">val</span> of_channel : <span><a href="../../ocaml/Stdlib/index.html#type-in_channel">in_channel</a> <span class="arrow">&#45;&gt;</span></span> <span>char <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Return the stream of the characters read from the input channel.</p></div></div><h6 id="other-stream-builders"><a href="#other-stream-builders" class="anchor"></a>Other Stream builders</h6><p>Warning: these functions create streams with fast access; it is illegal to mix them with streams built with <code>[&lt; &gt;]</code>; would raise <code>Failure</code> when accessing such mixed streams.</p><div class="odoc-spec"><div class="spec value" id="val-of_fun" class="anchored"><a href="#val-of_fun" class="anchor"></a><code><span><span class="keyword">val</span> of_fun : <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>Stream.of_fun f</code> returns a stream built from the function <code>f</code>. To create a new stream element, the function <code>f</code> is called with the current stream count. The user function <code>f</code> must return either <code>Some &lt;value&gt;</code> for a value or <code>None</code> to specify the end of the stream.</p></div></div><h6 id="stream-iterator"><a href="#stream-iterator" class="anchor"></a>Stream iterator</h6><div class="odoc-spec"><div class="spec value" id="val-iter" class="anchored"><a href="#val-iter" class="anchor"></a><code><span><span class="keyword">val</span> iter : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>Stream.iter f s</code> scans the whole stream s, applying function <code>f</code> in turn to each stream element encountered.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-foldl" class="anchored"><a href="#val-foldl" class="anchor"></a><code><span><span class="keyword">val</span> foldl : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> * <span>bool option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>foldl f init stream</code> is a lazy fold_left. <code>f accu elt</code> should return <code>(new_accu, state)</code> where <code>new_accu</code> is normal accumulation result, and <code>state</code> is a flag representing whether the computation should continue and whether the last operation is valid: <code>None</code> means continue, <code>Some b</code> means stop where <code>b = true</code> means the last addition is still valid and <code>b
    = false</code> means the last addition is invalid and should be revert.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-foldr" class="anchored"><a href="#val-foldr" class="anchor"></a><code><span><span class="keyword">val</span> foldr : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> lazy_t</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span></span></code></div><div class="spec-doc"><p><code>foldr f init stream</code> is a lazy fold_right. Unlike the normal fold_right, the accumulation parameter of <code>f elt accu</code> is lazy, hence it can decide not to force the evaluation of <code>accu</code> if the current element <code>elt</code> can determine the result by itself.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold" class="anchored"><a href="#val-fold" class="anchor"></a><code><span><span class="keyword">val</span> fold : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> * <span>bool option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>fold</code> is <code>foldl</code> without initialization value, where the first element of stream is taken as <code>init</code>. It raises <code>End_of_stream</code> exception when the input stream is empty.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-filter" class="anchored"><a href="#val-filter" class="anchor"></a><code><span><span class="keyword">val</span> filter : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>filter test stream</code> picks all the elements satisfying <code>test</code> from <code>stream</code> and return the results in the same order as a stream.</p></div></div><h6 id="predefined-parsers"><a href="#predefined-parsers" class="anchor"></a>Predefined parsers</h6><div class="odoc-spec"><div class="spec value" id="val-empty" class="anchored"><a href="#val-empty" class="anchor"></a><code><span><span class="keyword">val</span> empty : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Return <code>()</code> if the stream is empty, else raise <code>Stream.Failure</code>.</p></div></div><h6 id="useful-functions"><a href="#useful-functions" class="anchor"></a>Useful functions</h6><div class="odoc-spec"><div class="spec value" id="val-peek" class="anchored"><a href="#val-peek" class="anchor"></a><code><span><span class="keyword">val</span> peek : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div><div class="spec-doc"><p>Return <code>Some</code> of &quot;the first element&quot; of the stream, or <code>None</code> if the stream is empty.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-junk" class="anchored"><a href="#val-junk" class="anchor"></a><code><span><span class="keyword">val</span> junk : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Remove the first element of the stream, possibly unfreezing it before.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-count" class="anchored"><a href="#val-count" class="anchor"></a><code><span><span class="keyword">val</span> count : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Return the current count of the stream elements, i.e. the number of the stream elements discarded.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-npeek" class="anchored"><a href="#val-npeek" class="anchor"></a><code><span><span class="keyword">val</span> npeek : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>npeek n</code> returns the list of the <code>n</code> first elements of the stream, or all its remaining elements if less than <code>n</code> elements are available.</p></div></div><h6 id="conversion-functions"><a href="#conversion-functions" class="anchor"></a>Conversion functions</h6><div class="odoc-spec"><div class="spec value" id="val-enum" class="anchored"><a href="#val-enum" class="anchor"></a><code><span><span class="keyword">val</span> enum : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../BatEnum/index.html#type-t">BatEnum.t</a></span></span></code></div><div class="spec-doc"><p>Convert a stream to an enumeration. Reading the resulting enumeration will consume elements from the stream. This is the preferred manner of converting from a stream to any other data structure.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_enum" class="anchored"><a href="#val-of_enum" class="anchor"></a><code><span><span class="keyword">val</span> of_enum : <span><span><span class="type-var">'a</span> <a href="../BatEnum/index.html#type-t">BatEnum.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Convert an enumeration to a stream. Reading the resulting stream will consume elements from the enumeration. This is the preferred manner of creating a stream.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_input" class="anchored"><a href="#val-of_input" class="anchor"></a><code><span><span class="keyword">val</span> of_input : <span><a href="../BatIO/index.html#type-input">BatIO.input</a> <span class="arrow">&#45;&gt;</span></span> <span>char <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Convert an <code>input</code> to a stream.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_list" class="anchored"><a href="#val-to_list" class="anchor"></a><code><span><span class="keyword">val</span> to_list : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p>Convert a stream to a list</p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_string" class="anchored"><a href="#val-to_string" class="anchor"></a><code><span><span class="keyword">val</span> to_string : <span><span>char <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>convert stream of chars to string, using buffer</p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_string_fmt" class="anchored"><a href="#val-to_string_fmt" class="anchor"></a><code><span><span class="keyword">val</span> to_string_fmt : <span><span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> string, unit, string)</span> <a href="../../ocaml/Stdlib/index.html#type-format">format</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>convert stream to string, using Printf with given format</p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_string_fun" class="anchored"><a href="#val-to_string_fun" class="anchor"></a><code><span><span class="keyword">val</span> to_string_fun : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> string)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>convert stream to string, using given conversion function</p></div></div><h6 id="stream-consumers"><a href="#stream-consumers" class="anchor"></a>Stream consumers</h6><div class="odoc-spec"><div class="spec value" id="val-on_output" class="anchored"><a href="#val-on_output" class="anchor"></a><code><span><span class="keyword">val</span> on_output : <span><span><span class="type-var">'a</span> <a href="../BatIO/index.html#type-output">BatIO.output</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>char <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Convert an <code>output</code> to a stream.</p></div></div><h6 id="computation-over-stream"><a href="#computation-over-stream" class="anchor"></a>Computation over stream</h6><p>All the functions in this part are lazy.</p><div class="odoc-spec"><div class="spec value" id="val-map" class="anchored"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>map f stream</code> applies <code>f</code> in turn to elements from <code>stream</code> and return the results as a stream in the same order.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-map2" class="anchored"><a href="#val-map2" class="anchor"></a><code><span><span class="keyword">val</span> map2 : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>map2 f streama streamb</code> applies <code>f</code> in turn to elements of corresponding positions from <code>streama</code> and <code>streamb</code>. The results are constructed in the same order as a stream. If one stream is short, excess elements of the longer stream are ignored.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-scanl" class="anchored"><a href="#val-scanl" class="anchor"></a><code><span><span class="keyword">val</span> scanl : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>scanl f init stream</code> returns a stream of successive reduced values from the left: <code>scanl f init [&lt; 'e0; 'e1; ... &gt;]</code> is equivalent to <code>[&lt; 'init; '(f init e0); '(f (f init e0) e1); ... &gt;]</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-scan" class="anchored"><a href="#val-scan" class="anchor"></a><code><span><span class="keyword">val</span> scan : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>scan</code> is similar to <code>scanl</code> but without the <code>init</code> value: <code>scanl f init [&lt; 'e0; 'e1; 'e2; ... &gt;]</code> is equivalent to <code>[&lt; 'e0; '(f e0 e1); '(f (f e0 e1) e2); ... &gt;]</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-concat" class="anchored"><a href="#val-concat" class="anchor"></a><code><span><span class="keyword">val</span> concat : <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>concatenate a stream of streams</p></div></div><div class="odoc-spec"><div class="spec value" id="val-concat_map" class="anchored"><a href="#val-concat_map" class="anchor"></a><code><span><span class="keyword">val</span> concat_map : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Composition of <a href="#val-concat"><code>concat</code></a> and <a href="#val-map"><code>map</code></a>. <code>concat_map f e</code> is the same as <code>concat (map f e)</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.3.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-take" class="anchored"><a href="#val-take" class="anchor"></a><code><span><span class="keyword">val</span> take : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>take n stream</code> returns the prefix of <code>stream</code> of length <code>n</code>, or <code>stream</code> itself if <code>n</code> is greater than the length of <code>stream</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-drop" class="anchored"><a href="#val-drop" class="anchor"></a><code><span><span class="keyword">val</span> drop : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>drop n stream</code> returns the suffix of <code>stream</code> after the first <code>n</code> elements, or a empty stream if <code>n</code> is greater than the length of <code>stream</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-take_while" class="anchored"><a href="#val-take_while" class="anchor"></a><code><span><span class="keyword">val</span> take_while : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>take_while test stream</code> returns the longest (possibly empty) prefix of <code>stream</code> of elements that satisfy <code>test</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-drop_while" class="anchored"><a href="#val-drop_while" class="anchor"></a><code><span><span class="keyword">val</span> drop_while : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>drop_while test stream</code> returns the remaining suffix of <code>take_while test
    stream</code>.</p></div></div><h6 id="streams-pair-arithmetic"><a href="#streams-pair-arithmetic" class="anchor"></a>Streams pair arithmetic</h6><p>All the functions in this part are lazy.</p><div class="odoc-spec"><div class="spec value" id="val-dup" class="anchored"><a href="#val-dup" class="anchor"></a><code><span><span class="keyword">val</span> dup : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> * <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>dup stream</code> returns a pair of streams which are identical to <code>stream</code>. Note that stream is a destructive data structure, the point of <code>dup</code> is to return two streams can be used independently.</p><p>NOT IMPLEMENTED CORRECTLY - WILL RAISE Failure UNTIL CORRECT IMPLEMENTATION FOUND</p></div></div><div class="odoc-spec"><div class="spec value" id="val-comb" class="anchored"><a href="#val-comb" class="anchor"></a><code><span><span class="keyword">val</span> comb : <span><span>(<span><span class="type-var">'a</span> <a href="#type-t">t</a></span> * <span><span class="type-var">'b</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>comb</code> transform a pair of stream into a stream of pairs of corresponding elements. If one stream is short, excess elements of the longer stream are ignored.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-split" class="anchored"><a href="#val-split" class="anchor"></a><code><span><span class="keyword">val</span> split : <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> * <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>split</code> is the opposite of <code>comb</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-merge" class="anchored"><a href="#val-merge" class="anchor"></a><code><span><span class="keyword">val</span> merge : <span><span>(<span>bool <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <a href="#type-t">t</a></span> * <span><span class="type-var">'a</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>merge test (streama, streamb)</code> merge the elements from <code>streama</code> and <code>streamb</code> into a single stream. The <code>bool</code> type here represents the id of the two input streams where <code>true</code> is the first and <code>false</code> represents the second. The <code>test</code> function is applied to each element of the output stream together with the id of the input stream from which it was extracted, to decide which stream should the next element come from. The first element is always taken from <code>streama</code>. When a stream runs out of elements, the merge process will continue to take elements from the other stream until both streams reach their ends.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-switch" class="anchored"><a href="#val-switch" class="anchor"></a><code><span><span class="keyword">val</span> switch : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> * <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>switch test stream</code> split <code>stream</code> into two streams, where the first stream have all the elements satisfying <code>test</code>, the second stream is opposite. The order of elements in the source stream is preserved.</p></div></div><h6 id="stream-arithmetic"><a href="#stream-arithmetic" class="anchor"></a>Stream arithmetic</h6><p>All the functions in this part are lazy.</p><div class="odoc-spec"><div class="spec value" id="val-cons" class="anchored"><a href="#val-cons" class="anchor"></a><code><span><span class="keyword">val</span> cons : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>cons x stream</code> equals <code>[&lt;'x; stream&gt;]</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-apnd" class="anchored"><a href="#val-apnd" class="anchor"></a><code><span><span class="keyword">val</span> apnd : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>apnd fla flb</code> equals <code>[&lt;fla;flb&gt;]</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_empty" class="anchored"><a href="#val-is_empty" class="anchor"></a><code><span><span class="keyword">val</span> is_empty : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_empty stream</code> tests whether <code>stream</code> is empty. But note that it forces the evaluation of the head element if any.</p></div></div><h6 id="predefined-parsers_2"><a href="#predefined-parsers_2" class="anchor"></a>Predefined parsers</h6><div class="odoc-spec"><div class="spec value" id="val-next" class="anchored"><a href="#val-next" class="anchor"></a><code><span><span class="keyword">val</span> next : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Return the first element of the stream and remove it from the stream. </p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Stream.Failure</span> <p>if the stream is empty.</p></li></ul></div></div><div class="odoc-spec"><div class="spec module" id="module-StreamLabels" class="anchored"><a href="#module-StreamLabels" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="StreamLabels/index.html">StreamLabels</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p><b>Note</b> This module is provided essentially for backwards-compatibility. If you feel like using <code>Stream.t</code>, please take a look at <code>BatEnum</code> or <code>LazyList</code> and <code>GenParser</code>.</p></div></div></div></body></html>