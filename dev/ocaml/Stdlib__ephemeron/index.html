<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Stdlib__ephemeron (ocaml.Stdlib__ephemeron)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">ocaml</a> &#x00BB; Stdlib__ephemeron</nav><h1>Module <code>Stdlib__ephemeron</code></h1><p>Ephemerons and weak hash table</p></header><aside><p>Ephemerons and weak hash table are useful when one wants to cache or memorize the computation of a function, as long as the arguments and the function are used, without creating memory leaks by continuously keeping old computation results that are not useful anymore because one argument or the function is freed. An implementation using <span class="xref-unresolved" title="unresolved reference to &quot;Hashtbl.t&quot;"><code>Hashtbl</code>.t</span> is not suitable because all associations would keep in memory the arguments and the result.</p><p>Ephemerons can also be used for &quot;adding&quot; a field to an arbitrary boxed ocaml value: you can attach an information to a value created by an external library without memory leaks.</p><p>Ephemerons hold some keys and one or no data. They are all boxed ocaml values. The keys of an ephemeron have the same behavior than weak pointers according to the garbage collector. In fact ocaml weak pointers are implemented as ephemerons without data.</p><p>The keys and data of an ephemeron are said to be full if they point to a value, empty if the value have never been set, have been unset, or was erased by the GC. In the function that accesses the keys or data these two states are represented by the <code>option</code> type.</p><p>The data is considered by the garbage collector alive if all the full keys are alive and if the ephemeron is alive. When one of the keys is not considered alive anymore by the GC, the data is emptied from the ephemeron. The data could be alive for another reason and in that case the GC will not free it, but the ephemeron will not hold the data anymore.</p><p>The ephemerons complicate the notion of liveness of values, because it is not anymore an equivalence with the reachability from root value by usual pointers (not weak and not ephemerons). With ephemerons the notion of liveness is constructed by the least fixpoint of: A value is alive if:</p><ul><li>it is a root value</li><li>it is reachable from alive value by usual pointers</li><li>it is the data of an alive ephemeron with all its full keys alive</li></ul><p>Notes:</p><ul><li>All the types defined in this module cannot be marshaled using <a href="../Stdlib/index.html#val-output_value"><code>Stdlib.output_value</code></a> or the functions of the <code>Marshal</code> module.</li></ul><p>Ephemerons are defined in a language agnostic way in this paper: B. Hayes, Ephemerons: a New Finalization Mechanism, OOPSLA'9</p><dl><dt>since</dt><dd>4.03.0</dd></dl></aside><dl><dt class="spec module-type" id="module-type-S"><a href="#module-type-S" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-S/index.html">S</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The output signature of the functor <a href="K1/Make/index.html"><code>K1.Make</code></a> and <a href="K2/Make/index.html"><code>K2.Make</code></a>. These hash tables are weak in the keys. If all the keys of a binding are alive the binding is kept, but if one of the keys of the binding is dead then the binding is removed.</p></dd></dl><dl><dt class="spec module-type" id="module-type-SeededS"><a href="#module-type-SeededS" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-SeededS/index.html">SeededS</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The output signature of the functor <a href="K1/MakeSeeded/index.html"><code>K1.MakeSeeded</code></a> and <a href="K2/MakeSeeded/index.html"><code>K2.MakeSeeded</code></a>.</p></dd></dl><div class="spec module" id="module-K1"><a href="#module-K1" class="anchor"></a><code><span class="keyword">module</span> <a href="K1/index.html">K1</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-K2"><a href="#module-K2" class="anchor"></a><code><span class="keyword">module</span> <a href="K2/index.html">K2</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Kn"><a href="#module-Kn" class="anchor"></a><code><span class="keyword">module</span> <a href="Kn/index.html">Kn</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-GenHashTable"><a href="#module-GenHashTable" class="anchor"></a><code><span class="keyword">module</span> <a href="GenHashTable/index.html">GenHashTable</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></div></body></html>