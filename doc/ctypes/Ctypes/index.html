<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Ctypes (ctypes.Ctypes)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../index.html">ctypes</a> &#x00BB; Ctypes</nav><header class="odoc-preamble"><h1>Module <code><span>Ctypes</span></code></h1><p>The core ctypes module.</p><p>The main points of interest are the set of functions for describing C types (see <code>types</code>) and the set of functions for accessing C values (see <a href="#values">Values representing C values</a>). The <a href="../Foreign/index.html#val-foreign"><code>Foreign.foreign</code></a> function uses C type descriptions to bind external C values.</p></header><nav class="odoc-toc"><ul><li><a href="#pointer_types">Pointer types</a></li><li><a href="#c-compatible-pointers">C-compatible pointers</a></li><li><a href="#c-array-types">C array types</a></li><li><a href="#bigarray-types">Bigarray types</a></li><li><a href="#struct-and-union-types">Struct and union types</a></li><li><a href="#operations-on-types">Operations on types</a></li><li><a href="#values">Values representing C values</a><ul><li><a href="#pointer-values">Pointer values</a></li><li><a href="#array-values">Array values</a><ul><li><a href="#c-array-values">C array values</a></li><li><a href="#bigarray-values">Bigarray values</a></li></ul></li><li><a href="#struct-and-union-values">Struct and union values</a></li><li><a href="#coercions">Coercions</a></li></ul></li><li><a href="#binding-interfaces">binding interfaces</a></li><li><a href="#exceptions">Exceptions</a></li></ul></nav><div class="odoc-content"><h5 id="pointer_types"><a href="#pointer_types" class="anchor"></a>Pointer types</h5><div class="odoc-spec"><div class="spec type" id="type-pointer" class="anchored"><a href="#type-pointer" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 'b) pointer</span></span><span> = <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="../Ctypes_static/index.html#type-pointer">Ctypes_static.pointer</a></span></span></code></div><div class="spec-doc"><p>The type of pointer values. A value of type <code>('a, [`C]) pointer</code> contains a C-compatible pointer, and a value of type <code>('a, [`OCaml]) pointer</code> contains a pointer to a value that can be moved by OCaml runtime.</p></div></div><h5 id="c-compatible-pointers"><a href="#c-compatible-pointers" class="anchor"></a>C-compatible pointers</h5><div class="odoc-spec"><div class="spec type" id="type-ptr" class="anchored"><a href="#type-ptr" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a ptr</span></span><span> = <span><span>(<span class="type-var">'a</span>, <span>[ `C ]</span>)</span> <a href="#type-pointer">pointer</a></span></span></code></div><div class="spec-doc"><p>The type of C-compatible pointer values. A value of type <code>t ptr</code> can be used to read and write values of type <code>t</code> at particular addresses.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-ocaml" class="anchored"><a href="#type-ocaml" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a ocaml</span></span><span> = <span><span class="type-var">'a</span> <a href="../Ctypes_static/index.html#type-ocaml">Ctypes_static.ocaml</a></span></span></code></div><div class="spec-doc"><p>The type of pointer values pointing directly into OCaml values. <b>Pointers of this type should never be captured by external code</b>. In particular, functions accepting <code>'a ocaml</code> pointers must not invoke any OCaml code.</p></div></div><h5 id="c-array-types"><a href="#c-array-types" class="anchor"></a>C array types</h5><div class="odoc-spec"><div class="spec type" id="type-carray" class="anchored"><a href="#type-carray" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a carray</span></span><span> = <span><span class="type-var">'a</span> <a href="../Ctypes_static/index.html#type-carray">Ctypes_static.carray</a></span></span></code></div><div class="spec-doc"><p>The type of C array values. A value of type <code>t carray</code> can be used to read and write array objects in C-managed storage.</p></div></div><h5 id="bigarray-types"><a href="#bigarray-types" class="anchor"></a>Bigarray types</h5><div class="odoc-spec"><div class="spec type" id="type-bigarray_class" class="anchored"><a href="#type-bigarray_class" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a bigarray_class</span></span><span> = <span><span class="type-var">'a</span> <a href="../Ctypes_static/index.html#type-bigarray_class">Ctypes_static.bigarray_class</a></span></span></code></div><div class="spec-doc"><p>The type of Bigarray classes. There are four instances, one for each of the Bigarray submodules.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-genarray" class="anchored"><a href="#val-genarray" class="anchor"></a><code><span><span class="keyword">val</span> genarray : <span><span>&lt; element : <span class="type-var">'a</span>; layout : <span class="type-var">'l</span>; ba_repr : <span class="type-var">'b</span>; bigarray : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'l</span>)</span> <a href="../../bigarray-compat/Bigarray_compat/Genarray/index.html#type-t">Bigarray_compat.Genarray.t</a></span>; carray : <span><span class="type-var">'a</span> <a href="#type-carray">carray</a></span>; dims : <span>int array</span>; &gt;</span> <a href="#type-bigarray_class">bigarray_class</a></span></span></code></div><div class="spec-doc"><p>The class of <a href="../../ocaml/Bigarray/Genarray/index.html#type-t"><code>Bigarray.Genarray.t</code></a> values</p></div></div><div class="odoc-spec"><div class="spec value" id="val-array1" class="anchored"><a href="#val-array1" class="anchor"></a><code><span><span class="keyword">val</span> array1 : <span><span>&lt; element : <span class="type-var">'a</span>; layout : <span class="type-var">'l</span>; ba_repr : <span class="type-var">'b</span>; bigarray : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'l</span>)</span> <a href="../../bigarray-compat/Bigarray_compat/Array1/index.html#type-t">Bigarray_compat.Array1.t</a></span>; carray : <span><span class="type-var">'a</span> <a href="#type-carray">carray</a></span>; dims : int; &gt;</span> <a href="#type-bigarray_class">bigarray_class</a></span></span></code></div><div class="spec-doc"><p>The class of <a href="../../ocaml/Bigarray/Array1/index.html#type-t"><code>Bigarray.Array1.t</code></a> values</p></div></div><div class="odoc-spec"><div class="spec value" id="val-array2" class="anchored"><a href="#val-array2" class="anchor"></a><code><span><span class="keyword">val</span> array2 : <span><span>&lt; element : <span class="type-var">'a</span>; layout : <span class="type-var">'l</span>; ba_repr : <span class="type-var">'b</span>; bigarray : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'l</span>)</span> <a href="../../bigarray-compat/Bigarray_compat/Array2/index.html#type-t">Bigarray_compat.Array2.t</a></span>; carray : <span><span><span class="type-var">'a</span> <a href="#type-carray">carray</a></span> <a href="#type-carray">carray</a></span>; dims : int * int; &gt;</span> <a href="#type-bigarray_class">bigarray_class</a></span></span></code></div><div class="spec-doc"><p>The class of <a href="../../ocaml/Bigarray/Array2/index.html#type-t"><code>Bigarray.Array2.t</code></a> values</p></div></div><div class="odoc-spec"><div class="spec value" id="val-array3" class="anchored"><a href="#val-array3" class="anchor"></a><code><span><span class="keyword">val</span> array3 : <span><span>&lt; element : <span class="type-var">'a</span>; layout : <span class="type-var">'l</span>; ba_repr : <span class="type-var">'b</span>; bigarray : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'l</span>)</span> <a href="../../bigarray-compat/Bigarray_compat/Array3/index.html#type-t">Bigarray_compat.Array3.t</a></span>; carray : <span><span><span><span class="type-var">'a</span> <a href="#type-carray">carray</a></span> <a href="#type-carray">carray</a></span> <a href="#type-carray">carray</a></span>; dims : int * int * int; &gt;</span> <a href="#type-bigarray_class">bigarray_class</a></span></span></code></div><div class="spec-doc"><p>The class of <a href="../../ocaml/Bigarray/Array3/index.html#type-t"><code>Bigarray.Array3.t</code></a> values</p></div></div><h4 id="struct-and-union-types"><a href="#struct-and-union-types" class="anchor"></a>Struct and union types</h4><div class="odoc-spec"><div class="spec type" id="type-structured" class="anchored"><a href="#type-structured" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 'kind) structured</span></span><span> = <span><span>(<span class="type-var">'a</span>, <span class="type-var">'kind</span>)</span> <a href="../Ctypes_static/index.html#type-structured">Ctypes_static.structured</a></span></span></code></div><div class="spec-doc"><p>The base type of values representing C struct and union types. The <code>'kind</code> parameter is a polymorphic variant type indicating whether the type represents a struct (<code>`Struct</code>) or a union (<code>`Union</code>).</p></div></div><div class="odoc-spec"><div class="spec type" id="type-structure" class="anchored"><a href="#type-structure" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a structure</span></span><span> = <span><span>(<span class="type-var">'a</span>, <span>[ `Struct ]</span>)</span> <a href="#type-structured">structured</a></span></span></code></div><div class="spec-doc"><p>The type of values representing C struct types.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-union" class="anchored"><a href="#type-union" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a union</span></span><span> = <span><span>(<span class="type-var">'a</span>, <span>[ `Union ]</span>)</span> <a href="#type-structured">structured</a></span></span></code></div><div class="spec-doc"><p>The type of values representing C union types.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-field" class="anchored"><a href="#type-field" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 't) field</span></span><span> = <span><span>(<span class="type-var">'a</span>, <span class="type-var">'t</span>)</span> <a href="../Ctypes_static/index.html#type-field">Ctypes_static.field</a></span></span></code></div><div class="spec-doc"><p>The type of values representing C struct or union members (called &quot;fields&quot; here). A value of type <code>(a, s) field</code> represents a field of type <code>a</code> in a struct or union of type <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-abstract" class="anchored"><a href="#type-abstract" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a abstract</span></span><span> = <span><span class="type-var">'a</span> <a href="../Ctypes_static/index.html#type-abstract">Ctypes_static.abstract</a></span></span></code></div><div class="spec-doc"><p>The type of abstract values. The purpose of the <code>abstract</code> type is to represent values whose type varies from platform to platform.</p><p>For example, the type <code>pthread_t</code> is a pointer on some platforms, an integer on other platforms, and a struct on a third set of platforms. One way to deal with this kind of situation is to have possibly-platform-specific code which interrogates the C type in some way to help determine an appropriate representation. Another way is to use <code>abstract</code>, leaving the representation opaque.</p><p>(Note, however, that although <code>pthread_t</code> is a convenient example, since the type used to implement it varies significantly across platforms, it's not actually a good match for <code>abstract</code>, since values of type <code>pthread_t</code> are passed and returned by value.)</p></div></div><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../Ctypes_types/module-type-TYPE/index.html">Ctypes_types.TYPE</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="../Ctypes_types/module-type-TYPE/index.html#type-typ">typ</a></span> = <span><span class="type-var">'a</span> <a href="../Ctypes_static/index.html#type-typ">Ctypes_static.typ</a></span></span> <span class="keyword">and</span> <span><span class="keyword">type</span> <span>('a, 's) <a href="../Ctypes_types/module-type-TYPE/index.html#type-field">field</a></span> := <span><span>(<span class="type-var">'a</span>, <span class="type-var">'s</span>)</span> <a href="#type-field">field</a></span></span></span></code></summary><div class="odoc-spec"><div class="spec type" id="type-typ" class="anchored"><a href="#type-typ" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a typ</span></span><span> = <span><span class="type-var">'a</span> <a href="../Ctypes_static/index.html#type-typ">Ctypes_static.typ</a></span></span></code></div><div class="spec-doc"><p>The type of values representing C types. There are two types associated with each <code>typ</code> value: the C type used to store and pass values, and the corresponding OCaml type. The type parameter indicates the OCaml type, so a value of type <code>t typ</code> is used to read and write OCaml values of type <code>t</code>. There are various uses of <code>typ</code> values, including</p><ul><li>constructing function types for binding native functions using <a href="../Foreign/index.html#val-foreign"><code>Foreign.foreign</code></a></li></ul><ul><li>constructing pointers for reading and writing locations in C-managed storage using <a href="#val-ptr"><code>ptr</code></a></li></ul><ul><li>describing the fields of structured types built with <a href="#val-structure"><code>structure</code></a> and <a href="#val-union"><code>union</code></a>.</li></ul></div></div><h4 id="the-void-type"><a href="#the-void-type" class="anchor"></a>The void type</h4><div class="odoc-spec"><div class="spec value" id="val-void" class="anchored"><a href="#val-void" class="anchor"></a><code><span><span class="keyword">val</span> void : <span>unit <a href="#type-typ">typ</a></span></span></code></div><div class="spec-doc"><p>Value representing the C void type. Void values appear in OCaml as the unit type, so using void in an argument or result type specification produces a function which accepts or returns unit.</p><p>Dereferencing a pointer to void is an error, as in C, and will raise <a href="#exception-IncompleteType"><code>IncompleteType</code></a>.</p></div></div><h4 id="scalar-types"><a href="#scalar-types" class="anchor"></a>Scalar types</h4><p>The scalar types consist of the <a href="#arithmetic_types">Arithmetic types</a> and the <a href="#pointer_types">Pointer types</a>.</p><h5 id="arithmetic_types"><a href="#arithmetic_types" class="anchor"></a>Arithmetic types</h5><p>The arithmetic types consist of the signed and unsigned integer types (including character types) and the floating types. There are values representing both exact-width integer types (of 8, 16, 32 and 64 bits) and types whose size depend on the platform (signed and unsigned short, int, long, long long).</p><div class="odoc-spec"><div class="spec value" id="val-char" class="anchored"><a href="#val-char" class="anchor"></a><code><span><span class="keyword">val</span> char : <span>char <a href="#type-typ">typ</a></span></span></code></div><div class="spec-doc"><p>Value representing the C type <code>char</code>.</p></div></div><h6 id="signed-integer-types"><a href="#signed-integer-types" class="anchor"></a>Signed integer types</h6><div class="odoc-spec"><div class="spec value" id="val-schar" class="anchored"><a href="#val-schar" class="anchor"></a><code><span><span class="keyword">val</span> schar : <span>int <a href="#type-typ">typ</a></span></span></code></div><div class="spec-doc"><p>Value representing the C type <code>signed char</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-short" class="anchored"><a href="#val-short" class="anchor"></a><code><span><span class="keyword">val</span> short : <span>int <a href="#type-typ">typ</a></span></span></code></div><div class="spec-doc"><p>Value representing the C type (<code>signed</code>) <code>short</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-int" class="anchored"><a href="#val-int" class="anchor"></a><code><span><span class="keyword">val</span> int : <span>int <a href="#type-typ">typ</a></span></span></code></div><div class="spec-doc"><p>Value representing the C type (<code>signed</code>) <code>int</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-long" class="anchored"><a href="#val-long" class="anchor"></a><code><span><span class="keyword">val</span> long : <span><a href="../../integers/Signed/index.html#type-long">Signed.long</a> <a href="#type-typ">typ</a></span></span></code></div><div class="spec-doc"><p>Value representing the C type (<code>signed</code>) <code>long</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-llong" class="anchored"><a href="#val-llong" class="anchor"></a><code><span><span class="keyword">val</span> llong : <span><a href="../../integers/Signed/index.html#type-llong">Signed.llong</a> <a href="#type-typ">typ</a></span></span></code></div><div class="spec-doc"><p>Value representing the C type (<code>signed</code>) <code>long long</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-nativeint" class="anchored"><a href="#val-nativeint" class="anchor"></a><code><span><span class="keyword">val</span> nativeint : <span>nativeint <a href="#type-typ">typ</a></span></span></code></div><div class="spec-doc"><p>Value representing the C type (<code>signed</code>) <code>int</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-int8_t" class="anchored"><a href="#val-int8_t" class="anchor"></a><code><span><span class="keyword">val</span> int8_t : <span>int <a href="#type-typ">typ</a></span></span></code></div><div class="spec-doc"><p>Value representing an 8-bit signed integer C type.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-int16_t" class="anchored"><a href="#val-int16_t" class="anchor"></a><code><span><span class="keyword">val</span> int16_t : <span>int <a href="#type-typ">typ</a></span></span></code></div><div class="spec-doc"><p>Value representing a 16-bit signed integer C type.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-int32_t" class="anchored"><a href="#val-int32_t" class="anchor"></a><code><span><span class="keyword">val</span> int32_t : <span>int32 <a href="#type-typ">typ</a></span></span></code></div><div class="spec-doc"><p>Value representing a 32-bit signed integer C type.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-int64_t" class="anchored"><a href="#val-int64_t" class="anchor"></a><code><span><span class="keyword">val</span> int64_t : <span>int64 <a href="#type-typ">typ</a></span></span></code></div><div class="spec-doc"><p>Value representing a 64-bit signed integer C type.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Intptr" class="anchored"><a href="#module-Intptr" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Intptr/index.html">Intptr</a></span><span> : <a href="../../integers/Signed/module-type-S/index.html">Signed.S</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-intptr_t" class="anchored"><a href="#val-intptr_t" class="anchor"></a><code><span><span class="keyword">val</span> intptr_t : <span><a href="Intptr/index.html#type-t">Intptr.t</a> <a href="#type-typ">typ</a></span></span></code></div><div class="spec-doc"><p>Value representing the C type <code>intptr_t</code>.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Ptrdiff" class="anchored"><a href="#module-Ptrdiff" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Ptrdiff/index.html">Ptrdiff</a></span><span> : <a href="../../integers/Signed/module-type-S/index.html">Signed.S</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-ptrdiff_t" class="anchored"><a href="#val-ptrdiff_t" class="anchor"></a><code><span><span class="keyword">val</span> ptrdiff_t : <span><a href="Ptrdiff/index.html#type-t">Ptrdiff.t</a> <a href="#type-typ">typ</a></span></span></code></div><div class="spec-doc"><p>Value representing the C type <code>ptrdiff_t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-camlint" class="anchored"><a href="#val-camlint" class="anchor"></a><code><span><span class="keyword">val</span> camlint : <span>int <a href="#type-typ">typ</a></span></span></code></div><div class="spec-doc"><p>Value representing an integer type with the same storage requirements as an OCaml <code>int</code>.</p></div></div><h6 id="unsigned-integer-types"><a href="#unsigned-integer-types" class="anchor"></a>Unsigned integer types</h6><div class="odoc-spec"><div class="spec value" id="val-uchar" class="anchored"><a href="#val-uchar" class="anchor"></a><code><span><span class="keyword">val</span> uchar : <span><a href="../../integers/Unsigned/index.html#type-uchar">Unsigned.uchar</a> <a href="#type-typ">typ</a></span></span></code></div><div class="spec-doc"><p>Value representing the C type <code>unsigned char</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-bool" class="anchored"><a href="#val-bool" class="anchor"></a><code><span><span class="keyword">val</span> bool : <span>bool <a href="#type-typ">typ</a></span></span></code></div><div class="spec-doc"><p>Value representing the C type <code>bool</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-uint8_t" class="anchored"><a href="#val-uint8_t" class="anchor"></a><code><span><span class="keyword">val</span> uint8_t : <span><a href="../../integers/Unsigned/index.html#type-uint8">Unsigned.uint8</a> <a href="#type-typ">typ</a></span></span></code></div><div class="spec-doc"><p>Value representing an 8-bit unsigned integer C type.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-uint16_t" class="anchored"><a href="#val-uint16_t" class="anchor"></a><code><span><span class="keyword">val</span> uint16_t : <span><a href="../../integers/Unsigned/index.html#type-uint16">Unsigned.uint16</a> <a href="#type-typ">typ</a></span></span></code></div><div class="spec-doc"><p>Value representing a 16-bit unsigned integer C type.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-uint32_t" class="anchored"><a href="#val-uint32_t" class="anchor"></a><code><span><span class="keyword">val</span> uint32_t : <span><a href="../../integers/Unsigned/index.html#type-uint32">Unsigned.uint32</a> <a href="#type-typ">typ</a></span></span></code></div><div class="spec-doc"><p>Value representing a 32-bit unsigned integer C type.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-uint64_t" class="anchored"><a href="#val-uint64_t" class="anchor"></a><code><span><span class="keyword">val</span> uint64_t : <span><a href="../../integers/Unsigned/index.html#type-uint64">Unsigned.uint64</a> <a href="#type-typ">typ</a></span></span></code></div><div class="spec-doc"><p>Value representing a 64-bit unsigned integer C type.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-size_t" class="anchored"><a href="#val-size_t" class="anchor"></a><code><span><span class="keyword">val</span> size_t : <span><a href="../../integers/Unsigned/index.html#type-size_t">Unsigned.size_t</a> <a href="#type-typ">typ</a></span></span></code></div><div class="spec-doc"><p>Value representing the C type <code>size_t</code>, an alias for one of the unsigned integer types. The actual size and alignment requirements for <code>size_t</code> vary between platforms.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-ushort" class="anchored"><a href="#val-ushort" class="anchor"></a><code><span><span class="keyword">val</span> ushort : <span><a href="../../integers/Unsigned/index.html#type-ushort">Unsigned.ushort</a> <a href="#type-typ">typ</a></span></span></code></div><div class="spec-doc"><p>Value representing the C type <code>unsigned short</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sint" class="anchored"><a href="#val-sint" class="anchor"></a><code><span><span class="keyword">val</span> sint : <span><a href="../../integers/Signed/index.html#type-sint">Signed.sint</a> <a href="#type-typ">typ</a></span></span></code></div><div class="spec-doc"><p>Value representing the C type <code>int</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-uint" class="anchored"><a href="#val-uint" class="anchor"></a><code><span><span class="keyword">val</span> uint : <span><a href="../../integers/Unsigned/index.html#type-uint">Unsigned.uint</a> <a href="#type-typ">typ</a></span></span></code></div><div class="spec-doc"><p>Value representing the C type <code>unsigned int</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-ulong" class="anchored"><a href="#val-ulong" class="anchor"></a><code><span><span class="keyword">val</span> ulong : <span><a href="../../integers/Unsigned/index.html#type-ulong">Unsigned.ulong</a> <a href="#type-typ">typ</a></span></span></code></div><div class="spec-doc"><p>Value representing the C type <code>unsigned long</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-ullong" class="anchored"><a href="#val-ullong" class="anchor"></a><code><span><span class="keyword">val</span> ullong : <span><a href="../../integers/Unsigned/index.html#type-ullong">Unsigned.ullong</a> <a href="#type-typ">typ</a></span></span></code></div><div class="spec-doc"><p>Value representing the C type <code>unsigned long long</code>.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Uintptr" class="anchored"><a href="#module-Uintptr" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Uintptr/index.html">Uintptr</a></span><span> : <a href="../../integers/Unsigned/module-type-S/index.html">Unsigned.S</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-uintptr_t" class="anchored"><a href="#val-uintptr_t" class="anchor"></a><code><span><span class="keyword">val</span> uintptr_t : <span><a href="Uintptr/index.html#type-t">Uintptr.t</a> <a href="#type-typ">typ</a></span></span></code></div><div class="spec-doc"><p>Value representing the C type <code>uintptr_t</code>.</p></div></div><h6 id="floating-types"><a href="#floating-types" class="anchor"></a>Floating types</h6><div class="odoc-spec"><div class="spec value" id="val-float" class="anchored"><a href="#val-float" class="anchor"></a><code><span><span class="keyword">val</span> float : <span>float <a href="#type-typ">typ</a></span></span></code></div><div class="spec-doc"><p>Value representing the C single-precision <code>float</code> type.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-double" class="anchored"><a href="#val-double" class="anchor"></a><code><span><span class="keyword">val</span> double : <span>float <a href="#type-typ">typ</a></span></span></code></div><div class="spec-doc"><p>Value representing the C type <code>double</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-ldouble" class="anchored"><a href="#val-ldouble" class="anchor"></a><code><span><span class="keyword">val</span> ldouble : <span><a href="../LDouble/index.html#type-t">LDouble.t</a> <a href="#type-typ">typ</a></span></span></code></div><div class="spec-doc"><p>Value representing the C type <code>long double</code>.</p></div></div><h6 id="complex-types"><a href="#complex-types" class="anchor"></a>Complex types</h6><div class="odoc-spec"><div class="spec value" id="val-complex32" class="anchored"><a href="#val-complex32" class="anchor"></a><code><span><span class="keyword">val</span> complex32 : <span><a href="../../ocaml/Stdlib/Complex/index.html#type-t">Complex.t</a> <a href="#type-typ">typ</a></span></span></code></div><div class="spec-doc"><p>Value representing the C99 single-precision <code>float complex</code> type.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-complex64" class="anchored"><a href="#val-complex64" class="anchor"></a><code><span><span class="keyword">val</span> complex64 : <span><a href="../../ocaml/Stdlib/Complex/index.html#type-t">Complex.t</a> <a href="#type-typ">typ</a></span></span></code></div><div class="spec-doc"><p>Value representing the C99 double-precision <code>double complex</code> type.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-complexld" class="anchored"><a href="#val-complexld" class="anchor"></a><code><span><span class="keyword">val</span> complexld : <span><a href="../ComplexL/index.html#type-t">ComplexL.t</a> <a href="#type-typ">typ</a></span></span></code></div><div class="spec-doc"><p>Value representing the C99 long-double-precision <code>long double complex</code> type.</p></div></div><h5 id="pointer_types_2"><a href="#pointer_types_2" class="anchor"></a>Pointer types</h5><h6 id="c-compatible-pointers_2"><a href="#c-compatible-pointers_2" class="anchor"></a>C-compatible pointers</h6><div class="odoc-spec"><div class="spec value" id="val-ptr" class="anchored"><a href="#val-ptr" class="anchor"></a><code><span><span class="keyword">val</span> ptr : <span><span><span class="type-var">'a</span> <a href="#type-typ">typ</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="../Ctypes_static/index.html#type-ptr">Ctypes_static.ptr</a></span> <a href="#type-typ">typ</a></span></span></code></div><div class="spec-doc"><p>Construct a pointer type from an existing type (called the <i>reference type</i>).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-ptr_opt" class="anchored"><a href="#val-ptr_opt" class="anchor"></a><code><span><span class="keyword">val</span> ptr_opt : <span><span><span class="type-var">'a</span> <a href="#type-typ">typ</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span><span class="type-var">'a</span> <a href="../Ctypes_static/index.html#type-ptr">Ctypes_static.ptr</a></span> option</span> <a href="#type-typ">typ</a></span></span></code></div><div class="spec-doc"><p>Construct a pointer type from an existing type (called the <i>reference type</i>). This behaves like <a href="#val-ptr"><code>ptr</code></a>, except that null pointers appear in OCaml as <code>None</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-string" class="anchored"><a href="#val-string" class="anchor"></a><code><span><span class="keyword">val</span> string : <span>string <a href="#type-typ">typ</a></span></span></code></div><div class="spec-doc"><p>A high-level representation of the string type.</p><p>On the C side this behaves like <code>char *</code>; on the OCaml side values read and written using <a href="#val-string"><code>string</code></a> are simply native OCaml strings.</p><p>To avoid problems with the garbage collector, values passed using <a href="#val-string"><code>string</code></a> are copied into immovable C-managed storage before being passed to C.</p><p>When the memory is not owned by the C code, -- i.e. when creating or initializing a struct in OCaml before passing it to C -- then the <a href="#val-string"><code>string</code></a> view isn't a good choice, because there's no way to manage the lifetime of the C copy of the generated OCaml string.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-string_opt" class="anchored"><a href="#val-string_opt" class="anchor"></a><code><span><span class="keyword">val</span> string_opt : <span><span>string option</span> <a href="#type-typ">typ</a></span></span></code></div><div class="spec-doc"><p>A high-level representation of the string type. This behaves like <a href="#val-string"><code>string</code></a>, except that null pointers appear in OCaml as <code>None</code>.</p></div></div><h6 id="ocaml-pointers"><a href="#ocaml-pointers" class="anchor"></a>OCaml pointers</h6><div class="odoc-spec"><div class="spec value" id="val-ocaml_string" class="anchored"><a href="#val-ocaml_string" class="anchor"></a><code><span><span class="keyword">val</span> ocaml_string : <span><span>string <a href="../Ctypes_static/index.html#type-ocaml">Ctypes_static.ocaml</a></span> <a href="#type-typ">typ</a></span></span></code></div><div class="spec-doc"><p>Value representing the directly mapped storage of an OCaml string.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-ocaml_bytes" class="anchored"><a href="#val-ocaml_bytes" class="anchor"></a><code><span><span class="keyword">val</span> ocaml_bytes : <span><span>bytes <a href="../Ctypes_static/index.html#type-ocaml">Ctypes_static.ocaml</a></span> <a href="#type-typ">typ</a></span></span></code></div><div class="spec-doc"><p>Value representing the directly mapped storage of an OCaml byte array.</p></div></div><h4 id="array-types"><a href="#array-types" class="anchor"></a>Array types</h4><h5 id="c-array-types_2"><a href="#c-array-types_2" class="anchor"></a>C array types</h5><div class="odoc-spec"><div class="spec value" id="val-array" class="anchored"><a href="#val-array" class="anchor"></a><code><span><span class="keyword">val</span> array : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-typ">typ</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="../Ctypes_static/index.html#type-carray">Ctypes_static.carray</a></span> <a href="#type-typ">typ</a></span></span></code></div><div class="spec-doc"><p>Construct a sized array type from a length and an existing type (called the <i>element type</i>).</p></div></div><h5 id="bigarray-types_2"><a href="#bigarray-types_2" class="anchor"></a>Bigarray types</h5><div class="odoc-spec"><div class="spec value" id="val-bigarray" class="anchored"><a href="#val-bigarray" class="anchor"></a><code><span><span class="keyword">val</span> bigarray : <span><span><span>&lt; element : <span class="type-var">'a</span>; layout : <a href="../../bigarray-compat/Bigarray_compat/index.html#type-c_layout">Bigarray_compat.c_layout</a>; ba_repr : <span class="type-var">'b</span>; dims : <span class="type-var">'dims</span>; bigarray : <span class="type-var">'bigarray</span>; carray : <span class="type-var">_</span>; &gt;</span> <a href="../Ctypes_static/index.html#type-bigarray_class">Ctypes_static.bigarray_class</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'dims</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="../../bigarray-compat/Bigarray_compat/index.html#type-kind">Bigarray_compat.kind</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'bigarray</span> <a href="#type-typ">typ</a></span></span></code></div><div class="spec-doc"><p>Construct a sized C-layout bigarray type representation from a bigarray class, the dimensions, and the <a href="../../bigarray-compat/Bigarray_compat/index.html#type-kind"><code>Bigarray_compat.kind</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fortran_bigarray" class="anchored"><a href="#val-fortran_bigarray" class="anchor"></a><code><span><span class="keyword">val</span> fortran_bigarray : <span><span><span>&lt; element : <span class="type-var">'a</span>; layout : <a href="../../bigarray-compat/Bigarray_compat/index.html#type-fortran_layout">Bigarray_compat.fortran_layout</a>; ba_repr : <span class="type-var">'b</span>; dims : <span class="type-var">'dims</span>; bigarray : <span class="type-var">'bigarray</span>; carray : <span class="type-var">_</span>; &gt;</span> <a href="../Ctypes_static/index.html#type-bigarray_class">Ctypes_static.bigarray_class</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'dims</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="../../bigarray-compat/Bigarray_compat/index.html#type-kind">Bigarray_compat.kind</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'bigarray</span> <a href="#type-typ">typ</a></span></span></code></div><div class="spec-doc"><p>Construct a sized Fortran-layout bigarray type representation from a bigarray class, the dimensions, and the <a href="../../bigarray-compat/Bigarray_compat/index.html#type-kind"><code>Bigarray_compat.kind</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-typ_of_bigarray_kind" class="anchored"><a href="#val-typ_of_bigarray_kind" class="anchor"></a><code><span><span class="keyword">val</span> typ_of_bigarray_kind : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="../../bigarray-compat/Bigarray_compat/index.html#type-kind">Bigarray_compat.kind</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-typ">typ</a></span></span></code></div><div class="spec-doc"><p><code>typ_of_bigarray_kind k</code> is the type corresponding to the Bigarray kind <code>k</code>.</p></div></div><h4 id="struct-and-union-types_2"><a href="#struct-and-union-types_2" class="anchor"></a>Struct and union types</h4><div class="odoc-spec"><div class="spec value" id="val-structure" class="anchored"><a href="#val-structure" class="anchor"></a><code><span><span class="keyword">val</span> structure : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'s</span> <a href="../Ctypes_static/index.html#type-structure">Ctypes_static.structure</a></span> <a href="#type-typ">typ</a></span></span></code></div><div class="spec-doc"><p>Construct a new structure type. The type value returned is incomplete and can be updated using <a href="#val-field"><code>field</code></a> until it is passed to <a href="#val-seal"><code>seal</code></a>, at which point the set of fields is fixed.</p><p>The type (<code>'_s structure typ</code>) of the expression returned by the call <code>structure tag</code> includes a weak type variable, which can be explicitly instantiated to ensure that the OCaml values representing different C structure types have incompatible types. Typical usage is as follows:</p><p><code>type tagname</code></p><p><code>let tagname : tagname structure typ = structure &quot;tagname&quot;</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-union" class="anchored"><a href="#val-union" class="anchor"></a><code><span><span class="keyword">val</span> union : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'s</span> <a href="../Ctypes_static/index.html#type-union">Ctypes_static.union</a></span> <a href="#type-typ">typ</a></span></span></code></div><div class="spec-doc"><p>Construct a new union type. This behaves analogously to <a href="#val-structure"><code>structure</code></a>; fields are added with <a href="#val-field"><code>field</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-field" class="anchored"><a href="#val-field" class="anchor"></a><code><span><span class="keyword">val</span> field : <span><span><span class="type-var">'t</span> <a href="#type-typ">typ</a></span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-typ">typ</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span><span>(<span class="type-var">'s</span>, <span>[&lt; `Struct <span>| `Union</span> ]</span>)</span> <a href="../Ctypes_static/index.html#type-structured">Ctypes_static.structured</a></span> <span class="keyword">as</span> 't)</span> <a href="#type-field">field</a></span></span></code></div><div class="spec-doc"><p><code>field ty label ty'</code> adds a field of type <code>ty'</code> with label <code>label</code> to the structure or union type <code>ty</code> and returns a field value that can be used to read and write the field in structure or union instances (e.g. using <a href="#val-getf"><code>getf</code></a> and <a href="#val-setf"><code>setf</code></a>).</p><p>Attempting to add a field to a union type that has been sealed with <code>seal</code> is an error, and will raise <a href="#exception-ModifyingSealedType"><code>ModifyingSealedType</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-seal" class="anchored"><a href="#val-seal" class="anchor"></a><code><span><span class="keyword">val</span> seal : <span><span><span><span>(<span class="type-var">_</span>, <span>[&lt; `Struct <span>| `Union</span> ]</span>)</span> <a href="../Ctypes_static/index.html#type-structured">Ctypes_static.structured</a></span> <a href="#type-typ">typ</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>seal t</code> completes the struct or union type <code>t</code> so that no further fields can be added. Struct and union types must be sealed before they can be used in a way that involves their size or alignment; see the documentation for <a href="#exception-IncompleteType"><code>IncompleteType</code></a> for further details.</p></div></div><h4 id="view-types"><a href="#view-types" class="anchor"></a>View types</h4><div class="odoc-spec"><div class="spec value" id="val-view" class="anchored"><a href="#val-view" class="anchor"></a><code><span><span class="keyword">val</span> view : <span>?format_typ:<span>(<span><span>(<span><a href="../../ocaml/Stdlib/Format/index.html#type-formatter">Format.formatter</a> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../ocaml/Stdlib/Format/index.html#type-formatter">Format.formatter</a> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span>?format:<span>(<span><a href="../../ocaml/Stdlib/Format/index.html#type-formatter">Format.formatter</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
<span>read:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>write:<span>(<span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-typ">typ</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-typ">typ</a></span></span></code></div><div class="spec-doc"><p><code>view ~read:r ~write:w t</code> creates a C type representation <code>t'</code> which behaves like <code>t</code> except that values read using <code>t'</code> are subsequently transformed using the function <code>r</code> and values written using <code>t'</code> are first transformed using the function <code>w</code>.</p><p>For example, given suitable definitions of <code>string_of_char_ptr</code> and <code>char_ptr_of_string</code>, the type representation</p><p><code>view ~read:string_of_char_ptr ~write:char_ptr_of_string (ptr char)</code></p><p>can be used to pass OCaml strings directly to and from bound C functions, or to read and write string members in structs and arrays. (In fact, the <a href="#val-string"><code>string</code></a> type representation is defined in exactly this way.)</p><p>The optional argument <code>format_typ</code> is used by the <a href="#val-format_typ"><code>Ctypes.format_typ</code></a> and <a href="#val-string_of_typ"><code>string_of_typ</code></a> functions to print the type at the top level and elsewhere. If <code>format_typ</code> is not supplied the printer for <code>t</code> is used instead.</p><p>The optional argument <code>format</code> is used by the <a href="#val-format"><code>Ctypes.format</code></a> and <a href="#val-string_of"><code>string_of</code></a> functions to print the values. If <code>format_val</code> is not supplied the printer for <code>t</code> is used instead.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-typedef" class="anchored"><a href="#val-typedef" class="anchor"></a><code><span><span class="keyword">val</span> typedef : <span><span><span class="type-var">'a</span> <a href="#type-typ">typ</a></span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-typ">typ</a></span></span></code></div><div class="spec-doc"><p><code>typedef t name</code> creates a C type representation <code>t'</code> which is equivalent to <code>t</code> except its name is printed as <code>name</code>.</p><p>This is useful when generating C stubs involving &quot;anonymous&quot; types, for example: <code>typedef struct { int f } typedef_name;</code></p></div></div><h4 id="abstract-types"><a href="#abstract-types" class="anchor"></a>Abstract types</h4><div class="odoc-spec"><div class="spec value" id="val-abstract" class="anchored"><a href="#val-abstract" class="anchor"></a><code><span><span class="keyword">val</span> abstract : <span>name:string <span class="arrow">&#45;&gt;</span></span> <span>size:int <span class="arrow">&#45;&gt;</span></span> <span>alignment:int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="../Ctypes_static/index.html#type-abstract">Ctypes_static.abstract</a></span> <a href="#type-typ">typ</a></span></span></code></div><div class="spec-doc"><p>Create an abstract type specification from the size and alignment requirements for the type.</p></div></div><h4 id="injection-of-concrete-types"><a href="#injection-of-concrete-types" class="anchor"></a>Injection of concrete types</h4><div class="odoc-spec"><div class="spec value" id="val-lift_typ" class="anchored"><a href="#val-lift_typ" class="anchor"></a><code><span><span class="keyword">val</span> lift_typ : <span><span><span class="type-var">'a</span> <a href="../Ctypes_static/index.html#type-typ">Ctypes_static.typ</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-typ">typ</a></span></span></code></div><div class="spec-doc"><p><code>lift_typ t</code> turns a concrete type representation into an abstract type representation.</p><p>For example, retrieving struct layout from C involves working with an abstract representation of types which do not support operations such as <code>sizeof</code>. The <code>lift_typ</code> function makes it possible to use concrete type representations wherever such abstract type representations are needed.</p></div></div><h4 id="function-types"><a href="#function-types" class="anchor"></a>Function types</h4><p>Abstract interface to C function type descriptions</p><div class="odoc-spec"><div class="spec type" id="type-fn" class="anchored"><a href="#type-fn" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a fn</span></span><span> = <span><span class="type-var">'a</span> <a href="../Ctypes_static/index.html#type-fn">Ctypes_static.fn</a></span></span></code></div><div class="spec-doc"><p>The type of values representing C function types. A value of type <code>t fn</code> can be used to bind to C functions and to describe type of OCaml functions passed to C.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-(@-&gt;)" class="anchored"><a href="#val-(@-&gt;)" class="anchor"></a><code><span><span class="keyword">val</span> (@-&gt;) : <span><span><span class="type-var">'a</span> <a href="#type-typ">typ</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-fn">fn</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <a href="#type-fn">fn</a></span></span></code></div><div class="spec-doc"><p>Construct a function type from a type and an existing function type. This corresponds to prepending a parameter to a C function parameter list. For example,</p><p><code>int @-&gt; ptr void @-&gt; returning float</code></p><p>describes a function type that accepts two arguments -- an integer and a pointer to void -- and returns a float.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-returning" class="anchored"><a href="#val-returning" class="anchor"></a><code><span><span class="keyword">val</span> returning : <span><span><span class="type-var">'a</span> <a href="#type-typ">typ</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-fn">fn</a></span></span></code></div><div class="spec-doc"><p>Give the return type of a C function. Note that <code>returning</code> is intended to be used together with <a href="#val-(@-&gt;)"><code>(@-&gt;)</code></a>; see the documentation for <a href="#val-(@-&gt;)"><code>(@-&gt;)</code></a> for an example.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-static_funptr" class="anchored"><a href="#type-static_funptr" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a static_funptr</span></span><span> = <span><span class="type-var">'a</span> <a href="../Ctypes_static/index.html#type-static_funptr">Ctypes_static.static_funptr</a></span></span></code></div><div class="spec-doc"><p>Function pointer types</p><p>The type of values representing C function pointer types.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-static_funptr" class="anchored"><a href="#val-static_funptr" class="anchor"></a><code><span><span class="keyword">val</span> static_funptr : <span><span><span class="type-var">'a</span> <a href="#type-fn">fn</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="../Ctypes_static/index.html#type-static_funptr">Ctypes_static.static_funptr</a></span> <a href="#type-typ">typ</a></span></span></code></div><div class="spec-doc"><p>Construct a function pointer type from an existing function type (called the <i>reference type</i>).</p></div></div></details></div><h4 id="operations-on-types"><a href="#operations-on-types" class="anchor"></a>Operations on types</h4><div class="odoc-spec"><div class="spec value" id="val-sizeof" class="anchored"><a href="#val-sizeof" class="anchor"></a><code><span><span class="keyword">val</span> sizeof : <span><span><span class="type-var">'a</span> <a href="#type-typ">typ</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>sizeof t</code> computes the size in bytes of the type <code>t</code>. The exception <a href="#exception-IncompleteType"><code>IncompleteType</code></a> is raised if <code>t</code> is incomplete.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-alignment" class="anchored"><a href="#val-alignment" class="anchor"></a><code><span><span class="keyword">val</span> alignment : <span><span><span class="type-var">'a</span> <a href="#type-typ">typ</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>alignment t</code> computes the alignment requirements of the type <code>t</code>. The exception <a href="#exception-IncompleteType"><code>IncompleteType</code></a> is raised if <code>t</code> is incomplete.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-format_typ" class="anchored"><a href="#val-format_typ" class="anchor"></a><code><span><span class="keyword">val</span> format_typ : <span>?name:string <span class="arrow">&#45;&gt;</span></span> <span><a href="../../ocaml/Stdlib/Format/index.html#type-formatter">Format.formatter</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-typ">typ</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Pretty-print a C representation of the type to the specified formatter.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-format_fn" class="anchored"><a href="#val-format_fn" class="anchor"></a><code><span><span class="keyword">val</span> format_fn : <span>?name:string <span class="arrow">&#45;&gt;</span></span> <span><a href="../../ocaml/Stdlib/Format/index.html#type-formatter">Format.formatter</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-fn">fn</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Pretty-print a C representation of the function type to the specified formatter.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-string_of_typ" class="anchored"><a href="#val-string_of_typ" class="anchor"></a><code><span><span class="keyword">val</span> string_of_typ : <span>?name:string <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-typ">typ</a></span> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Return a C representation of the type.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-string_of_fn" class="anchored"><a href="#val-string_of_fn" class="anchor"></a><code><span><span class="keyword">val</span> string_of_fn : <span>?name:string <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-fn">fn</a></span> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Return a C representation of the function type.</p></div></div><h3 id="values"><a href="#values" class="anchor"></a>Values representing C values</h3><div class="odoc-spec"><div class="spec value" id="val-format" class="anchored"><a href="#val-format" class="anchor"></a><code><span><span class="keyword">val</span> format : <span><span><span class="type-var">'a</span> <a href="#type-typ">typ</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../ocaml/Stdlib/Format/index.html#type-formatter">Format.formatter</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Pretty-print a representation of the C value to the specified formatter.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-string_of" class="anchored"><a href="#val-string_of" class="anchor"></a><code><span><span class="keyword">val</span> string_of : <span><span><span class="type-var">'a</span> <a href="#type-typ">typ</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Return a string representation of the C value.</p></div></div><h4 id="pointer-values"><a href="#pointer-values" class="anchor"></a>Pointer values</h4><div class="odoc-spec"><div class="spec value" id="val-null" class="anchored"><a href="#val-null" class="anchor"></a><code><span><span class="keyword">val</span> null : <span>unit <a href="#type-ptr">ptr</a></span></span></code></div><div class="spec-doc"><p>A null pointer.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-(!@)" class="anchored"><a href="#val-(!@)" class="anchor"></a><code><span><span class="keyword">val</span> (!@) : <span><span><span class="type-var">'a</span> <a href="#type-ptr">ptr</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>!@ p</code> dereferences the pointer <code>p</code>. If the reference type is a scalar type then dereferencing constructs a new value. If the reference type is an aggregate type then dereferencing returns a value that references the memory pointed to by <code>p</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-(&lt;-@)" class="anchored"><a href="#val-(&lt;-@)" class="anchor"></a><code><span><span class="keyword">val</span> (&lt;-@) : <span><span><span class="type-var">'a</span> <a href="#type-ptr">ptr</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>p &lt;-@ v</code> writes the value <code>v</code> to the address <code>p</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-(+@)" class="anchored"><a href="#val-(+@)" class="anchor"></a><code><span><span class="keyword">val</span> (+@) : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-pointer">pointer</a></span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-pointer">pointer</a></span></span></code></div><div class="spec-doc"><p>If <code>p</code> is a pointer to an array element then <code>p +@ n</code> computes the address of the <code>n</code>th next element.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-(-@)" class="anchored"><a href="#val-(-@)" class="anchor"></a><code><span><span class="keyword">val</span> (-@) : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-pointer">pointer</a></span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-pointer">pointer</a></span></span></code></div><div class="spec-doc"><p>If <code>p</code> is a pointer to an array element then <code>p -@ n</code> computes the address of the nth previous element.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-ptr_diff" class="anchored"><a href="#val-ptr_diff" class="anchor"></a><code><span><span class="keyword">val</span> ptr_diff : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-pointer">pointer</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-pointer">pointer</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>ptr_diff p q</code> computes <code>q - p</code>. As in C, both <code>p</code> and <code>q</code> must point into the same array, and the result value is the difference of the subscripts of the two array elements.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-from_voidp" class="anchored"><a href="#val-from_voidp" class="anchor"></a><code><span><span class="keyword">val</span> from_voidp : <span><span><span class="type-var">'a</span> <a href="#type-typ">typ</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>unit <a href="#type-ptr">ptr</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-ptr">ptr</a></span></span></code></div><div class="spec-doc"><p>Conversion from <code>void *</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_voidp" class="anchored"><a href="#val-to_voidp" class="anchor"></a><code><span><span class="keyword">val</span> to_voidp : <span><span><span class="type-var">_</span> <a href="#type-ptr">ptr</a></span> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-ptr">ptr</a></span></span></code></div><div class="spec-doc"><p>Conversion to <code>void *</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-allocate" class="anchored"><a href="#val-allocate" class="anchor"></a><code><span><span class="keyword">val</span> allocate : <span>?finalise:<span>(<span><span><span class="type-var">'a</span> <a href="#type-ptr">ptr</a></span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-typ">typ</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-ptr">ptr</a></span></span></code></div><div class="spec-doc"><p><code>allocate t v</code> allocates a fresh value of type <code>t</code>, initialises it with <code>v</code> and returns its address. The argument <code>?finalise</code>, if present, will be called just before the memory is freed. The value will be automatically freed after no references to the pointer remain within the calling OCaml program.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-allocate_n" class="anchored"><a href="#val-allocate_n" class="anchor"></a><code><span><span class="keyword">val</span> allocate_n : <span>?finalise:<span>(<span><span><span class="type-var">'a</span> <a href="#type-ptr">ptr</a></span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-typ">typ</a></span> <span class="arrow">&#45;&gt;</span></span> <span>count:int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-ptr">ptr</a></span></span></code></div><div class="spec-doc"><p><code>allocate_n t ~count:n</code> allocates a fresh array with element type <code>t</code> and length <code>n</code>, and returns its address. The argument <code>?finalise</code>, if present, will be called just before the memory is freed. The array will be automatically freed after no references to the pointer remain within the calling OCaml program. The memory is allocated with libc's <code>calloc</code> and is guaranteed to be zero-filled.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-ptr_compare" class="anchored"><a href="#val-ptr_compare" class="anchor"></a><code><span><span class="keyword">val</span> ptr_compare : <span><span><span class="type-var">'a</span> <a href="#type-ptr">ptr</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-ptr">ptr</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>If <code>p</code> and <code>q</code> are pointers to elements <code>i</code> and <code>j</code> of the same array then <code>ptr_compare p q</code> compares the indexes of the elements. The result is negative if <code>i</code> is less than <code>j</code>, positive if <code>i</code> is greater than <code>j</code>, and zero if <code>i</code> and <code>j</code> are equal.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_null" class="anchored"><a href="#val-is_null" class="anchor"></a><code><span><span class="keyword">val</span> is_null : <span><span><span class="type-var">'a</span> <a href="#type-ptr">ptr</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_null p</code> is true when <code>p</code> is a null pointer.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-reference_type" class="anchored"><a href="#val-reference_type" class="anchor"></a><code><span><span class="keyword">val</span> reference_type : <span><span><span class="type-var">'a</span> <a href="#type-ptr">ptr</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-typ">typ</a></span></span></code></div><div class="spec-doc"><p>Retrieve the reference type of a pointer.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-ptr_of_raw_address" class="anchored"><a href="#val-ptr_of_raw_address" class="anchor"></a><code><span><span class="keyword">val</span> ptr_of_raw_address : <span>nativeint <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-ptr">ptr</a></span></span></code></div><div class="spec-doc"><p>Convert the numeric representation of an address to a pointer</p></div></div><div class="odoc-spec"><div class="spec value" id="val-funptr_of_raw_address" class="anchored"><a href="#val-funptr_of_raw_address" class="anchor"></a><code><span><span class="keyword">val</span> funptr_of_raw_address : <span>nativeint <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> unit)</span> <a href="../Ctypes_static/index.html#type-static_funptr">Ctypes_static.static_funptr</a></span></span></code></div><div class="spec-doc"><p>Convert the numeric representation of an address to a function pointer</p></div></div><div class="odoc-spec"><div class="spec value" id="val-raw_address_of_ptr" class="anchored"><a href="#val-raw_address_of_ptr" class="anchor"></a><code><span><span class="keyword">val</span> raw_address_of_ptr : <span><span>unit <a href="#type-ptr">ptr</a></span> <span class="arrow">&#45;&gt;</span></span> nativeint</span></code></div><div class="spec-doc"><p><code>raw_address_of_ptr p</code> returns the numeric representation of p.</p><p>Note that the return value remains valid only as long as the pointed-to object is alive. If <code>p</code> is a managed object (e.g. a value returned by <a href="#val-make"><code>make</code></a>) then unless the caller retains a reference to <code>p</code>, the object may be collected, invalidating the returned address.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-string_from_ptr" class="anchored"><a href="#val-string_from_ptr" class="anchor"></a><code><span><span class="keyword">val</span> string_from_ptr : <span><span>char <a href="#type-ptr">ptr</a></span> <span class="arrow">&#45;&gt;</span></span> <span>length:int <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>string_from_ptr p ~length</code> creates a string initialized with the <code>length</code> characters at address <code>p</code>.</p><p>Raise <code>Invalid_argument &quot;Ctypes.string_from_ptr&quot;</code> if <code>length</code> is negative.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-ocaml_string_start" class="anchored"><a href="#val-ocaml_string_start" class="anchor"></a><code><span><span class="keyword">val</span> ocaml_string_start : <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <a href="#type-ocaml">ocaml</a></span></span></code></div><div class="spec-doc"><p><code>ocaml_string_start s</code> allows to pass a pointer to the contents of an OCaml string directly to a C function.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-ocaml_bytes_start" class="anchored"><a href="#val-ocaml_bytes_start" class="anchor"></a><code><span><span class="keyword">val</span> ocaml_bytes_start : <span>bytes <span class="arrow">&#45;&gt;</span></span> <span>bytes <a href="#type-ocaml">ocaml</a></span></span></code></div><div class="spec-doc"><p><code>ocaml_bytes_start s</code> allows to pass a pointer to the contents of an OCaml byte array directly to a C function.</p></div></div><h4 id="array-values"><a href="#array-values" class="anchor"></a>Array values</h4><h5 id="c-array-values"><a href="#c-array-values" class="anchor"></a>C array values</h5><div class="odoc-spec"><div class="spec module" id="module-CArray" class="anchored"><a href="#module-CArray" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="CArray/index.html">CArray</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Operations on C arrays.</p></div></div><h5 id="bigarray-values"><a href="#bigarray-values" class="anchor"></a>Bigarray values</h5><div class="odoc-spec"><div class="spec value" id="val-bigarray_start" class="anchored"><a href="#val-bigarray_start" class="anchor"></a><code><span><span class="keyword">val</span> bigarray_start : <span><span><span>&lt; element : <span class="type-var">'a</span>; layout : <span class="type-var">'l</span>; ba_repr : <span class="type-var">_</span>; bigarray : <span class="type-var">'b</span>; carray : <span class="type-var">_</span>; dims : <span class="type-var">_</span>; &gt;</span> <a href="#type-bigarray_class">bigarray_class</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-ptr">ptr</a></span></span></code></div><div class="spec-doc"><p>Return the address of the first element of the given Bigarray value.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-bigarray_of_ptr" class="anchored"><a href="#val-bigarray_of_ptr" class="anchor"></a><code><span><span class="keyword">val</span> bigarray_of_ptr : <span><span><span>&lt; element : <span class="type-var">'a</span>; layout : <a href="../../bigarray-compat/Bigarray_compat/index.html#type-c_layout">Bigarray_compat.c_layout</a>; ba_repr : <span class="type-var">'f</span>; bigarray : <span class="type-var">'b</span>; carray : <span class="type-var">_</span>; dims : <span class="type-var">'i</span>; &gt;</span> <a href="#type-bigarray_class">bigarray_class</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'i</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'f</span>)</span> <a href="../../bigarray-compat/Bigarray_compat/index.html#type-kind">Bigarray_compat.kind</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-ptr">ptr</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span></span></code></div><div class="spec-doc"><p><code>bigarray_of_ptr c dims k p</code> converts the C pointer <code>p</code> to a C-layout bigarray value. No copy is made; the bigarray references the memory pointed to by <code>p</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fortran_bigarray_of_ptr" class="anchored"><a href="#val-fortran_bigarray_of_ptr" class="anchor"></a><code><span><span class="keyword">val</span> fortran_bigarray_of_ptr : <span><span><span>&lt; element : <span class="type-var">'a</span>; layout : <a href="../../bigarray-compat/Bigarray_compat/index.html#type-fortran_layout">Bigarray_compat.fortran_layout</a>; ba_repr : <span class="type-var">'f</span>; bigarray : <span class="type-var">'b</span>; carray : <span class="type-var">_</span>; dims : <span class="type-var">'i</span>; &gt;</span> <a href="#type-bigarray_class">bigarray_class</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'i</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'f</span>)</span> <a href="../../bigarray-compat/Bigarray_compat/index.html#type-kind">Bigarray_compat.kind</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-ptr">ptr</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span></span></code></div><div class="spec-doc"><p><code>fortran_bigarray_of_ptr c dims k p</code> converts the C pointer <code>p</code> to a Fortran-layout bigarray value. No copy is made; the bigarray references the memory pointed to by <code>p</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-array_of_bigarray" class="anchored"><a href="#val-array_of_bigarray" class="anchor"></a><code><span><span class="keyword">val</span> array_of_bigarray : <span><span><span>&lt; element : <span class="type-var">_</span>; layout : <a href="../../bigarray-compat/Bigarray_compat/index.html#type-c_layout">Bigarray_compat.c_layout</a>; ba_repr : <span class="type-var">_</span>; bigarray : <span class="type-var">'b</span>; carray : <span class="type-var">'c</span>; dims : <span class="type-var">_</span>; &gt;</span> <a href="#type-bigarray_class">bigarray_class</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span></span></code></div><div class="spec-doc"><p><code>array_of_bigarray c b</code> converts the bigarray value <code>b</code> to a value of type <a href="CArray/index.html#type-t"><code>CArray.t</code></a>. No copy is made; the result occupies the same memory as <code>b</code>.</p></div></div><p>Convert a Bigarray value to a C array.</p><div class="odoc-spec"><div class="spec value" id="val-bigarray_of_array" class="anchored"><a href="#val-bigarray_of_array" class="anchor"></a><code><span><span class="keyword">val</span> bigarray_of_array : <span><span><span>&lt; element : <span class="type-var">'a</span>; layout : <a href="../../bigarray-compat/Bigarray_compat/index.html#type-c_layout">Bigarray_compat.c_layout</a>; ba_repr : <span class="type-var">'f</span>; bigarray : <span class="type-var">'b</span>; carray : <span><span class="type-var">'c</span> <a href="#type-carray">carray</a></span>; dims : <span class="type-var">'i</span>; &gt;</span> <a href="#type-bigarray_class">bigarray_class</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'f</span>)</span> <a href="../../bigarray-compat/Bigarray_compat/index.html#type-kind">Bigarray_compat.kind</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'c</span> <a href="#type-carray">carray</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span></span></code></div><div class="spec-doc"><p><code>bigarray_of_array c k a</code> converts the <a href="CArray/index.html#type-t"><code>CArray.t</code></a> value <code>a</code> to a C-layout bigarray value. No copy is made; the result occupies the same memory as <code>a</code>.</p></div></div><h4 id="struct-and-union-values"><a href="#struct-and-union-values" class="anchor"></a>Struct and union values</h4><div class="odoc-spec"><div class="spec value" id="val-make" class="anchored"><a href="#val-make" class="anchor"></a><code><span><span class="keyword">val</span> make : <span>?finalise:<span>(<span><span class="type-var">'s</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="#type-structured">structured</a></span> <span class="keyword">as</span> 's <a href="#type-typ">typ</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'s</span></span></code></div><div class="spec-doc"><p>Allocate a fresh, uninitialised structure or union value. The argument <code>?finalise</code>, if present, will be called just before the underlying memory is freed.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-setf" class="anchored"><a href="#val-setf" class="anchor"></a><code><span><span class="keyword">val</span> setf : <span><span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="#type-structured">structured</a></span> <span class="keyword">as</span> 's <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'s</span>)</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>setf s f v</code> overwrites the value of the field <code>f</code> in the structure or union <code>s</code> with <code>v</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-getf" class="anchored"><a href="#val-getf" class="anchor"></a><code><span><span class="keyword">val</span> getf : <span><span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="#type-structured">structured</a></span> <span class="keyword">as</span> 's <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'s</span>)</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>getf s f</code> retrieves the value of the field <code>f</code> in the structure or union <code>s</code>. The semantics for non-scalar types are non-copying, as for <a href="#val-(!@)"><code>(!@)</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-(@.)" class="anchored"><a href="#val-(@.)" class="anchor"></a><code><span><span class="keyword">val</span> (@.) : <span><span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="#type-structured">structured</a></span> <span class="keyword">as</span> 's <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'s</span>)</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-ptr">ptr</a></span></span></code></div><div class="spec-doc"><p><code>s @. f</code> computes the address of the field <code>f</code> in the structure or union value <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-(|-&gt;)" class="anchored"><a href="#val-(|-&gt;)" class="anchor"></a><code><span><span class="keyword">val</span> (|-&gt;) : <span><span><span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="#type-structured">structured</a></span> <span class="keyword">as</span> 's <a href="#type-ptr">ptr</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'s</span>)</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-ptr">ptr</a></span></span></code></div><div class="spec-doc"><p><code>p |-&gt; f</code> computes the address of the field <code>f</code> in the structure or union value pointed to by <code>p</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-offsetof" class="anchored"><a href="#val-offsetof" class="anchor"></a><code><span><span class="keyword">val</span> offsetof : <span><span><span>(<span class="type-var">_</span>, <span><span class="type-var">_</span> <a href="#type-structure">structure</a></span>)</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>offsetof f</code> returns the offset, in bytes, of the field <code>f</code> from the beginning of the associated struct type.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-field_type" class="anchored"><a href="#val-field_type" class="anchor"></a><code><span><span class="keyword">val</span> field_type : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">_</span>)</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-typ">typ</a></span></span></code></div><div class="spec-doc"><p><code>field_type f</code> returns the type of the field <code>f</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-field_name" class="anchored"><a href="#val-field_name" class="anchor"></a><code><span><span class="keyword">val</span> field_name : <span><span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>field_name f</code> returns the name of the field <code>f</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-addr" class="anchored"><a href="#val-addr" class="anchor"></a><code><span><span class="keyword">val</span> addr : <span><span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="#type-structured">structured</a></span> <span class="keyword">as</span> 's <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'s</span> <a href="#type-ptr">ptr</a></span></span></code></div><div class="spec-doc"><p><code>addr s</code> returns the address of the structure or union <code>s</code>.</p></div></div><h4 id="coercions"><a href="#coercions" class="anchor"></a>Coercions</h4><div class="odoc-spec"><div class="spec value" id="val-coerce" class="anchored"><a href="#val-coerce" class="anchor"></a><code><span><span class="keyword">val</span> coerce : <span><span><span class="type-var">'a</span> <a href="#type-typ">typ</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-typ">typ</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span></span></code></div><div class="spec-doc"><p><code>coerce t1 t2</code> returns a coercion function between the types represented by <code>t1</code> and <code>t2</code>. If <code>t1</code> cannot be coerced to <code>t2</code>, <code>coerce</code> raises <a href="#exception-Uncoercible"><code>Uncoercible</code></a>.</p><p>The following coercions are currently supported:</p><ul><li>All function and object pointer types are intercoercible.</li><li>Any type may be coerced to <a href="#val-void"><code>void</code></a></li><li>There is a coercion between a <a href="#val-view"><code>view</code></a> and another type <code>t</code> (in either direction) if there is a coercion between the representation type underlying the view and <code>t</code>.</li><li>Coercion is transitive: if <code>t1</code> is coercible to <code>t2</code> and <code>t2</code> is coercible to <code>t3</code>, then <code>t1</code> is directly coercible to <code>t3</code>.</li></ul><p>The set of supported coercions is subject to change. Future versions of ctypes may both add new types of coercion and restrict the existing coercions.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-coerce_fn" class="anchored"><a href="#val-coerce_fn" class="anchor"></a><code><span><span class="keyword">val</span> coerce_fn : <span><span><span class="type-var">'a</span> <a href="#type-fn">fn</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-fn">fn</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span></span></code></div><div class="spec-doc"><p><code>coerce_fn f1 f2</code> returns a coercion function between the function types represented by <code>f1</code> and <code>f2</code>. If <code>f1</code> cannot be coerced to <code>f2</code>, <code>coerce_fn</code> raises <a href="#exception-Uncoercible"><code>Uncoercible</code></a>.</p><p>A function type <code>f1</code> may be coerced to another function type <code>f2</code> if all of the following hold:</p><ul><li>the C types described by <code>f1</code> and <code>f2</code> have the same arity</li></ul><ul><li>each argument of <code>f2</code> may be coerced to the corresponding argument of <code>f1</code></li></ul><ul><li>the return type of <code>f1</code> may be coerced to the return type of <code>f2</code></li></ul><p>The set of supported coercions is subject to change. Future versions of ctypes may both add new types of coercion and restrict the existing coercions.</p></div></div><h3 id="binding-interfaces"><a href="#binding-interfaces" class="anchor"></a>binding interfaces</h3><p>.</p><div class="odoc-spec"><div class="spec module-type" id="module-type-FOREIGN" class="anchored"><a href="#module-type-FOREIGN" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span><a href="module-type-FOREIGN/index.html">FOREIGN</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Foreign function binding interface.</p></div></div><div class="odoc-spec"><div class="spec module-type" id="module-type-TYPE" class="anchored"><a href="#module-type-TYPE" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span><a href="module-type-TYPE/index.html">TYPE</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Foreign types binding interface.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Root" class="anchored"><a href="#module-Root" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Root/index.html">Root</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><h3 id="exceptions"><a href="#exceptions" class="anchor"></a>Exceptions</h3><div class="odoc-spec"><div class="spec exception" id="exception-Unsupported" class="anchored"><a href="#exception-Unsupported" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Unsupported</span> <span class="keyword">of</span> string</span></code></div><div class="spec-doc"><p>An attempt was made to use a feature not currently supported by ctypes. In practice this refers to attempts to use an union, array or abstract type as an argument or return type of a function.</p></div></div><div class="odoc-spec"><div class="spec exception" id="exception-ModifyingSealedType" class="anchored"><a href="#exception-ModifyingSealedType" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">ModifyingSealedType</span> <span class="keyword">of</span> string</span></code></div><div class="spec-doc"><p>An attempt was made to modify a sealed struct or union type description.</p></div></div><div class="odoc-spec"><div class="spec exception" id="exception-IncompleteType" class="anchored"><a href="#exception-IncompleteType" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">IncompleteType</span></span></code></div><div class="spec-doc"><p>An attempt was made to compute the size or alignment of an incomplete type.</p><p>The incomplete types are struct and union types that have not been sealed, and the void type.</p><p>It is not permitted to compute the size or alignment requirements of an incomplete type, to use it as a struct or union member, to read or write a value of the type through a pointer or to use it as the referenced type in pointer arithmetic. Additionally, incomplete struct and union types cannot be used as argument or return types.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-uncoercible_info" class="anchored"><a href="#type-uncoercible_info" class="anchor"></a><code><span><span class="keyword">type</span> uncoercible_info</span></code></div></div><div class="odoc-spec"><div class="spec exception" id="exception-Uncoercible" class="anchored"><a href="#exception-Uncoercible" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Uncoercible</span> <span class="keyword">of</span> <a href="#type-uncoercible_info">uncoercible_info</a></span></code></div><div class="spec-doc"><p>An attempt was made to coerce between uncoercible types.</p></div></div></div></body></html>