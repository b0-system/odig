<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Uunf (uunf.Uunf)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">uunf</a> &#x00BB; Uunf</nav><h1>Module <code>Uunf</code></h1><p>Unicode text normalization.</p><p><code>Uunf</code> normalizes Unicode text. It supports all Unicode normalization forms. The module is independent from any IO mechanism or Unicode text data structure and it can process text without a complete in-memory representation of the data.</p><p>The supported Unicode version is determined by the <a href="index.html#val-unicode_version"><code>unicode_version</code></a> value.</p><p>Consult the <a href="index.html#basics"><span>basics</span></a>, <a href="index.html#limits"><span>limitations</span></a> and <a href="index.html#examples"><span>examples</span></a> of use.</p><p><em>v11.0.0 — Unicode version 11.0.0 — <a href="http://erratique.ch/software/uunf">homepage</a></em></p><h4 id="references"><a href="#references" class="anchor"></a>References</h4><ul><li>The Unicode Consortium. <em><a href="http://www.unicode.org/versions/latest">The Unicode Standard</a></em>. (latest version)</li><li>Mark Davis. <em><a href="http://www.unicode.org/reports/tr15/">UAX #15 Unicode Normalization Forms</a></em>. (latest version)</li><li>The Unicode Consortium. <em><a href="http://www.unicode.org/charts/normalization/">Normalization charts</a>.</em></li></ul><nav class="toc"><ul><li><a href="#normalize">Normalize</a></li><li><a href="#props">Normalization properties</a></li><li><a href="#limits">Limitations</a></li><li><a href="#basics">Basics</a></li><li><a href="#examples">Examples</a><ul><li><a href="#utf8">UTF-8 normalization</a></li></ul></li></ul></nav></header><section><header><h2 id="normalize"><a href="#normalize" class="anchor"></a>Normalize</h2></header><dl><dt class="spec type" id="type-form"><a href="#type-form" class="anchor"></a><code><span class="keyword">type</span> form</code> = <code>[ </code><table class="variant"><tr id="type-form.NFD" class="anchored"><td class="def constructor"><a href="#type-form.NFD" class="anchor"></a><code>| </code><code>`NFD</code></td></tr><tr id="type-form.NFC" class="anchored"><td class="def constructor"><a href="#type-form.NFC" class="anchor"></a><code>| </code><code>`NFC</code></td></tr><tr id="type-form.NFKD" class="anchored"><td class="def constructor"><a href="#type-form.NFKD" class="anchor"></a><code>| </code><code>`NFKD</code></td></tr><tr id="type-form.NFKC" class="anchored"><td class="def constructor"><a href="#type-form.NFKC" class="anchor"></a><code>| </code><code>`NFKC</code></td></tr></table><code> ]</code></dt><dd><p>The type for normalization forms.</p><ul><li><code>`NFD</code> <a href="http://www.unicode.org/glossary/#normalization_form_d">normalization form D</a>, canonical decomposition.</li><li><code>`NFC</code> <a href="http://www.unicode.org/glossary/#normalization_form_c">normalization form C</a>, canonical decomposition followed by canonical composition (<a href="http://www.w3.org/TR/charmod-norm/">recommended</a> for the www).</li><li><code>`NFKD</code> <a href="http://www.unicode.org/glossary/#normalization_form_kd">normalization form KD</a>, compatibility decomposition.</li><li><code>`NFKC</code> <a href="http://www.unicode.org/glossary/#normalization_form_kc">normalization form KC</a>, compatibility decomposition, followed by canonical composition.</li></ul></dd></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><p>The type for Unicode text normalizers.</p></dd></dl><dl><dt class="spec type" id="type-ret"><a href="#type-ret" class="anchor"></a><code><span class="keyword">type</span> ret</code> = <code>[ </code><table class="variant"><tr id="type-ret.Uchar" class="anchored"><td class="def constructor"><a href="#type-ret.Uchar" class="anchor"></a><code>| </code><code>`Uchar <span class="keyword">of</span> <a href="../../ocaml/Stdlib/Uchar/index.html#type-t">Stdlib.Uchar.t</a></code></td></tr><tr id="type-ret.End" class="anchored"><td class="def constructor"><a href="#type-ret.End" class="anchor"></a><code>| </code><code>`End</code></td></tr><tr id="type-ret.Await" class="anchored"><td class="def constructor"><a href="#type-ret.Await" class="anchor"></a><code>| </code><code>`Await</code></td></tr></table><code> ]</code></dt><dd><p>The type for normalizer results. See <a href="index.html#val-add"><code>add</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : [&lt; <a href="index.html#type-form">form</a> ] <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>create nf</code> is an Unicode text normalizer for the normal form <code>nf</code>.</p></dd></dl><dl><dt class="spec value" id="val-form"><a href="#val-form" class="anchor"></a><code><span class="keyword">val</span> form : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-form">form</a></code></dt><dd><p><code>form n</code> is the normalization form of <code>n</code>.</p></dd></dl><dl><dt class="spec value" id="val-add"><a href="#val-add" class="anchor"></a><code><span class="keyword">val</span> add : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> [ `Uchar of <a href="../../ocaml/Stdlib/Uchar/index.html#type-t">Stdlib.Uchar.t</a> | `Await | `End ] <span>&#45;&gt;</span> <a href="index.html#type-ret">ret</a></code></dt><dd><p><code>add n v</code> is:</p><ul><li><code>`Uchar u</code> if <code>u</code> is the next character in the normalized sequence. The client must then call <code>add</code> with <code>`Await</code> until <code>`Await</code> is returned.</li><li><code>`Await</code> when the normalizer is ready to add a new <code>`Uchar</code> or <code>`End</code>.</li></ul><p>For <code>v</code> use <code>`Uchar u</code> to add a new character to the sequence to normalize and <code>`End</code> to signal the end of sequence. After adding one of these two values, always call <code>add</code> with <code>`Await</code> until <code>`Await</code> is returned.</p><p><b>Raises.</b> <code>Invalid_argument</code> if <code>`Uchar </code> or <code>`End</code> is added directly after an <code>`Uchar</code> was returned by the normalizer or if an <code>`Uchar</code> is added after <code>`End</code> was added.</p></dd></dl><dl><dt class="spec value" id="val-reset"><a href="#val-reset" class="anchor"></a><code><span class="keyword">val</span> reset : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>reset n</code> resets the normalizer to a state equivalent to the state of <code>Uunf.create (Uunf.form n)</code>.</p></dd></dl><dl><dt class="spec value" id="val-copy"><a href="#val-copy" class="anchor"></a><code><span class="keyword">val</span> copy : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>copy n</code> is a copy of <code>n</code> in its current state. Subsequent <a href="index.html#val-add"><code>add</code></a>s on <code>n</code> do not affect the copy.</p></dd></dl><dl><dt class="spec value" id="val-pp_ret"><a href="#val-pp_ret" class="anchor"></a><code><span class="keyword">val</span> pp_ret : <a href="../../ocaml/Stdlib/Format/index.html#type-formatter">Stdlib.Format.formatter</a> <span>&#45;&gt;</span> <a href="index.html#type-ret">ret</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp_ret ppf v</code> prints an unspecified representation of <code>v</code> on <code>ppf</code>.</p></dd></dl></section><section><header><h2 id="props"><a href="#props" class="anchor"></a>Normalization properties</h2><p>These properties are used internally to implement the normalizers. They are not needed to use the module but are exposed as they may be useful to implement other algorithms.</p></header><dl><dt class="spec value" id="val-unicode_version"><a href="#val-unicode_version" class="anchor"></a><code><span class="keyword">val</span> unicode_version : string</code></dt><dd><p><code>unicode_version</code> is the Unicode version supported by the module.</p></dd></dl><dl><dt class="spec value" id="val-ccc"><a href="#val-ccc" class="anchor"></a><code><span class="keyword">val</span> ccc : <a href="../../ocaml/Stdlib/Uchar/index.html#type-t">Stdlib.Uchar.t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>ccc u</code> is <code>u</code>'s <a href="http://www.unicode.org/glossary/#combining_class">canonical combining class</a> value.</p></dd></dl><dl><dt class="spec value" id="val-decomp"><a href="#val-decomp" class="anchor"></a><code><span class="keyword">val</span> decomp : <a href="../../ocaml/Stdlib/Uchar/index.html#type-t">Stdlib.Uchar.t</a> <span>&#45;&gt;</span> int array</code></dt><dd><p><code>decomp u</code> is <code>u</code>'s <a href="http://www.unicode.org/glossary/#decomposition_mapping">decomposition mapping</a>. If the empty array is returned, <code>u</code> decomposes to itself.</p><p>The first number in the array contains additional information, it cannot be used as an <code>uchar</code>. Use <a href="index.html#val-d_uchar"><code>d_uchar</code></a> on the number to get the actual character and <a href="index.html#val-d_compatibility"><code>d_compatibility</code></a> to find out if this is a compatibility decomposition. All other characters of the array are guaranteed to be convertible using <span class="xref-unresolved" title="unresolved reference to &quot;Uchar.of_int&quot;"><code>Uchar</code>.of_int</span>.</p><p><b>Warning.</b> Do <b>not</b> mutate the array.</p></dd></dl><dl><dt class="spec value" id="val-d_uchar"><a href="#val-d_uchar" class="anchor"></a><code><span class="keyword">val</span> d_uchar : int <span>&#45;&gt;</span> <a href="../../ocaml/Stdlib/Uchar/index.html#type-t">Stdlib.Uchar.t</a></code></dt><dd><p>See <a href="index.html#val-decomp"><code>decomp</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-d_compatibility"><a href="#val-d_compatibility" class="anchor"></a><code><span class="keyword">val</span> d_compatibility : int <span>&#45;&gt;</span> bool</code></dt><dd><p>See <a href="index.html#val-decomp"><code>decomp</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-composite"><a href="#val-composite" class="anchor"></a><code><span class="keyword">val</span> composite : <a href="../../ocaml/Stdlib/Uchar/index.html#type-t">Stdlib.Uchar.t</a> <span>&#45;&gt;</span> <a href="../../ocaml/Stdlib/Uchar/index.html#type-t">Stdlib.Uchar.t</a> <span>&#45;&gt;</span> <a href="../../ocaml/Stdlib/Uchar/index.html#type-t">Stdlib.Uchar.t</a> option</code></dt><dd><p><code>composite u1 u2</code> is the <a href="http://www.unicode.org/glossary/#primary_composite">primary composite</a> canonically equivalent to the sequence <code>&lt;u1,u2&gt;</code>, if any.</p></dd></dl></section><section><header><h2 id="limits"><a href="#limits" class="anchor"></a>Limitations</h2><p>An <code>Uunf</code> normalizer consumes only a small bounded amount of memory on ordinary, <em>meaningful</em> text. However on legal but <em>degenerate</em> text like a <a href="http://www.unicode.org/glossary/#starter">starter</a> followed by 10'000 combining <a href="http://www.unicode.org/glossary/#nonspacing_mark">non-spacing marks</a> it will have to bufferize all the marks (a workaround is to first convert your input to <a href="http://www.unicode.org/reports/tr15/#Stream_Safe_Text_Format">stream-safe text format</a>).</p></header></section><section><header><h2 id="basics"><a href="#basics" class="anchor"></a>Basics</h2><p>A normalizer is a stateful filter that inputs a sequence of characters and outputs an equivalent sequence in the requested normal form.</p><p>The function <a href="index.html#val-create"><code>create</code></a> returns a new normalizer for a given normal form:</p><pre><code class="ml">let nfd = Uunf.create `NFD</code></pre><p>To add characters to the sequence to normalize, call <a href="index.html#val-add"><code>add</code></a> on <code>nfd</code> with <code>`Uchar _</code>. To end the sequence, call <a href="index.html#val-add"><code>add</code></a> on <code>nfd</code> with <code>`End</code>. The normalized sequence of characters is returned, character by character, by the successive calls to <a href="index.html#val-add"><code>add</code></a>.</p><p>The client and the normalizer must wait on each other to limit internal buffering: each time the client adds to the sequence by calling <a href="index.html#val-add"><code>add</code></a> with <code>`Uchar</code> or <code>`End</code> it must continue to call <a href="index.html#val-add"><code>add</code></a> with <code>`Await</code> until the normalizer returns <code>`Await</code>. In practice this leads to the following kind of control flow:</p><pre><code class="ml">let rec add acc v = match Uunf.add nfd v with
| `Uchar u -&gt; add (u :: acc) `Await
| `Await | `End -&gt; acc</code></pre><p>For example to normalize the character <code>U+00E9</code> (é) with <code>nfd</code> to a list of characters we can write:</p><pre><code class="ml">let e_acute = Uchar.of_int 0x00E9
let e_acute_nfd = List.rev (add (add [] (`Uchar e_acute)) `End)</code></pre><p>The next section has more examples.</p></header></section><section><header><h2 id="examples"><a href="#examples" class="anchor"></a>Examples</h2></header><section><header><h3 id="utf8"><a href="#utf8" class="anchor"></a>UTF-8 normalization</h3><p><code>utf_8_normalize nf s</code> is the UTF-8 encoded normal form <code>nf</code> of the UTF-8 encoded string <code>s</code>. This example uses <code>Uutf</code> to fold over the characters of <code>s</code> and to encode the normalized sequence in a standard OCaml buffer.</p><pre><code class="ml">let utf_8_normalize nf s =
  let b = Buffer.create (String.length s * 3) in
  let n = Uunf.create nf in
  let rec add v = match Uunf.add n v with
  | `Uchar u -&gt; Uutf.Buffer.add_utf_8 b u; add `Await
  | `Await | `End -&gt; ()
  in
  let add_uchar _ _ = function
  | `Malformed _ -&gt; add (`Uchar Uutf.u_rep)
  | `Uchar _ as u -&gt; add u
  in
  Uutf.String.fold_utf_8 add_uchar () s; add `End; Buffer.contents b</code></pre><p>Note that this functionality is available directly through <a href="../Uunf_string/index.html#val-normalize_utf_8"><code>Uunf_string.normalize_utf_8</code></a></p></header></section></section></div></body></html>