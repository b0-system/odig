<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>CCListLabels (containers.CCListLabels)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">containers</a> &#x00BB; CCListLabels</nav><header class="odoc-preamble"><h1>Module <code><span>CCListLabels</span></code></h1></header><nav class="odoc-toc"><ul><li><a href="#complements-to-list">Complements to list</a><ul><li><a href="#indices">Indices</a></li><li><a href="#set-operators">Set Operators</a></li><li><a href="#other-constructors">Other Constructors</a></li><li><a href="#association-lists_2">Association Lists</a></li><li><a href="#references-on-lists">References on Lists</a></li><li><a href="#conversions">Conversions</a></li><li><a href="#infix-operators">Infix Operators</a></li><li><a href="#io">IO</a></li></ul></li></ul></nav><div class="odoc-content"><h2 id="complements-to-list"><a href="#complements-to-list" class="anchor"></a>Complements to list</h2><div class="odoc-spec"><div class="spec type" id="type-iter" class="anchored"><a href="#type-iter" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a iter</span></span><span> = <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Fast internal iterator.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.8</li></ul></div></div><div class="odoc-spec"><div class="spec type" id="type-gen" class="anchored"><a href="#type-gen" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a gen</span></span><span> = <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-printer" class="anchored"><a href="#type-printer" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a printer</span></span><span> = <span><a href="../../ocaml/Stdlib/Format/index.html#type-formatter">Format.formatter</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-random_gen" class="anchored"><a href="#type-random_gen" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a random_gen</span></span><span> = <span><a href="../../ocaml/Stdlib/Random/State/index.html#type-t">Random.State.t</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div></div><div class="odoc-include"><div class="spec-doc"><p><a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/ListLabels.html">Documentation for the standard ListLabels module</a></p></div><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> <a href="../../ocaml/Stdlib/ListLabels/index.html">ListLabels</a></span></code></summary><div class="odoc-spec"><div class="spec value" id="val-length" class="anchored"><a href="#val-length" class="anchor"></a><code><span><span class="keyword">val</span> length : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Return the length (number of elements) of the given list.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-hd" class="anchored"><a href="#val-hd" class="anchor"></a><code><span><span class="keyword">val</span> hd : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Return the first element of the given list.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Failure</span> <p>if the list is empty.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-tl" class="anchored"><a href="#val-tl" class="anchor"></a><code><span><span class="keyword">val</span> tl : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p>Return the given list without its first element.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Failure</span> <p>if the list is empty.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-nth" class="anchored"><a href="#val-nth" class="anchor"></a><code><span><span class="keyword">val</span> nth : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Return the <code>n</code>-th element of the given list. The first element (head of the list) is at position 0.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Failure</span> <p>if the list is too short.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if <code>n</code> is negative.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-rev" class="anchored"><a href="#val-rev" class="anchor"></a><code><span><span class="keyword">val</span> rev : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p>List reversal.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-rev_append" class="anchored"><a href="#val-rev_append" class="anchor"></a><code><span><span class="keyword">val</span> rev_append : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>rev_append l1 l2</code> reverses <code>l1</code> and concatenates it with <code>l2</code>. This is equivalent to <code>(</code><a href="#val-rev"><code>rev</code></a><code> l1) @ l2</code>, but <code>rev_append</code> is tail-recursive and more efficient.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-concat" class="anchored"><a href="#val-concat" class="anchor"></a><code><span><span class="keyword">val</span> concat : <span><span><span><span class="type-var">'a</span> list</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p>Concatenate a list of lists. The elements of the argument are all concatenated together (in the same order) to give the result. Not tail-recursive (length of the argument + length of the longest sub-list).</p></div></div><h2 id="comparison"><a href="#comparison" class="anchor"></a>Comparison</h2><h2 id="iterators"><a href="#iterators" class="anchor"></a>Iterators</h2><div class="odoc-spec"><div class="spec value" id="val-iter" class="anchored"><a href="#val-iter" class="anchor"></a><code><span><span class="keyword">val</span> iter : <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>iter ~f [a1; ...; an]</code> applies function <code>f</code> in turn to <code>a1; ...; an</code>. It is equivalent to <code>begin f a1; f a2; ...; f an; () end</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-rev_map" class="anchored"><a href="#val-rev_map" class="anchor"></a><code><span><span class="keyword">val</span> rev_map : <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> list</span></span></code></div><div class="spec-doc"><p><code>rev_map ~f l</code> gives the same result as <a href="#val-rev"><code>rev</code></a><code> (</code><a href="#val-map"><code>map</code></a><code> f l)</code>, but is tail-recursive and more efficient.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-concat_map" class="anchored"><a href="#val-concat_map" class="anchor"></a><code><span><span class="keyword">val</span> concat_map : <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> list</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> list</span></span></code></div><div class="spec-doc"><p><code>concat_map ~f l</code> gives the same result as <a href="#val-concat"><code>concat</code></a><code> (</code><a href="#val-map"><code>map</code></a><code> f l)</code>. Tail-recursive.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.10.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_left_map" class="anchored"><a href="#val-fold_left_map" class="anchor"></a><code><span><span class="keyword">val</span> fold_left_map : <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> * <span class="type-var">'c</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>init:<span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> * <span><span class="type-var">'c</span> list</span></span></code></div><div class="spec-doc"><p><code>fold_left_map</code> is a combination of <code>fold_left</code> and <code>map</code> that threads an accumulator through calls to <code>f</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.11.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_left" class="anchored"><a href="#val-fold_left" class="anchor"></a><code><span><span class="keyword">val</span> fold_left : <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>init:<span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>fold_left ~f ~init [b1; ...; bn]</code> is <code>f (... (f (f init b1) b2) ...) bn</code>.</p></div></div><h2 id="iterators-on-two-lists"><a href="#iterators-on-two-lists" class="anchor"></a>Iterators on two lists</h2><div class="odoc-spec"><div class="spec value" id="val-iter2" class="anchored"><a href="#val-iter2" class="anchor"></a><code><span><span class="keyword">val</span> iter2 : <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>iter2 ~f [a1; ...; an] [b1; ...; bn]</code> calls in turn <code>f a1 b1; ...; f an bn</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if the two lists are determined to have different lengths.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-map2" class="anchored"><a href="#val-map2" class="anchor"></a><code><span><span class="keyword">val</span> map2 : <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> list</span></span></code></div><div class="spec-doc"><p><code>map2 ~f [a1; ...; an] [b1; ...; bn]</code> is <code>[f a1 b1; ...; f an bn]</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if the two lists are determined to have different lengths. Not tail-recursive.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-rev_map2" class="anchored"><a href="#val-rev_map2" class="anchor"></a><code><span><span class="keyword">val</span> rev_map2 : <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> list</span></span></code></div><div class="spec-doc"><p><code>rev_map2 ~f l1 l2</code> gives the same result as <a href="#val-rev"><code>rev</code></a><code> (</code><a href="#val-map2"><code>map2</code></a><code> f l1 l2)</code>, but is tail-recursive and more efficient.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_left2" class="anchored"><a href="#val-fold_left2" class="anchor"></a><code><span><span class="keyword">val</span> fold_left2 : <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>init:<span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'c</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>fold_left2 ~f ~init [a1; ...; an] [b1; ...; bn]</code> is <code>f (... (f (f init a1 b1) a2 b2) ...) an bn</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if the two lists are determined to have different lengths.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_right2" class="anchored"><a href="#val-fold_right2" class="anchor"></a><code><span><span class="keyword">val</span> fold_right2 : <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span>init:<span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span></span></code></div><div class="spec-doc"><p><code>fold_right2 ~f [a1; ...; an] [b1; ...; bn] ~init</code> is <code>f a1 b1 (f a2 b2 (... (f an bn init) ...))</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if the two lists are determined to have different lengths. Not tail-recursive.</p></li></ul></div></div><h2 id="list-scanning"><a href="#list-scanning" class="anchor"></a>List scanning</h2><div class="odoc-spec"><div class="spec value" id="val-for_all" class="anchored"><a href="#val-for_all" class="anchor"></a><code><span><span class="keyword">val</span> for_all : <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>for_all ~f [a1; ...; an]</code> checks if all elements of the list satisfy the predicate <code>f</code>. That is, it returns <code>(f a1) &amp;&amp; (f a2) &amp;&amp; ... &amp;&amp; (f an)</code> for a non-empty list and <code>true</code> if the list is empty.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-exists" class="anchored"><a href="#val-exists" class="anchor"></a><code><span><span class="keyword">val</span> exists : <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>exists ~f [a1; ...; an]</code> checks if at least one element of the list satisfies the predicate <code>f</code>. That is, it returns <code>(f a1) || (f a2) || ... || (f an)</code> for a non-empty list and <code>false</code> if the list is empty.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-for_all2" class="anchored"><a href="#val-for_all2" class="anchor"></a><code><span><span class="keyword">val</span> for_all2 : <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Same as <a href="#val-for_all"><code>for_all</code></a>, but for a two-argument predicate.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if the two lists are determined to have different lengths.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-exists2" class="anchored"><a href="#val-exists2" class="anchor"></a><code><span><span class="keyword">val</span> exists2 : <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Same as <a href="#val-exists"><code>exists</code></a>, but for a two-argument predicate.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if the two lists are determined to have different lengths.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-memq" class="anchored"><a href="#val-memq" class="anchor"></a><code><span><span class="keyword">val</span> memq : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span>set:<span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Same as <a href="#val-mem"><code>mem</code></a>, but uses physical equality instead of structural equality to compare list elements.</p></div></div><h2 id="list-searching"><a href="#list-searching" class="anchor"></a>List searching</h2><div class="odoc-spec"><div class="spec value" id="val-find" class="anchored"><a href="#val-find" class="anchor"></a><code><span><span class="keyword">val</span> find : <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>find ~f l</code> returns the first element of the list <code>l</code> that satisfies the predicate <code>f</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Not_found</span> <p>if there is no value that satisfies <code>f</code> in the list <code>l</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-find_all" class="anchored"><a href="#val-find_all" class="anchor"></a><code><span><span class="keyword">val</span> find_all : <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>find_all</code> is another name for <a href="#val-filter"><code>filter</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-filteri" class="anchored"><a href="#val-filteri" class="anchor"></a><code><span><span class="keyword">val</span> filteri : <span>f:<span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p>Same as <a href="#val-filter"><code>filter</code></a>, but the predicate is applied to the index of the element as first argument (counting from 0), and the element itself as second argument.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.11.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-partition" class="anchored"><a href="#val-partition" class="anchor"></a><code><span><span class="keyword">val</span> partition : <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span> * <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>partition ~f l</code> returns a pair of lists <code>(l1, l2)</code>, where <code>l1</code> is the list of all the elements of <code>l</code> that satisfy the predicate <code>f</code>, and <code>l2</code> is the list of all the elements of <code>l</code> that do not satisfy <code>f</code>. The order of the elements in the input list is preserved.</p></div></div><h2 id="association-lists"><a href="#association-lists" class="anchor"></a>Association lists</h2><div class="odoc-spec"><div class="spec value" id="val-assq" class="anchored"><a href="#val-assq" class="anchor"></a><code><span><span class="keyword">val</span> assq : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span></span></code></div><div class="spec-doc"><p>Same as <a href="#val-assoc"><code>assoc</code></a>, but uses physical equality instead of structural equality to compare keys.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mem_assq" class="anchored"><a href="#val-mem_assq" class="anchor"></a><code><span><span class="keyword">val</span> mem_assq : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span>map:<span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Same as <a href="#val-mem_assoc"><code>mem_assoc</code></a>, but uses physical equality instead of structural equality to compare keys.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-remove_assq" class="anchored"><a href="#val-remove_assq" class="anchor"></a><code><span><span class="keyword">val</span> remove_assq : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span></span></code></div><div class="spec-doc"><p>Same as <a href="#val-remove_assoc"><code>remove_assoc</code></a>, but uses physical equality instead of structural equality to compare keys. Not tail-recursive.</p></div></div><h2 id="lists-of-pairs"><a href="#lists-of-pairs" class="anchor"></a>Lists of pairs</h2><h2 id="sorting"><a href="#sorting" class="anchor"></a>Sorting</h2><div class="odoc-spec"><div class="spec value" id="val-sort" class="anchored"><a href="#val-sort" class="anchor"></a><code><span><span class="keyword">val</span> sort : <span>cmp:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p>Sort a list in increasing order according to a comparison function. The comparison function must return 0 if its arguments compare as equal, a positive integer if the first is greater, and a negative integer if the first is smaller (see Array.sort for a complete specification). For example, <a href="../../ocaml/Stdlib/index.html#val-compare"><code>Stdlib.compare</code></a> is a suitable comparison function. The resulting list is sorted in increasing order. <a href="#val-sort"><code>sort</code></a> is guaranteed to run in constant heap space (in addition to the size of the result list) and logarithmic stack space.</p><p>The current implementation uses Merge Sort. It runs in constant heap space and logarithmic stack space.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-stable_sort" class="anchored"><a href="#val-stable_sort" class="anchor"></a><code><span><span class="keyword">val</span> stable_sort : <span>cmp:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p>Same as <a href="#val-sort"><code>sort</code></a>, but the sorting algorithm is guaranteed to be stable (i.e. elements that compare equal are kept in their original order).</p><p>The current implementation uses Merge Sort. It runs in constant heap space and logarithmic stack space.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fast_sort" class="anchored"><a href="#val-fast_sort" class="anchor"></a><code><span><span class="keyword">val</span> fast_sort : <span>cmp:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p>Same as <a href="#val-sort"><code>sort</code></a> or <a href="#val-stable_sort"><code>stable_sort</code></a>, whichever is faster on typical input.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-merge" class="anchored"><a href="#val-merge" class="anchor"></a><code><span><span class="keyword">val</span> merge : <span>cmp:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p>Merge two lists: Assuming that <code>l1</code> and <code>l2</code> are sorted according to the comparison function <code>cmp</code>, <code>merge ~cmp l1 l2</code> will return a sorted list containing all the elements of <code>l1</code> and <code>l2</code>. If several elements compare equal, the elements of <code>l1</code> will be before the elements of <code>l2</code>. Not tail-recursive (sum of the lengths of the arguments).</p></div></div><h2 id="iterators_2"><a href="#iterators_2" class="anchor"></a>Iterators</h2></details></div><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a t</span></span><span> = <span><span class="type-var">'a</span> list</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-empty" class="anchored"><a href="#val-empty" class="anchor"></a><code><span><span class="keyword">val</span> empty : <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>empty</code> is <code>[]</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_empty" class="anchored"><a href="#val-is_empty" class="anchor"></a><code><span><span class="keyword">val</span> is_empty : <span><span><span class="type-var">_</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_empty l</code> returns <code>true</code> iff <code>l = []</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.11</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-map" class="anchored"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>map ~f [a0; a1; â€¦; an]</code> applies function <code>f</code> in turn to <code>[a0; a1; â€¦; an]</code>. Safe version of <code>List</code>.map.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-(&gt;|=)" class="anchored"><a href="#val-(&gt;|=)" class="anchor"></a><code><span><span class="keyword">val</span> (&gt;|=) : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>l &gt;|= f</code> is the infix version of <code>map</code> with reversed arguments.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.5</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-cons" class="anchored"><a href="#val-cons" class="anchor"></a><code><span><span class="keyword">val</span> cons : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>cons x l</code> is <code>x::l</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.12</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-append" class="anchored"><a href="#val-append" class="anchor"></a><code><span><span class="keyword">val</span> append : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>append l1 l2</code> returns the list that is the concatenation of <code>l1</code> and <code>l2</code>. Safe version of <code>List</code>.append.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-cons'" class="anchored"><a href="#val-cons'" class="anchor"></a><code><span><span class="keyword">val</span> cons' : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>cons' l x</code> is the same as <code>x :: l</code>. This is convenient for fold functions such as <code>List</code>.fold_left or <code>Array</code>.fold_left.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.3</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-cons_maybe" class="anchored"><a href="#val-cons_maybe" class="anchor"></a><code><span><span class="keyword">val</span> cons_maybe : <span><span><span class="type-var">'a</span> option</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>cons_maybe (Some x) l</code> is <code>x :: l</code>. <code>cons_maybe None l</code> is <code>l</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.13</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-(@)" class="anchored"><a href="#val-(@)" class="anchor"></a><code><span><span class="keyword">val</span> (@) : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>l1 @ l2</code> is like <code>append l1 l2</code>. Concatenate the two lists <code>l1</code> and <code>l2</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-filter" class="anchored"><a href="#val-filter" class="anchor"></a><code><span><span class="keyword">val</span> filter : <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>filter ~f l</code> returns all the elements of the list <code>l</code> that satisfy the predicate <code>f</code>. The order of the elements in the input list <code>l</code> is preserved. Safe version of <code>List</code>.filter.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_right" class="anchored"><a href="#val-fold_right" class="anchor"></a><code><span><span class="keyword">val</span> fold_right : <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>init:<span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span></span></code></div><div class="spec-doc"><p><code>fold_right ~f [a1; â€¦; an] ~init</code> is <code>f a1 (f a2 ( â€¦ (f an init) â€¦ ))</code>. Safe version of <code>List</code>.fold_right.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_while" class="anchored"><a href="#val-fold_while" class="anchor"></a><code><span><span class="keyword">val</span> fold_while : <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> * <span>[ `Stop <span>| `Continue</span> ]</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>init:<span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>fold_while ~f ~init l</code> folds until a stop condition via <code>('a, `Stop)</code> is indicated by the accumulator.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.8</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_map" class="anchored"><a href="#val-fold_map" class="anchor"></a><code><span><span class="keyword">val</span> fold_map : <span>f:<span>(<span><span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'acc</span> * <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>init:<span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'acc</span> * <span><span class="type-var">'b</span> list</span></span></code></div><div class="spec-doc"><p><code>fold_map ~f ~init l</code> is a <code>fold_left</code>-like function, but it also maps the list to another list.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.14</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_map_i" class="anchored"><a href="#val-fold_map_i" class="anchor"></a><code><span><span class="keyword">val</span> fold_map_i : <span>f:<span>(<span><span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'acc</span> * <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>init:<span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span>
<span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'acc</span> * <span><span class="type-var">'b</span> list</span></span></code></div><div class="spec-doc"><p><code>fold_map_i ~f ~init l</code> is a <code>foldi</code>-like function, but it also maps the list to another list.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.8</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_on_map" class="anchored"><a href="#val-fold_on_map" class="anchor"></a><code><span><span class="keyword">val</span> fold_on_map : <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>reduce:<span>(<span><span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'acc</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>init:<span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span>
<span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'acc</span></span></code></div><div class="spec-doc"><p><code>fold_on_map ~f ~reduce ~init l</code> combines <code>map ~f</code> and <code>fold_left ~reduce ~init</code> in one operation.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.8</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-scan_left" class="anchored"><a href="#val-scan_left" class="anchor"></a><code><span><span class="keyword">val</span> scan_left : <span>f:<span>(<span><span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'acc</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>init:<span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'acc</span> list</span></span></code></div><div class="spec-doc"><p><code>scan_left ~f ~init l</code> returns the list <code>[init; f init x0; f (f init x0) x1; â€¦]</code> where <code>x0</code>, <code>x1</code>, etc. are the elements of <code>l</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.2, but only</li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.2 with labels</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-reduce" class="anchored"><a href="#val-reduce" class="anchor"></a><code><span><span class="keyword">val</span> reduce : <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div><div class="spec-doc"><p><code>reduce f (hd::tl)</code> returns <code>Some (fold_left f hd tl)</code>. If <code>l</code> is empty, then <code>None</code> is returned.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.2</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-reduce_exn" class="anchored"><a href="#val-reduce_exn" class="anchor"></a><code><span><span class="keyword">val</span> reduce_exn : <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>reduce_exn</code> is the unsafe version of <a href="#val-reduce"><code>reduce</code></a>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if the given list is empty.</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.2</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_map2" class="anchored"><a href="#val-fold_map2" class="anchor"></a><code><span><span class="keyword">val</span> fold_map2 : <span>f:<span>(<span><span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'acc</span> * <span class="type-var">'c</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>init:<span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span>
<span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'acc</span> * <span><span class="type-var">'c</span> list</span></span></code></div><div class="spec-doc"><p><code>fold_map2 ~f ~init l1 l2</code> is to <code>fold_map</code> what <code>List.map2</code> is to <code>List.map</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if the lists do not have the same length.</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.16</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_filter_map" class="anchored"><a href="#val-fold_filter_map" class="anchor"></a><code><span><span class="keyword">val</span> fold_filter_map : <span>f:<span>(<span><span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'acc</span> * <span><span class="type-var">'b</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>init:<span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span>
<span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'acc</span> * <span><span class="type-var">'b</span> list</span></span></code></div><div class="spec-doc"><p><code>fold_filter_map ~f ~init l</code> is a <code>fold_left</code>-like function, but also generates a list of output in a way similar to <a href="#val-filter_map"><code>filter_map</code></a>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.17</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_filter_map_i" class="anchored"><a href="#val-fold_filter_map_i" class="anchor"></a><code><span><span class="keyword">val</span> fold_filter_map_i : <span>f:<span>(<span><span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'acc</span> * <span><span class="type-var">'b</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>init:<span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span>
<span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'acc</span> * <span><span class="type-var">'b</span> list</span></span></code></div><div class="spec-doc"><p><code>fold_filter_map_i ~f ~init l</code> is a <code>foldi</code>-like function, but also generates a list of output in a way similar to <a href="#val-filter_map"><code>filter_map</code></a>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.8</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_flat_map" class="anchored"><a href="#val-fold_flat_map" class="anchor"></a><code><span><span class="keyword">val</span> fold_flat_map : <span>f:<span>(<span><span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'acc</span> * <span><span class="type-var">'b</span> list</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>init:<span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span>
<span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'acc</span> * <span><span class="type-var">'b</span> list</span></span></code></div><div class="spec-doc"><p><code>fold_flat_map ~f ~init l</code> is a <code>fold_left</code>-like function, but it also maps the list to a list of lists that is then <code>flatten</code>'d.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.14</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_flat_map_i" class="anchored"><a href="#val-fold_flat_map_i" class="anchor"></a><code><span><span class="keyword">val</span> fold_flat_map_i : <span>f:<span>(<span><span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'acc</span> * <span><span class="type-var">'b</span> list</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>init:<span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span>
<span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'acc</span> * <span><span class="type-var">'b</span> list</span></span></code></div><div class="spec-doc"><p><code>fold_flat_map_i ~f ~init l</code> is a <code>fold_left</code>-like function, but it also maps the list to a list of lists that is then <code>flatten</code>'d.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.8</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-count" class="anchored"><a href="#val-count" class="anchor"></a><code><span><span class="keyword">val</span> count : <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>count ~f l</code> counts how many elements of <code>l</code> satisfy predicate <code>f</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.5, but only</li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.2 with labels</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-count_true_false" class="anchored"><a href="#val-count_true_false" class="anchor"></a><code><span><span class="keyword">val</span> count_true_false : <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> int * int</span></code></div><div class="spec-doc"><p><code>count_true_false ~f l</code> returns a pair <code>(int1,int2)</code> where <code>int1</code> is the number of elements in <code>l</code> that satisfy the predicate <code>f</code>, and <code>int2</code> the number of elements that do not satisfy <code>f</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.4</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-init" class="anchored"><a href="#val-init" class="anchor"></a><code><span><span class="keyword">val</span> init : <span>int <span class="arrow">&#45;&gt;</span></span> <span>f:<span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>init len ~f</code> is <code>f 0; f 1; â€¦; f (len-1)</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if len &lt; 0.</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.6</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-combine" class="anchored"><a href="#val-combine" class="anchor"></a><code><span><span class="keyword">val</span> combine : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span></span></code></div><div class="spec-doc"><p><code>combine [a1; â€¦; an] [b1; â€¦; bn]</code> is <code>[(a1,b1); â€¦; (an,bn)]</code>. Transform two lists into a list of pairs. Like <code>List</code>.combine but tail-recursive.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if the lists have distinct lengths.</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.2, but only</li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.2 with labels</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-combine_gen" class="anchored"><a href="#val-combine_gen" class="anchor"></a><code><span><span class="keyword">val</span> combine_gen : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p><code>combine_gen l1 l2</code> transforms two lists into a <code>gen</code> of pairs. Lazy version of <a href="#val-combine"><code>combine</code></a>. Unlike <a href="#val-combine"><code>combine</code></a>, it does not fail if the lists have different lengths; instead, the output has as many pairs as the smallest input list.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.2, but only</li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.2 with labels</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-combine_shortest" class="anchored"><a href="#val-combine_shortest" class="anchor"></a><code><span><span class="keyword">val</span> combine_shortest : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span></span></code></div><div class="spec-doc"><p><code>combine_shortest [a1; â€¦; am] [b1; â€¦; bn]</code> is <code>[(a1,b1); â€¦; (am,bm)]</code> if m &lt;= n. Like <a href="#val-combine"><code>combine</code></a> but stops at the shortest list rather than raising.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.1</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-split" class="anchored"><a href="#val-split" class="anchor"></a><code><span><span class="keyword">val</span> split : <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> * <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>split [(a1,b1); â€¦; (an,bn)]</code> is <code>([a1; â€¦; an], [b1; â€¦; bn])</code>. Transform a list of pairs into a pair of lists. A tail-recursive version of <code>List</code>.split.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.2, but only</li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.2 with labels</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-compare" class="anchored"><a href="#val-compare" class="anchor"></a><code><span><span class="keyword">val</span> compare : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>compare cmp l1 l2</code> compares the two lists <code>l1</code> and <code>l2</code> using the given comparison function <code>cmp</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-compare_lengths" class="anchored"><a href="#val-compare_lengths" class="anchor"></a><code><span><span class="keyword">val</span> compare_lengths : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>compare_lengths l1 l2</code> compare the lengths of the two lists <code>l1</code> and <code>l2</code>. Equivalent to <code>compare (length l1) (length l2)</code> but more efficient.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.5, but only</li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.2 with labels</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-compare_length_with" class="anchored"><a href="#val-compare_length_with" class="anchor"></a><code><span><span class="keyword">val</span> compare_length_with : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>compare_length_with l x</code> compares the length of the list <code>l</code> to an integer <code>x</code>. Equivalent to <code>compare (length l) x</code> but more efficient.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.5, but only</li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.2 with labels</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-equal" class="anchored"><a href="#val-equal" class="anchor"></a><code><span><span class="keyword">val</span> equal : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>equal p l1 l2</code> returns <code>true</code> if <code>l1</code> and <code>l2</code> are equal.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-flat_map" class="anchored"><a href="#val-flat_map" class="anchor"></a><code><span><span class="keyword">val</span> flat_map : <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>flat_map ~f l</code> maps and flattens at the same time (safe). Evaluation order is not guaranteed.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-flat_map_i" class="anchored"><a href="#val-flat_map_i" class="anchor"></a><code><span><span class="keyword">val</span> flat_map_i : <span>f:<span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>flat_map_i ~f l</code> maps with index and flattens at the same time (safe). Evaluation order is not guaranteed.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.8</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-flatten" class="anchored"><a href="#val-flatten" class="anchor"></a><code><span><span class="keyword">val</span> flatten : <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>flatten [l1]; [l2]; â€¦</code> concatenates a list of lists. Safe version of <code>List</code>.flatten.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-product" class="anchored"><a href="#val-product" class="anchor"></a><code><span><span class="keyword">val</span> product : <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>product ~f l1 l2</code> computes the cartesian product of the two lists, with the given combinator <code>f</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_product" class="anchored"><a href="#val-fold_product" class="anchor"></a><code><span><span class="keyword">val</span> fold_product : <span>f:<span>(<span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>init:<span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span></span></code></div><div class="spec-doc"><p><code>fold_product ~f ~init l1 l2</code> applies the function <code>f</code> with the accumulator <code>init</code> on all the pair of elements of <code>l1</code> and <code>l2</code>. Fold on the cartesian product.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-cartesian_product" class="anchored"><a href="#val-cartesian_product" class="anchor"></a><code><span><span class="keyword">val</span> cartesian_product : <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>cartesian_product [[l1];[l2]; â€¦; [ln]]</code> produces the cartesian product of this list of lists, by returning all the ways of picking one element per sublist. <b>NOTE</b> the order of the returned list is unspecified. For example:</p><pre><code># cartesian_product [[1;2];[3];[4;5;6]] |&gt; sort =
[[1;3;4];[1;3;5];[1;3;6];[2;3;4];[2;3;5];[2;3;6]];;
# cartesian_product [[1;2];[];[4;5;6]] = [];;
# cartesian_product [[1;2];[3];[4];[5];[6]] |&gt; sort =
[[1;3;4;5;6];[2;3;4;5;6]];;</code></pre><p>invariant: <code>cartesian_product l = map_product id l</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.2, but only</li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.2 with labels</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-map_product_l" class="anchored"><a href="#val-map_product_l" class="anchor"></a><code><span><span class="keyword">val</span> map_product_l : <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> list</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> list</span></span></code></div><div class="spec-doc"><p><code>map_product_l ~f l</code> maps each element of <code>l</code> to a list of objects of type <code>'b</code> using <code>f</code>. We obtain <code>[l1; l2; â€¦; ln]</code> where <code>length l=n</code> and <code>li : 'b list</code>. Then, it returns all the ways of picking exactly one element per <code>li</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.2, but only</li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.2 with labels</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-diagonal" class="anchored"><a href="#val-diagonal" class="anchor"></a><code><span><span class="keyword">val</span> diagonal : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'a</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>diagonal l</code> returns all pairs of distinct positions of the list <code>l</code>, that is the list of <code>List.nth i l, List.nth j l</code> if <code>i &lt; j</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-partition_map_either" class="anchored"><a href="#val-partition_map_either" class="anchor"></a><code><span><span class="keyword">val</span> partition_map_either : <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'b</span>,Â <span class="type-var">'c</span>)</span> <a href="../CCEither/index.html#type-t">CCEither.t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> list</span> * <span><span class="type-var">'c</span> list</span></span></code></div><div class="spec-doc"><p><code>partition_map_either ~f l</code> maps <code>f</code> on <code>l</code> and gather results in lists:</p><ul><li>if <code>f x = Left y</code>, adds <code>y</code> to the first list.</li><li>if <code>f x = Right z</code>, adds <code>z</code> to the second list.</li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.3</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-partition_filter_map" class="anchored"><a href="#val-partition_filter_map" class="anchor"></a><code><span><span class="keyword">val</span> partition_filter_map : <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span>[&lt; <span>`Left of <span class="type-var">'b</span></span> <span><span>| `Right</span> of <span class="type-var">'c</span></span> <span>| `Drop</span> ]</span>)</span> <span class="arrow">&#45;&gt;</span></span>
<span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> list</span> * <span><span class="type-var">'c</span> list</span></span></code></div><div class="spec-doc"><p><code>partition_filter_map ~f l</code> maps <code>f</code> on <code>l</code> and gather results in lists:</p><ul><li>if <code>f x = `Left y</code>, adds <code>y</code> to the first list.</li><li>if <code>f x = `Right z</code>, adds <code>z</code> to the second list.</li><li>if <code>f x = `Drop</code>, ignores <code>x</code>.</li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.11</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-partition_map" class="anchored"><a href="#val-partition_map" class="anchor"></a><code><span><span class="keyword">val</span> partition_map : <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span>[&lt; <span>`Left of <span class="type-var">'b</span></span> <span><span>| `Right</span> of <span class="type-var">'c</span></span> <span>| `Drop</span> ]</span>)</span> <span class="arrow">&#45;&gt;</span></span>
<span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> list</span> * <span><span class="type-var">'c</span> list</span></span></code></div><div class="spec-doc"><ul class="at-tags"><li class="deprecated"><span class="at-tag">deprecated</span> <p>use <code>partition_filter_map</code> instead</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-group_by" class="anchored"><a href="#val-group_by" class="anchor"></a><code><span><span class="keyword">val</span> group_by : <span>?hash:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span>?eq:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>group_by ?hash ?eq l</code> groups equal elements, regardless of their order of appearance. precondition: for any <code>x</code> and <code>y</code>, if <code>eq x y</code> then <code>hash x = hash y</code> must hold.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.3</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-join" class="anchored"><a href="#val-join" class="anchor"></a><code><span><span class="keyword">val</span> join : <span>join_row:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>join ~join_row a b</code> combines every element of <code>a</code> with every element of <code>b</code> using <code>join_row</code>. If <code>join_row</code> returns <code>None</code>, then the two elements do not combine. Assume that <code>b</code> allows for multiple iterations.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.3</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-join_by" class="anchored"><a href="#val-join_by" class="anchor"></a><code><span><span class="keyword">val</span> join_by : <span>?eq:<span>(<span><span class="type-var">'key</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'key</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span>?hash:<span>(<span><span class="type-var">'key</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span>
<span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'key</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'key</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>merge:<span>(<span><span class="type-var">'key</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>join_by ?eq ?hash key1 key2 ~merge la lb</code> is a binary operation that takes two sequences <code>a</code> and <code>b</code>, projects their elements resp. with <code>key1</code> and <code>key2</code>, and combine values <code>(x,y)</code> from <code>(a,b)</code> with the same <code>key</code> using <code>merge</code>. If <code>merge</code> returns <code>None</code>, the combination of values is discarded. precondition: for any <code>x</code> and <code>y</code>, if <code>eq x y</code> then <code>hash x = hash y</code> must hold.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.3</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-join_all_by" class="anchored"><a href="#val-join_all_by" class="anchor"></a><code><span><span class="keyword">val</span> join_all_by : <span>?eq:<span>(<span><span class="type-var">'key</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'key</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span>?hash:<span>(<span><span class="type-var">'key</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span>
<span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'key</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'key</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>merge:<span>(<span><span class="type-var">'key</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span>
<span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>join_all_by ?eq ?hash key1 key2 ~merge la lb</code> is a binary operation that takes two sequences <code>a</code> and <code>b</code>, projects their elements resp. with <code>key1</code> and <code>key2</code>, and, for each key <code>k</code> occurring in at least one of them:</p><ul><li>compute the list <code>l1</code> of elements of <code>a</code> that map to <code>k</code></li><li>compute the list <code>l2</code> of elements of <code>b</code> that map to <code>k</code></li><li>call <code>merge k l1 l2</code>. If <code>merge</code> returns <code>None</code>, the combination of values is discarded, otherwise it returns <code>Some c</code> and <code>c</code> is inserted in the result.</li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.3</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-group_join_by" class="anchored"><a href="#val-group_join_by" class="anchor"></a><code><span><span class="keyword">val</span> group_join_by : <span>?eq:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span>?hash:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span>
<span><span>(<span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span><span class="type-var">'b</span> list</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>group_join_by ?eq ?hash key la lb</code> associates to every element <code>x</code> of the first sequence, all the elements <code>y</code> of the second sequence such that <code>eq x (key y)</code>. Elements of the first sequences without corresponding values in the second one are mapped to <code>[]</code> precondition: for any <code>x</code> and <code>y</code>, if <code>eq x y</code> then <code>hash x = hash y</code> must hold.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.3</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-sublists_of_len" class="anchored"><a href="#val-sublists_of_len" class="anchor"></a><code><span><span class="keyword">val</span> sublists_of_len : <span>?last:<span>(<span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>?offset:int <span class="arrow">&#45;&gt;</span></span> <span>len:int <span class="arrow">&#45;&gt;</span></span>
<span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> list</span></span></code></div><div class="spec-doc"><p><code>sublists_of_len ?last ?offset n l</code> returns sub-lists of <code>l</code> that have length <code>n</code>. By default, these sub-lists are non overlapping: <code>sublists_of_len 2 [1;2;3;4;5;6]</code> returns <code>[1;2]; [3;4]; [5;6]</code>.</p><p>Examples:</p><ul><li><code>sublists_of_len 2 [1;2;3;4;5;6] = [[1;2]; [3;4]; [5;6]]</code>.</li><li><code>sublists_of_len 2 ~offset:3 [1;2;3;4;5;6] = [1;2];[4;5]</code>.</li><li><code>sublists_of_len 3 ~last:CCOpt.return [1;2;3;4] = [1;2;3];[4]</code>.</li><li><code>sublists_of_len 2 [1;2;3;4;5] = [[1;2]; [3;4]]</code>.</li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">offset</span> <p>the number of elements skipped between two consecutive sub-lists. By default it is <code>n</code>. If <code>offset &lt; n</code>, the sub-lists will overlap; if <code>offset &gt; n</code>, some elements will not appear at all.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">last</span> <p>if provided and the last group of elements <code>g</code> is such that <code>length g &lt; n</code>, <code>last g</code> is called. If <code>last g = Some g'</code>, <code>g'</code> is appended; otherwise <code>g</code> is dropped. If <code>last = CCOpt.return</code>, it will simply keep the last group. By default, <code>last = fun _ -&gt; None</code>, i.e. the last group is dropped if shorter than <code>n</code>.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if <code>offset &lt;= 0</code> or <code>n &lt;= 0</code>. See <code>CCList</code>.sublists_of_len for more details.</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.0, but only</li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.5 with labels</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-chunks" class="anchored"><a href="#val-chunks" class="anchor"></a><code><span><span class="keyword">val</span> chunks : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> list</span></span></code></div><div class="spec-doc"><p><code>chunks n l</code> returns consecutives chunks of size at most <code>n</code> from <code>l</code>. Each item of <code>l</code> will occur in exactly one chunk. Only the last chunk might be of length smaller than <code>n</code>. Invariant: <code>(chunks n l |&gt; List.flatten) = l</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.2</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-intersperse" class="anchored"><a href="#val-intersperse" class="anchor"></a><code><span><span class="keyword">val</span> intersperse : <span>x:<span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>intersperse ~x l</code> inserts the element <code>x</code> between adjacent elements of the list <code>l</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.1, but only</li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.2 with labels</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-interleave" class="anchored"><a href="#val-interleave" class="anchor"></a><code><span><span class="keyword">val</span> interleave : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>interleave [x1â€¦xn] [y1â€¦ym]</code> is <code>[x1,y1,x2,y2,â€¦]</code> and finishes with the suffix of the longest list.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.1, but only</li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.2 with labels</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-pure" class="anchored"><a href="#val-pure" class="anchor"></a><code><span><span class="keyword">val</span> pure : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>pure x</code> is <code>return x</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mguard" class="anchored"><a href="#val-mguard" class="anchor"></a><code><span><span class="keyword">val</span> mguard : <span>bool <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>mguard c</code> is <code>pure ()</code> if <code>c</code> is true, <code>[]</code> otherwise. This is useful to define a list by comprehension, e.g.:</p><pre><code># let square_even xs =
      let* x = xs in
      let* () = mguard (x mod 2 = 0) in
      return @@ x * x;;
val square_even : int list -&gt; int list = &lt;fun&gt;
# square_even [1;2;4;3;5;2];;
- : int list = [4; 16; 4]</code></pre><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.1</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-(&lt;*&gt;)" class="anchored"><a href="#val-(&lt;*&gt;)" class="anchor"></a><code><span><span class="keyword">val</span> (&lt;*&gt;) : <span><span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>funs &lt;*&gt; l</code> is <code>product (fun f x -&gt; f x) funs l</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-(&lt;$&gt;)" class="anchored"><a href="#val-(&lt;$&gt;)" class="anchor"></a><code><span><span class="keyword">val</span> (&lt;$&gt;) : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>(&lt;$&gt;)</code> is <code>map</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-return" class="anchored"><a href="#val-return" class="anchor"></a><code><span><span class="keyword">val</span> return : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>return x</code> is <code>x</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-(&gt;&gt;=)" class="anchored"><a href="#val-(&gt;&gt;=)" class="anchor"></a><code><span><span class="keyword">val</span> (&gt;&gt;=) : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>l &gt;&gt;= f</code> is <code>flat_map f l</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-take" class="anchored"><a href="#val-take" class="anchor"></a><code><span><span class="keyword">val</span> take : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>take n l</code> takes the <code>n</code> first elements of the list <code>l</code>, drop the rest.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-drop" class="anchored"><a href="#val-drop" class="anchor"></a><code><span><span class="keyword">val</span> drop : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>drop n l</code> drops the <code>n</code> first elements of the list <code>l</code>, keep the rest.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-hd_tl" class="anchored"><a href="#val-hd_tl" class="anchor"></a><code><span><span class="keyword">val</span> hd_tl : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> * <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>hd_tl (x :: l)</code> returns <code>hd, l</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Failure</span> <p>if the list is empty.</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.16</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-take_drop" class="anchored"><a href="#val-take_drop" class="anchor"></a><code><span><span class="keyword">val</span> take_drop : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> * <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>take_drop n l</code> returns <code>l1, l2</code> such that <code>l1 @ l2 = l</code> and <code>length l1 = min (length l) n</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-take_while" class="anchored"><a href="#val-take_while" class="anchor"></a><code><span><span class="keyword">val</span> take_while : <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>take_while ~f l</code> returns the longest prefix of <code>l</code> for which <code>f</code> is <code>true</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.13</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-drop_while" class="anchored"><a href="#val-drop_while" class="anchor"></a><code><span><span class="keyword">val</span> drop_while : <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>drop_while ~f l</code> drops the longest prefix of <code>l</code> for which <code>f</code> is <code>true</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.13</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-take_drop_while" class="anchored"><a href="#val-take_drop_while" class="anchor"></a><code><span><span class="keyword">val</span> take_drop_while : <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> * <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>take_drop_while ~f l</code> = <code>take_while ~f l, drop_while ~f l</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.2, but only</li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.2 with labels</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-last" class="anchored"><a href="#val-last" class="anchor"></a><code><span><span class="keyword">val</span> last : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>last n l</code> takes the last <code>n</code> elements of <code>l</code> (or less if <code>l</code> doesn't have that many elements).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-head_opt" class="anchored"><a href="#val-head_opt" class="anchor"></a><code><span><span class="keyword">val</span> head_opt : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div><div class="spec-doc"><p><code>head_opt l</code> returns <code>Some x</code> (the first element of the list <code>l</code>) or <code>None</code> if the list <code>l</code> is empty.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.20</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-tail_opt" class="anchored"><a href="#val-tail_opt" class="anchor"></a><code><span><span class="keyword">val</span> tail_opt : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> option</span></span></code></div><div class="spec-doc"><p><code>tail_opt l</code> returns <code>Some l'</code> (the given list <code>l</code> without its first element) or <code>None</code> if the list <code>l</code> is empty.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-last_opt" class="anchored"><a href="#val-last_opt" class="anchor"></a><code><span><span class="keyword">val</span> last_opt : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div><div class="spec-doc"><p><code>last_opt l</code> returns <code>Some x</code> (the last element of <code>l</code>) or <code>None</code> if the list <code>l</code> is empty.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.20</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-find_pred" class="anchored"><a href="#val-find_pred" class="anchor"></a><code><span><span class="keyword">val</span> find_pred : <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div><div class="spec-doc"><p><code>find_pred ~f l</code> finds the first element of <code>l</code> that satisfies <code>f</code>, or returns <code>None</code> if no element satisfies <code>f</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.11</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-find_opt" class="anchored"><a href="#val-find_opt" class="anchor"></a><code><span><span class="keyword">val</span> find_opt : <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div><div class="spec-doc"><p><code>find_opt ~f l</code> is the safe version of <a href="#val-find"><code>find</code></a>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.5, but only</li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.2 with labels</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-find_pred_exn" class="anchored"><a href="#val-find_pred_exn" class="anchor"></a><code><span><span class="keyword">val</span> find_pred_exn : <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>find_pred_exn ~f l</code> is the unsafe version of <a href="#val-find_pred"><code>find_pred</code></a>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Not_found</span> <p>if no such element is found.</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.11</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-find_map" class="anchored"><a href="#val-find_map" class="anchor"></a><code><span><span class="keyword">val</span> find_map : <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span></span></code></div><div class="spec-doc"><p><code>find_map ~f l</code> traverses <code>l</code>, applying <code>f</code> to each element. If for some element <code>x</code>, <code>f x = Some y</code>, then <code>Some y</code> is returned. Otherwise the call returns <code>None</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.11</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-find_mapi" class="anchored"><a href="#val-find_mapi" class="anchor"></a><code><span><span class="keyword">val</span> find_mapi : <span>f:<span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span></span></code></div><div class="spec-doc"><p><code>find_mapi ~f l</code> is like <a href="#val-find_map"><code>find_map</code></a>, but also pass the index to the predicate function.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.11</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-find_idx" class="anchored"><a href="#val-find_idx" class="anchor"></a><code><span><span class="keyword">val</span> find_idx : <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(int * <span class="type-var">'a</span>)</span> option</span></span></code></div><div class="spec-doc"><p><code>find_idx ~f x</code> returns <code>Some (i,x)</code> where <code>x</code> is the <code>i</code>-th element of <code>l</code>, and <code>f x</code> holds. Otherwise returns <code>None</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-remove" class="anchored"><a href="#val-remove" class="anchor"></a><code><span><span class="keyword">val</span> remove : <span>eq:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span>key:<span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>remove ~eq ~key l</code> removes every instance of <code>key</code> from <code>l</code>. Tail-recursive.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">eq</span> <p>equality function.</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.11</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-filter_map" class="anchored"><a href="#val-filter_map" class="anchor"></a><code><span><span class="keyword">val</span> filter_map : <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>filter_map ~f l</code> is the sublist of <code>l</code> containing only elements for which <code>f</code> returns <code>Some e</code>. Map and remove elements at the same time.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-keep_some" class="anchored"><a href="#val-keep_some" class="anchor"></a><code><span><span class="keyword">val</span> keep_some : <span><span><span><span class="type-var">'a</span> option</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>keep_some l</code> retains only elements of the form <code>Some x</code>. Like <code>filter_map CCFun.id</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.3, but only</li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.2 with labels</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-keep_ok" class="anchored"><a href="#val-keep_ok" class="anchor"></a><code><span><span class="keyword">val</span> keep_ok : <span><span><span><span>(<span class="type-var">'a</span>,Â <span class="type-var">_</span>)</span> <a href="../../ocaml/Stdlib/index.html#type-result">result</a></span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>keep_ok l</code> retains only elements of the form <code>Ok x</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.3, but only</li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.2 with labels</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-all_some" class="anchored"><a href="#val-all_some" class="anchor"></a><code><span><span class="keyword">val</span> all_some : <span><span><span><span class="type-var">'a</span> option</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> option</span></span></code></div><div class="spec-doc"><p><code>all_some l</code> returns <code>Some l'</code> if all elements of <code>l</code> are of the form <code>Some x</code>, or <code>None</code> otherwise.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.3, but only</li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.2 with labels</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-all_ok" class="anchored"><a href="#val-all_ok" class="anchor"></a><code><span><span class="keyword">val</span> all_ok : <span><span><span><span>(<span class="type-var">'a</span>,Â <span class="type-var">'err</span>)</span> <a href="../../ocaml/Stdlib/index.html#type-result">result</a></span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <a href="#type-t">t</a></span>,Â <span class="type-var">'err</span>)</span> <a href="../../ocaml/Stdlib/index.html#type-result">result</a></span></span></code></div><div class="spec-doc"><p><code>all_ok l</code> returns <code>Ok l'</code> if all elements of <code>l</code> are of the form <code>Ok x</code>, or <code>Error e</code> otherwise (with the first error met).</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.3, but only</li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.2 with labels</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-sorted_merge" class="anchored"><a href="#val-sorted_merge" class="anchor"></a><code><span><span class="keyword">val</span> sorted_merge : <span>cmp:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>sorted_merge ~cmp l1 l2</code> merges elements from both sorted list using the given comparison function <code>cmp</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sort_uniq" class="anchored"><a href="#val-sort_uniq" class="anchor"></a><code><span><span class="keyword">val</span> sort_uniq : <span>cmp:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>sort_uniq ~cmp l</code> sorts the list <code>l</code> using the given comparison function <code>cmp</code> and remove duplicate elements.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sorted_merge_uniq" class="anchored"><a href="#val-sorted_merge_uniq" class="anchor"></a><code><span><span class="keyword">val</span> sorted_merge_uniq : <span>cmp:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>sorted_merge_uniq ~cmp l1 l2</code> merges the sorted lists <code>l1</code> and <code>l2</code> and removes duplicates.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.10</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-is_sorted" class="anchored"><a href="#val-is_sorted" class="anchor"></a><code><span><span class="keyword">val</span> is_sorted : <span>cmp:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_sorted ~cmp l</code> returns <code>true</code> iff <code>l</code> is sorted (according to given order).</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">cmp</span> <p>the comparison function.</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.17</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-sorted_insert" class="anchored"><a href="#val-sorted_insert" class="anchor"></a><code><span><span class="keyword">val</span> sorted_insert : <span>cmp:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span>?uniq:bool <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>sorted_insert ~cmp ?uniq x l</code> inserts <code>x</code> into <code>l</code> such that, if <code>l</code> was sorted, then <code>sorted_insert x l</code> is sorted too.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">uniq</span> <p>if true and <code>x</code> is already in sorted position in <code>l</code>, then <code>x</code> is not duplicated. Default <code>false</code> (<code>x</code> will be inserted in any case).</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.17</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-uniq_succ" class="anchored"><a href="#val-uniq_succ" class="anchor"></a><code><span><span class="keyword">val</span> uniq_succ : <span>eq:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>uniq_succ ~eq l</code> removes duplicate elements that occur one next to the other. Examples: <code>uniq_succ [1;2;1] = [1;2;1]</code>. <code>uniq_succ [1;1;2] = [1;2]</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.10</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-group_succ" class="anchored"><a href="#val-group_succ" class="anchor"></a><code><span><span class="keyword">val</span> group_succ : <span>eq:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> list</span></span></code></div><div class="spec-doc"><p><code>group_succ ~eq l</code> groups together consecutive elements that are equal according to <code>eq</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.11</li></ul></div></div><h3 id="indices"><a href="#indices" class="anchor"></a>Indices</h3><div class="odoc-spec"><div class="spec value" id="val-mapi" class="anchored"><a href="#val-mapi" class="anchor"></a><code><span><span class="keyword">val</span> mapi : <span>f:<span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>mapi ~f l</code> is like <a href="#val-map"><code>map</code></a>, but the function <code>f</code> is applied to the index of the element as first argument (counting from 0), and the element itself as second argument.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-iteri" class="anchored"><a href="#val-iteri" class="anchor"></a><code><span><span class="keyword">val</span> iteri : <span>f:<span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>iteri ~f l</code> is like <a href="#val-iter"><code>iter</code></a>, but the function <code>f</code> is applied to the index of the element as first argument (counting from 0), and the element itself as second argument.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-iteri2" class="anchored"><a href="#val-iteri2" class="anchor"></a><code><span><span class="keyword">val</span> iteri2 : <span>f:<span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>iteri2 ~f l1 l2</code> applies <code>f</code> to the two lists <code>l1</code> and <code>l2</code> simultaneously. The integer passed to <code>f</code> indicates the index of element.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>when lists do not have the same length.</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.0, but only</li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.2 with labels</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-foldi" class="anchored"><a href="#val-foldi" class="anchor"></a><code><span><span class="keyword">val</span> foldi : <span>f:<span>(<span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>init:<span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span></span></code></div><div class="spec-doc"><p><code>foldi ~f ~init l</code> is like <code>fold</code> but it also passes in the index of each element, from <code>0</code> to <code>length l - 1</code> as additional argument to the folded function <code>f</code>. Tail-recursive.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-foldi2" class="anchored"><a href="#val-foldi2" class="anchor"></a><code><span><span class="keyword">val</span> foldi2 : <span>f:<span>(<span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>init:<span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span></span></code></div><div class="spec-doc"><p><code>foldi2 ~f ~init l1 l2</code> folds on the two lists <code>l1</code> and <code>l2</code>, with index of each element passed to the function <code>f</code>. Computes <code>f(â€¦ (f init i_0 l1_0 l2_0) â€¦) i_n l1_n l2_n</code> .</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>when lists do not have the same length.</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.0, but only</li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.2 with labels</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-get_at_idx" class="anchored"><a href="#val-get_at_idx" class="anchor"></a><code><span><span class="keyword">val</span> get_at_idx : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div><div class="spec-doc"><p><code>get_at_idx i l</code> returns <code>Some i-th</code> element of the given list <code>l</code> or <code>None</code> if the list <code>l</code> is too short. If the index is negative, it will get element starting from the end of the list <code>l</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-nth_opt" class="anchored"><a href="#val-nth_opt" class="anchor"></a><code><span><span class="keyword">val</span> nth_opt : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div><div class="spec-doc"><p><code>nth_opt l n</code> returns <code>Some n-th</code> element of <code>l</code>. Safe version of <a href="#val-nth"><code>nth</code></a>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if the int is negative.</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.5, but only</li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.2 with labels</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-get_at_idx_exn" class="anchored"><a href="#val-get_at_idx_exn" class="anchor"></a><code><span><span class="keyword">val</span> get_at_idx_exn : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>get_at_idx_exn i l</code> gets the <code>i-th</code> element of <code>l</code>, or</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Not_found</span> <p>if the index is invalid. The first element has index 0. If the index is negative, it will get element starting from the end of the list.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-set_at_idx" class="anchored"><a href="#val-set_at_idx" class="anchor"></a><code><span><span class="keyword">val</span> set_at_idx : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>set_at_idx i x l</code> replaces the <code>i-th</code> element with <code>x</code> (removes the old one), or does nothing if index is too high. If the index is negative, it will set element starting from the end of the list.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-insert_at_idx" class="anchored"><a href="#val-insert_at_idx" class="anchor"></a><code><span><span class="keyword">val</span> insert_at_idx : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>insert_at_idx i x l</code> inserts <code>x</code> at <code>i-th</code> position, between the two existing elements. If the index is too high, append at the end of the list. If the index is negative, it will insert element starting from the end of the list.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-remove_at_idx" class="anchored"><a href="#val-remove_at_idx" class="anchor"></a><code><span><span class="keyword">val</span> remove_at_idx : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>remove_at_idx i l</code> removes element at given index <code>i</code>. Does nothing if the index is too high. If the index is negative, it will remove element starting from the end of the list.</p></div></div><h3 id="set-operators"><a href="#set-operators" class="anchor"></a>Set Operators</h3><p>Those operations maintain the invariant that the list does not contain duplicates (if it already satisfies it).</p><div class="odoc-spec"><div class="spec value" id="val-add_nodup" class="anchored"><a href="#val-add_nodup" class="anchor"></a><code><span><span class="keyword">val</span> add_nodup : <span>eq:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>add_nodup ~eq x set</code> adds <code>x</code> to <code>set</code> if it was not already present. Linear time.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.11</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-remove_one" class="anchored"><a href="#val-remove_one" class="anchor"></a><code><span><span class="keyword">val</span> remove_one : <span>eq:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>remove_one ~eq x set</code> removes one occurrence of <code>x</code> from <code>set</code>. Linear time.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.11</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-mem" class="anchored"><a href="#val-mem" class="anchor"></a><code><span><span class="keyword">val</span> mem : <span>?eq:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>mem ?eq x l</code> is <code>true</code> iff <code>x</code> is equal to an element of <code>l</code>. A comparator function <code>eq</code> can be provided. Linear time.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-subset" class="anchored"><a href="#val-subset" class="anchor"></a><code><span><span class="keyword">val</span> subset : <span>eq:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>subset ~eq l1 l2</code> tests if all elements of the list <code>l1</code> are contained in the list <code>l2</code> by applying <code>eq</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-uniq" class="anchored"><a href="#val-uniq" class="anchor"></a><code><span><span class="keyword">val</span> uniq : <span>eq:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>uniq ~eq l</code> removes duplicates in <code>l</code> w.r.t the equality predicate <code>eq</code>. Complexity is quadratic in the length of the list, but the order of elements is preserved. If you wish for a faster de-duplication but do not care about the order, use <a href="#val-sort_uniq"><code>sort_uniq</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-union" class="anchored"><a href="#val-union" class="anchor"></a><code><span><span class="keyword">val</span> union : <span>eq:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>union ~eq l1 l2</code> is the union of the lists <code>l1</code> and <code>l2</code> w.r.t. the equality predicate <code>eq</code>. Complexity is product of length of inputs.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-inter" class="anchored"><a href="#val-inter" class="anchor"></a><code><span><span class="keyword">val</span> inter : <span>eq:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>inter ~eq l1 l2</code> is the intersection of the lists <code>l1</code> and <code>l2</code> w.r.t. the equality predicate <code>eq</code>. Complexity is product of length of inputs.</p></div></div><h3 id="other-constructors"><a href="#other-constructors" class="anchor"></a>Other Constructors</h3><div class="odoc-spec"><div class="spec value" id="val-range_by" class="anchored"><a href="#val-range_by" class="anchor"></a><code><span><span class="keyword">val</span> range_by : <span>step:int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>range_by ~step i j</code> iterates on integers from <code>i</code> to <code>j</code> included, where the difference between successive elements is <code>step</code>. Use a negative <code>step</code> for a decreasing list.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if <code>step=0</code>.</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.18</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-range" class="anchored"><a href="#val-range" class="anchor"></a><code><span><span class="keyword">val</span> range : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>range i j</code> iterates on integers from <code>i</code> to <code>j</code> included. It works both for decreasing and increasing ranges.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-range'" class="anchored"><a href="#val-range'" class="anchor"></a><code><span><span class="keyword">val</span> range' : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>range' i j</code> is like <a href="#val-range"><code>range</code></a> but the second bound <code>j</code> is excluded. For instance <code>range' 0 5 = [0;1;2;3;4]</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-(--)" class="anchored"><a href="#val-(--)" class="anchor"></a><code><span><span class="keyword">val</span> (--) : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>i -- j</code> is the list of integers from <code>i</code> to <code>j</code> included. Infix alias for <code>range</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-(--^)" class="anchored"><a href="#val-(--^)" class="anchor"></a><code><span><span class="keyword">val</span> (--^) : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>i --^ j</code> is the list of integers from <code>i</code> to <code>j</code> excluded. Infix alias for <code>range'</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.17</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-replicate" class="anchored"><a href="#val-replicate" class="anchor"></a><code><span><span class="keyword">val</span> replicate : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>replicate n x</code> replicates the given element <code>x</code> <code>n</code> times.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-repeat" class="anchored"><a href="#val-repeat" class="anchor"></a><code><span><span class="keyword">val</span> repeat : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>repeat n l</code> concatenates the list <code>l</code> with itself <code>n</code> times.</p></div></div><h3 id="association-lists_2"><a href="#association-lists_2" class="anchor"></a>Association Lists</h3><div class="odoc-spec"><div class="spec module" id="module-Assoc" class="anchored"><a href="#module-Assoc" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Assoc/index.html">Assoc</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-assoc" class="anchored"><a href="#val-assoc" class="anchor"></a><code><span><span class="keyword">val</span> assoc : <span>eq:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span></span></code></div><div class="spec-doc"><p><code>assoc ~eq k alist</code> returns the value <code>v</code> associated with key <code>k</code> in <code>alist</code>. Like <code>Assoc.get_exn</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-assoc_opt" class="anchored"><a href="#val-assoc_opt" class="anchor"></a><code><span><span class="keyword">val</span> assoc_opt : <span>eq:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span></span></code></div><div class="spec-doc"><p><code>assoc_opt ~eq k alist</code> returns <code>Some v</code> if the given key <code>k</code> is present into <code>alist</code>, or <code>None</code> if not present. Like <code>Assoc.get</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.5, but only</li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.0 with labels</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-assq_opt" class="anchored"><a href="#val-assq_opt" class="anchor"></a><code><span><span class="keyword">val</span> assq_opt : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span></span></code></div><div class="spec-doc"><p><code>assq_opt k alist</code> returns <code>Some v</code> if the given key <code>k</code> is present into <code>alist</code>. Like <code>Assoc.assoc_opt</code> but use physical equality instead of structural equality to compare keys. Safe version of <a href="#val-assq"><code>assq</code></a>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.5, but only</li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.0 with labels</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-mem_assoc" class="anchored"><a href="#val-mem_assoc" class="anchor"></a><code><span><span class="keyword">val</span> mem_assoc : <span>?eq:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">_</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>mem_assoc ?eq k alist</code> returns <code>true</code> iff <code>k</code> is a key in <code>alist</code>. Like <code>Assoc.mem</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-remove_assoc" class="anchored"><a href="#val-remove_assoc" class="anchor"></a><code><span><span class="keyword">val</span> remove_assoc : <span>eq:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>remove_assoc ~eq k alist</code> returns the <code>alist</code> without the first pair with key <code>k</code>, if any. Like <code>Assoc.remove</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.0</li></ul></div></div><h3 id="references-on-lists"><a href="#references-on-lists" class="anchor"></a>References on Lists</h3><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.3.3</li></ul><div class="odoc-spec"><div class="spec module" id="module-Ref" class="anchored"><a href="#module-Ref" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Ref/index.html">Ref</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module-type" id="module-type-MONAD" class="anchored"><a href="#module-type-MONAD" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span><a href="module-type-MONAD/index.html">MONAD</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Traverse" class="anchored"><a href="#module-Traverse" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Traverse/index.html">Traverse</a></span><span> (<a href="Traverse/argument-1-M/index.html">M</a> : <a href="module-type-MONAD/index.html">MONAD</a>) : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><h3 id="conversions"><a href="#conversions" class="anchor"></a>Conversions</h3><div class="odoc-spec"><div class="spec value" id="val-random" class="anchored"><a href="#val-random" class="anchor"></a><code><span><span class="keyword">val</span> random : <span><span><span class="type-var">'a</span> <a href="#type-random_gen">random_gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <a href="#type-random_gen">random_gen</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-random_non_empty" class="anchored"><a href="#val-random_non_empty" class="anchor"></a><code><span><span class="keyword">val</span> random_non_empty : <span><span><span class="type-var">'a</span> <a href="#type-random_gen">random_gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <a href="#type-random_gen">random_gen</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-random_len" class="anchored"><a href="#val-random_len" class="anchor"></a><code><span><span class="keyword">val</span> random_len : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-random_gen">random_gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <a href="#type-random_gen">random_gen</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-random_choose" class="anchored"><a href="#val-random_choose" class="anchor"></a><code><span><span class="keyword">val</span> random_choose : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-random_gen">random_gen</a></span></span></code></div><div class="spec-doc"><p><code>random_choose l</code> randomly chooses an element in the list <code>l</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Not_found</span> <p>if the list is empty.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-random_sequence" class="anchored"><a href="#val-random_sequence" class="anchor"></a><code><span><span class="keyword">val</span> random_sequence : <span><span><span><span class="type-var">'a</span> <a href="#type-random_gen">random_gen</a></span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <a href="#type-random_gen">random_gen</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-to_string" class="anchored"><a href="#val-to_string" class="anchor"></a><code><span><span class="keyword">val</span> to_string : <span>?start:string <span class="arrow">&#45;&gt;</span></span> <span>?stop:string <span class="arrow">&#45;&gt;</span></span> <span>?sep:string <span class="arrow">&#45;&gt;</span></span>
<span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> string)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>to_string ?start ?stop ?sep item_to_string l</code> print <code>l</code> to a string using <code>sep</code> as a separator between elements of <code>l</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.7</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-to_iter" class="anchored"><a href="#val-to_iter" class="anchor"></a><code><span><span class="keyword">val</span> to_iter : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-iter">iter</a></span></span></code></div><div class="spec-doc"><p><code>to_iter l</code> returns a <code>iter</code> of the elements of the list <code>l</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.8</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-to_seq" class="anchored"><a href="#val-to_seq" class="anchor"></a><code><span><span class="keyword">val</span> to_seq : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../../ocaml/Stdlib/Seq/index.html#type-t">Seq.t</a></span></span></code></div><div class="spec-doc"><p><code>to_seq l</code> returns a <code>Seq.t</code> of the elements of the list <code>l</code>. Renamed from <code>to_std_seq</code> since 3.0.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-of_iter" class="anchored"><a href="#val-of_iter" class="anchor"></a><code><span><span class="keyword">val</span> of_iter : <span><span><span class="type-var">'a</span> <a href="#type-iter">iter</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>of_iter iter</code> builds a list from a given <code>iter</code>. In the result, elements appear in the same order as they did in the source <code>iter</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.8</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-of_seq_rev" class="anchored"><a href="#val-of_seq_rev" class="anchor"></a><code><span><span class="keyword">val</span> of_seq_rev : <span><span><span class="type-var">'a</span> <a href="../../ocaml/Stdlib/Seq/index.html#type-t">Seq.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>of_seq_rev seq</code> builds a list from a given <code>Seq.t</code>, in reverse order. Renamed from <code>of_std_seq_rev</code> since 3.0.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-of_seq" class="anchored"><a href="#val-of_seq" class="anchor"></a><code><span><span class="keyword">val</span> of_seq : <span><span><span class="type-var">'a</span> <a href="../../ocaml/Stdlib/Seq/index.html#type-t">Seq.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>of_seq seq</code> builds a list from a given <code>Seq.t</code>. In the result, elements appear in the same order as they did in the source <code>Seq.t</code>. Renamed from <code>of_std_seq</code> since 3.0.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-to_gen" class="anchored"><a href="#val-to_gen" class="anchor"></a><code><span><span class="keyword">val</span> to_gen : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p><code>to_gen l</code> returns a <code>gen</code> of the elements of the list <code>l</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_gen" class="anchored"><a href="#val-of_gen" class="anchor"></a><code><span><span class="keyword">val</span> of_gen : <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>of_gen gen</code> builds a list from a given <code>gen</code>. In the result, elements appear in the same order as they did in the source <code>gen</code>.</p></div></div><h3 id="infix-operators"><a href="#infix-operators" class="anchor"></a>Infix Operators</h3><p>It is convenient to <code>open CCList</code>.Infix to access the infix operators without cluttering the scope too much.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.16</li></ul><div class="odoc-spec"><div class="spec module" id="module-Infix" class="anchored"><a href="#module-Infix" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Infix/index.html">Infix</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-include"><div class="spec-doc"><p>Let operators on OCaml &gt;= 4.08.0, nothing otherwise</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.8</li></ul></div><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../CCShimsMkLet_/module-type-S/index.html">CCShimsMkLet_.S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="../CCShimsMkLet_/module-type-S/index.html#type-t_let">t_let</a></span> := <span><span class="type-var">'a</span> list</span></span></span></code></summary><div class="odoc-spec"><div class="spec value" id="val-let+" class="anchored"><a href="#val-let+" class="anchor"></a><code><span><span class="keyword">val</span> let+ : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> list</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-and+" class="anchored"><a href="#val-and+" class="anchor"></a><code><span><span class="keyword">val</span> and+ : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-let*" class="anchored"><a href="#val-let*" class="anchor"></a><code><span><span class="keyword">val</span> let* : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> list</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> list</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-and*" class="anchored"><a href="#val-and*" class="anchor"></a><code><span><span class="keyword">val</span> and* : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span></span></code></div></div></details></div><h3 id="io"><a href="#io" class="anchor"></a>IO</h3><div class="odoc-spec"><div class="spec value" id="val-pp" class="anchored"><a href="#val-pp" class="anchor"></a><code><span><span class="keyword">val</span> pp : <span>?pp_start:<span>unit <a href="#type-printer">printer</a></span> <span class="arrow">&#45;&gt;</span></span> <span>?pp_stop:<span>unit <a href="#type-printer">printer</a></span> <span class="arrow">&#45;&gt;</span></span> <span>?pp_sep:<span>unit <a href="#type-printer">printer</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-printer">printer</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <a href="#type-printer">printer</a></span></span></code></div><div class="spec-doc"><p><code>pp ?pp_start ?pp_stop ?pp_sep ppf l</code> prints the contents of a list.</p></div></div></div></body></html>