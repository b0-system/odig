<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Xmlm (xmlm.Xmlm)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../index.html">xmlm</a> &#x00BB; Xmlm</nav><header class="odoc-preamble"><h1>Module <code><span>Xmlm</span></code></h1><p>Streaming XML codec.</p><p>A well-formed sequence of <a href="#type-signal">signals</a> represents an <a href="http://www.w3.org/TR/REC-xml">XML</a> document tree traversal in depth first order (this has nothing to do with XML well-formedness). Input pulls a well-formed sequence of signals from a data source and output pushes a well-formed sequence of signals to a data destination. Functions are provided to easily transform sequences of signals to/from arborescent data structures.</p><p>Consult the <a href="#io">features and limitations</a> and <a href="#ex">examples</a> of use.</p><p><em>v1.3.0 — <a href="http://erratique.ch/software/xmlm">homepage</a></em></p></header><nav class="odoc-toc"><ul><li><a href="#references">References</a></li><li><a href="#basic-types-and-values">Basic types and values</a></li><li><a href="#input">Input</a></li><li><a href="#output">Output</a></li><li><a href="#sto">Functorial interface (deprecated)</a></li><li><a href="#io">Features and limitations</a><ul><li><a href="#input_4">Input</a><ul><li><a href="#inenc">Encoding</a></li><li><a href="#inwspace">White space handling</a></li><li><a href="#inns">Namespaces</a></li><li><a href="#inentity">Character and entity references</a></li><li><a href="#iseq">Sequences of documents (deprecated)</a></li><li><a href="#inmisc">Miscellaneous</a></li></ul></li><li><a href="#output_4">Output</a><ul><li><a href="#outenc">Encoding</a></li><li><a href="#outns">Namespaces</a></li><li><a href="#outindent">Indentation</a></li><li><a href="#oseq">Sequences of documents (deprecated)</a></li><li><a href="#outmisc">Miscellaneous</a></li></ul></li><li><a href="#tips">Tips</a></li></ul></li><li><a href="#ex">Examples</a><ul><li><a href="#exseq">Sequential processing</a></li><li><a href="#extree">Tree processing</a></li><li><a href="#exrow">Tabular data processing</a></li></ul></li></ul></nav><div class="odoc-content"><h4 id="references"><a href="#references" class="anchor"></a>References</h4><ul><li>Tim Bray. <em><a href="http://www.xml.com/axml/axml.html">The annotated XML Specification</a></em>, 1998.</li><li>Tim Bray et al. <em><a href="http://www.w3.org/TR/xml-names11">Namespaces in XML 1.1 (2nd ed.)</a></em>, 2006.</li></ul><h2 id="basic-types-and-values"><a href="#basic-types-and-values" class="anchor"></a>Basic types and values</h2><div class="odoc-spec"><div class="spec type" id="type-encoding" class="anchored"><a href="#type-encoding" class="anchor"></a><code><span><span class="keyword">type</span> encoding</span><span> = </span><span>[ </span></code><table><tr id="type-encoding.UTF_8" class="anchored"><td class="def constructor"><a href="#type-encoding.UTF_8" class="anchor"></a><code><span>| </span></code><code><span>`UTF_8</span></code></td></tr><tr id="type-encoding.UTF_16" class="anchored"><td class="def constructor"><a href="#type-encoding.UTF_16" class="anchor"></a><code><span>| </span></code><code><span>`UTF_16</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Endianness determined from the <a href="http://www.unicode.org/unicode/faq/utf_bom.html#BOM">BOM</a>.</p><span class="comment-delim">*)</span></td></tr><tr id="type-encoding.UTF_16BE" class="anchored"><td class="def constructor"><a href="#type-encoding.UTF_16BE" class="anchor"></a><code><span>| </span></code><code><span>`UTF_16BE</span></code></td></tr><tr id="type-encoding.UTF_16LE" class="anchored"><td class="def constructor"><a href="#type-encoding.UTF_16LE" class="anchor"></a><code><span>| </span></code><code><span>`UTF_16LE</span></code></td></tr><tr id="type-encoding.ISO_8859_1" class="anchored"><td class="def constructor"><a href="#type-encoding.ISO_8859_1" class="anchor"></a><code><span>| </span></code><code><span>`ISO_8859_1</span></code></td></tr><tr id="type-encoding.US_ASCII" class="anchored"><td class="def constructor"><a href="#type-encoding.US_ASCII" class="anchor"></a><code><span>| </span></code><code><span>`US_ASCII</span></code></td></tr></table><code><span> ]</span></code></div><div class="spec-doc"><p>The type for character encodings. For <code>`UTF_16</code>, endianness is determined from the <a href="http://www.unicode.org/unicode/faq/utf_bom.html#BOM">BOM</a>.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-dtd" class="anchored"><a href="#type-dtd" class="anchor"></a><code><span><span class="keyword">type</span> dtd</span><span> = <span>string option</span></span></code></div><div class="spec-doc"><p>The type for the optional <a href="http://www.w3.org/TR/REC-xml/#dt-doctype">DTD</a>.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-name" class="anchored"><a href="#type-name" class="anchor"></a><code><span><span class="keyword">type</span> name</span><span> = string * string</span></code></div><div class="spec-doc"><p>The type for attribute and element's <a href="http://www.w3.org/TR/xml-names11/#dt-expname">expanded names</a> <code>(uri,local)</code>. An empty <code>uri</code> represents a name without a namespace name, i.e. an unprefixed name that is not under the scope of a default namespace.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-attribute" class="anchored"><a href="#type-attribute" class="anchor"></a><code><span><span class="keyword">type</span> attribute</span><span> = <a href="#type-name">name</a> * string</span></code></div><div class="spec-doc"><p>The type for attributes. Name and attribute data.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-tag" class="anchored"><a href="#type-tag" class="anchor"></a><code><span><span class="keyword">type</span> tag</span><span> = <a href="#type-name">name</a> * <span><a href="#type-attribute">attribute</a> list</span></span></code></div><div class="spec-doc"><p>The type for an element tag. Tag name and attribute list.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-signal" class="anchored"><a href="#type-signal" class="anchor"></a><code><span><span class="keyword">type</span> signal</span><span> = </span><span>[ </span></code><table><tr id="type-signal.Dtd" class="anchored"><td class="def constructor"><a href="#type-signal.Dtd" class="anchor"></a><code><span>| </span></code><code><span>`Dtd <span class="keyword">of</span> <a href="#type-dtd">dtd</a></span></code></td></tr><tr id="type-signal.El_start" class="anchored"><td class="def constructor"><a href="#type-signal.El_start" class="anchor"></a><code><span>| </span></code><code><span>`El_start <span class="keyword">of</span> <a href="#type-tag">tag</a></span></code></td></tr><tr id="type-signal.El_end" class="anchored"><td class="def constructor"><a href="#type-signal.El_end" class="anchor"></a><code><span>| </span></code><code><span>`El_end</span></code></td></tr><tr id="type-signal.Data" class="anchored"><td class="def constructor"><a href="#type-signal.Data" class="anchor"></a><code><span>| </span></code><code><span>`Data <span class="keyword">of</span> string</span></code></td></tr></table><code><span> ]</span></code></div><div class="spec-doc"><p>The type for signals. A <em>well-formed</em> sequence of signals belongs to the language of the <code>doc</code> grammar :</p><pre><code>doc ::= `Dtd tree
tree ::= `El_start child `El_end
child ::= `Data trees | trees
trees ::= tree child | epsilon</code></pre><p>The <code>trees</code> production is used to expresses the fact that there will never be two consecutive `Data signals in the children of an element.</p><p>Input and output deal only with well-formed sequences or exceptions are raised. However on output consecutive <code>`Data</code> signals are allowed.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-ns_xml" class="anchored"><a href="#val-ns_xml" class="anchor"></a><code><span><span class="keyword">val</span> ns_xml : string</span></code></div><div class="spec-doc"><p>Namespace name <a href="http://www.w3.org/XML/1998/namespace">value</a> bound to the reserved <code>&quot;xml&quot;</code> prefix.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-ns_xmlns" class="anchored"><a href="#val-ns_xmlns" class="anchor"></a><code><span><span class="keyword">val</span> ns_xmlns : string</span></code></div><div class="spec-doc"><p>Namespace name <a href="http://www.w3.org/2000/xmlns/">value</a> bound to the reserved <code>&quot;xmlns&quot;</code> prefix.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_dtd" class="anchored"><a href="#val-pp_dtd" class="anchor"></a><code><span><span class="keyword">val</span> pp_dtd : <span><a href="../../ocaml/Stdlib/Format/index.html#type-formatter">Format.formatter</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-dtd">dtd</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>pp_dtd ppf dtd</code> prints an unspecified representation of <code>dtd</code> on <code>ppf</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_name" class="anchored"><a href="#val-pp_name" class="anchor"></a><code><span><span class="keyword">val</span> pp_name : <span><a href="../../ocaml/Stdlib/Format/index.html#type-formatter">Format.formatter</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-name">name</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>pp_name ppf name</code> prints an unspecified representation of <code>name</code> on <code>ppf</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_attribute" class="anchored"><a href="#val-pp_attribute" class="anchor"></a><code><span><span class="keyword">val</span> pp_attribute : <span><a href="../../ocaml/Stdlib/Format/index.html#type-formatter">Format.formatter</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-attribute">attribute</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>pp_attribute ppf att</code> prints an unspecified representation of <code>att</code> on <code>ppf</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_tag" class="anchored"><a href="#val-pp_tag" class="anchor"></a><code><span><span class="keyword">val</span> pp_tag : <span><a href="../../ocaml/Stdlib/Format/index.html#type-formatter">Format.formatter</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-tag">tag</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>pp_tag ppf tag</code> prints an unspecified representation of <code>tag</code> on <code>ppf</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_signal" class="anchored"><a href="#val-pp_signal" class="anchor"></a><code><span><span class="keyword">val</span> pp_signal : <span><a href="../../ocaml/Stdlib/Format/index.html#type-formatter">Format.formatter</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-signal">signal</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>pp_signal ppf s</code> prints an unspecified representation of <code>s</code> on <code>ppf</code>.</p></div></div><h2 id="input"><a href="#input" class="anchor"></a>Input</h2><div class="odoc-spec"><div class="spec type" id="type-pos" class="anchored"><a href="#type-pos" class="anchor"></a><code><span><span class="keyword">type</span> pos</span><span> = int * int</span></code></div><div class="spec-doc"><p>The type for input positions. Line and column number, both start with 1.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-error" class="anchored"><a href="#type-error" class="anchor"></a><code><span><span class="keyword">type</span> error</span><span> = </span><span>[ </span></code><table><tr id="type-error.Max_buffer_size" class="anchored"><td class="def constructor"><a href="#type-error.Max_buffer_size" class="anchor"></a><code><span>| </span></code><code><span>`Max_buffer_size</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Maximal buffer size exceeded (<code>Sys.max_string_length</code>).</p><span class="comment-delim">*)</span></td></tr><tr id="type-error.Unexpected_eoi" class="anchored"><td class="def constructor"><a href="#type-error.Unexpected_eoi" class="anchor"></a><code><span>| </span></code><code><span>`Unexpected_eoi</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Unexpected end of input.</p><span class="comment-delim">*)</span></td></tr><tr id="type-error.Malformed_char_stream" class="anchored"><td class="def constructor"><a href="#type-error.Malformed_char_stream" class="anchor"></a><code><span>| </span></code><code><span>`Malformed_char_stream</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Malformed underlying character stream.</p><span class="comment-delim">*)</span></td></tr><tr id="type-error.Unknown_encoding" class="anchored"><td class="def constructor"><a href="#type-error.Unknown_encoding" class="anchor"></a><code><span>| </span></code><code><span>`Unknown_encoding <span class="keyword">of</span> string</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Unknown encoding.</p><span class="comment-delim">*)</span></td></tr><tr id="type-error.Unknown_entity_ref" class="anchored"><td class="def constructor"><a href="#type-error.Unknown_entity_ref" class="anchor"></a><code><span>| </span></code><code><span>`Unknown_entity_ref <span class="keyword">of</span> string</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Unknown entity reference, <a href="#inentity">details</a>.</p><span class="comment-delim">*)</span></td></tr><tr id="type-error.Unknown_ns_prefix" class="anchored"><td class="def constructor"><a href="#type-error.Unknown_ns_prefix" class="anchor"></a><code><span>| </span></code><code><span>`Unknown_ns_prefix <span class="keyword">of</span> string</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Unknown namespace prefix <a href="#inns">details</a></p><span class="comment-delim">*)</span></td></tr><tr id="type-error.Illegal_char_ref" class="anchored"><td class="def constructor"><a href="#type-error.Illegal_char_ref" class="anchor"></a><code><span>| </span></code><code><span>`Illegal_char_ref <span class="keyword">of</span> string</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Illegal character reference.</p><span class="comment-delim">*)</span></td></tr><tr id="type-error.Illegal_char_seq" class="anchored"><td class="def constructor"><a href="#type-error.Illegal_char_seq" class="anchor"></a><code><span>| </span></code><code><span>`Illegal_char_seq <span class="keyword">of</span> string</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Illegal character sequence.</p><span class="comment-delim">*)</span></td></tr><tr id="type-error.Expected_char_seqs" class="anchored"><td class="def constructor"><a href="#type-error.Expected_char_seqs" class="anchor"></a><code><span>| </span></code><code><span>`Expected_char_seqs <span class="keyword">of</span> <span>string list</span> * string</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Expected one of the character sequences in the list but found another.</p><span class="comment-delim">*)</span></td></tr><tr id="type-error.Expected_root_element" class="anchored"><td class="def constructor"><a href="#type-error.Expected_root_element" class="anchor"></a><code><span>| </span></code><code><span>`Expected_root_element</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Expected the document's root element.</p><span class="comment-delim">*)</span></td></tr></table><code><span> ]</span></code></div><div class="spec-doc"><p>The type for input errors.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-error_message" class="anchored"><a href="#val-error_message" class="anchor"></a><code><span><span class="keyword">val</span> error_message : <span><a href="#type-error">error</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Converts the error to an english error message.</p></div></div><div class="odoc-spec"><div class="spec exception" id="exception-Error" class="anchored"><a href="#exception-Error" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Error</span> <span class="keyword">of</span> <a href="#type-pos">pos</a> * <a href="#type-error">error</a></span></code></div><div class="spec-doc"><p>Raised on input errors.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-source" class="anchored"><a href="#type-source" class="anchor"></a><code><span><span class="keyword">type</span> source</span><span> = </span><span>[ </span></code><table><tr id="type-source.Channel" class="anchored"><td class="def constructor"><a href="#type-source.Channel" class="anchor"></a><code><span>| </span></code><code><span>`Channel <span class="keyword">of</span> <a href="../../ocaml/Stdlib/index.html#type-in_channel">in_channel</a></span></code></td></tr><tr id="type-source.String" class="anchored"><td class="def constructor"><a href="#type-source.String" class="anchor"></a><code><span>| </span></code><code><span>`String <span class="keyword">of</span> int * string</span></code></td></tr><tr id="type-source.Fun" class="anchored"><td class="def constructor"><a href="#type-source.Fun" class="anchor"></a><code><span>| </span></code><code><span>`Fun <span class="keyword">of</span> <span>unit <span class="arrow">&#45;&gt;</span></span> int</span></code></td></tr></table><code><span> ]</span></code></div><div class="spec-doc"><p>The type for input sources. For <code>`String</code> starts reading at the given integer position. For <code>`Fun</code> the function must return the next <em>byte</em> as an <code>int</code> and raise <code>End_of_file</code> if there is no such byte.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-input" class="anchored"><a href="#type-input" class="anchor"></a><code><span><span class="keyword">type</span> input</span></code></div><div class="spec-doc"><p>The type for input abstractions.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-make_input" class="anchored"><a href="#val-make_input" class="anchor"></a><code><span><span class="keyword">val</span> make_input : <span>?enc:<span><a href="#type-encoding">encoding</a> option</span> <span class="arrow">&#45;&gt;</span></span> <span>?strip:bool <span class="arrow">&#45;&gt;</span></span> <span>?ns:<span>(<span>string <span class="arrow">&#45;&gt;</span></span> <span>string option</span>)</span> <span class="arrow">&#45;&gt;</span></span>
<span>?entity:<span>(<span>string <span class="arrow">&#45;&gt;</span></span> <span>string option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-source">source</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-input">input</a></span></code></div><div class="spec-doc"><p>Returns a new input abstraction reading from the given source.</p><ul><li><code>enc</code>, character encoding of the document, <a href="#inenc">details</a>. Defaults to <code>None</code>.</li><li><code>strip</code>, strips whitespace in character data, <a href="#inwspace">details</a>. Defaults to <code>false</code>.</li><li><code>ns</code> is called to bind undeclared namespace prefixes, <a href="#inns">details</a>. Default returns always <code>None</code>.</li><li><code>entity</code> is called to resolve non predefined entity references, <a href="#inentity">details</a>. Default returns always <code>None</code>.</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-input" class="anchored"><a href="#val-input" class="anchor"></a><code><span><span class="keyword">val</span> input : <span><a href="#type-input">input</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-signal">signal</a></span></code></div><div class="spec-doc"><p>Inputs a signal. Repeated invocation of the function with the same input abstraction will generate a <a href="#type-signal">well-formed</a> sequence of signals or an <a href="#exception-Error"><code>Error</code></a> is raised. Furthermore there will be no two consecutive <code>`Data</code> signals in the sequence and their string is always non empty.</p><p><b>Deprecated</b> After a well-formed sequence was input another may be input, see <a href="#val-eoi"><code>eoi</code></a> and <a href="#iseq">details</a>.</p><p><b>Raises</b> <a href="#exception-Error"><code>Error</code></a> on input errors.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-input_tree" class="anchored"><a href="#val-input_tree" class="anchor"></a><code><span><span class="keyword">val</span> input_tree : <span>el:<span>(<span><a href="#type-tag">tag</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>data:<span>(<span>string <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-input">input</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>If the next signal is a :</p><ul><li><code>`Data</code> signal, inputs it and invokes <code>data</code> with the character data.</li><li><p><code>`El_start</code> signal, inputs the sequence of signals until its matching <code>`El_end</code> and invokes <code>el</code> and <code>data</code> as follows</p><ul><li><code>el</code>, is called on each <code>`El_end</code> signals with the corresponding <code>`El_start</code> tag and the result of the callback invocation for the element's children.</li><li><code>data</code>, is called on each <code>`Data</code> signals with the character data. This function won't be called twice consecutively or with the empty string.</li></ul></li><li>Other signals, raises <code>Invalid_argument</code>.</li></ul><p><b>Raises</b> <a href="#exception-Error"><code>Error</code></a> on input errors and <code>Invalid_argument</code> if the next signal is not <code>`El_start</code> or <code>`Data</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-input_doc_tree" class="anchored"><a href="#val-input_doc_tree" class="anchor"></a><code><span><span class="keyword">val</span> input_doc_tree : <span>el:<span>(<span><a href="#type-tag">tag</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>data:<span>(<span>string <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-input">input</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-dtd">dtd</a> * <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Same as <a href="#val-input_tree"><code>input_tree</code></a> but reads a complete <a href="#type-signal">well-formed</a> sequence of signals.</p><p><b>Raises</b> <a href="#exception-Error"><code>Error</code></a> on input errors and <code>Invalid_argument</code> if the next signal is not <code>`Dtd</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-peek" class="anchored"><a href="#val-peek" class="anchor"></a><code><span><span class="keyword">val</span> peek : <span><a href="#type-input">input</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-signal">signal</a></span></code></div><div class="spec-doc"><p>Same as <a href="#input">Input</a> but doesn't remove the signal from the sequence.</p><p><b>Raises</b> <a href="#exception-Error"><code>Error</code></a> on input errors.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-eoi" class="anchored"><a href="#val-eoi" class="anchor"></a><code><span><span class="keyword">val</span> eoi : <span><a href="#type-input">input</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Returns <code>true</code> if the end of input is reached. See <a href="#iseq">details</a>.</p><p><b>Raises</b> <a href="#exception-Error"><code>Error</code></a> on input errors.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pos" class="anchored"><a href="#val-pos" class="anchor"></a><code><span><span class="keyword">val</span> pos : <span><a href="#type-input">input</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-pos">pos</a></span></code></div><div class="spec-doc"><p>Current position in the input abstraction.</p></div></div><h2 id="output"><a href="#output" class="anchor"></a>Output</h2><div class="odoc-spec"><div class="spec type" id="type-frag" class="anchored"><a href="#type-frag" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a frag</span></span><span> = </span><span>[ </span></code><table><tr id="type-frag.El" class="anchored"><td class="def constructor"><a href="#type-frag.El" class="anchor"></a><code><span>| </span></code><code><span>`El <span class="keyword">of</span> <a href="#type-tag">tag</a> * <span><span class="type-var">'a</span> list</span></span></code></td></tr><tr id="type-frag.Data" class="anchored"><td class="def constructor"><a href="#type-frag.Data" class="anchor"></a><code><span>| </span></code><code><span>`Data <span class="keyword">of</span> string</span></code></td></tr></table><code><span> ]</span></code></div><div class="spec-doc"><p>The type for deconstructing data structures of type <code>'a</code>.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-dest" class="anchored"><a href="#type-dest" class="anchor"></a><code><span><span class="keyword">type</span> dest</span><span> = </span><span>[ </span></code><table><tr id="type-dest.Channel" class="anchored"><td class="def constructor"><a href="#type-dest.Channel" class="anchor"></a><code><span>| </span></code><code><span>`Channel <span class="keyword">of</span> <a href="../../ocaml/Stdlib/index.html#type-out_channel">out_channel</a></span></code></td></tr><tr id="type-dest.Buffer" class="anchored"><td class="def constructor"><a href="#type-dest.Buffer" class="anchor"></a><code><span>| </span></code><code><span>`Buffer <span class="keyword">of</span> <a href="../../ocaml/Stdlib/Buffer/index.html#type-t">Buffer.t</a></span></code></td></tr><tr id="type-dest.Fun" class="anchored"><td class="def constructor"><a href="#type-dest.Fun" class="anchor"></a><code><span>| </span></code><code><span>`Fun <span class="keyword">of</span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></td></tr></table><code><span> ]</span></code></div><div class="spec-doc"><p>The type for output destinations. For <code>`Buffer</code>, the buffer won't be cleared. For <code>`Fun</code> the function is called with the output <em>bytes</em> as <code>int</code>s.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-output" class="anchored"><a href="#type-output" class="anchor"></a><code><span><span class="keyword">type</span> output</span></code></div><div class="spec-doc"><p>The type for output abstractions.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-make_output" class="anchored"><a href="#val-make_output" class="anchor"></a><code><span><span class="keyword">val</span> make_output : <span>?decl:bool <span class="arrow">&#45;&gt;</span></span> <span>?nl:bool <span class="arrow">&#45;&gt;</span></span> <span>?indent:<span>int option</span> <span class="arrow">&#45;&gt;</span></span>
<span>?ns_prefix:<span>(<span>string <span class="arrow">&#45;&gt;</span></span> <span>string option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-dest">dest</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-output">output</a></span></code></div><div class="spec-doc"><p>Returns a new output abstraction writing to the given destination.</p><ul><li><code>decl</code>, if <code>true</code> the <a href="http://www.w3.org/TR/REC-xml/#NT-XMLDecl">XML declaration</a> is output (defaults to <code>true</code>).</li><li><code>nl</code>, if <code>true</code> a newline is output when the root's element <code>`El_end</code> signal is output. Defaults to <code>false</code>.</li><li><code>indent</code>, identation behaviour, see <a href="#outindent">details</a>. Defaults to <code>None</code>.</li><li><code>ns_prefix</code>, undeclared namespace prefix bindings, see <a href="#outns">details</a>. Default returns always <code>None</code>.</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-output" class="anchored"><a href="#val-output" class="anchor"></a><code><span><span class="keyword">val</span> output : <span><a href="#type-output">output</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-signal">signal</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Outputs a signal.</p><p><b>Deprecated.</b> After a well-formed sequence of signals was output a new well-formed sequence can be output.</p><p><b>Raises</b> <code>Invalid_argument</code> if the resulting signal sequence on the output abstraction is not <a href="#type-signal">well-formed</a> or if a namespace name could not be bound to a prefix.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-output_depth" class="anchored"><a href="#val-output_depth" class="anchor"></a><code><span><span class="keyword">val</span> output_depth : <span><a href="#type-output">output</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>output_depth o</code> is <code>o</code>'s current element nesting level (undefined before the first <code>`El_start</code> and after the last <code>`El_end</code>).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-output_tree" class="anchored"><a href="#val-output_tree" class="anchor"></a><code><span><span class="keyword">val</span> output_tree : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-frag">frag</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-output">output</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Outputs signals corresponding to a value by recursively applying the given value deconstructor.</p><p><b>Raises</b> see <a href="#output">Output</a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-output_doc_tree" class="anchored"><a href="#val-output_doc_tree" class="anchor"></a><code><span><span class="keyword">val</span> output_doc_tree : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-frag">frag</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-output">output</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-dtd">dtd</a> * <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Same as <a href="#val-output_tree"><code>output_tree</code></a> but outputs a complete <a href="#type-signal">well-formed</a> sequence of signals.</p><p><b>Raises</b> see <a href="#output">Output</a>.</p></div></div><h2 id="sto"><a href="#sto" class="anchor"></a>Functorial interface (deprecated)</h2><p><b>WARNING.</b> The functioral interface is deprecated and will be removed.</p><p><a href="Make/index.html"><code>Make</code></a> allows client to specify types for strings and internal buffers. Among other things this can be used to perform hash-consing or to process the character stream, e.g. to normalize unicode characters or to convert to a custom encoding.</p><div class="odoc-spec"><div class="spec type" id="type-std_string" class="anchored"><a href="#type-std_string" class="anchor"></a><code><span><span class="keyword">type</span> std_string</span><span> = string</span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-std_buffer" class="anchored"><a href="#type-std_buffer" class="anchor"></a><code><span><span class="keyword">type</span> std_buffer</span><span> = <a href="../../ocaml/Stdlib/Buffer/index.html#type-t">Buffer.t</a></span></code></div></div><div class="odoc-spec"><div class="spec module-type" id="module-type-String" class="anchored"><a href="#module-type-String" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span><a href="module-type-String/index.html">String</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Input signature for strings.</p></div></div><div class="odoc-spec"><div class="spec module-type" id="module-type-Buffer" class="anchored"><a href="#module-type-Buffer" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span><a href="module-type-Buffer/index.html">Buffer</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Input signature for internal buffers.</p></div></div><div class="odoc-spec"><div class="spec module-type" id="module-type-S" class="anchored"><a href="#module-type-S" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span><a href="module-type-S/index.html">S</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Output signature of <a href="Make/index.html"><code>Make</code></a>.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Make" class="anchored"><a href="#module-Make" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Make/index.html">Make</a></span><span> (<a href="Make/argument-1-String/index.html">String</a> : <a href="module-type-String/index.html">String</a>) (<a href="Make/argument-2-Buffer/index.html">Buffer</a> : <a href="module-type-Buffer/index.html">Buffer</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="module-type-Buffer/index.html#type-string">string</a> = <a href="Make/argument-1-String/index.html#type-t">String.t</a></span>) : <a href="module-type-S/index.html">S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="module-type-S/index.html#type-string">string</a> = <a href="Make/argument-1-String/index.html#type-t">String.t</a></span></span></code></div><div class="spec-doc"><p>Functor building streaming XML IO with the given strings and buffers.</p></div></div><h2 id="io"><a href="#io" class="anchor"></a>Features and limitations</h2><p>The module assumes strings are immutable, thus strings the client gives or receives <em>during</em> the input and output process must not be modified.</p><h3 id="input_4"><a href="#input_4" class="anchor"></a>Input</h3><h4 id="inenc"><a href="#inenc" class="anchor"></a>Encoding</h4><p>The parser supports ASCII, US-ASCII, <a href="http://www.faqs.org/rfcs/rfc3629.html">UTF-8</a>, <a href="http://www.faqs.org/rfcs/rfc2781.html">UTF-16</a>, <a href="http://www.faqs.org/rfcs/rfc2781.html">UTF-16LE</a>, <a href="http://www.faqs.org/rfcs/rfc2781.html">UTF-16BE</a> and <a href="http://anubis.dkuug.dk/JTC1/SC2/WG3/docs/n411.pdf">ISO-8559-1</a> (Latin-1) encoded documents. But strings returned by the library are <b>always</b> UTF-8 encoded.</p><p>The encoding can be specified explicitly using the optional argument <code>enc</code>. Otherwise the parser uses UTF-16 or UTF-8 if there is a <a href="http://www.unicode.org/unicode/faq/utf_bom.html#BOM">BOM</a> at the beginning of the document. If there is no BOM it uses the encoding specified in the <a href="http://www.w3.org/TR/REC-xml/#NT-XMLDecl">XML declaration</a>. Finally, if there is no XML declaration UTF-8 is assumed.</p><h4 id="inwspace"><a href="#inwspace" class="anchor"></a>White space handling</h4><p>The parser performs <a href="http://www.w3.org/TR/REC-xml/#AVNormalize">attribute data normalization</a> on <em>every</em> attribute data. This means that attribute data does not have leading and trailling white space and that any white space is collapsed and transformed to a single space character (<code>U+0020</code>).</p><p>White space handling of character data depends on the <code>strip</code> argument. If <code>strip</code> is <code>true</code>, character data is treated like attribute data, white space before and after elements is removed and any white space is collapsed and transformed to a single space character (<code>U+0020</code>), except if the data is under the scope of a <em>xml:space</em> attribute whose value is <em>preserve</em>. If <code>strip</code> is <code>false</code> all white space data is preserved as present in the document (however all kinds of <a href="http://www.w3.org/TR/REC-xml/#sec-line-ends">line ends</a> are translated to the newline character (<code>U+000A</code>). </p><h4 id="inns"><a href="#inns" class="anchor"></a>Namespaces</h4><p>Xmlm's <a href="#type-name">names</a> are <a href="http://www.w3.org/TR/xml-names11/#dt-expname">expanded names</a>. The parser automatically handles the document's namespace declarations. Undeclared namespace prefixes can be bound via the callback <code>ns</code>, which must return a namespace name. If <code>ns</code> returns <code>None</code> an <code>`Unknown_ns_prefix</code> error is raised.</p><p>Attributes used for namespace declarations are preserved by the parser. They are in the <a href="#val-ns_xmlns"><code>ns_xmlns</code></a> namespace. Default namespace declarations made with <i>xmlns</i> have the attribute name <code>(Xmlm.ns_xmlns, &quot;xmlns&quot;)</code>. Prefix declarations have the prefix as the local name, for example <i>xmlns:ex</i> results in the attribute name <code>(Xmlm.ns_xmlns, &quot;ex&quot;)</code>.</p><p>Regarding constraints on the usage of the <i>xml</i> and <i>xmlns</i> prefixes by documents, the parser does not report errors on violations of the <i>must</i> constraints listed in <a href="http://www.w3.org/TR/xml-names11/#xmlReserved">this paragraph</a>.</p><h4 id="inentity"><a href="#inentity" class="anchor"></a>Character and entity references</h4><p><a href="http://www.w3.org/TR/REC-xml/#dt-charref">Character references</a> and <a href="http://www.w3.org/TR/REC-xml/#sec-predefined-ent">predefined entities</a> are automatically resolved. Other entity references can be resolved by the callback <code>entity</code>, which must return an UTF-8 string corresponding to the replacement character data. The replacement data is <em>not</em> analysed for further references, it is added to the data as such modulo white space stripping. If <code>entity</code> returns <code>None</code> the error <code>`Unknown_entity_ref</code> is returned.</p><h4 id="iseq"><a href="#iseq" class="anchor"></a>Sequences of documents (deprecated)</h4><p><b>WARNING.</b> This feature is deprecated and will be removed.</p><p>When a well-formed sequence of signals is input, no data is consumed beyond the closing <code>'&gt;'</code> of the document's root element.</p><p>If you want to parse a document as <a href="http://www.w3.org/TR/REC-xml/#NT-document">defined</a> in the XML specification, call <a href="#val-eoi"><code>eoi</code></a> after a well-formed sequence of signals, it must return <code>true</code>. If you expect another document on the same input abstraction a new well-formed sequence of signals can be <a href="#input">Input</a>. Use <a href="#val-eoi"><code>eoi</code></a> to check if a document follows (this may consume data).</p><p>Invoking <a href="#val-eoi"><code>eoi</code></a> after a well-formed sequence of signals skips whitespaces, comments and processing instructions until it gets to either an <a href="http://www.w3.org/TR/REC-xml/#NT-XMLDecl">XML declaration</a> or a <a href="http://www.w3.org/TR/REC-xml/#dt-doctype">DTD</a> or the start of a new element or the end of input (in which case <a href="#val-eoi"><code>eoi</code></a> returns <code>true</code>). If there is a new document but there is no XML declaration or the declaration specifies UTF-16, the same encoding as for the previous document is used.</p><h4 id="inmisc"><a href="#inmisc" class="anchor"></a>Miscellaneous</h4><ul><li>Parses the more liberal and simpler XML 1.1 <a href="http://www.w3.org/TR/xml11/#NT-Name">Name</a> definition (minus <code>':'</code> because of namespaces).</li><li>The <a href="http://www.w3.org/TR/REC-xml/#dt-doctype">DTD</a> is parsed roughly (no guarantee it is well formed) and its information is ignored.</li><li>The parser drops <a href="http://www.w3.org/TR/REC-xml/#dt-comment">comments</a>, <a href="http://www.w3.org/TR/REC-xml/#dt-pi">processing instructions</a>, and <a href="http://www.w3.org/TR/REC-xml/#sec-rmd">standalone declaration</a>.</li><li>Element attributes are not checked for uniqueness.</li><li>Attribute and character data chunks are limited by <code>Sys.max_string_length</code>. The error <code>`Max_buffer_size</code> is raised if the limit is hit.</li><li>Tail recursive.</li><li>Non validating.</li></ul><h3 id="output_4"><a href="#output_4" class="anchor"></a>Output</h3><h4 id="outenc"><a href="#outenc" class="anchor"></a>Encoding</h4><p>Outputs only <a href="http://www.faqs.org/rfcs/rfc3629.html">UTF-8</a> encoded documents. Strings given to output functions <b>must be</b> UTF-8 encoded, no checks are performed. Unicode characters that are not legal XML <a href="http://www.w3.org/TR/REC-xml/#NT-Char">characters</a> are replaced by the <a href="http://unicode.org/glossary/#replacement_character">Unicode replacement character</a>.</p><h4 id="outns"><a href="#outns" class="anchor"></a>Namespaces</h4><p>Xmlm's <a href="#TYPEname">names</a> are <a href="http://www.w3.org/TR/xml-names11/#dt-expname">expanded names</a>. Expanded names are automatically converted to <a href="http://www.w3.org/TR/xml-names11/#dt-qualname">qualified names</a> by the output abstraction. There is no particular api to specify prefixes and default namespaces, the actual result depends solely on the output of attributes belonging to the <a href="#val-ns_xmlns"><code>ns_xmlns</code></a> namespace. For example to set the default namespace of an element to <i>http://example.org/myns</i>, use the following attribute :</p><pre><code>(* xmlns='http://example.org/myns' *)
let default_ns = (Xmlm.ns_xmlns, &quot;xmlns&quot;), &quot;http://example.org/myns&quot;</code></pre><p>To bind the prefix <code>&quot;ex&quot;</code> to <i>http://example.org/ex</i>, use the following attribute :</p><pre><code>(* xmlns:ex='http://example.org/ex' *)
let ex_ns = (Xmlm.ns_xmlns, &quot;ex&quot;), &quot;http://example.org/ex&quot;</code></pre><p>Note that outputing input signals without touching namespace declaration attributes will preserve existing prefixes and bindings provided the same namespace name is not bound to different prefixes in a given context.</p><p>The callback <code>ns_prefix</code> of an output abstraction can be used to give a prefix to a namespace name lacking a prefix binding in the current output scope. Given a namespace name the function must return the prefix to use. Note that this will <b>not</b> add any namespace declaration attribute to the output. If the function returns <code>None</code>, <a href="#output">Output</a> will raise <code>Invalid_argument</code>. The default function returns always <code>None</code>.</p><h4 id="outindent"><a href="#outindent" class="anchor"></a>Indentation</h4><p>Output can be indented by specifying the <code>indent</code> argument when an output abstraction is created. If <code>indent</code> is <code>None</code> (default) signal output does not introduce any extra white space. If <code>ident</code> is <code>Some c</code>, each <a href="#type-signal"><code>signal</code></a> is output on its own line (for empty elements <code>`El_start</code> and <code>`El_end</code> are collapsed on a single line) and nested elements are indented with <code>c</code> space characters.</p><h4 id="oseq"><a href="#oseq" class="anchor"></a>Sequences of documents (deprecated)</h4><p><b>WARNING.</b> This feature is deprecated and will be removed.</p><p>After a well-formed sequence of signals was output, the output abstraction can be reused to output a new well-formed sequence of signals.</p><h4 id="outmisc"><a href="#outmisc" class="anchor"></a>Miscellaneous</h4><ul><li>Output on a channel does not flush it.</li><li>In attribute and character data you provide, markup delimiters <code>'&lt;'</code>,<code>'&gt;'</code>,<code>'&amp;'</code>, and <code>'\&quot;'</code> are automatically escaped to <a href="http://www.w3.org/TR/REC-xml/#sec-predefined-ent">predefined entities</a>.</li><li>No checks are peformed on the prefix and local part of output names to verify they are <a href="http://www.w3.org/TR/xml-names11/#NT-NCName">NCName</a>s. For example using the tag name <code>(&quot;&quot;,&quot;dip d&quot;)</code> will produce a non well-formed document because of the space character.</li><li>Tail recursive.</li></ul><h3 id="tips"><a href="#tips" class="anchor"></a>Tips</h3><ul><li>The best options to do an input/output round trip and preserve as much information as possible is to input with <code>strip = false</code> and output with <code>indent = None</code>.</li><li>Complete whitespace control on output is achieved with <code>indent = None</code> and suitable <code>`Data</code> signals</li></ul><h2 id="ex"><a href="#ex" class="anchor"></a>Examples</h2><h3 id="exseq"><a href="#exseq" class="anchor"></a>Sequential processing</h3><p>Sequential processing has the advantage that you don't need to get the whole document tree in memory to process it.</p><p>The following function reads a <em>single</em> document on an input channel and outputs it.</p><pre><code>let id ic oc =
let i = Xmlm.make_input (`Channel ic) in
let o = Xmlm.make_output (`Channel oc) in
let rec pull i o depth =
  Xmlm.output o (Xmlm.peek i);
  match Xmlm.input i with
  | `El_start _ -&gt; pull i o (depth + 1)
  | `El_end -&gt; if depth = 1 then () else pull i o (depth - 1)
  | `Data _ -&gt; pull i o depth
  | `Dtd _ -&gt; assert false
in
Xmlm.output o (Xmlm.input i); (* `Dtd *)
pull i o 0;
if not (Xmlm.eoi i) then invalid_arg &quot;document not well-formed&quot;</code></pre><p>The following function reads a <em>sequence</em> of documents on an input channel and outputs it.</p><pre><code>let id_seq ic oc =
let i = Xmlm.make_input (`Channel ic) in
let o = Xmlm.make_output ~nl:true (`Channel oc) in
while not (Xmlm.eoi i) do Xmlm.output o (Xmlm.input i) done</code></pre><p>The following function reads a <em>sequence</em> of documents on the input channel. In each document's tree it prunes non root elements whose name belongs to <code>prune_list</code>.</p><pre><code>let prune_docs prune_list ic oc =
let i = Xmlm.make_input (`Channel ic) in
let o = Xmlm.make_output ~nl:true (`Channel oc) in
let copy i o = Xmlm.output o (Xmlm.input i) in
let prune (name, _) = List.mem name prune_list in
let rec process i o d =
  let rec skip i d = match Xmlm.input i with
  | `El_start _ -&gt; skip i (d + 1)
  | `El_end -&gt; if d = 1 then () else skip i (d - 1)
  | s -&gt; skip i d
  in
  match Xmlm.peek i with
  | `El_start tag when prune tag -&gt; skip i 0; process i o d
  | `El_start _ -&gt; copy i o; process i o (d + 1)
  | `El_end -&gt; copy i o; if d = 0 then () else process i o (d - 1)
  | `Data _ -&gt; copy i o; process i o d
  | `Dtd _ -&gt; assert false
in
let rec docs i o =
  copy i o; (* `Dtd *)
  copy i o; (* root start *)
  process i o 0;
  if Xmlm.eoi i then () else docs i o
in
docs i o</code></pre><h3 id="extree"><a href="#extree" class="anchor"></a>Tree processing</h3><p>A document's sequence of signals can be easily converted to an arborescent data structure. Assume your trees are defined by :</p><pre><code>type tree = E of Xmlm.tag * tree list | D of string</code></pre><p>The following functions input/output xml documents from/to abstractions as value of type <code>tree</code>.</p><pre><code>let in_tree i =
  let el tag childs = E (tag, childs)  in
  let data d = D d in
  Xmlm.input_doc_tree ~el ~data i

let out_tree o t =
  let frag = function
  | E (tag, childs) -&gt; `El (tag, childs)
  | D d -&gt; `Data d
  in
  Xmlm.output_doc_tree frag o t</code></pre><h3 id="exrow"><a href="#exrow" class="anchor"></a>Tabular data processing</h3><p>We show how to process XML data that represents tabular data (some people like do that).</p><p>The file we need to deal with represents nominal data about <a href="http://www.w3.org/">W3C bureaucrats</a>. There are no namespaces and attributes are ignored. The element structure of the document is :</p><ul><li><p>&lt;list&gt;</p><ul><li><p>&lt;bureaucrat&gt; represents a W3C bureaucrat (zero or more).</p><p>A bureaucrat contains the following elements, in order.</p><ul><li>&lt;name&gt; its name (mandatory, string).</li><li>&lt;surname&gt; its surname (mandatory, string).</li><li>&lt;honest&gt; present iff he implemented one of its spec (optional, empty).</li><li>&lt;obfuscation_level&gt; its grade on the open scale of obfuscation (mandatory, float).</li><li>&lt;tr&gt; (zero or more, string), technical reports he worked on.</li></ul></li></ul></li></ul><p>In OCaml we represent a W3C bureaucrat by this type :</p><pre><code>type w3c_bureaucrat = {
  name : string;
  surname : string;
  honest : bool;
  obfuscation_level : float;
  trs : string list; }</code></pre><p>The following functions input and output W3C bureaucrats as lists of values of type <code>w3c_bureaucrat</code>.</p><pre><code>let in_w3c_bureaucrats src =
  let i = Xmlm.make_input ~strip:true src in
  let tag n = (&quot;&quot;, n), [] in
  let error () = invalid_arg &quot;parse error&quot; in
  let accept s i = if Xmlm.input i = s then () else error () in
  let rec i_seq el acc i = match Xmlm.peek i with
  | `El_start _ -&gt; i_seq el ((el i) :: acc) i
  | `El_end -&gt; List.rev acc
  | _ -&gt; error ()
  in
  let i_el n i =
    accept (`El_start (tag n)) i;
    let d = match Xmlm.peek i with
    | `Data d -&gt; ignore (Xmlm.input i); d
    | `El_end -&gt; &quot;&quot;
    | _ -&gt; error ()
    in
    accept (`El_end) i;
    d
  in
  let i_bureaucrat i =
    try
      accept (`El_start (tag &quot;bureaucrat&quot;)) i;
      let name = i_el &quot;name&quot; i in
      let surname = i_el &quot;surname&quot; i in
      let honest = match Xmlm.peek i with
      | `El_start ((&quot;&quot;, &quot;honest&quot;), []) -&gt; ignore (i_el &quot;honest&quot; i); true
      | _ -&gt; false
      in
      let obf = float_of_string (i_el &quot;obfuscation_level&quot; i) in
      let trs = i_seq (i_el &quot;tr&quot;) [] i in
      accept (`El_end) i;
      { name = name; surname = surname; honest = honest;
        obfuscation_level = obf; trs = trs }
    with
    | Failure _ -&gt; error () (* float_of_string *)
  in
  accept (`Dtd None) i;
  accept (`El_start (tag &quot;list&quot;)) i;
  let bl = i_seq i_bureaucrat [] i in
  accept (`El_end) i;
  if not (Xmlm.eoi i) then invalid_arg &quot;more than one document&quot;;
  bl

let out_w3c_bureaucrats dst bl =
  let tag n = (&quot;&quot;, n), [] in
  let o = Xmlm.make_output ~nl:true ~indent:(Some 2) dst in
  let out = Xmlm.output o in
  let o_el n d =
    out (`El_start (tag n));
    if d &lt;&gt; &quot;&quot; then out (`Data d);
    out `El_end
  in
  let o_bureaucrat b =
    out (`El_start (tag &quot;bureaucrat&quot;));
    o_el &quot;name&quot; b.name;
    o_el &quot;surname&quot; b.surname;
    if b.honest then o_el &quot;honest&quot; &quot;&quot;;
    o_el &quot;obfuscation_level&quot; (string_of_float b.obfuscation_level);
    List.iter (o_el &quot;tr&quot;) b.trs;
    out `El_end
  in
  out (`Dtd None);
  out (`El_start (tag &quot;list&quot;));
  List.iter o_bureaucrat bl;
  out (`El_end)</code></pre></div></body></html>