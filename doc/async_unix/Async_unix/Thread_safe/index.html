<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Thread_safe (async_unix.Async_unix.Thread_safe)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">async_unix</a> &#x00BB; <a href="../index.html">Async_unix</a> &#x00BB; Thread_safe</nav><h1>Module <code>Async_unix.Thread_safe</code></h1><p>The <code>Thread_safe</code> module has functions that are safe to call from threads outside Async, such as the ones spawned by <code>In_thread.run</code>.</p><p>This is in contrast with the rest of <code>Async</code> library which is generally not thread-safe.</p><p>All the <code>Thread_safe.block*</code> and <code>Thread_safe.run*</code> functions wake up the Async scheduler to ensure that it continues in a timely manner with whatever jobs got started. Some functions take an optional <code>?wakeup_scheduler:bool</code> argument, which defaults to <code>true</code>. One can cause the scheduler to not be woken up by supplying <code>~wakeup_scheduler:false</code>, which can reduce CPU use, but increase latency, because the scheduler may not wake up for a while to process jobs.</p></header><dl><dt class="spec value" id="val-am_holding_async_lock"><a href="#val-am_holding_async_lock" class="anchor"></a><code><span class="keyword">val</span> am_holding_async_lock : unit <span>&#45;&gt;</span> bool</code></dt><dd><p><code>am_holding_async_lock ()</code> returns true if the currently running thread is holding the Async lock.</p></dd></dl><dl><dt class="spec value" id="val-deferred"><a href="#val-deferred" class="anchor"></a><code><span class="keyword">val</span> deferred : unit <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a> * (<span class="type-var">'a</span> <span>&#45;&gt;</span> unit)</code></dt><dd><p><code>deferred ()</code> returns <code>(d, fill)</code> where <code>d</code> is a deferred that will become determined with value <code>v</code> once <code>fill v</code> is called.</p><p>It is ok to call <code>deferred</code> from inside or outside Async. <code>fill</code> must be called from outside Async.</p></dd></dl><dl><dt class="spec value" id="val-run_in_async_with_optional_cycle"><a href="#val-run_in_async_with_optional_cycle" class="anchor"></a><code><span class="keyword">val</span> run_in_async_with_optional_cycle : ?&#8288;wakeup_scheduler:bool <span>&#45;&gt;</span> (unit <span>&#45;&gt;</span> [ `Run_a_cycle | `Do_not_run_a_cycle ] * <span class="type-var">'a</span>) <span>&#45;&gt;</span> (<span class="type-var">'a</span>, exn) <a href="../../../core_kernel/Core_kernel/Result/index.html#type-t">Core.Result.t</a></code></dt><dd><p><code>run_in_async_with_optional_cycle f</code> acquires the Async lock and runs <code>f ()</code> while holding the lock. Depending on the result of <code>f</code>, it may also run a cycle.</p></dd></dl><dl><dt class="spec value" id="val-run_in_async"><a href="#val-run_in_async" class="anchor"></a><code><span class="keyword">val</span> run_in_async : ?&#8288;wakeup_scheduler:bool <span>&#45;&gt;</span> (unit <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> (<span class="type-var">'a</span>, exn) <a href="../../../core_kernel/Core_kernel/Result/index.html#type-t">Core.Result.t</a></code></dt><dd><p><code>run_in_async f</code> acquires the Async lock and runs <code>f ()</code> while holding the lock. It returns the result of <code>f ()</code> to the outside world. The scheduler is woken up to ensure the code that depends on <code>f ()</code> is run soon enough.</p><p><code>run_in_async</code> doesn't run a cycle.</p><p><code>run_in_async</code> does not automatically start the Async scheduler. You still need to call <code>Scheduler.go</code> elsewhere in your program.</p></dd></dl><dl><dt class="spec value" id="val-run_in_async_exn"><a href="#val-run_in_async_exn" class="anchor"></a><code><span class="keyword">val</span> run_in_async_exn : ?&#8288;wakeup_scheduler:bool <span>&#45;&gt;</span> (unit <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dt class="spec value" id="val-block_on_async"><a href="#val-block_on_async" class="anchor"></a><code><span class="keyword">val</span> block_on_async : (unit <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a>) <span>&#45;&gt;</span> (<span class="type-var">'a</span>, exn) <a href="../../../core_kernel/Core_kernel/Result/index.html#type-t">Core.Result.t</a></code></dt><dd><p><code>block_on_async f</code> runs <code>f ()</code> in the Async world and blocks until the result becomes determined. This function can be called from the main thread (before Async is started) or from a thread outside Async.</p><p><code>block_on_async</code> will run a cycle if the deferred isn't determined, in the hope that running the cycle will cause the deferred to become determined.</p><p><code>block_on_async</code> will automatically start the scheduler if it isn't already running.</p></dd></dl><dl><dt class="spec value" id="val-block_on_async_exn"><a href="#val-block_on_async_exn" class="anchor"></a><code><span class="keyword">val</span> block_on_async_exn : (unit <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a>) <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dt class="spec value" id="val-run_in_async_wait"><a href="#val-run_in_async_wait" class="anchor"></a><code><span class="keyword">val</span> run_in_async_wait : (unit <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a>) <span>&#45;&gt;</span> (<span class="type-var">'a</span>, exn) <a href="../../../core_kernel/Core_kernel/Result/index.html#type-t">Core.Result.t</a></code></dt><dd><p><code>run_in_async_wait f</code> is like <code>block_on_async f</code>, except that it must be called from a thread outside Async. Upon returning from <code>run_in_async_wait</code>, it is guaranteed that the caller does not have the Async lock.</p></dd></dl><dl><dt class="spec value" id="val-run_in_async_wait_exn"><a href="#val-run_in_async_wait_exn" class="anchor"></a><code><span class="keyword">val</span> run_in_async_wait_exn : (unit <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a>) <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dt class="spec value" id="val-reset_scheduler"><a href="#val-reset_scheduler" class="anchor"></a><code><span class="keyword">val</span> reset_scheduler : unit <span>&#45;&gt;</span> unit</code></dt><dd><p><code>reset_scheduler</code> stops the scheduler thread and any associated threads, and resets Async's global state to its initial state. This is useful if you need to first use Async to compute a value and then to daemonize (in which case you should <code>daemonize</code> with <code>~allow_threads_to_have_been_created:true</code>).</p><p><code>reset_scheduler</code> can be called from the main thread (before Async is started) or from a thread outside Async. <code>reset_scheduler</code> is known to be imperfect, and to have races in which there are still threads running after it returns.</p></dd></dl></div></body></html>