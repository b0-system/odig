<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Raw (yojson.Yojson.Raw)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">yojson</a> &#x00BB; <a href="../index.html">Yojson</a> &#x00BB; Raw</nav><h1>Module <code>Yojson.Raw</code></h1><nav class="toc"><ul><li><a href="#type-of-the-json-tree">Type of the JSON tree</a></li><li><a href="#json-writers">JSON writers</a></li><li><a href="#miscellaneous">Miscellaneous</a></li><li><a href="#json-pretty-printing">JSON pretty-printing</a></li><li><a href="#json-readers">JSON readers</a></li></ul></nav></header><aside><p>Ints, floats and strings literals are systematically preserved using <code>`Intlit</code>, <code>`Floatlit</code> and <code>`Stringlit</code>. This module also supports the specific syntax for variants and tuples supported by <a href="../Safe/index.html"><code>Yojson.Safe</code></a>.</p></aside><section><header><h4 id="type-of-the-json-tree"><a href="#type-of-the-json-tree" class="anchor"></a>Type of the JSON tree</h4></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code> = <code>[ </code><table class="variant"><tr id="type-t.Null" class="anchored"><td class="def constructor"><a href="#type-t.Null" class="anchor"></a><code>| </code><code>`Null</code></td></tr><tr id="type-t.Bool" class="anchored"><td class="def constructor"><a href="#type-t.Bool" class="anchor"></a><code>| </code><code>`Bool <span class="keyword">of</span> bool</code></td></tr><tr id="type-t.Intlit" class="anchored"><td class="def constructor"><a href="#type-t.Intlit" class="anchor"></a><code>| </code><code>`Intlit <span class="keyword">of</span> string</code></td></tr><tr id="type-t.Floatlit" class="anchored"><td class="def constructor"><a href="#type-t.Floatlit" class="anchor"></a><code>| </code><code>`Floatlit <span class="keyword">of</span> string</code></td></tr><tr id="type-t.Stringlit" class="anchored"><td class="def constructor"><a href="#type-t.Stringlit" class="anchor"></a><code>| </code><code>`Stringlit <span class="keyword">of</span> string</code></td></tr><tr id="type-t.Assoc" class="anchored"><td class="def constructor"><a href="#type-t.Assoc" class="anchor"></a><code>| </code><code>`Assoc <span class="keyword">of</span> (string * <a href="index.html#type-t">t</a>) list</code></td></tr><tr id="type-t.List" class="anchored"><td class="def constructor"><a href="#type-t.List" class="anchor"></a><code>| </code><code>`List <span class="keyword">of</span> <a href="index.html#type-t">t</a> list</code></td></tr><tr id="type-t.Tuple" class="anchored"><td class="def constructor"><a href="#type-t.Tuple" class="anchor"></a><code>| </code><code>`Tuple <span class="keyword">of</span> <a href="index.html#type-t">t</a> list</code></td></tr><tr id="type-t.Variant" class="anchored"><td class="def constructor"><a href="#type-t.Variant" class="anchor"></a><code>| </code><code>`Variant <span class="keyword">of</span> string * <a href="index.html#type-t">t</a> option</code></td></tr></table><code> ]</code></dt><dd><p>All possible cases defined in Yojson:</p><ul><li>`Null: JSON null</li><li>`Bool of bool: JSON boolean</li><li>`Int of int: JSON number without decimal point or exponent.</li><li>`Intlit of string: JSON number without decimal point or exponent, preserved as a string.</li><li>`Float of float: JSON number, Infinity, -Infinity or NaN.</li><li>`Floatlit of string: JSON number, Infinity, -Infinity or NaN, preserved as a string.</li><li>`String of string: JSON string. Bytes in the range 128-255 are preserved as-is without encoding validation for both reading and writing.</li><li>`Stringlit of string: JSON string literal including the double quotes.</li><li>`Assoc of (string * json) list: JSON object.</li><li>`List of json list: JSON array.</li><li>`Tuple of json list: Tuple (non-standard extension of JSON). Syntax: <code>(&quot;abc&quot;, 123)</code>.</li><li>`Variant of (string * json option): Variant (non-standard extension of JSON). Syntax: <code>&lt;&quot;Foo&quot;&gt;</code> or <code>&lt;&quot;Bar&quot;:123&gt;</code>.</li></ul></dd></dl><dl><dt class="spec type" id="type-json"><a href="#type-json" class="anchor"></a><code><span class="keyword">type</span> json</code><code> = <a href="index.html#type-t">t</a></code></dt><dd><p>* Compatibility type alias for type `t`</p></dd></dl><dl><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val</span> pp : <a href="../../../ocaml/Stdlib/Format/index.html#type-formatter">Stdlib.Format.formatter</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Pretty printer, useful for debugging</p></dd></dl><dl><dt class="spec value" id="val-show"><a href="#val-show" class="anchor"></a><code><span class="keyword">val</span> show : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p>Convert value to string, useful for debugging</p></dd></dl><dl><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val</span> equal : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>equal a b</code> is the monomorphic equality. Determines whether two JSON values are considered equal. In the case of JSON objects, the order of the keys does not matter, except for duplicate keys which will be considered equal as long as they are in the same input order.</p></dd></dl></section><section><header><h3 id="json-writers"><a href="#json-writers" class="anchor"></a>JSON writers</h3></header><dl><dt class="spec value" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span class="keyword">val</span> to_string : ?&#8288;buf:<a href="../../../biniou/Bi_outbuf/index.html#type-t">Bi_outbuf.t</a> <span>&#45;&gt;</span> ?&#8288;len:int <span>&#45;&gt;</span> ?&#8288;std:bool <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p>Write a compact JSON value to a string.</p><dl><dt>parameter buf</dt><dd><p>allows to reuse an existing buffer created with <code>Bi_outbuf.create</code>. The buffer is cleared of all contents before starting and right before returning.</p></dd></dl><dl><dt>parameter len</dt><dd><p>initial length of the output buffer.</p></dd></dl><dl><dt>parameter std</dt><dd><p>use only standard JSON syntax, i.e. convert tuples and variants into standard JSON (if applicable), refuse to print NaN and infinities, require the root node to be either an object or an array. Default is <code>false</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-to_channel"><a href="#val-to_channel" class="anchor"></a><code><span class="keyword">val</span> to_channel : ?&#8288;buf:<a href="../../../biniou/Bi_outbuf/index.html#type-t">Bi_outbuf.t</a> <span>&#45;&gt;</span> ?&#8288;len:int <span>&#45;&gt;</span> ?&#8288;std:bool <span>&#45;&gt;</span> <a href="../../../ocaml/Stdlib/index.html#type-out_channel">Stdlib.out_channel</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Write a compact JSON value to a channel.</p><dl><dt>parameter buf</dt><dd><p>allows to reuse an existing buffer created with <code>Bi_outbuf.create_channel_writer</code> on the same channel. <code>buf</code> is flushed right before <code>to_channel</code> returns but the <code>out_channel</code> is not flushed automatically.</p><p>See <code>to_string</code> for the role of the other optional arguments.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-to_output"><a href="#val-to_output" class="anchor"></a><code><span class="keyword">val</span> to_output : ?&#8288;buf:<a href="../../../biniou/Bi_outbuf/index.html#type-t">Bi_outbuf.t</a> <span>&#45;&gt;</span> ?&#8288;len:int <span>&#45;&gt;</span> ?&#8288;std:bool <span>&#45;&gt;</span> &lt; output : string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int; .. &gt; <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Write a compact JSON value to an OO channel.</p><dl><dt>parameter buf</dt><dd><p>allows to reuse an existing buffer created with <code>Bi_outbuf.create_output_writer</code> on the same channel. <code>buf</code> is flushed right before <code>to_output</code> returns but the channel itself is not flushed automatically.</p><p>See <code>to_string</code> for the role of the other optional arguments.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-to_file"><a href="#val-to_file" class="anchor"></a><code><span class="keyword">val</span> to_file : ?&#8288;len:int <span>&#45;&gt;</span> ?&#8288;std:bool <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Write a compact JSON value to a file. See <code>to_string</code> for the role of the optional arguments.</p></dd></dl><dl><dt class="spec value" id="val-to_outbuf"><a href="#val-to_outbuf" class="anchor"></a><code><span class="keyword">val</span> to_outbuf : ?&#8288;std:bool <span>&#45;&gt;</span> <a href="../../../biniou/Bi_outbuf/index.html#type-t">Bi_outbuf.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Write a compact JSON value to an existing buffer. See <code>to_string</code> for the role of the optional argument.</p></dd></dl><dl><dt class="spec value" id="val-stream_to_string"><a href="#val-stream_to_string" class="anchor"></a><code><span class="keyword">val</span> stream_to_string : ?&#8288;buf:<a href="../../../biniou/Bi_outbuf/index.html#type-t">Bi_outbuf.t</a> <span>&#45;&gt;</span> ?&#8288;len:int <span>&#45;&gt;</span> ?&#8288;std:bool <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <a href="../../../ocaml/Stdlib/Stream/index.html#type-t">Stdlib.Stream.t</a> <span>&#45;&gt;</span> string</code></dt><dd><p>Write a newline-separated sequence of compact one-line JSON values to a string. See <code>to_string</code> for the role of the optional arguments.</p></dd></dl><dl><dt class="spec value" id="val-stream_to_channel"><a href="#val-stream_to_channel" class="anchor"></a><code><span class="keyword">val</span> stream_to_channel : ?&#8288;buf:<a href="../../../biniou/Bi_outbuf/index.html#type-t">Bi_outbuf.t</a> <span>&#45;&gt;</span> ?&#8288;len:int <span>&#45;&gt;</span> ?&#8288;std:bool <span>&#45;&gt;</span> <a href="../../../ocaml/Stdlib/index.html#type-out_channel">Stdlib.out_channel</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <a href="../../../ocaml/Stdlib/Stream/index.html#type-t">Stdlib.Stream.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Write a newline-separated sequence of compact one-line JSON values to a channel. See <code>to_channel</code> for the role of the optional arguments.</p></dd></dl><dl><dt class="spec value" id="val-stream_to_file"><a href="#val-stream_to_file" class="anchor"></a><code><span class="keyword">val</span> stream_to_file : ?&#8288;len:int <span>&#45;&gt;</span> ?&#8288;std:bool <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <a href="../../../ocaml/Stdlib/Stream/index.html#type-t">Stdlib.Stream.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Write a newline-separated sequence of compact one-line JSON values to a file. See <code>to_string</code> for the role of the optional arguments.</p></dd></dl><dl><dt class="spec value" id="val-stream_to_outbuf"><a href="#val-stream_to_outbuf" class="anchor"></a><code><span class="keyword">val</span> stream_to_outbuf : ?&#8288;std:bool <span>&#45;&gt;</span> <a href="../../../biniou/Bi_outbuf/index.html#type-t">Bi_outbuf.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <a href="../../../ocaml/Stdlib/Stream/index.html#type-t">Stdlib.Stream.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Write a newline-separated sequence of compact one-line JSON values to an existing buffer. See <code>to_string</code> for the role of the optional arguments.</p></dd></dl><dl><dt class="spec value" id="val-write_t"><a href="#val-write_t" class="anchor"></a><code><span class="keyword">val</span> write_t : <a href="../../../biniou/Bi_outbuf/index.html#type-t">Bi_outbuf.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Write the given JSON value to the given buffer. Provided as a writer function for atdgen.</p></dd></dl></section><section><header><h3 id="miscellaneous"><a href="#miscellaneous" class="anchor"></a>Miscellaneous</h3></header><dl><dt class="spec value" id="val-sort"><a href="#val-sort" class="anchor"></a><code><span class="keyword">val</span> sort : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Sort object fields (stable sort, comparing field names and treating them as byte sequences)</p></dd></dl></section><section><header><h3 id="json-pretty-printing"><a href="#json-pretty-printing" class="anchor"></a>JSON pretty-printing</h3></header><dl><dt class="spec value" id="val-pretty_format"><a href="#val-pretty_format" class="anchor"></a><code><span class="keyword">val</span> pretty_format : ?&#8288;std:bool <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../easy-format/Easy_format/index.html#type-t">Easy_format.t</a></code></dt><dd><p>Convert into a pretty-printable tree. See <code>to_string</code> for the role of the optional <code>std</code> argument.</p><dl><dt>see <a href="http://martin.jambon.free.fr/easy-format.html">http://martin.jambon.free.fr/easy-format.html</a></dt><dd><p>Easy-format</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-pretty_print"><a href="#val-pretty_print" class="anchor"></a><code><span class="keyword">val</span> pretty_print : ?&#8288;std:bool <span>&#45;&gt;</span> <a href="../../../ocaml/Stdlib/Format/index.html#type-formatter">Stdlib.Format.formatter</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Pretty-print into a <span class="xref-unresolved" title="unresolved reference to &quot;Format.formatter&quot;"><code>Format</code>.formatter</span>. See <code>to_string</code> for the role of the optional <code>std</code> argument.</p><dl><dt>since</dt><dd>1.3.1</dd></dl></dd></dl><dl><dt class="spec value" id="val-pretty_to_string"><a href="#val-pretty_to_string" class="anchor"></a><code><span class="keyword">val</span> pretty_to_string : ?&#8288;std:bool <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p>Pretty-print into a string. See <code>to_string</code> for the role of the optional <code>std</code> argument.</p></dd></dl><dl><dt class="spec value" id="val-pretty_to_channel"><a href="#val-pretty_to_channel" class="anchor"></a><code><span class="keyword">val</span> pretty_to_channel : ?&#8288;std:bool <span>&#45;&gt;</span> <a href="../../../ocaml/Stdlib/index.html#type-out_channel">Stdlib.out_channel</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Pretty-print to a channel. See <code>to_string</code> for the role of the optional <code>std</code> argument.</p></dd></dl><dl><dt class="spec value" id="val-prettify"><a href="#val-prettify" class="anchor"></a><code><span class="keyword">val</span> prettify : ?&#8288;std:bool <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt><dd><p>Combined parser and pretty-printer. See <code>to_string</code> for the role of the optional <code>std</code> argument.</p></dd></dl><dl><dt class="spec value" id="val-compact"><a href="#val-compact" class="anchor"></a><code><span class="keyword">val</span> compact : ?&#8288;std:bool <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt><dd><p>Combined parser and printer. See <code>to_string</code> for the role of the optional <code>std</code> argument.</p></dd></dl></section><section><header><h3 id="json-readers"><a href="#json-readers" class="anchor"></a>JSON readers</h3></header><dl><dt class="spec exception" id="exception-Finally"><a href="#exception-Finally" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Finally</span> <span class="keyword">of</span> exn * exn</code></dt><dd><p>Exception describing a failure in both finalizer and parsing.</p></dd></dl><dl><dt class="spec value" id="val-from_string"><a href="#val-from_string" class="anchor"></a><code><span class="keyword">val</span> from_string : ?&#8288;buf:<a href="../../../biniou/Bi_outbuf/index.html#type-t">Bi_outbuf.t</a> <span>&#45;&gt;</span> ?&#8288;fname:string <span>&#45;&gt;</span> ?&#8288;lnum:int <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Read a JSON value from a string.</p><dl><dt>parameter buf</dt><dd><p>use this buffer at will during parsing instead of creating a new one.</p></dd></dl><dl><dt>parameter fname</dt><dd><p>data file name to be used in error messages. It does not have to be a real file.</p></dd></dl><dl><dt>parameter lnum</dt><dd><p>number of the first line of input. Default is 1.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-from_channel"><a href="#val-from_channel" class="anchor"></a><code><span class="keyword">val</span> from_channel : ?&#8288;buf:<a href="../../../biniou/Bi_outbuf/index.html#type-t">Bi_outbuf.t</a> <span>&#45;&gt;</span> ?&#8288;fname:string <span>&#45;&gt;</span> ?&#8288;lnum:int <span>&#45;&gt;</span> <a href="../../../ocaml/Stdlib/index.html#type-in_channel">Stdlib.in_channel</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Read a JSON value from a channel. See <code>from_string</code> for the meaning of the optional arguments.</p></dd></dl><dl><dt class="spec value" id="val-from_file"><a href="#val-from_file" class="anchor"></a><code><span class="keyword">val</span> from_file : ?&#8288;buf:<a href="../../../biniou/Bi_outbuf/index.html#type-t">Bi_outbuf.t</a> <span>&#45;&gt;</span> ?&#8288;fname:string <span>&#45;&gt;</span> ?&#8288;lnum:int <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Read a JSON value from a file. See <code>from_string</code> for the meaning of the optional arguments.</p></dd></dl><dl><dt class="spec type" id="type-lexer_state"><a href="#type-lexer_state" class="anchor"></a><code><span class="keyword">type</span> lexer_state</code><code> = <a href="../Lexer_state/index.html#type-t">Lexer_state.t</a></code><code> = </code><code>{</code><table class="record"><tr id="type-lexer_state.buf" class="anchored"><td class="def field"><a href="#type-lexer_state.buf" class="anchor"></a><code>buf : <a href="../../../biniou/Bi_outbuf/index.html#type-t">Bi_outbuf.t</a>;</code></td></tr><tr id="type-lexer_state.lnum" class="anchored"><td class="def field"><a href="#type-lexer_state.lnum" class="anchor"></a><code><span class="keyword">mutable</span> lnum : int;</code></td></tr><tr id="type-lexer_state.bol" class="anchored"><td class="def field"><a href="#type-lexer_state.bol" class="anchor"></a><code><span class="keyword">mutable</span> bol : int;</code></td></tr><tr id="type-lexer_state.fname" class="anchored"><td class="def field"><a href="#type-lexer_state.fname" class="anchor"></a><code><span class="keyword">mutable</span> fname : string option;</code></td></tr></table><code>}</code></dt><dd><p>This alias is provided for backward compatibility. New code should refer to <a href="../index.html#type-lexer_state"><code>Yojson.lexer_state</code></a> directly.</p></dd></dl><dl><dt class="spec value" id="val-init_lexer"><a href="#val-init_lexer" class="anchor"></a><code><span class="keyword">val</span> init_lexer : ?&#8288;buf:<a href="../../../biniou/Bi_outbuf/index.html#type-t">Bi_outbuf.t</a> <span>&#45;&gt;</span> ?&#8288;fname:string <span>&#45;&gt;</span> ?&#8288;lnum:int <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-lexer_state">lexer_state</a></code></dt><dd><p>This alias is provided for backward compatibility. New code should use <a href="../index.html#val-init_lexer"><code>Yojson.init_lexer</code></a> directly.</p></dd></dl><dl><dt class="spec value" id="val-from_lexbuf"><a href="#val-from_lexbuf" class="anchor"></a><code><span class="keyword">val</span> from_lexbuf : <a href="index.html#type-lexer_state">lexer_state</a> <span>&#45;&gt;</span> ?&#8288;stream:bool <span>&#45;&gt;</span> <a href="../../../ocaml/Stdlib/Lexing/index.html#type-lexbuf">Stdlib.Lexing.lexbuf</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Read a JSON value from a lexbuf. A valid initial <code>lexer_state</code> can be created with <code>init_lexer</code>. See <code>from_string</code> for the meaning of the optional arguments.</p><dl><dt>parameter stream</dt><dd><p>indicates whether more data may follow. The default value is false and indicates that only JSON whitespace can be found between the end of the JSON value and the end of the input.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-stream_from_string"><a href="#val-stream_from_string" class="anchor"></a><code><span class="keyword">val</span> stream_from_string : ?&#8288;buf:<a href="../../../biniou/Bi_outbuf/index.html#type-t">Bi_outbuf.t</a> <span>&#45;&gt;</span> ?&#8288;fname:string <span>&#45;&gt;</span> ?&#8288;lnum:int <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <a href="../../../ocaml/Stdlib/Stream/index.html#type-t">Stdlib.Stream.t</a></code></dt><dd><p>Input a sequence of JSON values from a string. Whitespace between JSON values is fine but not required. See <code>from_string</code> for the meaning of the optional arguments.</p></dd></dl><dl><dt class="spec value" id="val-stream_from_channel"><a href="#val-stream_from_channel" class="anchor"></a><code><span class="keyword">val</span> stream_from_channel : ?&#8288;buf:<a href="../../../biniou/Bi_outbuf/index.html#type-t">Bi_outbuf.t</a> <span>&#45;&gt;</span> ?&#8288;fin:(unit <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> ?&#8288;fname:string <span>&#45;&gt;</span> ?&#8288;lnum:int <span>&#45;&gt;</span> <a href="../../../ocaml/Stdlib/index.html#type-in_channel">Stdlib.in_channel</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <a href="../../../ocaml/Stdlib/Stream/index.html#type-t">Stdlib.Stream.t</a></code></dt><dd><p>Input a sequence of JSON values from a channel. Whitespace between JSON values is fine but not required.</p><dl><dt>parameter fin</dt><dd><p>finalization function executed once when the end of the stream is reached either because there is no more input or because the input could not be parsed, raising an exception.</p></dd></dl><dl><dt>raises Finally</dt><dd><p>When the parsing and the finalizer both raised, <code>Finally (exn, fin_exn)</code> is raised, <code>exn</code> being the parsing exception and <code>fin_exn</code> the finalizer one.</p><p>See <code>from_string</code> for the meaning of the other optional arguments.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-stream_from_file"><a href="#val-stream_from_file" class="anchor"></a><code><span class="keyword">val</span> stream_from_file : ?&#8288;buf:<a href="../../../biniou/Bi_outbuf/index.html#type-t">Bi_outbuf.t</a> <span>&#45;&gt;</span> ?&#8288;fname:string <span>&#45;&gt;</span> ?&#8288;lnum:int <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <a href="../../../ocaml/Stdlib/Stream/index.html#type-t">Stdlib.Stream.t</a></code></dt><dd><p>Input a sequence of JSON values from a file. Whitespace between JSON values is fine but not required.</p><p>See <code>from_string</code> for the meaning of the optional arguments.</p></dd></dl><dl><dt class="spec value" id="val-stream_from_lexbuf"><a href="#val-stream_from_lexbuf" class="anchor"></a><code><span class="keyword">val</span> stream_from_lexbuf : <a href="index.html#type-lexer_state">lexer_state</a> <span>&#45;&gt;</span> ?&#8288;fin:(unit <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <a href="../../../ocaml/Stdlib/Lexing/index.html#type-lexbuf">Stdlib.Lexing.lexbuf</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <a href="../../../ocaml/Stdlib/Stream/index.html#type-t">Stdlib.Stream.t</a></code></dt><dd><p>Input a sequence of JSON values from a lexbuf. A valid initial <code>lexer_state</code> can be created with <code>init_lexer</code>. Whitespace between JSON values is fine but not required.</p><dl><dt>raises Finally</dt><dd><p>When the parsing and the finalizer both raised, <code>Finally (exn, fin_exn)</code> is raised, <code>exn</code> being the parsing exception and <code>fin_exn</code> the finalizer one.</p><p>See <code>stream_from_channel</code> for the meaning of the optional <code>fin</code> argument.</p></dd></dl></dd></dl><dl><dt class="spec type" id="type-json_line"><a href="#type-json_line" class="anchor"></a><code><span class="keyword">type</span> json_line</code> = <code>[ </code><table class="variant"><tr id="type-json_line.Json" class="anchored"><td class="def constructor"><a href="#type-json_line.Json" class="anchor"></a><code>| </code><code>`Json <span class="keyword">of</span> <a href="index.html#type-t">t</a></code></td></tr><tr id="type-json_line.Exn" class="anchored"><td class="def constructor"><a href="#type-json_line.Exn" class="anchor"></a><code>| </code><code>`Exn <span class="keyword">of</span> exn</code></td></tr></table><code> ]</code></dt><dd><p>The type of values resulting from a parsing attempt of a JSON value.</p></dd></dl><dl><dt class="spec value" id="val-linestream_from_channel"><a href="#val-linestream_from_channel" class="anchor"></a><code><span class="keyword">val</span> linestream_from_channel : ?&#8288;buf:<a href="../../../biniou/Bi_outbuf/index.html#type-t">Bi_outbuf.t</a> <span>&#45;&gt;</span> ?&#8288;fin:(unit <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> ?&#8288;fname:string <span>&#45;&gt;</span> ?&#8288;lnum:int <span>&#45;&gt;</span> <a href="../../../ocaml/Stdlib/index.html#type-in_channel">Stdlib.in_channel</a> <span>&#45;&gt;</span> <a href="index.html#type-json_line">json_line</a> <a href="../../../ocaml/Stdlib/Stream/index.html#type-t">Stdlib.Stream.t</a></code></dt><dd><p>Input a sequence of JSON values, one per line, from a channel. Exceptions raised when reading malformed lines are caught and represented using <code>`Exn</code>.</p><p>See <code>stream_from_channel</code> for the meaning of the optional <code>fin</code> argument. See <code>from_string</code> for the meaning of the other optional arguments.</p></dd></dl><dl><dt class="spec value" id="val-linestream_from_file"><a href="#val-linestream_from_file" class="anchor"></a><code><span class="keyword">val</span> linestream_from_file : ?&#8288;buf:<a href="../../../biniou/Bi_outbuf/index.html#type-t">Bi_outbuf.t</a> <span>&#45;&gt;</span> ?&#8288;fname:string <span>&#45;&gt;</span> ?&#8288;lnum:int <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-json_line">json_line</a> <a href="../../../ocaml/Stdlib/Stream/index.html#type-t">Stdlib.Stream.t</a></code></dt><dd><p>Input a sequence of JSON values, one per line, from a file. Exceptions raised when reading malformed lines are caught and represented using <code>`Exn</code>.</p><p>See <code>stream_from_channel</code> for the meaning of the optional <code>fin</code> argument. See <code>from_string</code> for the meaning of the other optional arguments.</p></dd></dl><dl><dt class="spec value" id="val-read_t"><a href="#val-read_t" class="anchor"></a><code><span class="keyword">val</span> read_t : <a href="index.html#type-lexer_state">lexer_state</a> <span>&#45;&gt;</span> <a href="../../../ocaml/Stdlib/Lexing/index.html#type-lexbuf">Stdlib.Lexing.lexbuf</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Read a JSON value from the given lexer_state and lexing buffer and return it. Provided as a reader function for atdgen.</p></dd></dl></section></div></body></html>