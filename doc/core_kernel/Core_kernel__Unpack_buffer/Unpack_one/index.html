<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Unpack_one (core_kernel.Core_kernel__Unpack_buffer.Unpack_one)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">core_kernel</a> &#x00BB; <a href="../index.html">Core_kernel__Unpack_buffer</a> &#x00BB; Unpack_one</nav><h1>Module <code>Core_kernel__Unpack_buffer.Unpack_one</code></h1></header><aside><p>If <code>unpack_one : ('a, 'partial_unpack) unpack_one</code>, then <code>unpack_one buf ?pos
      ?len ?partial_unpack</code> must unpack at most one value of type <code>'a</code> from <code>buf</code> starting at <code>pos</code>, and not using more than <code>len</code> characters. <code>unpack_one</code> must returns one the following:</p><ul><li><code>`Ok (value, n)</code> -- unpacking succeeded and consumed <code>n</code> bytes, where <code>0 &lt;= n &lt;=
        len</code>. It is possible to have <code>n = 0</code>, e.g. for sexp unpacking, which can only tell it has reached the end of an atom when it encounters the following punctuation character, which if it is left paren, is the start of the following sexp.</li></ul><ul><li><code>`Not_enough_data (p, n)</code> -- unpacking encountered a valid proper prefix of a packed value, and consumed <code>n</code> bytes, where <code>0 &lt;= n &lt;= len</code>. <code>p</code> is a &quot;partial unpack&quot; that can be supplied to a future call to <code>unpack_one</code> to continue unpacking.</li></ul><ul><li><code>`Invalid_data</code> -- unpacking encountered an invalidly packed value.</li></ul><p>A naive <code>unpack_one</code> that only succeeds on a fully packed value could lead to quadratic behavior if a packed value's bytes are input using a linear number of calls to <code>feed</code>.</p></aside><dl><dt class="spec type" id="type-unpack_result"><a href="#type-unpack_result" class="anchor"></a><code><span class="keyword">type</span> ('a, 'partial_unpack) unpack_result</code> = <code>[ </code><table class="variant"><tr id="type-unpack_result.Ok" class="anchored"><td class="def constructor"><a href="#type-unpack_result.Ok" class="anchor"></a><code>| </code><code>`Ok <span class="keyword">of</span> <span class="type-var">'a</span> * <a href="../../Core_kernel__/Import/index.html#type-int">Core_kernel__.Import.int</a></code></td></tr><tr id="type-unpack_result.Not_enough_data" class="anchored"><td class="def constructor"><a href="#type-unpack_result.Not_enough_data" class="anchor"></a><code>| </code><code>`Not_enough_data <span class="keyword">of</span> <span class="type-var">'partial_unpack</span> * <a href="../../Core_kernel__/Import/index.html#type-int">Core_kernel__.Import.int</a></code></td></tr><tr id="type-unpack_result.Invalid_data" class="anchored"><td class="def constructor"><a href="#type-unpack_result.Invalid_data" class="anchor"></a><code>| </code><code>`Invalid_data <span class="keyword">of</span> <a href="../../Core_kernel/Error/index.html#type-t">Core_kernel.Error.t</a></code></td></tr></table><code> ]</code></dt><dt class="spec type" id="type-unpacked"><a href="#type-unpacked" class="anchor"></a><code><span class="keyword">type</span> ('a, 'partial_unpack) unpacked</code><code> = ?&#8288;partial_unpack:<span class="type-var">'partial_unpack</span> <span>&#45;&gt;</span> ?&#8288;pos:<a href="../../Core_kernel__/Import/index.html#type-int">Core_kernel__.Import.int</a> <span>&#45;&gt;</span> ?&#8288;len:<a href="../../Core_kernel__/Import/index.html#type-int">Core_kernel__.Import.int</a> <span>&#45;&gt;</span> <a href="../../Core_kernel/Bigstring/index.html#type-t">Core_kernel.Bigstring.t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'partial_unpack</span>) <a href="index.html#type-unpack_result">unpack_result</a></code></dt><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> 'a t</code><code> = </code><table class="variant"><tr id="type-t.T" class="anchored"><td class="def constructor"><a href="#type-t.T" class="anchor"></a><code>| </code><code><span class="constructor">T</span> : (<span class="type-var">'a</span>, <span class="type-var">_</span>) <a href="index.html#type-unpacked">unpacked</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></td></tr></table></dt></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../../../base/Base/Monad/index.html#module-type-S">Core_kernel__.Import.Monad.S</a> <span class="keyword">with</span> <span class="keyword">type</span> 'a <a href="../../../base/Base/Monad/module-type-S/index.html#type-t">t</a> := <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> 'a t</code></dt></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../../../base/Base__/Monad_intf/index.html#module-type-S_without_syntax">Base__.Monad_intf.S_without_syntax</a> <span class="keyword">with</span> <span class="keyword">type</span> 'a <a href="../../../base/Base__/Monad_intf/module-type-S_without_syntax/index.html#type-t">t</a> := <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> 'a t</code></dt></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../../../base/Base__/Monad_intf/index.html#module-type-Infix">Base__.Monad_intf.Infix</a> <span class="keyword">with</span> <span class="keyword">type</span> 'a <a href="../../../base/Base__/Monad_intf/module-type-Infix/index.html#type-t">t</a> := <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> 'a t</code></dt></dl><dl><dt class="spec value" id="val-(&gt;&gt;=)"><a href="#val-(&gt;&gt;=)" class="anchor"></a><code><span class="keyword">val</span> (&gt;&gt;=) : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>t &gt;&gt;= f</code> returns a computation that sequences the computations represented by two monad elements. The resulting computation first does <code>t</code> to yield a value <code>v</code>, and then runs the computation returned by <code>f v</code>.</p></dd></dl><dl><dt class="spec value" id="val-(&gt;&gt;|)"><a href="#val-(&gt;&gt;|)" class="anchor"></a><code><span class="keyword">val</span> (&gt;&gt;|) : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>t &gt;&gt;| f</code> is <code>t &gt;&gt;= (fun a -&gt; return (f a))</code>.</p></dd></dl></details></div></div></div><div class="spec module" id="module-Monad_infix"><a href="#module-Monad_infix" class="anchor"></a><code><span class="keyword">module</span> <a href="Monad_infix/index.html">Monad_infix</a> : <a href="../../../base/Base__/Monad_intf/index.html#module-type-Infix">Base__.Monad_intf.Infix</a> <span class="keyword">with</span> <span class="keyword">type</span> 'a <a href="../../../base/Base__/Monad_intf/module-type-Infix/index.html#type-t">t</a> := <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></div><dl><dt class="spec value" id="val-bind"><a href="#val-bind" class="anchor"></a><code><span class="keyword">val</span> bind : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>bind t ~f</code> = <code>t &gt;&gt;= f</code></p></dd></dl><dl><dt class="spec value" id="val-return"><a href="#val-return" class="anchor"></a><code><span class="keyword">val</span> return : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>return v</code> returns the (trivial) computation that returns v.</p></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>map t ~f</code> is t &gt;&gt;| f.</p></dd></dl><dl><dt class="spec value" id="val-join"><a href="#val-join" class="anchor"></a><code><span class="keyword">val</span> join : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>join t</code> is <code>t &gt;&gt;= (fun t' -&gt; t')</code>.</p></dd></dl><dl><dt class="spec value" id="val-ignore_m"><a href="#val-ignore_m" class="anchor"></a><code><span class="keyword">val</span> ignore_m : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit <a href="index.html#type-t">t</a></code></dt><dd><p><code>ignore_m t</code> is <code>map t ~f:(fun _ -&gt; ())</code>. <code>ignore_m</code> used to be called <code>ignore</code>, but we decided that was a bad name, because it shadowed the widely used <code>Pervasives.ignore</code>. Some monads still do <code>let ignore = ignore_m</code> for historical reasons.</p></dd></dl><dl><dt class="spec value" id="val-all"><a href="#val-all" class="anchor"></a><code><span class="keyword">val</span> all : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-all_unit"><a href="#val-all_unit" class="anchor"></a><code><span class="keyword">val</span> all_unit : unit <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> unit <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-all_ignore"><a href="#val-all_ignore" class="anchor"></a><code><span class="keyword">val</span> all_ignore : unit <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> unit <a href="index.html#type-t">t</a></code></dt></dl></details></div></div></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../../../base/Base__/Monad_intf/index.html#module-type-Syntax">Base__.Monad_intf.Syntax</a> <span class="keyword">with</span> <span class="keyword">type</span> 'a <a href="../../../base/Base__/Monad_intf/module-type-Syntax/index.html#type-t">t</a> := <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> 'a t</code></dt></dl><div class="spec module" id="module-Let_syntax"><a href="#module-Let_syntax" class="anchor"></a><code><span class="keyword">module</span> <a href="Let_syntax/index.html">Let_syntax</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></details></div></div></div></details></div></div></div><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : (?&#8288;partial_unpack:<span class="type-var">'p</span> <span>&#45;&gt;</span> <a href="../../Core_kernel/Bigstring/index.html#type-t">Core_kernel.Bigstring.t</a> <span>&#45;&gt;</span> pos:<a href="../../Core_kernel__/Import/index.html#type-int">Core_kernel__.Import.int</a> <span>&#45;&gt;</span> len:<a href="../../Core_kernel__/Import/index.html#type-int">Core_kernel__.Import.int</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'p</span>) <a href="index.html#type-unpack_result">unpack_result</a>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>create</code> converts an unpacking function that takes required <code>pos</code> and <code>len</code> arguments and converts it to the <code>unpacked</code> form that takes an optional <code>pos</code> and <code>len</code>.</p></dd></dl><dl><dt class="spec value" id="val-create_bin_prot"><a href="#val-create_bin_prot" class="anchor"></a><code><span class="keyword">val</span> create_bin_prot : <span class="type-var">'a</span> <a href="../../../bin_prot/Bin_prot/Type_class/index.html#type-reader">Bin_prot.Type_class.reader</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>create_bin_prot reader</code> returns an unpacker that reads the &quot;size-prefixed&quot; bin_prot encoding, in which a value is encoded by first writing the length of the bin_prot data as a 64-bit int, and then writing the data itself. This encoding makes it trivial to know if enough data is available in the buffer, so there is no need to represent partially unpacked values, and hence <code>'partial_unpack = unit</code>.</p></dd></dl><dl><dt class="spec value" id="val-bin_blob"><a href="#val-bin_blob" class="anchor"></a><code><span class="keyword">val</span> bin_blob : <a href="../../../bin_prot/Bin_prot/Blob/Opaque/Bigstring/index.html#type-t">Bin_prot.Blob.Opaque.Bigstring.t</a> <a href="index.html#type-t">t</a></code></dt><dd><p>Reads &quot;size-prefixed&quot; bin-blobs, much like <code>create_bin_prot _</code>, but preserves the size information and doesn't deserialize the blob. This allows deserialization to be deferred and the remainder of the sequence can be unpacked if an individual blob can't be deserialized.</p></dd></dl><dl><dt class="spec value" id="val-sexp"><a href="#val-sexp" class="anchor"></a><code><span class="keyword">val</span> sexp : <a href="../../Core_kernel/Sexp/index.html#type-t">Core_kernel.Sexp.t</a> <a href="index.html#type-t">t</a></code></dt><dd><p>Beware that when unpacking sexps, one cannot tell if one is at the end of an atom until one hits punctuation. So, one should always feed a space (&quot; &quot;) to a sexp unpack buffer after feeding a batch of complete sexps, to ensure that the final sexp is unpacked.</p></dd></dl><dl><dt class="spec value" id="val-char"><a href="#val-char" class="anchor"></a><code><span class="keyword">val</span> char : <a href="../../Core_kernel__/Import/index.html#type-char">Core_kernel__.Import.char</a> <a href="index.html#type-t">t</a></code></dt></dl><div class="spec module-type" id="module-type-Equal"><a href="#module-type-Equal" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Equal/index.html">Equal</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-expect"><a href="#val-expect" class="anchor"></a><code><span class="keyword">val</span> expect : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="keyword">module</span> <a href="module-type-Equal/index.html">Equal</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="module-type-Equal/index.html#type-t">t</a> = <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a> <a href="index.html#type-t">t</a></code></dt><dd><p><code>expect t equal a</code> returns an unpacker that unpacks using <code>t</code> and then returns <code>`Ok</code> if the unpacked value equals <code>a</code>, or <code>`Invalid_data</code> otherwise.</p></dd></dl><dl><dt class="spec value" id="val-expect_char"><a href="#val-expect_char" class="anchor"></a><code><span class="keyword">val</span> expect_char : <a href="../../Core_kernel__/Import/index.html#type-char">Core_kernel__.Import.char</a> <span>&#45;&gt;</span> <a href="../../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a> <a href="index.html#type-t">t</a></code></dt><dd><p><code>expect_char</code> is <code>expect char (module Char)</code></p></dd></dl><dl><dt class="spec value" id="val-newline"><a href="#val-newline" class="anchor"></a><code><span class="keyword">val</span> newline : <a href="../../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a> <a href="index.html#type-t">t</a></code></dt></dl></div></body></html>