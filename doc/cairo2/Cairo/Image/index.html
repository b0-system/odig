<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Image (cairo2.Cairo.Image)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">cairo2</a> &#x00BB; <a href="../index.html">Cairo</a> &#x00BB; Image</nav><h1>Module <code>Cairo.Image</code></h1><p>Image surfaces provide the ability to render to memory buffers either allocated by cairo or by the calling code. The supported image formats are those defined in <a href="index.html#type-format"><code>Cairo.Image.format</code></a>.</p></header><dl><dt class="spec type" id="type-format"><a href="#type-format" class="anchor"></a><code><span class="keyword">type</span> format</code><code> = </code><table class="variant"><tr id="type-format.ARGB32" class="anchored"><td class="def constructor"><a href="#type-format.ARGB32" class="anchor"></a><code>| </code><code><span class="constructor">ARGB32</span></code></td><td class="doc"><p>each pixel is a 32-bit quantity, with alpha in the upper 8 bits, then red, then green, then blue. The 32-bit quantities are stored native-endian. Pre-multiplied alpha is used. (That is, 50% transparent red is 0x80800000, not 0x80ff0000.)</p></td></tr><tr id="type-format.RGB24" class="anchored"><td class="def constructor"><a href="#type-format.RGB24" class="anchor"></a><code>| </code><code><span class="constructor">RGB24</span></code></td><td class="doc"><p>each pixel is a 32-bit quantity, with the upper 8 bits unused. Red, Green, and Blue are stored in the remaining 24 bits in that order.</p></td></tr><tr id="type-format.A8" class="anchored"><td class="def constructor"><a href="#type-format.A8" class="anchor"></a><code>| </code><code><span class="constructor">A8</span></code></td><td class="doc"><p>each pixel is a 8-bit quantity holding an alpha value.</p></td></tr><tr id="type-format.A1" class="anchored"><td class="def constructor"><a href="#type-format.A1" class="anchor"></a><code>| </code><code><span class="constructor">A1</span></code></td><td class="doc"><p>each pixel is a 1-bit quantity holding an alpha value. Pixels are packed together into 32-bit quantities. The ordering of the bits matches the endianess of the platform. On a big-endian machine, the first pixel is in the uppermost bit, on a little-endian machine the first pixel is in the least-significant bit.</p></td></tr></table></dt><dd><p>This is used to identify the memory format of image data.</p></dd></dl><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : <a href="index.html#type-format">format</a> <span>&#45;&gt;</span> w:int <span>&#45;&gt;</span> h:int <span>&#45;&gt;</span> <a href="../Surface/index.html#type-t">Surface.t</a></code></dt><dd><p>Creates an image surface of the specified format and dimensions. Initially the surface contents are all 0. (Specifically, within each pixel, each color or alpha channel belonging to format will be 0. The contents of bits within a pixel, but not belonging to the given format are undefined).</p></dd></dl><dl><dt class="spec type" id="type-data8"><a href="#type-data8" class="anchor"></a><code><span class="keyword">type</span> data8</code><code> = (int, <a href="../../../ocaml/Bigarray/index.html#type-int8_unsigned_elt">Bigarray.int8_unsigned_elt</a>, <a href="../../../ocaml/Bigarray/index.html#type-c_layout">Bigarray.c_layout</a>) <a href="../../../ocaml/Bigarray/Array1/index.html#type-t">Bigarray.Array1.t</a></code></dt><dd><p>Images represented as an array of 8 bytes values.</p></dd></dl><dl><dt class="spec type" id="type-data32"><a href="#type-data32" class="anchor"></a><code><span class="keyword">type</span> data32</code><code> = (int32, <a href="../../../ocaml/Bigarray/index.html#type-int32_elt">Bigarray.int32_elt</a>, <a href="../../../ocaml/Bigarray/index.html#type-c_layout">Bigarray.c_layout</a>) <a href="../../../ocaml/Bigarray/Array2/index.html#type-t">Bigarray.Array2.t</a></code></dt><dd><p>Images represented as an array of 32 bytes (RGB or RGBA) values.</p></dd></dl><dl><dt class="spec value" id="val-create_for_data8"><a href="#val-create_for_data8" class="anchor"></a><code><span class="keyword">val</span> create_for_data8 : <a href="index.html#type-data8">data8</a> <span>&#45;&gt;</span> ?&#8288;stride:int <span>&#45;&gt;</span> <a href="index.html#type-format">format</a> <span>&#45;&gt;</span> w:int <span>&#45;&gt;</span> h:int <span>&#45;&gt;</span> <a href="../Surface/index.html#type-t">Surface.t</a></code></dt><dd><p><code>create_for_data8 data format ?stride width height</code> creates an image surface for the provided pixel data. The initial contents of buffer will be used as the initial image contents; you must explicitly clear the buffer, using, for example, <a href="../index.html#type-rectangle"><code>Cairo.rectangle</code></a> and <a href="../index.html#val-fill"><code>Cairo.fill</code></a> if you want it cleared.</p><dl><dt>parameter stride</dt><dd><p>the number of bytes between the start of rows in the buffer as allocated. This value should always be computed by <a href="index.html#val-stride_for_width"><code>stride_for_width</code></a> before allocating the data buffer. (that's what this function does if the argument is not provided).</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-create_for_data32"><a href="#val-create_for_data32" class="anchor"></a><code><span class="keyword">val</span> create_for_data32 : ?&#8288;w:int <span>&#45;&gt;</span> ?&#8288;h:int <span>&#45;&gt;</span> ?&#8288;alpha:bool <span>&#45;&gt;</span> <a href="index.html#type-data32">data32</a> <span>&#45;&gt;</span> <a href="../Surface/index.html#type-t">Surface.t</a></code></dt><dd><p><code>create_for_data32 ?w ?h ?alpha data</code> same as <a href="index.html#val-create_for_data8"><code>Cairo.Image.create_for_data8</code></a> except that the stride will necessarily be according to the bigarray 1st dimension (so that matrix coordinates correspond to pixels) and the width <code>w</code> and height <code>h</code> will be by default taken from the bigarray 1st and 2nd dimensions respectively. If <code>alpha</code> is true (default), the <code>ARGB32</code> format is selected, otherwise <code>RGB24</code> is used.</p></dd></dl><dl><dt class="spec value" id="val-get_data8"><a href="#val-get_data8" class="anchor"></a><code><span class="keyword">val</span> get_data8 : <a href="../Surface/index.html#type-t">Surface.t</a> <span>&#45;&gt;</span> <a href="index.html#type-data8">data8</a></code></dt><dd><p>Get the data of the image surface (shared), for direct inspection or modification. A call to <a href="../Surface/index.html#val-mark_dirty"><code>Cairo.Surface.mark_dirty</code></a> or <a href="../Surface/index.html#val-mark_dirty_rectangle"><code>Cairo.Surface.mark_dirty_rectangle</code></a> is required after the data is modified.</p></dd></dl><dl><dt class="spec value" id="val-get_data32"><a href="#val-get_data32" class="anchor"></a><code><span class="keyword">val</span> get_data32 : <a href="../Surface/index.html#type-t">Surface.t</a> <span>&#45;&gt;</span> <a href="index.html#type-data32">data32</a></code></dt><dd><p>Get the data of the image surface (shared), for direct inspection or modification. The 1st (resp. 2nd) dimension of the bigarray correspond to the height (resp. width) of the surface. A call to <a href="../Surface/index.html#val-mark_dirty"><code>Cairo.Surface.mark_dirty</code></a> or <a href="../Surface/index.html#val-mark_dirty_rectangle"><code>Cairo.Surface.mark_dirty_rectangle</code></a> is required after the data is modified.</p><dl><dt>raises Invalid_argument</dt><dd><p>if the format is not <code>ARGB32</code> or <code>RGB24</code> because the array dimensions would not reflect the image coordinates.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-get_format"><a href="#val-get_format" class="anchor"></a><code><span class="keyword">val</span> get_format : <a href="../Surface/index.html#type-t">Surface.t</a> <span>&#45;&gt;</span> <a href="index.html#type-format">format</a></code></dt><dd><p>Get the format of the image surface.</p></dd></dl><dl><dt class="spec value" id="val-get_width"><a href="#val-get_width" class="anchor"></a><code><span class="keyword">val</span> get_width : <a href="../Surface/index.html#type-t">Surface.t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Get the width of the image surface in pixels.</p></dd></dl><dl><dt class="spec value" id="val-get_height"><a href="#val-get_height" class="anchor"></a><code><span class="keyword">val</span> get_height : <a href="../Surface/index.html#type-t">Surface.t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Get the height of the image surface in pixels.</p></dd></dl><dl><dt class="spec value" id="val-get_stride"><a href="#val-get_stride" class="anchor"></a><code><span class="keyword">val</span> get_stride : <a href="../Surface/index.html#type-t">Surface.t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Get the stride of the image surface in bytes. Note that in order to convert this stride in bytes to a stride in the bigarray indices, the type of the surface has to be taken into account: for <code>ARGB32</code> and <code>RGB24</code>, the stride has to be divided by 4.</p></dd></dl><dl><dt class="spec value" id="val-stride_for_width"><a href="#val-stride_for_width" class="anchor"></a><code><span class="keyword">val</span> stride_for_width : <a href="index.html#type-format">format</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dd><p><code>stride_for_width format w</code> a stride value that will respect all alignment requirements of the accelerated image-rendering code within cairo. See <a href="index.html#val-create_for_data8"><code>create_for_data8</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-output_ppm"><a href="#val-output_ppm" class="anchor"></a><code><span class="keyword">val</span> output_ppm : <a href="../../../ocaml/Stdlib/index.html#type-out_channel">Stdlib.out_channel</a> <span>&#45;&gt;</span> ?&#8288;w:int <span>&#45;&gt;</span> ?&#8288;h:int <span>&#45;&gt;</span> <a href="index.html#type-data32">data32</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>output_ppm ch width height data</code> convenience function to write the subarray of size (<code>width</code>, <code>height</code>) representing an image to the PPM format. The possible alpha channel is ignored.</p></dd></dl></div></body></html>