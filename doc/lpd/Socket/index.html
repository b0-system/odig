<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Socket (lpd.Socket)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">lpd</a> &#x00BB; Socket</nav><h1>Module <code>Socket</code></h1><p>Buffered sockets (Pervasive like functions for sockets working on all platforms).</p><p>This library is distributed under the terms of the GNU Lesser General Public License, with the special exception on linking as for the OCaml Library.</p><dl><dt>author</dt><dd>Christophe Troestler</dd></dl><dl><dt>version</dt><dd>1.2.2</dd></dl><nav class="toc"><ul><li><a href="#high-level-network-connection-functions">High-level network connection functions</a></li><li><a href="#output-functions">Output functions</a></li><li><a href="#input-functions">Input functions</a></li><li><a href="#polling">Polling</a></li><li><a href="#i/o-objects">I/O objects</a></li></ul></nav></header><dl><dt class="spec type" id="type-in_channel"><a href="#type-in_channel" class="anchor"></a><code><span class="keyword">type</span> in_channel</code></dt><dt class="spec type" id="type-out_channel"><a href="#type-out_channel" class="anchor"></a><code><span class="keyword">type</span> out_channel</code></dt><dd><p>Abstract types for buffered sockets.</p></dd></dl><dl><dt class="spec value" id="val-in_channel_of_descr"><a href="#val-in_channel_of_descr" class="anchor"></a><code><span class="keyword">val</span> in_channel_of_descr : <a href="../../ocaml/Unix/index.html#type-file_descr">Unix.file_descr</a> <span>&#45;&gt;</span> <a href="index.html#type-in_channel">in_channel</a></code></dt><dd><p>Create an input channel reading from the given descriptor.</p></dd></dl><dl><dt class="spec value" id="val-out_channel_of_descr"><a href="#val-out_channel_of_descr" class="anchor"></a><code><span class="keyword">val</span> out_channel_of_descr : <a href="../../ocaml/Unix/index.html#type-file_descr">Unix.file_descr</a> <span>&#45;&gt;</span> <a href="index.html#type-out_channel">out_channel</a></code></dt><dd><p>Create an output channel writing on the given descriptor.</p></dd></dl><dl><dt class="spec value" id="val-descr_of_in_channel"><a href="#val-descr_of_in_channel" class="anchor"></a><code><span class="keyword">val</span> descr_of_in_channel : <a href="index.html#type-in_channel">in_channel</a> <span>&#45;&gt;</span> <a href="../../ocaml/Unix/index.html#type-file_descr">Unix.file_descr</a></code></dt><dd><p>Return the descriptor corresponding to an input channel.</p></dd></dl><dl><dt class="spec value" id="val-descr_of_out_channel"><a href="#val-descr_of_out_channel" class="anchor"></a><code><span class="keyword">val</span> descr_of_out_channel : <a href="index.html#type-out_channel">out_channel</a> <span>&#45;&gt;</span> <a href="../../ocaml/Unix/index.html#type-file_descr">Unix.file_descr</a></code></dt><dd><p>Return the descriptor corresponding to an output channel.</p></dd></dl><section><header><h3 id="high-level-network-connection-functions"><a href="#high-level-network-connection-functions" class="anchor"></a>High-level network connection functions</h3></header><dl><dt class="spec value" id="val-open_connection"><a href="#val-open_connection" class="anchor"></a><code><span class="keyword">val</span> open_connection : <a href="../../ocaml/Unix/index.html#type-sockaddr">Unix.sockaddr</a> <span>&#45;&gt;</span> <a href="index.html#type-in_channel">in_channel</a> * <a href="index.html#type-out_channel">out_channel</a></code></dt><dd><p>Connect to a server at the given address. Return a buffered socket. Can raise the same exceptions as <code>Unix.open_connection</code>.</p></dd></dl><dl><dt class="spec value" id="val-shutdown_connection"><a href="#val-shutdown_connection" class="anchor"></a><code><span class="keyword">val</span> shutdown_connection : <a href="index.html#type-in_channel">in_channel</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>``Shut down'' a connection established with <a href="index.html#val-open_connection"><code>Socket.open_connection</code></a>; that is, transmit an end-of-file condition to the server reading on the other side of the connection. (You should flush the out_channels connected to the same socket if you want to make sure all data is transmitted.)</p></dd></dl></section><section><header><h3 id="output-functions"><a href="#output-functions" class="anchor"></a>Output functions</h3></header><dl><dt class="spec value" id="val-output"><a href="#val-output" class="anchor"></a><code><span class="keyword">val</span> output : <a href="index.html#type-out_channel">out_channel</a> <span>&#45;&gt;</span> <a href="../../ocaml/Stdlib/Bytes/index.html#type-t">Stdlib.Bytes.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p><code>output oc buf pos len</code> writes <code>len</code> characters from string <code>buf</code>, starting at offset <code>pos</code>, to the given buffered socket <code>oc</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>&quot;Socket.output&quot; if <code>pos</code> and <code>len</code> do not designate a valid substring of <code>buf</code>.</p></dd></dl><dl><dt>raises Sys_blocked_io</dt><dd><p>if we are in non-blocking mode and <code>output</code> would block.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-output_char"><a href="#val-output_char" class="anchor"></a><code><span class="keyword">val</span> output_char : <a href="index.html#type-out_channel">out_channel</a> <span>&#45;&gt;</span> char <span>&#45;&gt;</span> unit</code></dt><dd><p>Write the character on the given buffered socket.</p></dd></dl><dl><dt class="spec value" id="val-output_string"><a href="#val-output_string" class="anchor"></a><code><span class="keyword">val</span> output_string : <a href="index.html#type-out_channel">out_channel</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> unit</code></dt><dd><p>Write the string on the given buffered socket.</p></dd></dl><dl><dt class="spec value" id="val-fprintf"><a href="#val-fprintf" class="anchor"></a><code><span class="keyword">val</span> fprintf : <a href="index.html#type-out_channel">out_channel</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, unit, string, unit) <a href="../../ocaml/Stdlib/index.html#type-format4">Stdlib.format4</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>fprintf oc format arguments</code> is like <code>Printf.fprintf</code> except that <code>oc</code> is a buffered socket.</p></dd></dl><dl><dt class="spec value" id="val-flush"><a href="#val-flush" class="anchor"></a><code><span class="keyword">val</span> flush : <a href="index.html#type-out_channel">out_channel</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Flush the output buffer associated with the given buffered socket.</p></dd></dl><dl><dt class="spec value" id="val-close_out"><a href="#val-close_out" class="anchor"></a><code><span class="keyword">val</span> close_out : <a href="index.html#type-out_channel">out_channel</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>close_out oc</code> closes the socket <code>oc</code>, flushing all buffered write operations. (This closes the underlying file descriptor as well.) Output functions raise a <code>Sys_error</code> exception when they are applied to a closed output channel, except <code>close_out</code> and <code>flush</code> which do nothing.</p></dd></dl></section><section><header><h3 id="input-functions"><a href="#input-functions" class="anchor"></a>Input functions</h3></header><dl><dt class="spec value" id="val-input"><a href="#val-input" class="anchor"></a><code><span class="keyword">val</span> input : <a href="index.html#type-in_channel">in_channel</a> <span>&#45;&gt;</span> <a href="../../ocaml/Stdlib/Bytes/index.html#type-t">Stdlib.Bytes.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dd><p><code>input ic buf pos len</code> reads up to <code>len</code> characters from the given socket <code>ic</code>, storing them in string <code>buf</code>, starting at character number <code>pos</code>. It returns the actual number of characters read, between 0 and <code>len</code> (inclusive).</p><p>A return value of 0 means that the end of file was reached.</p><dl><dt>raises Invalid_argument</dt><dd><p>&quot;Socket.input&quot; if <code>pos</code> and <code>len</code> do not designate a valid substring of <code>buf</code>.</p></dd></dl><dl><dt>raises Sys_blocked_io</dt><dd><p>if we are in non-blocking mode and <code>input</code> would block (no characters are then read).</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-input_char"><a href="#val-input_char" class="anchor"></a><code><span class="keyword">val</span> input_char : <a href="index.html#type-in_channel">in_channel</a> <span>&#45;&gt;</span> char</code></dt><dd><p>Read one character from the given input channel.</p><dl><dt>raises End_of_file</dt><dd><p>if there are no more characters to read.</p></dd></dl><dl><dt>raises Sys_blocked_io</dt><dd><p>if we are in non-blocking mode and <code>input_char</code> would block (no characters are then read).</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-really_input"><a href="#val-really_input" class="anchor"></a><code><span class="keyword">val</span> really_input : <a href="index.html#type-in_channel">in_channel</a> <span>&#45;&gt;</span> <a href="../../ocaml/Stdlib/Bytes/index.html#type-t">Stdlib.Bytes.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p><code>really_input ic buf pos len</code> reads <code>len</code> characters from the buffered socket <code>ic</code>, storing them in string <code>buf</code>, starting at character number <code>pos</code>.</p><dl><dt>raises End_of_file</dt><dd><p>if the end of file is reached before <code>len</code> characters have been read.</p></dd></dl><dl><dt>raises Invalid_argument</dt><dd><p>&quot;Socket.really_read&quot; if <code>pos</code> and <code>len</code> do not designate a valid substring of <code>buf</code>.</p></dd></dl><dl><dt>raises Sys_blocked_io</dt><dd><p>if we are in non-blocking mode and <code>really_input</code> would block (the characters that may have been read are lost).</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-input_line"><a href="#val-input_line" class="anchor"></a><code><span class="keyword">val</span> input_line : <a href="index.html#type-in_channel">in_channel</a> <span>&#45;&gt;</span> string</code></dt><dd><p><code>input_line ic</code> returns the next line from the socket <code>ic</code> without the final '\n'.</p><dl><dt>raises End_of_file</dt><dd><p>if the end of the file is reached.</p></dd></dl><dl><dt>raises Sys_blocked_io</dt><dd><p>if we are in non-blocking mode and <code>input_line</code> would block (the characters that may have been read are lost).</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-input_till"><a href="#val-input_till" class="anchor"></a><code><span class="keyword">val</span> input_till : char <span>&#45;&gt;</span> <a href="index.html#type-in_channel">in_channel</a> <span>&#45;&gt;</span> <a href="../../ocaml/Stdlib/Bytes/index.html#type-t">Stdlib.Bytes.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dd><p><code>input_till c ic buf pos len</code> reads up to <code>len</code> characters different from <code>c</code> from the socket <code>ic</code>, storing them in string <code>buf</code>, starting at character number <code>pos</code>. The return value is the actual number of characters read (different from <code>c</code>), between 0 and <code>len</code> (inclusive). If <code>c</code> is encountered, the reading stops. <code>c</code> is left in the input stream; thus all further <code>input_till</code> commands will return <code>0</code>.</p><dl><dt>raises End_of_file</dt><dd><p>if the end of the file is reached (i.e., there are no more characters to read). This is different from the return value being <code>0</code> -- the latter indicating that the first character in the stream is <code>c</code>.</p></dd></dl><dl><dt>raises Invalid_argument</dt><dd><p>&quot;Socket.input_till&quot; if <code>pos</code> and <code>len</code> do not designate a valid substring of <code>buf</code>.</p></dd></dl><dl><dt>raises Sys_blocked_io</dt><dd><p>if we are in non-blocking mode and <code>input_till</code> would block (no characters are then read).</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-input_all_till"><a href="#val-input_all_till" class="anchor"></a><code><span class="keyword">val</span> input_all_till : char <span>&#45;&gt;</span> <a href="index.html#type-in_channel">in_channel</a> <span>&#45;&gt;</span> string</code></dt><dd><p><code>input_all_till c ic</code> returns the next chunk from the socket <code>ic</code> from the current position to the character <code>c</code> (excluded) or the end of the file. The character <code>c</code> is read and discarded.</p><dl><dt>raises End_of_file</dt><dd><p>if the end of the file is reached before any character can be read. (This is different from an empty string being returned which indicates that <code>c</code> is the first character in the input stream.)</p></dd></dl><dl><dt>raises Sys_blocked_io</dt><dd><p>if we are in non-blocking mode and <code>input_all_till</code> would block (the characters that may have been read are lost).</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-close_in"><a href="#val-close_in" class="anchor"></a><code><span class="keyword">val</span> close_in : <a href="index.html#type-in_channel">in_channel</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>close_in ic</code> closes the socket <code>ic</code>. (This closes the underlying file descriptor as well.) Input functions raise a <code>Sys_error</code> exception when they are applied to a closed input channel, except <code>close_in</code>, which does nothing when applied to an already closed channel.</p></dd></dl></section><section><header><h3 id="polling"><a href="#polling" class="anchor"></a>Polling</h3></header><dl><dt class="spec value" id="val-select"><a href="#val-select" class="anchor"></a><code><span class="keyword">val</span> select : <a href="index.html#type-in_channel">in_channel</a> list <span>&#45;&gt;</span> <a href="index.html#type-out_channel">out_channel</a> list <span>&#45;&gt;</span> float <span>&#45;&gt;</span> <a href="index.html#type-in_channel">in_channel</a> list * <a href="index.html#type-out_channel">out_channel</a> list</code></dt><dd><p><code>select inl outl t</code> waits at most <code>t</code> seconds until some input/output operations become possible on some channels among <code>inl</code> and <code>outl</code>. A negative <code>t</code> means unbounded wait. The result is composed of two sets of channels: those ready for reading (first component) and those ready for writing (second component).</p></dd></dl></section><section><header><h3 id="i/o-objects"><a href="#i/o-objects" class="anchor"></a>I/O objects</h3></header><aside><p>I/O objects for the channels respecting the conventions for <a href="http://ocaml-programming.de/rec/IO-Classes.html">IO-Classes</a>. The objects only give another access to the channels and their methods can be interspersed with the above function calls.</p></aside><div class="spec class" id="class-out_channel_obj"><a href="#class-out_channel_obj" class="anchor"></a><code><span class="keyword">class</span> <a href="class-out_channel_obj/index.html">out_channel_obj</a> : <a href="index.html#type-out_channel">out_channel</a> <span>&#45;&gt;</span> <span class="keyword">object</span> ... <span class="keyword">end</span></code></div><div class="spec class" id="class-in_channel_obj"><a href="#class-in_channel_obj" class="anchor"></a><code><span class="keyword">class</span> <a href="class-in_channel_obj/index.html">in_channel_obj</a> : <a href="index.html#type-in_channel">in_channel</a> <span>&#45;&gt;</span> <span class="keyword">object</span> ... <span class="keyword">end</span></code></div></section></div></body></html>