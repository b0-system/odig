<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Named (typerep.Typerep_lib.Type_generic.Named)</title><link rel="stylesheet" href="../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">typerep</a> &#x00BB; <a href="../../index.html">Typerep_lib</a> &#x00BB; <a href="../index.html">Type_generic</a> &#x00BB; Named</nav><header class="odoc-preamble"><h1>Module type <code><span>Type_generic.Named</span></code></h1></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-computation" class="anchored"><a href="#type-computation" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a computation</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Context" class="anchored"><a href="#module-Context" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Context/index.html">Context</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a t</span></span></code></div><div class="spec-doc"><p>Work in progress representation of a computation. This is mostly used to handle recursive types. While building a computation on a recursive type, one needs to have some computation available for the location where the type appears recursively. <code>init</code> will be called once on each new type_name met during the traversal of a type. Each time the same type is encountered again, <code>get_wip_computation</code> will be called. At the end of the traversal of that particular type, <code>set_final_computation</code> will be called, offering as a way to &quot;close&quot; the wip representation. <code>'a t</code> can be mutable (and is likely to be in practice).</p><p>After a <code>set_final_computation</code> is performed and return a final computation C for a type_name, C will be memoized and returned for each further occurrences of the same type_name inside the typerep, going further on.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-init" class="anchored"><a href="#val-init" class="anchor"></a><code><span><span class="keyword">val</span> init : <span><a href="Context/index.html#type-t">Context.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="../../Typename/index.html#type-t">Typename.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-get_wip_computation" class="anchored"><a href="#val-get_wip_computation" class="anchor"></a><code><span><span class="keyword">val</span> get_wip_computation : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-computation">computation</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-set_final_computation" class="anchored"><a href="#val-set_final_computation" class="anchor"></a><code><span><span class="keyword">val</span> set_final_computation : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-computation">computation</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-computation">computation</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-share" class="anchored"><a href="#val-share" class="anchor"></a><code><span><span class="keyword">val</span> share : <span><span><span class="type-var">_</span> <a href="../../Std_internal/Typerep/index.html#type-t">Std_internal.Typerep.t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>It might be interesting to inline some computation for a few typerep if they appear several times within a typerep. This parameters will allow one to tweak the sharing between multiple occurences of the same typename. <code>share = true</code> means no inlining.</p><p>Note that not sharing recursive types will lead the <code>of_typerep</code> function to loop forever. Be careful when setting this.</p><p>An example where it is not suitable to share everything for example is typestruct. The typestruct of an int is a simple constructor called <code>Int</code>, naming it once and using the name to refere to it later within the typestruct does not lead to a shorter typestruct, and is in fact less readable. The benefit of the sharing depends on the computation, its memory and building costs.</p></div></div></div></body></html>