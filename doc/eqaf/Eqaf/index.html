<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Eqaf (eqaf.Eqaf)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">eqaf</a> &#x00BB; Eqaf</nav><header class="odoc-preamble"><h1>Module <code><span>Eqaf</span></code></h1><p>Eqaf - timing-safe comparison functions</p></header><nav class="odoc-toc"><ul><li><a href="#basics">Basics</a><ul><li><a href="#implementations">Implementations</a></li></ul></li></ul></nav><div class="odoc-content"><h2 id="basics"><a href="#basics" class="anchor"></a>Basics</h2><p>In cryptography, a timing-attack is a side-channel attack in which the attacker attempts to compromise a cryptosystem by analyzing the time taken to execute cryptographic algorithms.</p><p>In some cases, a process needs to compare two values (input value and expected password). An attacker can analyze time needed by <code>String</code>.compare/<code>String</code>.equal to calculate expected password.</p><p>This side-channel attack is due implementation of <code>String</code>.compare/<code>String</code>.equal which leaves as soon as possible when it reachs a difference between <code>a</code> and <code>b</code>. By this way, time taken to compare two values differs if they are equal or not.</p><p>Distribution provides a little example of this kind of attack where we construct step by step (byte per byte) expected value from time spended to execute <code>compare</code>.</p><p>Distribution wants to provide some functions which protect user against this kind of attack:</p><ul><li><code>equal</code> like <code>String</code>.equal</li><li><code>compare_be</code> like <code>String</code>.compare</li><li><code>compare_le</code> which is a <code>String</code>.compare with a reverse operation on inputs</li></ul><p>These functions are tested to see how long they took to compare two equal values and two different values. See <i>check</i> tool for more informations.</p><h3 id="implementations"><a href="#implementations" class="anchor"></a>Implementations</h3><div class="odoc-spec"><div class="spec value" id="val-equal" class="anchored"><a href="#val-equal" class="anchor"></a><code><span><span class="keyword">val</span> equal : <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>equal a b</code> returns <code>true</code> if <code>a</code> and <code>b</code> are equals. <code>String.equal a b =
   equal a b</code> for any <code>a</code> and <code>b</code>. The execution time of <code>equal</code> depends solely on the length of the strings, not the contents.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-compare_be" class="anchored"><a href="#val-compare_be" class="anchor"></a><code><span><span class="keyword">val</span> compare_be : <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>compare_be a b</code> returns <code>0</code> if <code>a</code> is equal to <code>b</code>, a negative integer if <code>a</code> if <i>less</i> (lexicographically) than <code>b</code>, and a positive integer if <code>a</code> is <i>greater</i> (lexicographically) than <code>b</code>.</p><p><code>compare_be a b</code> returns the same <i>order</i> than <code>String.compare a b</code> for any <code>a</code> and <code>b</code> (but not necessary the same integer!). Order is defined as:</p><ul><li><code>compare_be a b &lt; 0</code> means <code>a &lt; b</code></li><li><code>compare_be a b &gt; 0</code> means <code>a &gt; b</code></li><li><code>compare_be a b = 0</code> means <code>a = b</code></li></ul><p>About time, if <code>String.length a &lt;&gt; String.length b</code>, <code>compare_be</code> does not look into <code>a</code> or <code>b</code> and no comparison in bytes will be done.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-compare_be_with_len" class="anchored"><a href="#val-compare_be_with_len" class="anchor"></a><code><span><span class="keyword">val</span> compare_be_with_len : <span>len:int <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>compare_be_with_len ~len a b</code> does <code>compare_be a b</code> on <code>len</code> bytes.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if <code>len</code> is upper than <code>String.length a</code> or <code>String.length b</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-compare_le" class="anchored"><a href="#val-compare_le" class="anchor"></a><code><span><span class="keyword">val</span> compare_le : <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>compare_le a b</code> is semantically <code>compare_be (rev a) (rev b)</code>. With <code>rev</code> reverses a string (<code>a = rev (rev a)</code>).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-compare_le_with_len" class="anchored"><a href="#val-compare_le_with_len" class="anchor"></a><code><span><span class="keyword">val</span> compare_le_with_len : <span>len:int <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>compare_le_with_len a b</code> is semantically <code>compare_be_with_len ~len (rev a)
   (rev b)</code>. With <code>rev</code> reverse a string (<code>a = rev (rev a)</code>).</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if <code>len</code> is upper than <code>String.length a</code> or <code>String.length b</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-one_if_not_zero" class="anchored"><a href="#val-one_if_not_zero" class="anchor"></a><code><span><span class="keyword">val</span> one_if_not_zero : <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>one_if_not_zero n</code> is a constant-time version of <code>if n &lt;&gt; 0 then 1 else 0</code>. This is functionally equivalent to <code>!!n</code> in the C programming language.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-zero_if_not_zero" class="anchored"><a href="#val-zero_if_not_zero" class="anchor"></a><code><span><span class="keyword">val</span> zero_if_not_zero : <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>zero_if_not_zero n</code> is a constant-time of <code>if n &lt;&gt; 0 then 0 else 1</code>. This is functionnaly equivalent to <code>!n</code> in the C programming language.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-select_int" class="anchored"><a href="#val-select_int" class="anchor"></a><code><span><span class="keyword">val</span> select_int : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>select_int choose_b a b</code> is <code>a</code> if <code>choose_b = 0</code> and <code>b</code> otherwise. This comparison is constant-time and it should not be possible for a measuring adversary to determine anything about the values of <code>choose_b</code>, <code>a</code>, or <code>b</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-find_uint8" class="anchored"><a href="#val-find_uint8" class="anchor"></a><code><span><span class="keyword">val</span> find_uint8 : <span>?off:int <span class="arrow">&#45;&gt;</span></span> <span>f:<span>(<span>int <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>find_uint8 ?off ~f v</code> returns the index of the first occurrence which respects the predicate <code>f</code> in string <code>v</code>. Otherwise, it returns <code>-1</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-exists_uint8" class="anchored"><a href="#val-exists_uint8" class="anchor"></a><code><span><span class="keyword">val</span> exists_uint8 : <span>?off:int <span class="arrow">&#45;&gt;</span></span> <span>f:<span>(<span>int <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>exists_uint8 ?off ~f v</code> tests if an occurrence respects the predicate <code>f</code> in the string <code>v</code>.</p></div></div></div></body></html>