<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Reader (async_unix.Async_unix__.Reader)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">async_unix</a> &#x00BB; <a href="../index.html">Async_unix__</a> &#x00BB; Reader</nav><h1>Module <code>Async_unix__.Reader</code></h1></header><aside><p><code>Reader</code> is Async's main API for buffered input from a file descriptor. It is the analog of <a href="../../../stdio/Stdio/In_channel/index.html"><span><code>Stdio.In_channel</code></span></a>.</p><p>Each reader has an internal buffer, which is filled via <code>read()</code> system calls when data is needed to satisfy a <code>Reader.read*</code> call.</p><p>Each of the read functions returns a deferred that will become determined when the read completes. It is an error to have two simultaneous reads. That is, if you call a read function, you should not call another read function until the first one completes.</p><p>If the file descriptor underlying a reader is closed, the reader will return EOF (after all the buffered bytes have been read).</p><p>Any <code>Reader.read*</code> call could, rather than determine its result, send an exception to the monitor in effect when <code>read</code> was called. Such exceptions can be handled in the usual way by using <code>try_with</code>, e.g.:</p><pre><code class="ml">try_with (fun () -&gt; Reader.read reader ...) </code></pre></aside><div class="spec module" id="module-Read_result"><a href="#module-Read_result" class="anchor"></a><code><span class="keyword">module</span> <a href="Read_result/index.html">Read_result</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Id"><a href="#module-Id" class="anchor"></a><code><span class="keyword">module</span> <a href="Id/index.html">Id</a> : <a href="../../../core/Core/index.html#module-type-Unique_id">Core.Unique_id</a></code></div><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></span></summary><dl><dt class="spec value" id="val-sexp_of_t"><a href="#val-sexp_of_t" class="anchor"></a><code><span class="keyword">val</span> sexp_of_t : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a></code></dt></dl></details></div></div></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../../../async_kernel/Async_kernel__/Async_invariant/index.html#module-type-S">Async_unix__.Import.Invariant.S</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../../../async_kernel/Async_kernel__/Async_invariant/module-type-S/index.html#type-t">t</a> := <a href="index.html#type-t">t</a></code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt></dl><dl><dt class="spec value" id="val-invariant"><a href="#val-invariant" class="anchor"></a><code><span class="keyword">val</span> invariant : <a href="index.html#type-t">t</a> <a href="../../../base/Base__/Invariant_intf/index.html#type-inv">Base__.Invariant_intf.inv</a></code></dt></dl></details></div></div></div><dl><dt class="spec value" id="val-io_stats"><a href="#val-io_stats" class="anchor"></a><code><span class="keyword">val</span> io_stats : <a href="../../Async_unix/Io_stats/index.html#type-t">Async_unix.Io_stats.t</a></code></dt><dd><p>Overall IO statistics for all readers.</p></dd></dl><dl><dt class="spec value" id="val-last_read_time"><a href="#val-last_read_time" class="anchor"></a><code><span class="keyword">val</span> last_read_time : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../core/Core__/Core_time_float/index.html#type-t">Core.Time.t</a></code></dt><dd><p>Returns time of the most recent <code>read</code> system call that returned data.</p></dd></dl><dl><dt class="spec value" id="val-stdin"><a href="#val-stdin" class="anchor"></a><code><span class="keyword">val</span> stdin : <a href="index.html#type-t">t</a> <a href="../../../core_kernel/Core_kernel/Lazy/index.html#type-t">Core.Lazy.t</a></code></dt><dd><p><code>stdin</code> is a reader for file descriptor 0. It is lazy because we don't want to create it in all programs that happen to link with Async.</p></dd></dl><dl><dt class="spec value" id="val-open_file"><a href="#val-open_file" class="anchor"></a><code><span class="keyword">val</span> open_file : ?&#8288;buf_len:int <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>open_file file</code> opens <code>file</code> for reading and returns a reader reading from it.</p></dd></dl><dl><dt class="spec value" id="val-transfer"><a href="#val-transfer" class="anchor"></a><code><span class="keyword">val</span> transfer : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string <a href="../../../async_kernel/Async_kernel__Pipe/Writer/index.html#type-t">Async_unix__.Import.Pipe.Writer.t</a> <span>&#45;&gt;</span> unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>transfer t pipe_w</code> transfers data from <code>t</code> into <code>pipe_w</code> one chunk at a time (whatever is read from the underlying file descriptor without post-processing). The result becomes determined after reaching EOF on <code>t</code> and the final bytes have been transferred, or if <code>pipe_w</code> is closed.</p><p>This function will normally not be needed (see <code>pipe</code>).</p></dd></dl><dl><dt class="spec value" id="val-pipe"><a href="#val-pipe" class="anchor"></a><code><span class="keyword">val</span> pipe : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string <a href="../../../async_kernel/Async_kernel__Pipe/Reader/index.html#type-t">Async_unix__.Import.Pipe.Reader.t</a></code></dt><dd><p><code>pipe t</code> returns the reader end of a pipe that will continually be filled with chunks of data from the underlying <code>Reader.t</code>. When the reader reaches EOF or the pipe is closed, <code>pipe</code> closes the reader, and then after the reader close is finished, closes the pipe.</p></dd></dl><dl><dt class="spec value" id="val-of_pipe"><a href="#val-of_pipe" class="anchor"></a><code><span class="keyword">val</span> of_pipe : <a href="../../../core_kernel/Core_kernel/Info/index.html#type-t">Core.Info.t</a> <span>&#45;&gt;</span> string <a href="../../../async_kernel/Async_kernel__Pipe/Reader/index.html#type-t">Async_unix__.Import.Pipe.Reader.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>of_pipe info pipe_r</code> returns a reader <code>t</code> that receives all the data from <code>pipe_r</code>. If <code>pipe_r</code> is closed, <code>t</code> will see an EOF (but will not be automatically closed). If <code>t</code> is closed, then <code>pipe_r</code> will stop being drained.</p><p><code>of_pipe</code> is implemented by shuttling bytes from <code>pipe_r</code> to the write-end of a Unix pipe, with <code>t</code> being attached to the read end of the Unix pipe.</p></dd></dl><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : ?&#8288;buf_len:int <span>&#45;&gt;</span> <a href="../../Async_unix/Fd/index.html#type-t">Async_unix.Fd.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>create ~buf_len fd</code> creates a new reader that is reading from <code>fd</code>.</p></dd></dl><dl><dt class="spec value" id="val-of_in_channel"><a href="#val-of_in_channel" class="anchor"></a><code><span class="keyword">val</span> of_in_channel : <a href="../../../stdio/Stdio/In_channel/index.html#type-t">Core.In_channel.t</a> <span>&#45;&gt;</span> <a href="../../Async_unix/Fd/Kind/index.html#type-t">Async_unix.Fd.Kind.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-with_file"><a href="#val-with_file" class="anchor"></a><code><span class="keyword">val</span> with_file : ?&#8288;buf_len:int <span>&#45;&gt;</span> ?&#8288;exclusive:bool <span>&#45;&gt;</span> string <span>&#45;&gt;</span> f:(<a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>with_file file f</code> opens <code>files</code>, creates a reader with it, and passes the reader to <code>f</code>. It closes the reader when the result of <code>f</code> becomes determined, and returns <code>f</code>'s result.</p><p><b>Note:</b> You need to be careful that all your IO is done when the deferred you return becomes determined. If for example you use <code>with_file</code> and call <code>lines</code>, make sure you return a deferred that becomes determined when the EOF is reached on the pipe, not when you get the pipe (because you get it straight away).</p></dd></dl><dl><dt class="spec value" id="val-close"><a href="#val-close" class="anchor"></a><code><span class="keyword">val</span> close : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>close t</code> prevents further use of <code>t</code> and closes <code>t</code>'s underlying file descriptor. The result of <code>close</code> becomes determined once the underlying file descriptor has been closed. It is an error to call other operations on <code>t</code> after <code>close t</code> has been called, except that calls of <code>close</code> subsequent to the original call to <code>close</code> will return the same deferred as the original call.</p><p><code>close_finished t</code> becomes determined after <code>t</code>'s underlying file descriptor has been closed, i.e., it is the same as the result of <code>close</code>. <code>close_finished</code> differs from <code>close</code> in that it does not have the side effect of initiating a close.</p><p><code>is_closed t</code> returns <code>true</code> iff <code>close t</code> has been called.</p><p><code>with_close t ~f</code> runs <code>f ()</code>, and closes <code>t</code> after <code>f</code> finishes or raises.</p></dd></dl><dl><dt class="spec value" id="val-close_finished"><a href="#val-close_finished" class="anchor"></a><code><span class="keyword">val</span> close_finished : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dt class="spec value" id="val-is_closed"><a href="#val-is_closed" class="anchor"></a><code><span class="keyword">val</span> is_closed : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-with_close"><a href="#val-with_close" class="anchor"></a><code><span class="keyword">val</span> with_close : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(unit <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dt class="spec value" id="val-id"><a href="#val-id" class="anchor"></a><code><span class="keyword">val</span> id : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="Id/index.html#type-t">Id.t</a></code></dt><dd><p><code>id</code> returns a name for this reader that is unique across all instances of the reader module.</p></dd></dl><dl><dt class="spec value" id="val-fd"><a href="#val-fd" class="anchor"></a><code><span class="keyword">val</span> fd : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../Async_unix/Fd/index.html#type-t">Async_unix.Fd.t</a></code></dt><dd><p><code>fd</code> returns the <code>Fd.t</code> used to create this reader.</p></dd></dl><dl><dt class="spec value" id="val-read"><a href="#val-read" class="anchor"></a><code><span class="keyword">val</span> read : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;len:int <span>&#45;&gt;</span> <a href="../../../core_kernel/Core_kernel/Bytes/index.html#type-t">Core.Bytes.t</a> <span>&#45;&gt;</span> int <a href="Read_result/index.html#type-t">Read_result.t</a> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>read t ?pos ?len buf</code> reads up to <code>len</code> bytes into <code>buf</code>, blocking until some data is available or EOF is reached. The resulting <code>i</code> satisfies <code>0 &lt; i &lt;= len</code>.</p></dd></dl><dl><dt class="spec value" id="val-peek"><a href="#val-peek" class="anchor"></a><code><span class="keyword">val</span> peek : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> len:int <span>&#45;&gt;</span> string <a href="Read_result/index.html#type-t">Read_result.t</a> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>peek t ~len</code> peeks exactly <code>len</code> bytes from <code>t</code>'s buffer. It blocks until <code>len</code> bytes are available or EOF is reached.</p></dd></dl><dl><dt class="spec value" id="val-drain"><a href="#val-drain" class="anchor"></a><code><span class="keyword">val</span> drain : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>drain t</code> reads and ignores all data from <code>t</code> until it hits EOF, and then closes <code>t</code>.</p></dd></dl><dl><dt class="spec type" id="type-read_one_chunk_at_a_time_result"><a href="#type-read_one_chunk_at_a_time_result" class="anchor"></a><code><span class="keyword">type</span> 'a read_one_chunk_at_a_time_result</code> = <code>[ </code><table class="variant"><tr id="type-read_one_chunk_at_a_time_result.Eof" class="anchored"><td class="def constructor"><a href="#type-read_one_chunk_at_a_time_result.Eof" class="anchor"></a><code>| </code><code>`Eof</code></td></tr><tr id="type-read_one_chunk_at_a_time_result.Stopped" class="anchored"><td class="def constructor"><a href="#type-read_one_chunk_at_a_time_result.Stopped" class="anchor"></a><code>| </code><code>`Stopped <span class="keyword">of</span> <span class="type-var">'a</span></code></td><td class="doc"><p><code>`Eof_with_unconsumed_data s</code> means that <code>handle_chunk</code> returned <code>`Consumed (c, _)</code> and left data in the reader's buffer (i.e., <code>c &lt; len</code>), and that the reader reached EOF without reading any more data into the buffer; hence the data in the buffer was never consumed (and never will be, since the reader is at EOF).</p></td></tr><tr id="type-read_one_chunk_at_a_time_result.Eof_with_unconsumed_data" class="anchored"><td class="def constructor"><a href="#type-read_one_chunk_at_a_time_result.Eof_with_unconsumed_data" class="anchor"></a><code>| </code><code>`Eof_with_unconsumed_data <span class="keyword">of</span> string</code></td></tr></table><code> ]</code></dt></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></span></summary><dl><dt class="spec value" id="val-sexp_of_read_one_chunk_at_a_time_result"><a href="#val-sexp_of_read_one_chunk_at_a_time_result" class="anchor"></a><code><span class="keyword">val</span> sexp_of_read_one_chunk_at_a_time_result : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-read_one_chunk_at_a_time_result">read_one_chunk_at_a_time_result</a> <span>&#45;&gt;</span> <a href="../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a></code></dt></dl></details></div></div></div><dl><dt class="spec type" id="type-handle_chunk_result"><a href="#type-handle_chunk_result" class="anchor"></a><code><span class="keyword">type</span> 'a handle_chunk_result</code> = <code>[ </code><table class="variant"><tr id="type-handle_chunk_result.Stop" class="anchored"><td class="def constructor"><a href="#type-handle_chunk_result.Stop" class="anchor"></a><code>| </code><code>`Stop <span class="keyword">of</span> <span class="type-var">'a</span></code></td><td class="doc"><p><code>`Stop a</code> means that <code>handle_chunk</code> consumed all <code>len</code> bytes, and that <code>read_one_chunk_at_a_time</code> should stop reading and return <code>`Stopped a</code>.</p></td></tr><tr id="type-handle_chunk_result.Stop_consumed" class="anchored"><td class="def constructor"><a href="#type-handle_chunk_result.Stop_consumed" class="anchor"></a><code>| </code><code>`Stop_consumed <span class="keyword">of</span> <span class="type-var">'a</span> * int</code></td><td class="doc"><p><code>`Stop_consumed (a, n)</code> means that <code>handle_chunk</code> consumed <code>n</code> bytes, and that <code>read_one_chunk_at_a_time</code> should stop reading and return <code>`Stopped a</code>.</p></td></tr><tr id="type-handle_chunk_result.Continue" class="anchored"><td class="def constructor"><a href="#type-handle_chunk_result.Continue" class="anchor"></a><code>| </code><code>`Continue</code></td><td class="doc"><p><code>`Continue</code> means that <code>handle_chunk</code> has consumed all <code>len</code> bytes.</p></td></tr><tr id="type-handle_chunk_result.Consumed" class="anchored"><td class="def constructor"><a href="#type-handle_chunk_result.Consumed" class="anchor"></a><code>| </code><code>`Consumed <span class="keyword">of</span> int * [ `Need of int | `Need_unknown ]</code></td><td class="doc"><p><code>`Consumed (c, need)</code> means that <code>c</code> bytes were consumed and <code>need</code> says how many bytes are needed (including the data remaining in the buffer after the <code>c</code> were already consumed). It is an error if <code>c &lt; 0 || c &gt; len</code>. For <code>`Need n</code>, it is an error if <code>n &lt; 0 || c + n &lt;= len</code>.</p></td></tr></table><code> ]</code></dt></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></span></summary><dl><dt class="spec value" id="val-sexp_of_handle_chunk_result"><a href="#val-sexp_of_handle_chunk_result" class="anchor"></a><code><span class="keyword">val</span> sexp_of_handle_chunk_result : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-handle_chunk_result">handle_chunk_result</a> <span>&#45;&gt;</span> <a href="../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a></code></dt></dl></details></div></div></div><dl><dt class="spec value" id="val-read_one_chunk_at_a_time"><a href="#val-read_one_chunk_at_a_time" class="anchor"></a><code><span class="keyword">val</span> read_one_chunk_at_a_time : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> handle_chunk:(<a href="../../../core/Core/Bigstring/index.html#type-t">Core.Bigstring.t</a> <span>&#45;&gt;</span> pos:int <span>&#45;&gt;</span> len:int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-handle_chunk_result">handle_chunk_result</a> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-read_one_chunk_at_a_time_result">read_one_chunk_at_a_time_result</a> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>read_one_chunk_at_a_time t ~handle_chunk</code> reads into <code>t</code>'s internal buffer, and whenever bytes are available, applies <code>handle_chunk</code> to them. It waits to read again until the deferred returned by <code>handle_chunk</code> becomes determined. If <code>handle_chunk</code> returns <code>`Consumed</code>, then <code>read_one_chunk_at_a_time</code> will wait for additional data to arrive before calling <code>handle_chunk</code> again. Thus, <code>handle_chunk</code> should consume as much as possible.</p><p><code>read_one_chunk_at_a_time</code> continues reading until it reaches <code>`Eof</code> or <code>handle_chunk</code> returns <code>`Stop</code> or <code>`Stop_consumed</code>. In the case of <code>`Stop</code> and <code>`Stop_consumed</code>, one may read from <code>t</code> after <code>read_one_chunk_at_a_time</code> returns.</p></dd></dl><dl><dt class="spec type" id="type-handle_iobuf_result"><a href="#type-handle_iobuf_result" class="anchor"></a><code><span class="keyword">type</span> 'a handle_iobuf_result</code> = <code>[ </code><table class="variant"><tr id="type-handle_iobuf_result.Stop" class="anchored"><td class="def constructor"><a href="#type-handle_iobuf_result.Stop" class="anchor"></a><code>| </code><code>`Stop <span class="keyword">of</span> <span class="type-var">'a</span></code></td></tr><tr id="type-handle_iobuf_result.Continue" class="anchored"><td class="def constructor"><a href="#type-handle_iobuf_result.Continue" class="anchor"></a><code>| </code><code>`Continue</code></td></tr></table><code> ]</code></dt><dd><p><code>`Stop a</code> or <code>`Continue</code> respects the usual <code>Iobuf</code> semantics where data up to the <code>Iobuf.Lo_bound</code> is considered consumed.</p></dd></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></span></summary><dl><dt class="spec value" id="val-sexp_of_handle_iobuf_result"><a href="#val-sexp_of_handle_iobuf_result" class="anchor"></a><code><span class="keyword">val</span> sexp_of_handle_iobuf_result : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-handle_iobuf_result">handle_iobuf_result</a> <span>&#45;&gt;</span> <a href="../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a></code></dt></dl></details></div></div></div><dl><dt class="spec value" id="val-read_one_iobuf_at_a_time"><a href="#val-read_one_iobuf_at_a_time" class="anchor"></a><code><span class="keyword">val</span> read_one_iobuf_at_a_time : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> handle_chunk:((<a href="../../../core/Core/index.html#type-read_write">Core.read_write</a>, <a href="../../../core/Core/Iobuf/index.html#type-seek">Core.Iobuf.seek</a>) <a href="../../../core/Core/Iobuf/index.html#type-t">Core.Iobuf.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-handle_iobuf_result">handle_iobuf_result</a> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-read_one_chunk_at_a_time_result">read_one_chunk_at_a_time_result</a> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>read_one_iobuf_at_a_time</code> is like <code>read_one_chunk_at_a_time</code>, except that the user-supplied <code>handle_chunk</code> function receives its data in an <code>Iobuf.t</code>, and uses the <code>Iobuf</code> position to communicate how much data was consumed. <code>read_one_iobuf_at_a_time</code> is implemented as a wrapper around <code>read_one_chunk_at_a_time</code>.</p></dd></dl><dl><dt class="spec value" id="val-read_substring"><a href="#val-read_substring" class="anchor"></a><code><span class="keyword">val</span> read_substring : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../core_kernel/Core_kernel/Substring/index.html#type-t">Core.Substring.t</a> <span>&#45;&gt;</span> int <a href="Read_result/index.html#type-t">Read_result.t</a> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>read_substring t ss</code> reads up to <code>Substring.length ss</code> bytes into <code>ss</code>, blocking until some data is available or EOF is reached. The resulting <code>i</code> satisfies <code>0 &lt; i &lt;=
    Substring.length ss</code>.</p></dd></dl><dl><dt class="spec value" id="val-read_bigsubstring"><a href="#val-read_bigsubstring" class="anchor"></a><code><span class="keyword">val</span> read_bigsubstring : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../core_kernel/Core_kernel/Bigsubstring/index.html#type-t">Core.Bigsubstring.t</a> <span>&#45;&gt;</span> int <a href="Read_result/index.html#type-t">Read_result.t</a> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dt class="spec value" id="val-read_char"><a href="#val-read_char" class="anchor"></a><code><span class="keyword">val</span> read_char : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> char <a href="Read_result/index.html#type-t">Read_result.t</a> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dt class="spec value" id="val-really_read"><a href="#val-really_read" class="anchor"></a><code><span class="keyword">val</span> really_read : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;len:int <span>&#45;&gt;</span> <a href="../../../core_kernel/Core_kernel/Bytes/index.html#type-t">Core.Bytes.t</a> <span>&#45;&gt;</span> [ `Ok | `Eof of int ] <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>really_read t buf ?pos ?len</code> reads until it fills <code>len</code> bytes of <code>buf</code> starting at <code>pos</code>, or runs out of input. In the former case it returns <code>`Ok</code>. In the latter, it returns <code>`Eof n</code> where <code>n</code> is the number of bytes that were read before end of input, and <code>0 &lt;= n &lt; String.length ss</code>.</p></dd></dl><dl><dt class="spec value" id="val-really_read_substring"><a href="#val-really_read_substring" class="anchor"></a><code><span class="keyword">val</span> really_read_substring : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../core_kernel/Core_kernel/Substring/index.html#type-t">Core.Substring.t</a> <span>&#45;&gt;</span> [ `Ok | `Eof of int ] <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dt class="spec value" id="val-really_read_bigsubstring"><a href="#val-really_read_bigsubstring" class="anchor"></a><code><span class="keyword">val</span> really_read_bigsubstring : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../core_kernel/Core_kernel/Bigsubstring/index.html#type-t">Core.Bigsubstring.t</a> <span>&#45;&gt;</span> [ `Ok | `Eof of int ] <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dt class="spec value" id="val-read_until"><a href="#val-read_until" class="anchor"></a><code><span class="keyword">val</span> read_until : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> [ `Pred of char <span>&#45;&gt;</span> bool | `Char of char ] <span>&#45;&gt;</span> keep_delim:bool <span>&#45;&gt;</span> [ `Ok of string | `Eof_without_delim of string | `Eof ] <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>read_until t pred ~keep_delim</code> reads until it hits a delimiter <code>c</code> such that:</p><ul><li>if <code>pred = `Char c'</code> then <code>c = c'</code></li><li>if <code>pred = `Pred p</code> then <code>p c</code></li></ul><p><code>`Char c'</code> is equivalent to <code>`Pred (fun c -&gt; c = c')</code> but the underlying implementation is more efficient, in particular it will not call a function on every input character.</p><p><code>read_until</code> returns a freshly-allocated string consisting of all the characters read and optionally including the delimiter as per <code>keep_delim</code>.</p></dd></dl><dl><dt class="spec value" id="val-read_until_max"><a href="#val-read_until_max" class="anchor"></a><code><span class="keyword">val</span> read_until_max : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> [ `Pred of char <span>&#45;&gt;</span> bool | `Char of char ] <span>&#45;&gt;</span> keep_delim:bool <span>&#45;&gt;</span> max:int <span>&#45;&gt;</span> [ `Ok of string | `Eof_without_delim of string | `Eof | `Max_exceeded of string ] <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>read_until_max</code> is just like <code>read_until</code>, except you have the option of specifying a maximum number of chars to read.</p></dd></dl><dl><dt class="spec value" id="val-read_line"><a href="#val-read_line" class="anchor"></a><code><span class="keyword">val</span> read_line : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string <a href="Read_result/index.html#type-t">Read_result.t</a> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>read_line t</code> reads up to and including the next newline (<code>\n</code>) character (or <code>\r\n</code>) and returns a freshly-allocated string containing everything up to but not including the newline character. If <code>read_line</code> encounters EOF before the newline char then everything read up to but not including EOF will be returned as a line.</p></dd></dl><dl><dt class="spec value" id="val-really_read_line"><a href="#val-really_read_line" class="anchor"></a><code><span class="keyword">val</span> really_read_line : wait_time:<a href="../../../core_kernel/Core_kernel__Time_intf/module-type-S/Time/Span/index.html#type-t">Core.Time.Span.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string option <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>really_read_line ~wait_time t</code> reads up to and including the next newline (<code>\n</code>) character and returns an optional, freshly-allocated string containing everything up to but not including the newline character. If <code>really_read_line</code> encounters EOF before the newline char, then a time span of <code>wait_time</code> will be used before the input operation is retried. If the descriptor is closed, <code>None</code> will be returned.</p></dd></dl><dl><dt class="spec type" id="type-read"><a href="#type-read" class="anchor"></a><code><span class="keyword">type</span> 'a read</code><code> = ?&#8288;parse_pos:<a href="../../../sexplib/Sexplib__Sexp/Parse_pos/index.html#type-t">Core.Sexp.Parse_pos.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt></dl><dl><dt class="spec value" id="val-read_sexp"><a href="#val-read_sexp" class="anchor"></a><code><span class="keyword">val</span> read_sexp : (<a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../core_kernel/Core_kernel/Sexp/index.html#type-t">Core.Sexp.t</a> <a href="Read_result/index.html#type-t">Read_result.t</a> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a>) <a href="index.html#type-read">read</a></code></dt><dd><p><code>read_sexp t</code> reads the next sexp.</p></dd></dl><dl><dt class="spec value" id="val-read_sexps"><a href="#val-read_sexps" class="anchor"></a><code><span class="keyword">val</span> read_sexps : (<a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../core_kernel/Core_kernel/Sexp/index.html#type-t">Core.Sexp.t</a> <a href="../../../async_kernel/Async_kernel__Pipe/Reader/index.html#type-t">Async_unix__.Import.Pipe.Reader.t</a>) <a href="index.html#type-read">read</a></code></dt><dd><p><code>read_sexps t</code> reads all the sexps and returns them as a pipe. When the reader reaches EOF or the pipe is closed, <code>read_sexps</code> closes the reader, and then after the reader close is finished, closes the pipe.</p></dd></dl><dl><dt class="spec value" id="val-read_bin_prot"><a href="#val-read_bin_prot" class="anchor"></a><code><span class="keyword">val</span> read_bin_prot : ?&#8288;max_len:int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../../bin_prot/Bin_prot/Type_class/index.html#type-reader">Bin_prot.Type_class.reader</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="Read_result/index.html#type-t">Read_result.t</a> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>read_bin_prot ?max_len t bp_reader</code> reads the next binary protocol message using binary protocol reader <code>bp_reader</code>. The format is the &quot;size-prefixed binary protocol&quot;, in which the length of the data is prefixed as a 64-bit integer to the data. This is the format that <code>Writer.write_bin_prot</code> writes.</p><p>For higher performance, consider <code>Unpack_sequence.unpack_bin_prot_from_reader</code>.</p></dd></dl><dl><dt class="spec value" id="val-peek_bin_prot"><a href="#val-peek_bin_prot" class="anchor"></a><code><span class="keyword">val</span> peek_bin_prot : ?&#8288;max_len:int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../../bin_prot/Bin_prot/Type_class/index.html#type-reader">Bin_prot.Type_class.reader</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="Read_result/index.html#type-t">Read_result.t</a> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p>Similar to <code>read_bin_prot</code>, but doesn't consume any bytes from <code>t</code>.</p></dd></dl><dl><dt class="spec value" id="val-read_marshal_raw"><a href="#val-read_marshal_raw" class="anchor"></a><code><span class="keyword">val</span> read_marshal_raw : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../core_kernel/Core_kernel/Bytes/index.html#type-t">Core.Bytes.t</a> <a href="Read_result/index.html#type-t">Read_result.t</a> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>read_marshal_raw</code> reads and returns a buffer containing one marshaled value, but doesn't unmarshal it. You can just call <code>Marshal.from_string</code> on the string, and cast it to the desired type (preferably the actual type). Similar to <code>Marshal.from_channel</code>, but suffers from the String-length limitation (16MB) on 32-bit platforms.</p></dd></dl><dl><dt class="spec value" id="val-read_marshal"><a href="#val-read_marshal" class="anchor"></a><code><span class="keyword">val</span> read_marshal : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">_</span> <a href="Read_result/index.html#type-t">Read_result.t</a> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>read_marshal</code> is like <code>read_marshal_raw</code>, but unmarshals the value after reading it.</p></dd></dl><dl><dt class="spec value" id="val-recv"><a href="#val-recv" class="anchor"></a><code><span class="keyword">val</span> recv : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../core_kernel/Core_kernel/Bytes/index.html#type-t">Core.Bytes.t</a> <a href="Read_result/index.html#type-t">Read_result.t</a> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>recv</code> returns a string that was written with <code>Writer.send</code>.</p></dd></dl><dl><dt class="spec value" id="val-read_all"><a href="#val-read_all" class="anchor"></a><code><span class="keyword">val</span> read_all : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="Read_result/index.html#type-t">Read_result.t</a> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel__Pipe/Reader/index.html#type-t">Async_unix__.Import.Pipe.Reader.t</a></code></dt><dd><p><code>read_all t read_one</code> returns a pipe that receives all values read from <code>t</code> by repeatedly using <code>read_one t</code>. When the reader reaches EOF, it closes the reader, and then after the reader close is finished, closes the pipe.</p></dd></dl><dl><dt class="spec value" id="val-lseek"><a href="#val-lseek" class="anchor"></a><code><span class="keyword">val</span> lseek : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int64 <span>&#45;&gt;</span> mode:[&lt; `Set | `End ] <span>&#45;&gt;</span> int64 <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>lseek t offset ~mode</code> clears <code>t</code>'s buffer and calls <code>Unix.lseek</code> on <code>t</code>'s file descriptor. The <code>`Cur</code> mode is not exposed because seeking relative to the current position of the file descriptor is not the same as seeking relative to the current position of the reader.</p></dd></dl><dl><dt class="spec value" id="val-ltell"><a href="#val-ltell" class="anchor"></a><code><span class="keyword">val</span> ltell : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int64 <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>ltell t</code> returns the file position of <code>t</code> from the perspective of a consumer of <code>t</code>. It uses <code>Unix.lseek</code> to find the file position of <code>t</code>'s underlying file descriptor, and then subtracts the number of bytes in <code>t</code>'s buffer that have been read from the OS but not from <code>t</code>.</p></dd></dl><dl><dt class="spec value" id="val-lines"><a href="#val-lines" class="anchor"></a><code><span class="keyword">val</span> lines : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string <a href="../../../async_kernel/Async_kernel__Pipe/Reader/index.html#type-t">Async_unix__.Import.Pipe.Reader.t</a></code></dt><dd><p><code>lines t</code> reads all the lines from <code>t</code> and puts them in the pipe, one line per pipe element. The lines do not contain the trailing newline. When the reader reaches EOF or the pipe is closed, <code>lines</code> closes the reader, and then after the reader close is finished, closes the pipe.</p></dd></dl><dl><dt class="spec value" id="val-contents"><a href="#val-contents" class="anchor"></a><code><span class="keyword">val</span> contents : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>contents t</code> returns the string corresponding to the full contents (up to EOF) of the reader. <code>contents</code> closes <code>t</code> before returning the string.</p></dd></dl><dl><dt class="spec value" id="val-file_contents"><a href="#val-file_contents" class="anchor"></a><code><span class="keyword">val</span> file_contents : string <span>&#45;&gt;</span> string <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>file_contents file</code> returns the string with the full contents of the file.</p></dd></dl><dl><dt class="spec value" id="val-file_lines"><a href="#val-file_lines" class="anchor"></a><code><span class="keyword">val</span> file_lines : string <span>&#45;&gt;</span> string list <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>file_lines file</code> returns a list of the lines in the file. The lines do not contain the trailing newline.</p></dd></dl><dl><dt class="spec type" id="type-load"><a href="#type-load" class="anchor"></a><code><span class="keyword">type</span> ('sexp, 'a, 'b) load</code><code> = ?&#8288;exclusive:bool <span>&#45;&gt;</span> ?&#8288;expand_macros:bool <span>&#45;&gt;</span> string <span>&#45;&gt;</span> (<span class="type-var">'sexp</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>load_sexp file conv</code> loads a sexp from <code>file</code> and converts it to a value using <code>conv</code>. This function provides an accurate error location if <code>convert</code> raises <code>Of_sexp_error</code>.</p><p><code>load_sexps</code> is similar, but converts a sequence of sexps.</p><p>Using <code>~expand_macros:true</code> expands macros as defined in <a href="../../../sexplib/Sexplib/Macro/index.html"><code>Macro</code></a>. If <code>~expand_macros:true</code> then the <code>exclusive</code> flag is ignored. Also, <code>load_annotated*</code> don't support <code>~expand_macros:true</code>, and will raise.</p></dd></dl><dl><dt class="spec value" id="val-load_sexp"><a href="#val-load_sexp" class="anchor"></a><code><span class="keyword">val</span> load_sexp : (<a href="../../../core_kernel/Core_kernel/Sexp/index.html#type-t">Core.Sexp.t</a>, <span class="type-var">'a</span>, <span class="type-var">'a</span> <a href="../../../core_kernel/Core_kernel/Or_error/index.html#type-t">Core.Or_error.t</a>) <a href="index.html#type-load">load</a></code></dt><dt class="spec value" id="val-load_sexp_exn"><a href="#val-load_sexp_exn" class="anchor"></a><code><span class="keyword">val</span> load_sexp_exn : (<a href="../../../core_kernel/Core_kernel/Sexp/index.html#type-t">Core.Sexp.t</a>, <span class="type-var">'a</span>, <span class="type-var">'a</span>) <a href="index.html#type-load">load</a></code></dt><dt class="spec value" id="val-load_sexps"><a href="#val-load_sexps" class="anchor"></a><code><span class="keyword">val</span> load_sexps : (<a href="../../../core_kernel/Core_kernel/Sexp/index.html#type-t">Core.Sexp.t</a>, <span class="type-var">'a</span>, <span class="type-var">'a</span> list <a href="../../../core_kernel/Core_kernel/Or_error/index.html#type-t">Core.Or_error.t</a>) <a href="index.html#type-load">load</a></code></dt><dt class="spec value" id="val-load_sexps_exn"><a href="#val-load_sexps_exn" class="anchor"></a><code><span class="keyword">val</span> load_sexps_exn : (<a href="../../../core_kernel/Core_kernel/Sexp/index.html#type-t">Core.Sexp.t</a>, <span class="type-var">'a</span>, <span class="type-var">'a</span> list) <a href="index.html#type-load">load</a></code></dt><dt class="spec value" id="val-load_annotated_sexp"><a href="#val-load_annotated_sexp" class="anchor"></a><code><span class="keyword">val</span> load_annotated_sexp : (<a href="../../../sexplib/Sexplib__Sexp/Annotated/index.html#type-t">Core.Sexp.Annotated.t</a>, <span class="type-var">'a</span>, <span class="type-var">'a</span> <a href="../../../core_kernel/Core_kernel/Or_error/index.html#type-t">Core.Or_error.t</a>) <a href="index.html#type-load">load</a></code></dt><dt class="spec value" id="val-load_annotated_sexp_exn"><a href="#val-load_annotated_sexp_exn" class="anchor"></a><code><span class="keyword">val</span> load_annotated_sexp_exn : (<a href="../../../sexplib/Sexplib__Sexp/Annotated/index.html#type-t">Core.Sexp.Annotated.t</a>, <span class="type-var">'a</span>, <span class="type-var">'a</span>) <a href="index.html#type-load">load</a></code></dt><dt class="spec value" id="val-load_annotated_sexps"><a href="#val-load_annotated_sexps" class="anchor"></a><code><span class="keyword">val</span> load_annotated_sexps : (<a href="../../../sexplib/Sexplib__Sexp/Annotated/index.html#type-t">Core.Sexp.Annotated.t</a>, <span class="type-var">'a</span>, <span class="type-var">'a</span> list <a href="../../../core_kernel/Core_kernel/Or_error/index.html#type-t">Core.Or_error.t</a>) <a href="index.html#type-load">load</a></code></dt><dt class="spec value" id="val-load_annotated_sexps_exn"><a href="#val-load_annotated_sexps_exn" class="anchor"></a><code><span class="keyword">val</span> load_annotated_sexps_exn : (<a href="../../../sexplib/Sexplib__Sexp/Annotated/index.html#type-t">Core.Sexp.Annotated.t</a>, <span class="type-var">'a</span>, <span class="type-var">'a</span> list) <a href="index.html#type-load">load</a></code></dt></dl><dl><dt class="spec type" id="type-load_bin_prot"><a href="#type-load_bin_prot" class="anchor"></a><code><span class="keyword">type</span> ('a, 'b) load_bin_prot</code><code> = ?&#8288;exclusive:bool <span>&#45;&gt;</span> ?&#8288;max_len:int <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../../bin_prot/Bin_prot/Type_class/index.html#type-reader">Bin_prot.Type_class.reader</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt></dl><dl><dt class="spec value" id="val-load_bin_prot"><a href="#val-load_bin_prot" class="anchor"></a><code><span class="keyword">val</span> load_bin_prot : (<span class="type-var">'a</span>, <span class="type-var">'a</span> <a href="../../../core_kernel/Core_kernel/Or_error/index.html#type-t">Core.Or_error.t</a>) <a href="index.html#type-load_bin_prot">load_bin_prot</a></code></dt><dt class="spec value" id="val-load_bin_prot_exn"><a href="#val-load_bin_prot_exn" class="anchor"></a><code><span class="keyword">val</span> load_bin_prot_exn : (<span class="type-var">'a</span>, <span class="type-var">'a</span>) <a href="index.html#type-load_bin_prot">load_bin_prot</a></code></dt></dl><div class="spec module" id="module-Macro_loader"><a href="#module-Macro_loader" class="anchor"></a><code><span class="keyword">module</span> <a href="Macro_loader/index.html">Macro_loader</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></div></body></html>