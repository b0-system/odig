<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>IO (extlib.IO)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">extlib</a> &#x00BB; IO</nav><h1>Module <code>IO</code></h1><p>High-order abstract I/O.</p><p>IO module simply deals with abstract inputs/outputs. It provides a set of methods for working with these IO as well as several constructors that enable to write to an underlying channel, buffer, or enum.</p><nav class="toc"><ul><li><a href="#standard-api">Standard API</a></li><li><a href="#creation-of-io-inputs/outputs">Creation of IO Inputs/Outputs</a></li><li><a href="#utilities">Utilities</a></li><li><a href="#binary-files-api">Binary files API</a></li><li><a href="#bits-api">Bits API</a></li><li><a href="#generic-io-object-wrappers">Generic IO Object Wrappers</a></li></ul></nav></header><dl><dt class="spec type" id="type-input"><a href="#type-input" class="anchor"></a><code><span class="keyword">type</span> input</code></dt><dd><p>The abstract input type.</p></dd></dl><dl><dt class="spec type" id="type-output"><a href="#type-output" class="anchor"></a><code><span class="keyword">type</span> 'a output</code></dt><dd><p>The abstract output type, <code>'a</code> is the accumulator data, it is returned when the <code>close_out</code> function is called.</p></dd></dl><dl><dt class="spec exception" id="exception-No_more_input"><a href="#exception-No_more_input" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">No_more_input</span></code></dt><dd><p>This exception is raised when reading on an input with the <code>read</code> or <code>nread</code> functions while there is no available token to read.</p></dd></dl><dl><dt class="spec exception" id="exception-Input_closed"><a href="#exception-Input_closed" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Input_closed</span></code></dt><dd><p>This exception is raised when reading on a closed input.</p></dd></dl><dl><dt class="spec exception" id="exception-Output_closed"><a href="#exception-Output_closed" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Output_closed</span></code></dt><dd><p>This exception is raised when reading on a closed output.</p></dd></dl><section><header><h6 id="standard-api"><a href="#standard-api" class="anchor"></a>Standard API</h6></header><dl><dt class="spec value" id="val-read"><a href="#val-read" class="anchor"></a><code><span class="keyword">val</span> read : <a href="index.html#type-input">input</a> <span>&#45;&gt;</span> char</code></dt><dd><p>Read a single char from an input or raise <code>No_more_input</code> if no input available.</p></dd></dl><dl><dt class="spec value" id="val-nread"><a href="#val-nread" class="anchor"></a><code><span class="keyword">val</span> nread : <a href="index.html#type-input">input</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="../../ocaml/Stdlib/Bytes/index.html#type-t">ExtBytes.Bytes.t</a></code></dt><dd><p><code>nread i n</code> reads a byte sequence of size up to <code>n</code> from an input. The function will raise <code>No_more_input</code> if no input is available. It will raise <code>Invalid_argument</code> if <code>n</code> &lt; 0.</p></dd></dl><dl><dt class="spec value" id="val-really_nread"><a href="#val-really_nread" class="anchor"></a><code><span class="keyword">val</span> really_nread : <a href="index.html#type-input">input</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="../../ocaml/Stdlib/Bytes/index.html#type-t">ExtBytes.Bytes.t</a></code></dt><dd><p><code>really_nread i n</code> reads a byte sequence of exactly <code>n</code> characters from the input. Raises <code>No_more_input</code> if at least <code>n</code> characters are not available. Raises <code>Invalid_argument</code> if <code>n</code> &lt; 0.</p></dd></dl><dl><dt class="spec value" id="val-nread_string"><a href="#val-nread_string" class="anchor"></a><code><span class="keyword">val</span> nread_string : <a href="index.html#type-input">input</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> string</code></dt><dd><p>as <code>nread</code>, but reads a string.</p></dd></dl><dl><dt class="spec value" id="val-really_nread_string"><a href="#val-really_nread_string" class="anchor"></a><code><span class="keyword">val</span> really_nread_string : <a href="index.html#type-input">input</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> string</code></dt><dd><p>as <code>really_nread</code>, but reads a string.</p></dd></dl><dl><dt class="spec value" id="val-input"><a href="#val-input" class="anchor"></a><code><span class="keyword">val</span> input : <a href="index.html#type-input">input</a> <span>&#45;&gt;</span> <a href="../../ocaml/Stdlib/Bytes/index.html#type-t">ExtBytes.Bytes.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dd><p><code>input i b p l</code> reads up to <code>l</code> characters from the given input, storing them in buffer <code>b</code>, starting at character number <code>p</code>. It returns the actual number of characters read or raise <code>No_more_input</code> if no character can be read. It will raise <code>Invalid_argument</code> if <code>p</code> and <code>l</code> do not designate a valid subsequence of <code>b</code>.</p></dd></dl><dl><dt class="spec value" id="val-really_input"><a href="#val-really_input" class="anchor"></a><code><span class="keyword">val</span> really_input : <a href="index.html#type-input">input</a> <span>&#45;&gt;</span> <a href="../../ocaml/Stdlib/Bytes/index.html#type-t">ExtBytes.Bytes.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dd><p><code>really_input i b p l</code> reads exactly <code>l</code> characters from the given input, storing them in the buffer <code>b</code>, starting at position <code>p</code>. For consistency with <a href="index.html#type-input"><code>IO.input</code></a> it returns <code>l</code>. Raises <code>No_more_input</code> if at <code>l</code> characters are not available. Raises <code>Invalid_argument</code> if <code>p</code> and <code>l</code> do not designate a valid subsequence of <code>b</code>.</p></dd></dl><dl><dt class="spec value" id="val-close_in"><a href="#val-close_in" class="anchor"></a><code><span class="keyword">val</span> close_in : <a href="index.html#type-input">input</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Close the input. It can no longer be read from.</p></dd></dl><dl><dt class="spec value" id="val-write"><a href="#val-write" class="anchor"></a><code><span class="keyword">val</span> write : <span class="type-var">'a</span> <a href="index.html#type-output">output</a> <span>&#45;&gt;</span> char <span>&#45;&gt;</span> unit</code></dt><dd><p>Write a single char to an output.</p></dd></dl><dl><dt class="spec value" id="val-nwrite"><a href="#val-nwrite" class="anchor"></a><code><span class="keyword">val</span> nwrite : <span class="type-var">'a</span> <a href="index.html#type-output">output</a> <span>&#45;&gt;</span> <a href="../../ocaml/Stdlib/Bytes/index.html#type-t">ExtBytes.Bytes.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Write a byte sequence to an output.</p></dd></dl><dl><dt class="spec value" id="val-nwrite_string"><a href="#val-nwrite_string" class="anchor"></a><code><span class="keyword">val</span> nwrite_string : <span class="type-var">'a</span> <a href="index.html#type-output">output</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> unit</code></dt><dd><p>Write a string to an output.</p></dd></dl><dl><dt class="spec value" id="val-output"><a href="#val-output" class="anchor"></a><code><span class="keyword">val</span> output : <span class="type-var">'a</span> <a href="index.html#type-output">output</a> <span>&#45;&gt;</span> <a href="../../ocaml/Stdlib/Bytes/index.html#type-t">ExtBytes.Bytes.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dd><p><code>output o b p l</code> writes up to <code>l</code> characters from byte sequence <code>b</code>, starting at offset <code>p</code>. It returns the number of characters written. It will raise <code>Invalid_argument</code> if <code>p</code> and <code>l</code> do not designate a valid subsequence of <code>b</code>.</p></dd></dl><dl><dt class="spec value" id="val-really_output"><a href="#val-really_output" class="anchor"></a><code><span class="keyword">val</span> really_output : <span class="type-var">'a</span> <a href="index.html#type-output">output</a> <span>&#45;&gt;</span> <a href="../../ocaml/Stdlib/Bytes/index.html#type-t">ExtBytes.Bytes.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dd><p><code>really_output o b p l</code> writes exactly <code>l</code> characters from byte sequence <code>b</code> onto the the output, starting with the character at offset <code>p</code>. For consistency with <a href="index.html#type-output"><code>IO.output</code></a> it returns <code>l</code>. Raises <code>Invalid_argument</code> if <code>p</code> and <code>l</code> do not designate a valid subsequence of <code>b</code>.</p></dd></dl><dl><dt class="spec value" id="val-flush"><a href="#val-flush" class="anchor"></a><code><span class="keyword">val</span> flush : <span class="type-var">'a</span> <a href="index.html#type-output">output</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Flush an output.</p></dd></dl><dl><dt class="spec value" id="val-close_out"><a href="#val-close_out" class="anchor"></a><code><span class="keyword">val</span> close_out : <span class="type-var">'a</span> <a href="index.html#type-output">output</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Close the output and return its accumulator data. It can no longer be written.</p></dd></dl></section><section><header><h6 id="creation-of-io-inputs/outputs"><a href="#creation-of-io-inputs/outputs" class="anchor"></a>Creation of IO Inputs/Outputs</h6></header><dl><dt class="spec value" id="val-input_string"><a href="#val-input_string" class="anchor"></a><code><span class="keyword">val</span> input_string : string <span>&#45;&gt;</span> <a href="index.html#type-input">input</a></code></dt><dd><p>Create an input that will read from a string.</p></dd></dl><dl><dt class="spec value" id="val-input_bytes"><a href="#val-input_bytes" class="anchor"></a><code><span class="keyword">val</span> input_bytes : <a href="../../ocaml/Stdlib/Bytes/index.html#type-t">ExtBytes.Bytes.t</a> <span>&#45;&gt;</span> <a href="index.html#type-input">input</a></code></dt><dd><p>Create an input that will read from a byte sequence.</p></dd></dl><dl><dt class="spec value" id="val-output_string"><a href="#val-output_string" class="anchor"></a><code><span class="keyword">val</span> output_string : unit <span>&#45;&gt;</span> string <a href="index.html#type-output">output</a></code></dt><dd><p>Create an output that will write into a string in an efficient way. When closed, the output returns all the data written into it.</p></dd></dl><dl><dt class="spec value" id="val-output_bytes"><a href="#val-output_bytes" class="anchor"></a><code><span class="keyword">val</span> output_bytes : unit <span>&#45;&gt;</span> <a href="../../ocaml/Stdlib/Bytes/index.html#type-t">ExtBytes.Bytes.t</a> <a href="index.html#type-output">output</a></code></dt><dd><p>Create an output that will write into a byte sequence in an efficient way. When closed, the output returns all the data written into it.</p></dd></dl><dl><dt class="spec value" id="val-output_strings"><a href="#val-output_strings" class="anchor"></a><code><span class="keyword">val</span> output_strings : unit <span>&#45;&gt;</span> string list <a href="index.html#type-output">output</a></code></dt><dd><p>Create an output that will write into a string in an efficient way. When closed, the output returns all the data written into it. Several strings are used in case the output size excess max_string_length</p></dd></dl><dl><dt class="spec value" id="val-input_channel"><a href="#val-input_channel" class="anchor"></a><code><span class="keyword">val</span> input_channel : <a href="../../ocaml/Stdlib/index.html#type-in_channel">Stdlib.in_channel</a> <span>&#45;&gt;</span> <a href="index.html#type-input">input</a></code></dt><dd><p>Create an input that will read from a channel.</p></dd></dl><dl><dt class="spec value" id="val-output_channel"><a href="#val-output_channel" class="anchor"></a><code><span class="keyword">val</span> output_channel : <a href="../../ocaml/Stdlib/index.html#type-out_channel">Stdlib.out_channel</a> <span>&#45;&gt;</span> unit <a href="index.html#type-output">output</a></code></dt><dd><p>Create an output that will write into a channel.</p></dd></dl><dl><dt class="spec value" id="val-input_enum"><a href="#val-input_enum" class="anchor"></a><code><span class="keyword">val</span> input_enum : char <a href="../Enum/index.html#type-t">Enum.t</a> <span>&#45;&gt;</span> <a href="index.html#type-input">input</a></code></dt><dd><p>Create an input that will read from an <code>enum</code>.</p></dd></dl><dl><dt class="spec value" id="val-output_enum"><a href="#val-output_enum" class="anchor"></a><code><span class="keyword">val</span> output_enum : unit <span>&#45;&gt;</span> char <a href="../Enum/index.html#type-t">Enum.t</a> <a href="index.html#type-output">output</a></code></dt><dd><p>Create an output that will write into an <code>enum</code>. The final enum is returned when the output is closed.</p></dd></dl><dl><dt class="spec value" id="val-create_in"><a href="#val-create_in" class="anchor"></a><code><span class="keyword">val</span> create_in : read:(unit <span>&#45;&gt;</span> char) <span>&#45;&gt;</span> input:(<a href="../../ocaml/Stdlib/Bytes/index.html#type-t">ExtBytes.Bytes.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> close:(unit <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <a href="index.html#type-input">input</a></code></dt><dd><p>Fully create an input by giving all the needed functions.</p></dd></dl><dl><dt class="spec value" id="val-create_out"><a href="#val-create_out" class="anchor"></a><code><span class="keyword">val</span> create_out : write:(char <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> output:(<a href="../../ocaml/Stdlib/Bytes/index.html#type-t">ExtBytes.Bytes.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> flush:(unit <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> close:(unit <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-output">output</a></code></dt><dd><p>Fully create an output by giving all the needed functions.</p></dd></dl></section><section><header><h6 id="utilities"><a href="#utilities" class="anchor"></a>Utilities</h6></header><dl><dt class="spec value" id="val-scanf"><a href="#val-scanf" class="anchor"></a><code><span class="keyword">val</span> scanf : <a href="index.html#type-input">input</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>) <a href="../../ocaml/Stdlib/Scanf/index.html#type-scanner">Stdlib.Scanf.scanner</a></code></dt><dd><p>The scanf function works for any input.</p></dd></dl><dl><dt class="spec value" id="val-printf"><a href="#val-printf" class="anchor"></a><code><span class="keyword">val</span> printf : <span class="type-var">'a</span> <a href="index.html#type-output">output</a> <span>&#45;&gt;</span> (<span class="type-var">'b</span>, unit, string, unit) <a href="../../ocaml/Stdlib/index.html#type-format4">Stdlib.format4</a> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p>The printf function works for any output.</p></dd></dl><dl><dt class="spec value" id="val-read_all"><a href="#val-read_all" class="anchor"></a><code><span class="keyword">val</span> read_all : <a href="index.html#type-input">input</a> <span>&#45;&gt;</span> string</code></dt><dd><p>read all the contents of the input until <code>No_more_input</code> is raised.</p></dd></dl><dl><dt class="spec value" id="val-pipe"><a href="#val-pipe" class="anchor"></a><code><span class="keyword">val</span> pipe : unit <span>&#45;&gt;</span> <a href="index.html#type-input">input</a> * unit <a href="index.html#type-output">output</a></code></dt><dd><p>Create a pipe between an input and an ouput. Data written from the output can be read from the input.</p></dd></dl><dl><dt class="spec value" id="val-pos_in"><a href="#val-pos_in" class="anchor"></a><code><span class="keyword">val</span> pos_in : <a href="index.html#type-input">input</a> <span>&#45;&gt;</span> <a href="index.html#type-input">input</a> * (unit <span>&#45;&gt;</span> int)</code></dt><dd><p>Create an input that provide a count function of the number of Bytes.t read from it.</p></dd></dl><dl><dt class="spec value" id="val-pos_out"><a href="#val-pos_out" class="anchor"></a><code><span class="keyword">val</span> pos_out : <span class="type-var">'a</span> <a href="index.html#type-output">output</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-output">output</a> * (unit <span>&#45;&gt;</span> int)</code></dt><dd><p>Create an output that provide a count function of the number of Bytes.t written through it.</p></dd></dl><dl><dt class="spec external" id="val-cast_output"><a href="#val-cast_output" class="anchor"></a><code><span class="keyword">val</span> cast_output : <span class="type-var">'a</span> <a href="index.html#type-output">output</a> <span>&#45;&gt;</span> unit <a href="index.html#type-output">output</a></code></dt><dd><p>You can safely transform any output to an unit output in a safe way by using this function.</p></dd></dl></section><section><header><h6 id="binary-files-api"><a href="#binary-files-api" class="anchor"></a>Binary files API</h6><p>Here is some API useful for working with binary files, in particular binary files generated by C applications. By default, encoding of multibyte integers is low-endian. The BigEndian module provide multibyte operations with other encoding.</p></header><dl><dt class="spec exception" id="exception-Overflow"><a href="#exception-Overflow" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Overflow</span> <span class="keyword">of</span> string</code></dt><dd><p>Exception raised when a read or write operation cannot be completed.</p></dd></dl><dl><dt class="spec value" id="val-read_byte"><a href="#val-read_byte" class="anchor"></a><code><span class="keyword">val</span> read_byte : <a href="index.html#type-input">input</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Read an unsigned 8-bit integer.</p></dd></dl><dl><dt class="spec value" id="val-read_signed_byte"><a href="#val-read_signed_byte" class="anchor"></a><code><span class="keyword">val</span> read_signed_byte : <a href="index.html#type-input">input</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Read an signed 8-bit integer.</p></dd></dl><dl><dt class="spec value" id="val-read_ui16"><a href="#val-read_ui16" class="anchor"></a><code><span class="keyword">val</span> read_ui16 : <a href="index.html#type-input">input</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Read an unsigned 16-bit word.</p></dd></dl><dl><dt class="spec value" id="val-read_i16"><a href="#val-read_i16" class="anchor"></a><code><span class="keyword">val</span> read_i16 : <a href="index.html#type-input">input</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Read a signed 16-bit word.</p></dd></dl><dl><dt class="spec value" id="val-read_i31"><a href="#val-read_i31" class="anchor"></a><code><span class="keyword">val</span> read_i31 : <a href="index.html#type-input">input</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Read a signed 32-bit integer. Raise <code>Overflow</code> if the read integer cannot be represented as an OCaml 31-bit integer.</p></dd></dl><dl><dt class="spec value" id="val-read_i32"><a href="#val-read_i32" class="anchor"></a><code><span class="keyword">val</span> read_i32 : <a href="index.html#type-input">input</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Deprecated, same as read_i31</p></dd></dl><dl><dt class="spec value" id="val-read_i32_as_int"><a href="#val-read_i32_as_int" class="anchor"></a><code><span class="keyword">val</span> read_i32_as_int : <a href="index.html#type-input">input</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Read a signed 32-bit integer, represented as OCaml integer, wrapping around 31-bit int on 32-bit architecture</p></dd></dl><dl><dt class="spec value" id="val-read_real_i32"><a href="#val-read_real_i32" class="anchor"></a><code><span class="keyword">val</span> read_real_i32 : <a href="index.html#type-input">input</a> <span>&#45;&gt;</span> int32</code></dt><dd><p>Read a signed 32-bit integer as an OCaml int32.</p></dd></dl><dl><dt class="spec value" id="val-read_i64"><a href="#val-read_i64" class="anchor"></a><code><span class="keyword">val</span> read_i64 : <a href="index.html#type-input">input</a> <span>&#45;&gt;</span> int64</code></dt><dd><p>Read a signed 64-bit integer as an OCaml int64.</p></dd></dl><dl><dt class="spec value" id="val-read_float32"><a href="#val-read_float32" class="anchor"></a><code><span class="keyword">val</span> read_float32 : <a href="index.html#type-input">input</a> <span>&#45;&gt;</span> float</code></dt><dd><p>Read an IEEE single precision floating point value (32 bits).</p></dd></dl><dl><dt class="spec value" id="val-read_double"><a href="#val-read_double" class="anchor"></a><code><span class="keyword">val</span> read_double : <a href="index.html#type-input">input</a> <span>&#45;&gt;</span> float</code></dt><dd><p>Read an IEEE double precision floating point value (64 bits).</p></dd></dl><dl><dt class="spec value" id="val-read_string"><a href="#val-read_string" class="anchor"></a><code><span class="keyword">val</span> read_string : <a href="index.html#type-input">input</a> <span>&#45;&gt;</span> string</code></dt><dd><p>Read a null-terminated string.</p></dd></dl><dl><dt class="spec value" id="val-read_bytes"><a href="#val-read_bytes" class="anchor"></a><code><span class="keyword">val</span> read_bytes : <a href="index.html#type-input">input</a> <span>&#45;&gt;</span> <a href="../../ocaml/Stdlib/Bytes/index.html#type-t">ExtBytes.Bytes.t</a></code></dt><dd><p>Read a null-terminated byte sequence.</p></dd></dl><dl><dt class="spec value" id="val-read_line"><a href="#val-read_line" class="anchor"></a><code><span class="keyword">val</span> read_line : <a href="index.html#type-input">input</a> <span>&#45;&gt;</span> string</code></dt><dd><p>Read a LF or CRLF terminated string.</p></dd></dl><dl><dt class="spec value" id="val-write_byte"><a href="#val-write_byte" class="anchor"></a><code><span class="keyword">val</span> write_byte : <span class="type-var">'a</span> <a href="index.html#type-output">output</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p>Write an unsigned 8-bit byte.</p></dd></dl><dl><dt class="spec value" id="val-write_ui16"><a href="#val-write_ui16" class="anchor"></a><code><span class="keyword">val</span> write_ui16 : <span class="type-var">'a</span> <a href="index.html#type-output">output</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p>Write an unsigned 16-bit word.</p></dd></dl><dl><dt class="spec value" id="val-write_i16"><a href="#val-write_i16" class="anchor"></a><code><span class="keyword">val</span> write_i16 : <span class="type-var">'a</span> <a href="index.html#type-output">output</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p>Write a signed 16-bit word.</p></dd></dl><dl><dt class="spec value" id="val-write_i31"><a href="#val-write_i31" class="anchor"></a><code><span class="keyword">val</span> write_i31 : <span class="type-var">'a</span> <a href="index.html#type-output">output</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p>Write a signed 31-bit integer as 4 bytes.</p></dd></dl><dl><dt class="spec value" id="val-write_i32"><a href="#val-write_i32" class="anchor"></a><code><span class="keyword">val</span> write_i32 : <span class="type-var">'a</span> <a href="index.html#type-output">output</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p>Write a signed 32-bit integer.</p></dd></dl><dl><dt class="spec value" id="val-write_real_i32"><a href="#val-write_real_i32" class="anchor"></a><code><span class="keyword">val</span> write_real_i32 : <span class="type-var">'a</span> <a href="index.html#type-output">output</a> <span>&#45;&gt;</span> int32 <span>&#45;&gt;</span> unit</code></dt><dd><p>Write an OCaml int32.</p></dd></dl><dl><dt class="spec value" id="val-write_i64"><a href="#val-write_i64" class="anchor"></a><code><span class="keyword">val</span> write_i64 : <span class="type-var">'a</span> <a href="index.html#type-output">output</a> <span>&#45;&gt;</span> int64 <span>&#45;&gt;</span> unit</code></dt><dd><p>Write an OCaml int64.</p></dd></dl><dl><dt class="spec value" id="val-write_float32"><a href="#val-write_float32" class="anchor"></a><code><span class="keyword">val</span> write_float32 : <span class="type-var">'a</span> <a href="index.html#type-output">output</a> <span>&#45;&gt;</span> float <span>&#45;&gt;</span> unit</code></dt><dd><p>Write an IEEE single precision floating point value (32 bits).</p></dd></dl><dl><dt class="spec value" id="val-write_double"><a href="#val-write_double" class="anchor"></a><code><span class="keyword">val</span> write_double : <span class="type-var">'a</span> <a href="index.html#type-output">output</a> <span>&#45;&gt;</span> float <span>&#45;&gt;</span> unit</code></dt><dd><p>Write an IEEE double precision floating point value (64 bits).</p></dd></dl><dl><dt class="spec value" id="val-write_string"><a href="#val-write_string" class="anchor"></a><code><span class="keyword">val</span> write_string : <span class="type-var">'a</span> <a href="index.html#type-output">output</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> unit</code></dt><dd><p>Write a string and append an null character.</p></dd></dl><dl><dt class="spec value" id="val-write_bytes"><a href="#val-write_bytes" class="anchor"></a><code><span class="keyword">val</span> write_bytes : <span class="type-var">'a</span> <a href="index.html#type-output">output</a> <span>&#45;&gt;</span> <a href="../../ocaml/Stdlib/Bytes/index.html#type-t">ExtBytes.Bytes.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Write a byte sequence and append an null character.</p></dd></dl><dl><dt class="spec value" id="val-write_line"><a href="#val-write_line" class="anchor"></a><code><span class="keyword">val</span> write_line : <span class="type-var">'a</span> <a href="index.html#type-output">output</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> unit</code></dt><dd><p>Write a line and append a LF (it might be converted to CRLF on some systems depending on the underlying IO).</p></dd></dl><dl><dt class="spec module" id="module-BigEndian"><a href="#module-BigEndian" class="anchor"></a><code><span class="keyword">module</span> <a href="BigEndian/index.html">BigEndian</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Same as operations above, but use big-endian encoding</p></dd></dl></section><section><header><h6 id="bits-api"><a href="#bits-api" class="anchor"></a>Bits API</h6><p>This enable you to read and write from an IO bit-by-bit or several bits at the same time.</p></header><dl><dt class="spec type" id="type-in_bits"><a href="#type-in_bits" class="anchor"></a><code><span class="keyword">type</span> in_bits</code></dt><dt class="spec type" id="type-out_bits"><a href="#type-out_bits" class="anchor"></a><code><span class="keyword">type</span> out_bits</code></dt></dl><dl><dt class="spec exception" id="exception-Bits_error"><a href="#exception-Bits_error" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Bits_error</span></code></dt></dl><dl><dt class="spec value" id="val-input_bits"><a href="#val-input_bits" class="anchor"></a><code><span class="keyword">val</span> input_bits : <a href="index.html#type-input">input</a> <span>&#45;&gt;</span> <a href="index.html#type-in_bits">in_bits</a></code></dt><dd><p>Read bits from an input</p></dd></dl><dl><dt class="spec value" id="val-output_bits"><a href="#val-output_bits" class="anchor"></a><code><span class="keyword">val</span> output_bits : <span class="type-var">'a</span> <a href="index.html#type-output">output</a> <span>&#45;&gt;</span> <a href="index.html#type-out_bits">out_bits</a></code></dt><dd><p>Write bits to an output</p></dd></dl><dl><dt class="spec value" id="val-read_bits"><a href="#val-read_bits" class="anchor"></a><code><span class="keyword">val</span> read_bits : <a href="index.html#type-in_bits">in_bits</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dd><p>Read up to 31 bits, raise Bits_error if n &lt; 0 or n &gt; 31</p></dd></dl><dl><dt class="spec value" id="val-write_bits"><a href="#val-write_bits" class="anchor"></a><code><span class="keyword">val</span> write_bits : <a href="index.html#type-out_bits">out_bits</a> <span>&#45;&gt;</span> nbits:int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p>Write up to 31 bits represented as a value, raise Bits_error if nbits &lt; 0 or nbits &gt; 31 or the value representation excess nbits.</p></dd></dl><dl><dt class="spec value" id="val-flush_bits"><a href="#val-flush_bits" class="anchor"></a><code><span class="keyword">val</span> flush_bits : <a href="index.html#type-out_bits">out_bits</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Flush remaining unwritten bits, adding up to 7 bits which values 0.</p></dd></dl><dl><dt class="spec value" id="val-drop_bits"><a href="#val-drop_bits" class="anchor"></a><code><span class="keyword">val</span> drop_bits : <a href="index.html#type-in_bits">in_bits</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Drop up to 7 buffered bits and restart to next input character.</p></dd></dl></section><section><header><h6 id="generic-io-object-wrappers"><a href="#generic-io-object-wrappers" class="anchor"></a>Generic IO Object Wrappers</h6><p>Theses OO Wrappers have been written to provide easy support of ExtLib IO by external librairies. If you want your library to support ExtLib IO without actually requiring ExtLib to compile, you can should implement the classes <code>in_channel</code>, <code>out_channel</code>, <code>poly_in_channel</code> and/or <code>poly_out_channel</code> which are the common IO specifications established for ExtLib, OCamlNet and Camomile.</p><p>(see http://www.ocaml-programming.de/tmp/IO-Classes.html for more details).</p></header><div class="spec class" id="class-in_channel"><a href="#class-in_channel" class="anchor"></a><code><span class="keyword">class</span> <a href="class-in_channel/index.html">in_channel</a> : <a href="index.html#type-input">input</a> <span>&#45;&gt;</span> <span class="keyword">object</span> ... <span class="keyword">end</span></code></div><div class="spec class" id="class-out_channel"><a href="#class-out_channel" class="anchor"></a><code><span class="keyword">class</span> <a href="class-out_channel/index.html">out_channel</a> : <span class="type-var">'a</span> <a href="index.html#type-output">output</a> <span>&#45;&gt;</span> <span class="keyword">object</span> ... <span class="keyword">end</span></code></div><div class="spec class" id="class-in_chars"><a href="#class-in_chars" class="anchor"></a><code><span class="keyword">class</span> <a href="class-in_chars/index.html">in_chars</a> : <a href="index.html#type-input">input</a> <span>&#45;&gt;</span> <span class="keyword">object</span> ... <span class="keyword">end</span></code></div><div class="spec class" id="class-out_chars"><a href="#class-out_chars" class="anchor"></a><code><span class="keyword">class</span> <a href="class-out_chars/index.html">out_chars</a> : <span class="type-var">'a</span> <a href="index.html#type-output">output</a> <span>&#45;&gt;</span> <span class="keyword">object</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-from_in_channel"><a href="#val-from_in_channel" class="anchor"></a><code><span class="keyword">val</span> from_in_channel : <a href="class-in_channel/index.html">in_channel</a> <span>&#45;&gt;</span> <a href="index.html#type-input">input</a></code></dt><dt class="spec value" id="val-from_out_channel"><a href="#val-from_out_channel" class="anchor"></a><code><span class="keyword">val</span> from_out_channel : <a href="class-out_channel/index.html">out_channel</a> <span>&#45;&gt;</span> unit <a href="index.html#type-output">output</a></code></dt><dt class="spec value" id="val-from_in_chars"><a href="#val-from_in_chars" class="anchor"></a><code><span class="keyword">val</span> from_in_chars : <a href="class-in_chars/index.html">in_chars</a> <span>&#45;&gt;</span> <a href="index.html#type-input">input</a></code></dt><dt class="spec value" id="val-from_out_chars"><a href="#val-from_out_chars" class="anchor"></a><code><span class="keyword">val</span> from_out_chars : <a href="class-out_chars/index.html">out_chars</a> <span>&#45;&gt;</span> unit <a href="index.html#type-output">output</a></code></dt></dl></section></div></body></html>