<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>React (react.React)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">react</a> &#x00BB; React</nav><h1>Module <code>React</code></h1><p>Declarative events and signals.</p><p>React is a module for functional reactive programming (frp). It provides support to program with time varying values : declarative <a href="E/index.html"><span>events</span></a> and <a href="S/index.html"><span>signals</span></a>. React doesn't define any primitive event or signal, this lets the client choose the concrete timeline.</p><p>Consult the <a href="index.html#sem"><span>semantics</span></a>, the <a href="index.html#basics"><span>basics</span></a> and <a href="index.html#ex"><span>examples</span></a>. Open the module to use it, this defines only two types and modules in your scope.</p><p><em>Release v1.2.1 - %%MAINTAINER%%</em></p><nav class="toc"><ul><li><a href="#interface">Interface</a></li><li><a href="#sem">Semantics</a><ul><li><a href="#evsem">Events</a></li><li><a href="#sigsem">Signals</a><ul><li><a href="#sigeq">Equality</a></li><li><a href="#sigcont">Continuity</a></li></ul></li></ul></li><li><a href="#basics">Basics</a><ul><li><a href="#primitives">Primitive events and signals</a></li><li><a href="#steps">Update steps</a></li><li><a href="#simultaneity">Simultaneous events</a></li><li><a href="#update">The update step and thread safety</a></li><li><a href="#sideeffects">Side effects</a></li><li><a href="#lifting">Lifting</a></li><li><a href="#recursion">Mutual and self reference</a></li><li><a href="#strongstop">Strong stops</a></li></ul></li><li><a href="#ex">Examples</a><ul><li><a href="#clock">Clock</a></li></ul></li></ul></nav></header><section><header><h2 id="interface"><a href="#interface" class="anchor"></a>Interface</h2></header><dl><dt class="spec type" id="type-event"><a href="#type-event" class="anchor"></a><code><span class="keyword">type</span> 'a event</code></dt><dd><p>The type for events of type <code>'a</code>.</p></dd></dl><dl><dt class="spec type" id="type-signal"><a href="#type-signal" class="anchor"></a><code><span class="keyword">type</span> 'a signal</code></dt><dd><p>The type for signals of type <code>'a</code>.</p></dd></dl><dl><dt class="spec type" id="type-step"><a href="#type-step" class="anchor"></a><code><span class="keyword">type</span> step</code></dt><dd><p>The type for update steps.</p></dd></dl><dl><dt class="spec module" id="module-E"><a href="#module-E" class="anchor"></a><code><span class="keyword">module</span> <a href="E/index.html">E</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Event combinators.</p></dd></dl><dl><dt class="spec module" id="module-S"><a href="#module-S" class="anchor"></a><code><span class="keyword">module</span> <a href="S/index.html">S</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Signal combinators.</p></dd></dl><dl><dt class="spec module" id="module-Step"><a href="#module-Step" class="anchor"></a><code><span class="keyword">module</span> <a href="Step/index.html">Step</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Update steps.</p></dd></dl></section><section><header><h2 id="sem"><a href="#sem" class="anchor"></a>Semantics</h2><p>The following notations are used to give precise meaning to the combinators. It is important to note that in these semantic descriptions the origin of time t = 0 is <em>always</em> fixed at the time at which the combinator creates the event or the signal and the semantics of the dependents is evaluated relative to this timeline.</p><p>We use dt to denote an infinitesimal amount of time.</p></header><section><header><h3 id="evsem"><a href="#evsem" class="anchor"></a>Events</h3><p>An event is a value with discrete occurrences over time.</p><p>The semantic function [] <code>: 'a event -&gt; time -&gt; 'a option</code> gives meaning to an event <code>e</code> by mapping it to a function of time [<code>e</code>] returning <code>Some v</code> whenever the event occurs with value <code>v</code> and <code>None</code> otherwise. We write [<code>e</code>]<sub>t</sub> the evaluation of this <em>semantic</em> function at time t.</p><p>As a shortcut notation we also define []<sub>&lt;t</sub> <code>: 'a event -&gt; 'a option</code> (resp. []<sub>&lt;=t</sub>) to denote the last occurrence, if any, of an event before (resp. before or at) <code>t</code>. More precisely :</p><ul><li>[<code>e</code>]<sub>&lt;t</sub> <code>=</code> [<code>e</code>]<sub>t'</sub> with t' the greatest t' &lt; t (resp. <code>&lt;=</code>) such that [<code>e</code>]<sub>t'</sub> <code>&lt;&gt; None</code>.</li><li>[<code>e</code>]<sub>&lt;t</sub> <code>= None</code> if there is no such t'.</li></ul></header></section><section><header><h3 id="sigsem"><a href="#sigsem" class="anchor"></a>Signals</h3><p>A signal is a value that varies continuously over time. In contrast to <a href="index.html#evsem"><span>events</span></a> which occur at specific point in time, a signal has a value at every point in time.</p><p>The semantic function [] <code>: 'a signal -&gt; time -&gt; 'a</code> gives meaning to a signal <code>s</code> by mapping it to a function of time [<code>s</code>] that returns its value at a given time. We write [<code>s</code>]<sub>t</sub> the evaluation of this <em>semantic</em> function at time t.</p></header><section><header><h4 id="sigeq"><a href="#sigeq" class="anchor"></a>Equality</h4><p>Most signal combinators have an optional <code>eq</code> parameter that defaults to structural equality. <code>eq</code> specifies the equality function used to detect changes in the value of the resulting signal. This function is needed for the efficient update of signals and to deal correctly with signals that perform <a href="index.html#sideeffects"><span>side effects</span></a>.</p><p>Given an equality function on a type the combinators can be automatically <a href="S/index.html#special"><span>specialized</span></a> via a functor.</p></header></section><section><header><h4 id="sigcont"><a href="#sigcont" class="anchor"></a>Continuity</h4><p>Ultimately signal updates depend on <a href="index.html#primitives"><span>primitives</span></a> updates. Thus a signal can only approximate a real continuous signal. The accuracy of the approximation depends on the variation rate of the real signal and the primitive's update frequency.</p></header></section></section></section><section><header><h2 id="basics"><a href="#basics" class="anchor"></a>Basics</h2></header><section><header><h3 id="primitives"><a href="#primitives" class="anchor"></a>Primitive events and signals</h3><p>React doesn't define primitive events and signals, they must be created and updated by the client.</p><p>Primitive events are created with <a href="E/index.html#val-create"><code>E.create</code></a>. This function returns a new event and an update function that generates an occurrence for the event at the time it is called. The following code creates a primitive integer event <code>x</code> and generates three occurrences with value <code>1</code>, <code>2</code>, <code>3</code>. Those occurrences are printed on stdout by the effectful event <code>pr_x</code>. </p><pre><code class="ml">open React;;

let x, send_x = E.create ()
let pr_x = E.map print_int x
let () = List.iter send_x [1; 2; 3]</code></pre><p>Primitive signals are created with <a href="S/index.html#val-create"><code>S.create</code></a>. This function returns a new signal and an update function that sets the signal's value at the time it is called. The following code creates an integer signal <code>x</code> initially set to <code>1</code> and updates it three time with values <code>2</code>, <code>2</code>, <code>3</code>. The signal's values are printed on stdout by the effectful signal <code>pr_x</code>. Note that only updates that change the signal's value are printed, hence the program prints <code>123</code>, not <code>1223</code>. See the discussion on <a href="index.html#sideeffects"><span>side effects</span></a> for more details.</p><pre><code class="ml">open React;;

let x, set_x = S.create 1
let pr_x = S.map print_int x
let () = List.iter set_x [2; 2; 3]</code></pre><p>The <a href="index.html#clock"><span>clock</span></a> example shows how a realtime time flow can be defined.</p></header></section><section><header><h3 id="steps"><a href="#steps" class="anchor"></a>Update steps</h3><p>The <a href="E/index.html#val-create"><code>E.create</code></a> and <a href="S/index.html#val-create"><code>S.create</code></a> functions return update functions used to generate primitive event occurences and set the value of primitive signals. Upon invocation as in the preceding section these functions immediatly create and invoke an update step. The <em>update step</em> automatically updates events and signals that transitively depend on the updated primitive. The dependents of a signal are updated iff the signal's value changed according to its <a href="index.html#sigeq"><span>equality function</span></a>.</p><p>The update functions have an optional <code>step</code> argument. If they are given a concrete <code>step</code> value created with <a href="Step/index.html#val-create"><code>Step.create</code></a>, then it updates the event or signal but doesn't update its dependencies. It will only do so whenever <code>step</code> is executed with <a href="Step/index.html#val-execute"><code>Step.execute</code></a>. This allows to make primitive event occurences and signal changes simultaneous. See next section for an example.</p></header></section><section><header><h3 id="simultaneity"><a href="#simultaneity" class="anchor"></a>Simultaneous events</h3><p><a href="index.html#steps"><span>Update steps</span></a> are made under a <a href="http://dx.doi.org/10.1016/0167-6423(92)90005-V">synchrony hypothesis</a> : the update step takes no time, it is instantenous. Two event occurrences are <em>simultaneous</em> if they occur in the same update step.</p><p>In the code below <code>w</code>, <code>x</code> and <code>y</code> will always have simultaneous occurrences. They <em>may</em> have simulatenous occurences with <code>z</code> if <code>send_w</code> and <code>send_z</code> are used with the same update step.</p><pre><code class="ml">let w, send_w = E.create ()
let x = E.map succ w
let y = E.map succ x
let z, send_z = E.create ()

let () =
  let () = send_w 3 (* w x y occur simultaneously, z doesn't occur *) in
  let step = Step.create () in
  send_w ~step 3;
  send_z ~step 4;
  Step.execute step (* w x z y occur simultaneously *)</code></pre></header></section><section><header><h3 id="update"><a href="#update" class="anchor"></a>The update step and thread safety</h3><p><a href="index.html#primitives"><span>Primitives</span></a> are the only mean to drive the reactive system and they are entirely under the control of the client. When the client invokes a primitive's update function without the <code>step</code> argument or when it invokes <a href="Step/index.html#val-execute"><code>Step.execute</code></a> on a <code>step</code> value, React performs an update step.</p><p>To ensure correctness in the presence of threads, update steps must be executed in a critical section. Let uset(<code>p</code>) be the set of events and signals that need to be updated whenever the primitive <code>p</code> is updated. Updating two primitives <code>p</code> and <code>p'</code> concurrently is only allowed if uset(<code>p</code>) and uset(<code>p'</code>) are disjoint. Otherwise the updates must be properly serialized.</p><p>Below, concurrent, updates to <code>x</code> and <code>y</code> must be serialized (or performed on the same step if it makes sense semantically), but z can be updated concurently to both <code>x</code> and <code>y</code>.</p><pre><code class="ml">open React;;

let x, set_x = S.create 0
let y, send_y = E.create ()
let z, set_z = S.create 0
let max_xy = S.l2 (fun x y -&gt; if x &gt; y then x else y) x (S.hold 0 y)
let succ_z = S.map succ z</code></pre></header></section><section><header><h3 id="sideeffects"><a href="#sideeffects" class="anchor"></a>Side effects</h3><p>Effectful events and signals perform their side effect exactly <em>once</em> in each <a href="index.html#steps"><span>update step</span></a> in which there is an update of at least one of the event or signal it depends on.</p><p>Remember that a signal updates in a step iff its <a href="index.html#sigeq"><span>equality function</span></a> determined that the signal value changed. Signal initialization is unconditionally considered as an update.</p><p>It is important to keep references on effectful events and signals. Otherwise they may be reclaimed by the garbage collector. The following program prints only a <code>1</code>.</p><pre><code class="ml">let x, set_x = S.create 1
let () = ignore (S.map print_int x)
let () = Gc.full_major (); List.iter set_x [2; 2; 3]</code></pre></header></section><section><header><h3 id="lifting"><a href="#lifting" class="anchor"></a>Lifting</h3><p>Lifting transforms a regular function to make it act on signals. The combinators <a href="S/index.html#val-const"><code>S.const</code></a> and <a href="S/index.html#val-app"><code>S.app</code></a> allow to lift functions of arbitrary arity n, but this involves the inefficient creation of n-1 intermediary closure signals. The fixed arity <a href="S/index.html#lifting"><span>lifting functions</span></a> are more efficient. For example :</p><pre><code class="ml">let f x y = x mod y
let fl x y = S.app (S.app ~eq:(==) (S.const f) x) y (* inefficient *)
let fl' x y = S.l2 f x y                            (* efficient *)</code></pre><p>Besides, some of <code>Pervasives</code>'s functions and operators are already lifted and availables in submodules of <a href="S/index.html"><code>S</code></a>. They can be be opened in specific scopes. For example if you are dealing with float signals you can open <a href="S/Float/index.html"><code>S.Float</code></a>.</p><pre><code class="ml">open React
open React.S.Float

let f t = sqrt t *. sin t (* f is defined on float signals *)
...
open Pervasives (* back to pervasives floats *)</code></pre><p>If you are using OCaml 3.12 or later you can also use the <code>let open</code> construct</p><pre><code class="ml">let open React.S.Float in
let f t = sqrt t *. sin t in (* f is defined on float signals *)
...</code></pre></header></section><section><header><h3 id="recursion"><a href="#recursion" class="anchor"></a>Mutual and self reference</h3><p>Mutual and self reference among time varying values occurs naturally in programs. However a mutually recursive definition of two signals in which both need the value of the other at time t to define their value at time t has no least fixed point. To break this tight loop one signal must depend on the value the other had at time t-dt where dt is an infinitesimal delay.</p><p>The fixed point combinators <a href="E/index.html#val-fix"><code>E.fix</code></a> and <a href="S/index.html#val-fix"><code>S.fix</code></a> allow to refer to the value an event or signal had an infinitesimal amount of time before. These fixed point combinators act on a function <code>f</code> that takes as argument the infinitesimally delayed event or signal that <code>f</code> itself returns.</p><p>In the example below <code>history s</code> returns a signal whose value is the history of <code>s</code> as a list.</p><pre><code class="ml">let history ?(eq = ( = )) s =
  let push v = function
    | [] -&gt; [ v ]
    | v' :: _ as l when eq v v' -&gt; l
    | l -&gt; v :: l
  in
  let define h =
    let h' = S.l2 push s h in
    h', h'
  in
  S.fix [] define</code></pre><p>When a program has infinitesimally delayed values a <a href="index.html#primitives"><span>primitive</span></a> may trigger more than one update step. For example if a signal <code>s</code> is infinitesimally delayed, then its update in a step <code>c</code> will trigger a new step <code>c'</code> at the end of the step in which the delayed signal of <code>s</code> will have the value <code>s</code> had in <code>c</code>. This means that the recursion occuring between a signal (or event) and its infinitesimally delayed counterpart must be well-founded otherwise this may trigger an infinite number of update steps, like in the following examples.</p><pre><code class="ml">let start, send_start = E.create ()
let diverge =
  let define e =
    let e' = E.select [e; start] in
    e', e'
  in
  E.fix define

let () = send_start ()        (* diverges *)

let diverge =                 (* diverges *)
  let define s =
    let s' = S.Int.succ s in
    s', s'
  in
  S.fix 0 define</code></pre><p>For technical reasons, delayed events and signals (those given to fixing functions) are not allowed to directly depend on each other. Fixed point combinators will raise <code>Invalid_argument</code> if such dependencies are created. This limitation can be circumvented by mapping these values with the identity.</p></header></section><section><header><h3 id="strongstop"><a href="#strongstop" class="anchor"></a>Strong stops</h3><p>Strong stops should only be used on platforms where weak arrays have a strong semantics (i.e. JavaScript). You can safely ignore that section and the <code>strong</code> argument of <a href="E/index.html#val-stop"><code>E.stop</code></a> and <a href="S/index.html#val-stop"><code>S.stop</code></a> if that's not the case.</p><p>Whenever <a href="E/index.html#val-stop"><code>E.stop</code></a> and <a href="S/index.html#val-stop"><code>S.stop</code></a> is called with <code>~strong:true</code> on a reactive value <code>v</code>, it is first stopped and then it walks over the list <code>prods</code> of events and signals that it depends on and unregisters itself from these ones as a dependent (something that is normally automatically done when <code>v</code> is garbage collected since dependents are stored in a weak array). Then for each element of <code>prod</code> that has no dependents anymore and is not a primitive it stops them aswell and recursively.</p><p>A stop call with <code>~strong:true</code> is more involved. But it allows to prevent memory leaks when used judiciously on the leaves of the reactive system that are no longer used.</p><p><b>Warning.</b> It should be noted that if direct references are kept on an intermediate event or signal of the reactive system it may suddenly stop updating if all its dependents were strongly stopped. In the example below, <code>e1</code> will <em>never</em> occur:</p><pre><code class="ml">let e, e_send = E.create ()
let e1 = E.map (fun x -&gt; x + 1) e (* never occurs *)
let () =
  let e2 = E.map (fun x -&gt; x + 1) e1 in
  E.stop ~strong:true e2</code></pre><p>This can be side stepped by making an artificial dependency to keep the reference:</p><pre><code class="ml">let e, e_send = E.create ()
let e1 = E.map (fun x -&gt; x + 1) e (* may still occur *)
let e1_ref = E.map (fun x -&gt; x) e1
let () =
  let e2 = E.map (fun x -&gt; x + 1) e1 in
  E.stop ~strong:true e2</code></pre></header></section></section><section><header><h2 id="ex"><a href="#ex" class="anchor"></a>Examples</h2></header><section><header><h3 id="clock"><a href="#clock" class="anchor"></a>Clock</h3><p>The following program defines a primitive event <code>seconds</code> holding the UNIX time and occuring on every second. An effectful event converts these occurences to local time and prints them on stdout along with an <a href="http://www.ecma-international.org/publications/standards/Ecma-048.htm">ANSI escape sequence</a> to control the cursor position.</p><pre><code class="ml">let pr_time t =
  let tm = Unix.localtime t in
  Printf.printf &quot;\x1B[8D%02d:%02d:%02d%!&quot;
    tm.Unix.tm_hour tm.Unix.tm_min tm.Unix.tm_sec

open React;;

let seconds, run =
  let e, send = E.create () in
  let run () =
    while true do send (Unix.gettimeofday ()); Unix.sleep 1 done
  in
  e, run

let printer = E.map pr_time seconds

let () = run ()</code></pre></header></section></section></div></body></html>