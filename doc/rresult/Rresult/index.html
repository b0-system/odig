<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Rresult (rresult.Rresult)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../index.html">rresult</a> &#x00BB; Rresult</nav><header class="odoc-preamble"><h1>Module <code><span>Rresult</span></code></h1><p>Result value combinators.</p><p><b>Note.</b> OCaml 4.08 provides the <a href="../../ocaml/Stdlib/Result/index.html"><code>Stdlib.Result</code></a> module which you should prefer to <code>Rresult</code>.</p><p><code>Rresult</code> is a module for handling computation results and errors in an explicit and declarative manner without resorting to exceptions. It defines a <a href="#type-result"><code>result</code></a> type equal to OCaml 4.03's <code>result</code> type and <a href="R/index.html">combinators</a> to operate on these values.</p><p>Open the module to use it, this defines the <a href="#type-result">result type</a>, the <a href="R/Infix/index.html"><code>R.Infix</code></a> operators <a href="R/index.html"><code>R</code></a> in your scope.</p><p>Consult <a href="#usage">usage guidelines</a> for the type.</p></header><nav class="odoc-toc"><ul><li><a href="#results">Results</a></li><li><a href="#usage">Usage design guidelines</a><ul><li><a href="#error-messages">Error messages</a></li><li><a href="#custom-error-types">Custom error types</a></li></ul></li></ul></nav><div class="odoc-content"><h2 id="results"><a href="#results" class="anchor"></a>Results</h2><div class="odoc-spec"><div class="spec type" id="type-result" class="anchored"><a href="#type-result" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 'b) result</span></span><span> = <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="../../ocaml/Stdlib/index.html#type-result">result</a></span></span><span> = </span></code><table><tr id="type-result.Ok" class="anchored"><td class="def variant constructor"><a href="#type-result.Ok" class="anchor"></a><code><span>| </span><span><span class="constructor">Ok</span> <span class="keyword">of</span> <span class="type-var">'a</span></span></code></td></tr><tr id="type-result.Error" class="anchored"><td class="def variant constructor"><a href="#type-result.Error" class="anchor"></a><code><span>| </span><span><span class="constructor">Error</span> <span class="keyword">of</span> <span class="type-var">'b</span></span></code></td></tr></table></div><div class="spec-doc"><p>The type for results.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-(&gt;&gt;=)" class="anchored"><a href="#val-(&gt;&gt;=)" class="anchor"></a><code><span><span class="keyword">val</span> (&gt;&gt;=) : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-result">result</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'c</span>, <span class="type-var">'b</span>)</span> <a href="#type-result">result</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'c</span>, <span class="type-var">'b</span>)</span> <a href="#type-result">result</a></span></span></code></div><div class="spec-doc"><p><code>(&gt;&gt;=)</code> is <a href="R/index.html#val-(&gt;&gt;=)"><code>R.(&gt;&gt;=)</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-(&gt;&gt;|)" class="anchored"><a href="#val-(&gt;&gt;|)" class="anchor"></a><code><span><span class="keyword">val</span> (&gt;&gt;|) : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-result">result</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'c</span>, <span class="type-var">'b</span>)</span> <a href="#type-result">result</a></span></span></code></div><div class="spec-doc"><p><code>(&gt;&gt;|)</code> is <a href="R/index.html#val-(&gt;&gt;|)"><code>R.(&gt;&gt;|)</code></a>.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-R" class="anchored"><a href="#module-R" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="R/index.html">R</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Result value combinators.</p></div></div><h2 id="usage"><a href="#usage" class="anchor"></a>Usage design guidelines</h2><p>These are rough design guidelines, don't forget to think.</p><h3 id="error-messages"><a href="#error-messages" class="anchor"></a>Error messages</h3><p>Use <a href="R/index.html#msgs">error messages</a> if:</p><ol><li>Your error messages don't need to be localized, e.g. scripts, command line programs.</li><li>The errors don't need to be processed. They are just meant to be logged at certain point in your program.</li></ol><p>If the above doesn't hold and your errors need to be processed for localization or error recovery then use a custom error type in your result values.</p><h3 id="custom-error-types"><a href="#custom-error-types" class="anchor"></a>Custom error types</h3><p>If your module has specific errors then define an error type, and a result type that tags this error type with the library name (or any other tag that may make sense, see for example <a href="R/index.html#exn"><code>exn</code></a>) along with the following functions:</p><pre><code>module Mod : sig
  type error = ...
  type 'a result = ('a, [`Mod of error]) Rresult.result
  val pp_error : Format.formatter -&gt; [`Mod of error] -&gt; unit
  val open_error : 'a result -&gt; ('a, [&gt; `Mod of error]) Rresult.result
  val error_to_msg : 'a result -&gt; ('a, Rresult.R.msg) Rresult.result

  val f : ... -&gt; 'a result
end</code></pre><p>If your library has generic errors that may be useful in other context or shared among modules and to be composed together, then define your error type itself as being a variant and return these values without tagging them.</p><pre><code>module Mod : sig
  type error = [`Generic of ... | ... ]
  type 'a result = ('a, error) Rresult.result
  val pp_error : Format.formatter -&gt; error -&gt; unit
  val open_error : 'a result -&gt; ('a, [&gt; error]) Rresult.result
  val error_to_msg : 'a result -&gt; ('a, Rresult.R.msg) Rresult.result

  val f : ... -&gt; 'a result
end</code></pre><p>In the latter case it may still be useful to provide a function to tag these errors whenever they reach a certain point of the program. For this the following function could be added to <code>Mod</code>:</p><pre><code>val pack_error : 'a result -&gt;  ('a, [&gt; `Mod of error]) Rresult.result</code></pre><p>You should then provide the following functions aswell, so that the packed error composes well in the system:</p><pre><code>val pp_pack_error : Format.formatter -&gt; [ `Mod of error] -&gt; unit
val open_pack_error :  ('a, [ `Mod of error]) Rresult.result -&gt;
  ('a, [&gt; `Mod of error]) Rresult.result

val error_pack_to_msg : ('a, [ `Mod of error]) Rresult.result -&gt;
  ('a, Rresult.R.msg) Rresult.result</code></pre></div></body></html>