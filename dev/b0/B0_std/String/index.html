<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>String (b0.B0_std.String)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">b0</a> &#x00BB; <a href="../index.html">B0_std</a> &#x00BB; String</nav><h1>Module <code>B0_std.String</code></h1><p>Strings.</p><nav class="toc"><ul><li><a href="#string">String</a></li><li><a href="#preds">Predicates</a></li><li><a href="#subs">Extracting substrings</a></li><li><a href="#break">Breaking</a><ul><li><a href="#break_mag">Breaking with magnitudes</a></li><li><a href="#break_pred">Breaking with predicates</a></li><li><a href="#break_sep">Breaking with separators</a></li></ul></li><li><a href="#traversing">Traversing</a></li><li><a href="#fmt">Formatting</a></li><li><a href="#unique">Uniqueness</a></li><li><a href="#suggesting">Suggesting</a></li><li><a href="#escunesc">Escaping and unescaping bytes</a></li><li><a href="#ascii">Strings as US-ASCII character sequences</a></li><li><a href="#setmap">String map and sets</a></li></ul></nav></header><section><header><h2 id="string"><a href="#string" class="anchor"></a>String</h2></header><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> <a href="../../../ocaml/Stdlib/index.html#module-String">Stdlib.String</a></code></span></summary><aside><p>String operations.</p><p>A string is an immutable data structure that contains a fixed-length sequence of (single-byte) characters. Each character can be accessed in constant time through its index.</p><p>Given a string <code>s</code> of length <code>l</code>, we can access each of the <code>l</code> characters of <code>s</code> via its index in the sequence. Indexes start at <code>0</code>, and we will call an index valid in <code>s</code> if it falls within the range <code>[0...l-1]</code> (inclusive). A position is the point between two characters or at the beginning or end of the string. We call a position valid in <code>s</code> if it falls within the range <code>[0...l]</code> (inclusive). Note that the character at index <code>n</code> is between positions <code>n</code> and <code>n+1</code>.</p><p>Two parameters <code>start</code> and <code>len</code> are said to designate a valid substring of <code>s</code> if <code>len &gt;= 0</code> and <code>start</code> and <code>start+len</code> are valid positions in <code>s</code>.</p><p>OCaml strings used to be modifiable in place, for instance via the <a href="index.html#val-set"><code>String.set</code></a> and <a href="index.html#val-blit"><code>String.blit</code></a> functions described below. This usage is deprecated and only possible when the compiler is put in &quot;unsafe-string&quot; mode by giving the <code>-unsafe-string</code> command-line option (which is currently the default for reasons of backward compatibility). This is done by making the types <code>string</code> and <code>bytes</code> (see module <code>Bytes</code>) interchangeable so that functions expecting byte sequences can also accept strings as arguments and modify them.</p><p>All new code should avoid this feature and be compiled with the <code>-safe-string</code> command-line option to enforce the separation between the types <code>string</code> and <code>bytes</code>.</p></aside><dl><dt class="spec external" id="val-length"><a href="#val-length" class="anchor"></a><code><span class="keyword">val</span> length : string <span>&#45;&gt;</span> int</code></dt><dd><p>Return the length (number of characters) of the given string.</p></dd></dl><dl><dt class="spec external" id="val-get"><a href="#val-get" class="anchor"></a><code><span class="keyword">val</span> get : string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> char</code></dt><dd><p><code>String.get s n</code> returns the character at index <code>n</code> in string <code>s</code>. You can also write <code>s.[n]</code> instead of <code>String.get s n</code>.</p><p>Raise <code>Invalid_argument</code> if <code>n</code> not a valid index in <code>s</code>.</p></dd></dl><dl><dt class="spec external" id="val-set"><a href="#val-set" class="anchor"></a><code><span class="keyword">val</span> set : bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> char <span>&#45;&gt;</span> unit</code></dt><dd><p><code>String.set s n c</code> modifies byte sequence <code>s</code> in place, replacing the byte at index <code>n</code> with <code>c</code>. You can also write <code>s.[n] &lt;- c</code> instead of <code>String.set s n c</code>.</p><p>Raise <code>Invalid_argument</code> if <code>n</code> is not a valid index in <code>s</code>.</p><dl><dt>deprecated</dt><dd><p>This is a deprecated alias of <span class="xref-unresolved" title="unresolved reference to &quot;Bytes.set&quot;"><code>Bytes</code>.set</span>.<code> </code></p></dd></dl></dd></dl><dl><dt class="spec external" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : int <span>&#45;&gt;</span> bytes</code></dt><dd><p><code>String.create n</code> returns a fresh byte sequence of length <code>n</code>. The sequence is uninitialized and contains arbitrary bytes.</p><p>Raise <code>Invalid_argument</code> if <code>n &lt; 0</code> or <code>n &gt; </code><span class="xref-unresolved" title="unresolved reference to &quot;Sys.max_string_length&quot;"><code>Sys</code>.max_string_length</span>.</p><dl><dt>deprecated</dt><dd><p>This is a deprecated alias of <span class="xref-unresolved" title="unresolved reference to &quot;Bytes.create&quot;"><code>Bytes</code>.create</span>.<code> </code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-make"><a href="#val-make" class="anchor"></a><code><span class="keyword">val</span> make : int <span>&#45;&gt;</span> char <span>&#45;&gt;</span> string</code></dt><dd><p><code>String.make n c</code> returns a fresh string of length <code>n</code>, filled with the character <code>c</code>.</p><p>Raise <code>Invalid_argument</code> if <code>n &lt; 0</code> or <code>n &gt; </code><span class="xref-unresolved" title="unresolved reference to &quot;Sys.max_string_length&quot;"><code>Sys</code>.max_string_length</span>.</p></dd></dl><dl><dt class="spec value" id="val-init"><a href="#val-init" class="anchor"></a><code><span class="keyword">val</span> init : int <span>&#45;&gt;</span> (int <span>&#45;&gt;</span> char) <span>&#45;&gt;</span> string</code></dt><dd><p><code>String.init n f</code> returns a string of length <code>n</code>, with character <code>i</code> initialized to the result of <code>f i</code> (called in increasing index order).</p><p>Raise <code>Invalid_argument</code> if <code>n &lt; 0</code> or <code>n &gt; </code><span class="xref-unresolved" title="unresolved reference to &quot;Sys.max_string_length&quot;"><code>Sys</code>.max_string_length</span>.</p><dl><dt>since</dt><dd>4.02.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-copy"><a href="#val-copy" class="anchor"></a><code><span class="keyword">val</span> copy : string <span>&#45;&gt;</span> string</code></dt><dd><p>Return a copy of the given string.</p><dl><dt>deprecated</dt><dd><p>Because strings are immutable, it doesn't make much sense to make identical copies of them.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sub"><a href="#val-sub" class="anchor"></a><code><span class="keyword">val</span> sub : string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> string</code></dt><dd><p><code>String.sub s start len</code> returns a fresh string of length <code>len</code>, containing the substring of <code>s</code> that starts at position <code>start</code> and has length <code>len</code>.</p><p>Raise <code>Invalid_argument</code> if <code>start</code> and <code>len</code> do not designate a valid substring of <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-fill"><a href="#val-fill" class="anchor"></a><code><span class="keyword">val</span> fill : bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> char <span>&#45;&gt;</span> unit</code></dt><dd><p><code>String.fill s start len c</code> modifies byte sequence <code>s</code> in place, replacing <code>len</code> bytes with <code>c</code>, starting at <code>start</code>.</p><p>Raise <code>Invalid_argument</code> if <code>start</code> and <code>len</code> do not designate a valid range of <code>s</code>.</p><dl><dt>deprecated</dt><dd><p>This is a deprecated alias of <span class="xref-unresolved" title="unresolved reference to &quot;Bytes.fill&quot;"><code>Bytes</code>.fill</span>.<code> </code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-blit"><a href="#val-blit" class="anchor"></a><code><span class="keyword">val</span> blit : string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p>Same as <span class="xref-unresolved" title="unresolved reference to &quot;Bytes.blit_string&quot;"><code>Bytes</code>.blit_string</span>.</p></dd></dl><dl><dt class="spec value" id="val-concat"><a href="#val-concat" class="anchor"></a><code><span class="keyword">val</span> concat : string <span>&#45;&gt;</span> string list <span>&#45;&gt;</span> string</code></dt><dd><p><code>String.concat sep sl</code> concatenates the list of strings <code>sl</code>, inserting the separator string <code>sep</code> between each.</p><p>Raise <code>Invalid_argument</code> if the result is longer than <span class="xref-unresolved" title="unresolved reference to &quot;Sys.max_string_length&quot;"><code>Sys</code>.max_string_length</span> bytes.</p></dd></dl><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : (char <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> string <span>&#45;&gt;</span> unit</code></dt><dd><p><code>String.iter f s</code> applies function <code>f</code> in turn to all the characters of <code>s</code>. It is equivalent to <code>f s.[0]; f s.[1]; ...; f s.[String.length s - 1]; ()</code>.</p></dd></dl><dl><dt class="spec value" id="val-iteri"><a href="#val-iteri" class="anchor"></a><code><span class="keyword">val</span> iteri : (int <span>&#45;&gt;</span> char <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> string <span>&#45;&gt;</span> unit</code></dt><dd><p>Same as <a href="index.html#val-iter"><code>String.iter</code></a>, but the function is applied to the index of the element as first argument (counting from 0), and the character itself as second argument.</p><dl><dt>since</dt><dd>4.00.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : (char <span>&#45;&gt;</span> char) <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt><dd><p><code>String.map f s</code> applies function <code>f</code> in turn to all the characters of <code>s</code> (in increasing index order) and stores the results in a new string that is returned.</p><dl><dt>since</dt><dd>4.00.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-mapi"><a href="#val-mapi" class="anchor"></a><code><span class="keyword">val</span> mapi : (int <span>&#45;&gt;</span> char <span>&#45;&gt;</span> char) <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt><dd><p><code>String.mapi f s</code> calls <code>f</code> with each character of <code>s</code> and its index (in increasing index order) and stores the results in a new string that is returned.</p><dl><dt>since</dt><dd>4.02.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-trim"><a href="#val-trim" class="anchor"></a><code><span class="keyword">val</span> trim : string <span>&#45;&gt;</span> string</code></dt><dd><p>Return a copy of the argument, without leading and trailing whitespace. The characters regarded as whitespace are: <code>' '</code>, <code>'\012'</code>, <code>'\n'</code>, <code>'\r'</code>, and <code>'\t'</code>. If there is neither leading nor trailing whitespace character in the argument, return the original string itself, not a copy.</p><dl><dt>since</dt><dd>4.00.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-escaped"><a href="#val-escaped" class="anchor"></a><code><span class="keyword">val</span> escaped : string <span>&#45;&gt;</span> string</code></dt><dd><p>Return a copy of the argument, with special characters represented by escape sequences, following the lexical conventions of OCaml. All characters outside the ASCII printable range (32..126) are escaped, as well as backslash and double-quote.</p><p>If there is no special character in the argument that needs escaping, return the original string itself, not a copy.</p><p>Raise <code>Invalid_argument</code> if the result is longer than <span class="xref-unresolved" title="unresolved reference to &quot;Sys.max_string_length&quot;"><code>Sys</code>.max_string_length</span> bytes.</p><p>The function <span class="xref-unresolved" title="unresolved reference to &quot;Scanf.unescaped&quot;"><code>Scanf</code>.unescaped</span> is a left inverse of <code>escaped</code>, i.e. <code>Scanf.unescaped (escaped s) = s</code> for any string <code>s</code> (unless <code>escape s</code> fails).</p></dd></dl><dl><dt class="spec value" id="val-index"><a href="#val-index" class="anchor"></a><code><span class="keyword">val</span> index : string <span>&#45;&gt;</span> char <span>&#45;&gt;</span> int</code></dt><dd><p><code>String.index s c</code> returns the index of the first occurrence of character <code>c</code> in string <code>s</code>.</p><p>Raise <code>Not_found</code> if <code>c</code> does not occur in <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-index_opt"><a href="#val-index_opt" class="anchor"></a><code><span class="keyword">val</span> index_opt : string <span>&#45;&gt;</span> char <span>&#45;&gt;</span> int option</code></dt><dd><p><code>String.index_opt s c</code> returns the index of the first occurrence of character <code>c</code> in string <code>s</code>, or <code>None</code> if <code>c</code> does not occur in <code>s</code>.</p><dl><dt>since</dt><dd>4.05</dd></dl></dd></dl><dl><dt class="spec value" id="val-rindex"><a href="#val-rindex" class="anchor"></a><code><span class="keyword">val</span> rindex : string <span>&#45;&gt;</span> char <span>&#45;&gt;</span> int</code></dt><dd><p><code>String.rindex s c</code> returns the index of the last occurrence of character <code>c</code> in string <code>s</code>.</p><p>Raise <code>Not_found</code> if <code>c</code> does not occur in <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-rindex_opt"><a href="#val-rindex_opt" class="anchor"></a><code><span class="keyword">val</span> rindex_opt : string <span>&#45;&gt;</span> char <span>&#45;&gt;</span> int option</code></dt><dd><p><code>String.rindex_opt s c</code> returns the index of the last occurrence of character <code>c</code> in string <code>s</code>, or <code>None</code> if <code>c</code> does not occur in <code>s</code>.</p><dl><dt>since</dt><dd>4.05</dd></dl></dd></dl><dl><dt class="spec value" id="val-index_from"><a href="#val-index_from" class="anchor"></a><code><span class="keyword">val</span> index_from : string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> char <span>&#45;&gt;</span> int</code></dt><dd><p><code>String.index_from s i c</code> returns the index of the first occurrence of character <code>c</code> in string <code>s</code> after position <code>i</code>. <code>String.index s c</code> is equivalent to <code>String.index_from s 0 c</code>.</p><p>Raise <code>Invalid_argument</code> if <code>i</code> is not a valid position in <code>s</code>. Raise <code>Not_found</code> if <code>c</code> does not occur in <code>s</code> after position <code>i</code>.</p></dd></dl><dl><dt class="spec value" id="val-index_from_opt"><a href="#val-index_from_opt" class="anchor"></a><code><span class="keyword">val</span> index_from_opt : string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> char <span>&#45;&gt;</span> int option</code></dt><dd><p><code>String.index_from_opt s i c</code> returns the index of the first occurrence of character <code>c</code> in string <code>s</code> after position <code>i</code> or <code>None</code> if <code>c</code> does not occur in <code>s</code> after position <code>i</code>.</p><p><code>String.index_opt s c</code> is equivalent to <code>String.index_from_opt s 0 c</code>. Raise <code>Invalid_argument</code> if <code>i</code> is not a valid position in <code>s</code>.</p><dl><dt>since</dt><dd>4.05</dd></dl></dd></dl><dl><dt class="spec value" id="val-rindex_from"><a href="#val-rindex_from" class="anchor"></a><code><span class="keyword">val</span> rindex_from : string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> char <span>&#45;&gt;</span> int</code></dt><dd><p><code>String.rindex_from s i c</code> returns the index of the last occurrence of character <code>c</code> in string <code>s</code> before position <code>i+1</code>. <code>String.rindex s c</code> is equivalent to <code>String.rindex_from s (String.length s - 1) c</code>.</p><p>Raise <code>Invalid_argument</code> if <code>i+1</code> is not a valid position in <code>s</code>. Raise <code>Not_found</code> if <code>c</code> does not occur in <code>s</code> before position <code>i+1</code>.</p></dd></dl><dl><dt class="spec value" id="val-rindex_from_opt"><a href="#val-rindex_from_opt" class="anchor"></a><code><span class="keyword">val</span> rindex_from_opt : string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> char <span>&#45;&gt;</span> int option</code></dt><dd><p><code>String.rindex_from_opt s i c</code> returns the index of the last occurrence of character <code>c</code> in string <code>s</code> before position <code>i+1</code> or <code>None</code> if <code>c</code> does not occur in <code>s</code> before position <code>i+1</code>.</p><p><code>String.rindex_opt s c</code> is equivalent to <code>String.rindex_from_opt s (String.length s - 1) c</code>.</p><p>Raise <code>Invalid_argument</code> if <code>i+1</code> is not a valid position in <code>s</code>.</p><dl><dt>since</dt><dd>4.05</dd></dl></dd></dl><dl><dt class="spec value" id="val-contains"><a href="#val-contains" class="anchor"></a><code><span class="keyword">val</span> contains : string <span>&#45;&gt;</span> char <span>&#45;&gt;</span> bool</code></dt><dd><p><code>String.contains s c</code> tests if character <code>c</code> appears in the string <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-contains_from"><a href="#val-contains_from" class="anchor"></a><code><span class="keyword">val</span> contains_from : string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> char <span>&#45;&gt;</span> bool</code></dt><dd><p><code>String.contains_from s start c</code> tests if character <code>c</code> appears in <code>s</code> after position <code>start</code>. <code>String.contains s c</code> is equivalent to <code>String.contains_from s 0 c</code>.</p><p>Raise <code>Invalid_argument</code> if <code>start</code> is not a valid position in <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-rcontains_from"><a href="#val-rcontains_from" class="anchor"></a><code><span class="keyword">val</span> rcontains_from : string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> char <span>&#45;&gt;</span> bool</code></dt><dd><p><code>String.rcontains_from s stop c</code> tests if character <code>c</code> appears in <code>s</code> before position <code>stop+1</code>.</p><p>Raise <code>Invalid_argument</code> if <code>stop &lt; 0</code> or <code>stop+1</code> is not a valid position in <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-uppercase"><a href="#val-uppercase" class="anchor"></a><code><span class="keyword">val</span> uppercase : string <span>&#45;&gt;</span> string</code></dt><dd><p>Return a copy of the argument, with all lowercase letters translated to uppercase, including accented letters of the ISO Latin-1 (8859-1) character set.</p><dl><dt>deprecated</dt><dd><p>Functions operating on Latin-1 character set are deprecated.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-lowercase"><a href="#val-lowercase" class="anchor"></a><code><span class="keyword">val</span> lowercase : string <span>&#45;&gt;</span> string</code></dt><dd><p>Return a copy of the argument, with all uppercase letters translated to lowercase, including accented letters of the ISO Latin-1 (8859-1) character set.</p><dl><dt>deprecated</dt><dd><p>Functions operating on Latin-1 character set are deprecated.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-capitalize"><a href="#val-capitalize" class="anchor"></a><code><span class="keyword">val</span> capitalize : string <span>&#45;&gt;</span> string</code></dt><dd><p>Return a copy of the argument, with the first character set to uppercase, using the ISO Latin-1 (8859-1) character set..</p><dl><dt>deprecated</dt><dd><p>Functions operating on Latin-1 character set are deprecated.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-uncapitalize"><a href="#val-uncapitalize" class="anchor"></a><code><span class="keyword">val</span> uncapitalize : string <span>&#45;&gt;</span> string</code></dt><dd><p>Return a copy of the argument, with the first character set to lowercase, using the ISO Latin-1 (8859-1) character set..</p><dl><dt>deprecated</dt><dd><p>Functions operating on Latin-1 character set are deprecated.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-uppercase_ascii"><a href="#val-uppercase_ascii" class="anchor"></a><code><span class="keyword">val</span> uppercase_ascii : string <span>&#45;&gt;</span> string</code></dt><dd><p>Return a copy of the argument, with all lowercase letters translated to uppercase, using the US-ASCII character set.</p><dl><dt>since</dt><dd>4.03.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-lowercase_ascii"><a href="#val-lowercase_ascii" class="anchor"></a><code><span class="keyword">val</span> lowercase_ascii : string <span>&#45;&gt;</span> string</code></dt><dd><p>Return a copy of the argument, with all uppercase letters translated to lowercase, using the US-ASCII character set.</p><dl><dt>since</dt><dd>4.03.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-capitalize_ascii"><a href="#val-capitalize_ascii" class="anchor"></a><code><span class="keyword">val</span> capitalize_ascii : string <span>&#45;&gt;</span> string</code></dt><dd><p>Return a copy of the argument, with the first character set to uppercase, using the US-ASCII character set.</p><dl><dt>since</dt><dd>4.03.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-uncapitalize_ascii"><a href="#val-uncapitalize_ascii" class="anchor"></a><code><span class="keyword">val</span> uncapitalize_ascii : string <span>&#45;&gt;</span> string</code></dt><dd><p>Return a copy of the argument, with the first character set to lowercase, using the US-ASCII character set.</p><dl><dt>since</dt><dd>4.03.0</dd></dl></dd></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code><code> = string</code></dt><dd><p>An alias for the type of strings.</p></dd></dl><dl><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val</span> compare : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>The comparison function for strings, with the same specification as <a href="../../../ocaml/Stdlib/index.html#val-compare"><code>Stdlib.compare</code></a>. Along with the type <code>t</code>, this function <code>compare</code> allows the module <code>String</code> to be passed as argument to the functors <span class="xref-unresolved" title="unresolved reference to &quot;Set.Make&quot;"><a href="index.html#module-Set"><code>Set</code></a>.Make</span> and <span class="xref-unresolved" title="unresolved reference to &quot;Map.Make&quot;"><a href="index.html#module-Map"><code>Map</code></a>.Make</span>.</p></dd></dl><dl><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val</span> equal : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>The equal function for strings.</p><dl><dt>since</dt><dd>4.03.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-split_on_char"><a href="#val-split_on_char" class="anchor"></a><code><span class="keyword">val</span> split_on_char : char <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string list</code></dt><dd><p><code>String.split_on_char sep s</code> returns the list of all (possibly empty) substrings of <code>s</code> that are delimited by the <code>sep</code> character.</p><p>The function's output is specified by the following invariants:</p><ul><li>The list is not empty.</li><li>Concatenating its elements using <code>sep</code> as a separator returns a string equal to the input (<code>String.concat (String.make 1 sep)
      (String.split_on_char sep s) = s</code>).</li><li>No string in the result contains the <code>sep</code> character.</li></ul><dl><dt>since</dt><dd>4.04.0</dd></dl></dd></dl><section><header><h2 id="iterators"><a href="#iterators" class="anchor"></a>Iterators</h2></header><dl><dt class="spec value" id="val-to_seq"><a href="#val-to_seq" class="anchor"></a><code><span class="keyword">val</span> to_seq : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> char <a href="../../../ocaml/Stdlib/Seq/index.html#type-t">Stdlib.Seq.t</a></code></dt><dd><p>Iterate on the string, in increasing index order. Modifications of the string during iteration will be reflected in the iterator.</p><dl><dt>since</dt><dd>4.07</dd></dl></dd></dl><dl><dt class="spec value" id="val-to_seqi"><a href="#val-to_seqi" class="anchor"></a><code><span class="keyword">val</span> to_seqi : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (int * char) <a href="../../../ocaml/Stdlib/Seq/index.html#type-t">Stdlib.Seq.t</a></code></dt><dd><p>Iterate on the string, in increasing order, yielding indices along chars</p><dl><dt>since</dt><dd>4.07</dd></dl></dd></dl><dl><dt class="spec value" id="val-of_seq"><a href="#val-of_seq" class="anchor"></a><code><span class="keyword">val</span> of_seq : char <a href="../../../ocaml/Stdlib/Seq/index.html#type-t">Stdlib.Seq.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Create a string from the generator</p><dl><dt>since</dt><dd>4.07</dd></dl></dd></dl></section></details></div></div></div><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val</span> empty : string</code></dt><dd><p><code>empty</code> is <code>&quot;&quot;</code>.</p></dd></dl><dl><dt class="spec value" id="val-head"><a href="#val-head" class="anchor"></a><code><span class="keyword">val</span> head : string <span>&#45;&gt;</span> char option</code></dt><dd><p><code>head s</code> if <code>Some s.[0]</code> if <code>s &lt;&gt; &quot;&quot;</code> and <code>None</code> otherwise.</p></dd></dl><dl><dt class="spec value" id="val-of_char"><a href="#val-of_char" class="anchor"></a><code><span class="keyword">val</span> of_char : char <span>&#45;&gt;</span> string</code></dt><dd><p><code>of_char c</code> is <code>c</code> as a string.</p></dd></dl></section><section><header><h2 id="preds"><a href="#preds" class="anchor"></a>Predicates</h2></header><dl><dt class="spec value" id="val-is_empty"><a href="#val-is_empty" class="anchor"></a><code><span class="keyword">val</span> is_empty : string <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_empty s</code> is <code>equal empty s</code>.</p></dd></dl><dl><dt class="spec value" id="val-is_prefix"><a href="#val-is_prefix" class="anchor"></a><code><span class="keyword">val</span> is_prefix : affix:string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_prefix ~affix s</code> is <code>true</code> iff <code>affix.[i] = s.[i]</code> for all indices <code>i</code> of <code>affix</code>.</p></dd></dl><dl><dt class="spec value" id="val-is_infix"><a href="#val-is_infix" class="anchor"></a><code><span class="keyword">val</span> is_infix : affix:string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_infix ~affix s</code> is <code>true</code> iff there exists an index <code>j</code> such that for all indices <code>i</code> of <code>affix</code>, <code>affix.[i] = s.[j+ 1]</code>.</p></dd></dl><dl><dt class="spec value" id="val-is_suffix"><a href="#val-is_suffix" class="anchor"></a><code><span class="keyword">val</span> is_suffix : affix:string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_suffix ~affix s</code> is true iff <code>affix.[i] = s.[m - i]</code> for all indices <code>i</code> of <code>affix</code> and with <code>m = String.length s - 1</code>.</p></dd></dl><dl><dt class="spec value" id="val-for_all"><a href="#val-for_all" class="anchor"></a><code><span class="keyword">val</span> for_all : (char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> string <span>&#45;&gt;</span> bool</code></dt><dd><p><code>for_all p s</code> is <code>true</code> iff for all indices <code>i</code> of <code>s</code>, <code>p s.[i]
      = true</code>.</p></dd></dl><dl><dt class="spec value" id="val-exists"><a href="#val-exists" class="anchor"></a><code><span class="keyword">val</span> exists : (char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> string <span>&#45;&gt;</span> bool</code></dt><dd><p><code>exists p s</code> is <code>true</code> iff there exists an index <code>i</code> of <code>s</code> with <code>p s.[i] = true</code>.</p></dd></dl></section><section><header><h2 id="subs"><a href="#subs" class="anchor"></a>Extracting substrings</h2></header><dl><dt class="spec value" id="val-with_index_range"><a href="#val-with_index_range" class="anchor"></a><code><span class="keyword">val</span> with_index_range : ?&#8288;first:int <span>&#45;&gt;</span> ?&#8288;last:int <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt><dd><p><code>with_index_range ~first ~last s</code> are the consecutive bytes of <code>s</code> whose indices exist in the range [<code>first</code>;<code>last</code>].</p><p><code>first</code> defaults to <code>0</code> and last to <code>String.length s - 1</code>.</p><p>Note that both <code>first</code> and <code>last</code> can be any integer. If <code>first &gt; last</code> the interval is empty and the empty string is returned.</p></dd></dl></section><section><header><h2 id="break"><a href="#break" class="anchor"></a>Breaking</h2></header><section><header><h3 id="break_mag"><a href="#break_mag" class="anchor"></a>Breaking with magnitudes</h3></header><dl><dt class="spec value" id="val-take_left"><a href="#val-take_left" class="anchor"></a><code><span class="keyword">val</span> take_left : int <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt><dd><p><code>take_left n s</code> are the first <code>n</code> bytes of <code>s</code>. This is <code>s</code> if <code>n &gt;= length s</code> and <code>&quot;&quot;</code> if <code>n &lt;= 0</code>.</p></dd></dl><dl><dt class="spec value" id="val-take_right"><a href="#val-take_right" class="anchor"></a><code><span class="keyword">val</span> take_right : int <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt><dd><p><code>take_right n s</code> are the last <code>n</code> bytes of <code>s</code>. This is <code>s</code> if <code>n &gt;= length s</code> and <code>&quot;&quot;</code> if <code>n &lt;= 0</code>.</p></dd></dl><dl><dt class="spec value" id="val-drop_left"><a href="#val-drop_left" class="anchor"></a><code><span class="keyword">val</span> drop_left : int <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt><dd><p><code>drop_left n s</code> is <code>s</code> without the first <code>n</code> bytes of <code>s</code>. This is <code>&quot;&quot;</code> if <code>n &gt;= length s</code> and <code>s</code> if <code>n &lt;= 0</code>.</p></dd></dl><dl><dt class="spec value" id="val-drop_right"><a href="#val-drop_right" class="anchor"></a><code><span class="keyword">val</span> drop_right : int <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt><dd><p><code>drop_right n s</code> is <code>s</code> without the last <code>n</code> bytes of <code>s</code>. This is <code>&quot;&quot;</code> if <code>n &gt;= length s</code> and <code>s</code> if <code>n &lt;= 0</code>.</p></dd></dl><dl><dt class="spec value" id="val-break_left"><a href="#val-break_left" class="anchor"></a><code><span class="keyword">val</span> break_left : int <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string * string</code></dt><dd><p><code>break_left n v</code> is <code>(take_left n v, drop_left n v)</code>.</p></dd></dl><dl><dt class="spec value" id="val-break_right"><a href="#val-break_right" class="anchor"></a><code><span class="keyword">val</span> break_right : int <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string * string</code></dt><dd><p><code>break_right n v</code> is <code>(drop_left n v, take_right n v)</code>.</p></dd></dl></section><section><header><h3 id="break_pred"><a href="#break_pred" class="anchor"></a>Breaking with predicates</h3></header><dl><dt class="spec value" id="val-keep_left"><a href="#val-keep_left" class="anchor"></a><code><span class="keyword">val</span> keep_left : (char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt><dd><p><code>keep_left sat s</code> are the first consecutive <code>sat</code> statisfying bytes of <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-keep_right"><a href="#val-keep_right" class="anchor"></a><code><span class="keyword">val</span> keep_right : (char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt><dd><p><code>keep_right sat s</code> are the last consecutive <code>sat</code> satisfying bytes of <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-lose_left"><a href="#val-lose_left" class="anchor"></a><code><span class="keyword">val</span> lose_left : (char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt><dd><p><code>lose_left sat s</code> is <code>s</code> without the first consecutive <code>sat</code> satisfying bytes of <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-lose_right"><a href="#val-lose_right" class="anchor"></a><code><span class="keyword">val</span> lose_right : (char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt><dd><p><code>lose_right sat s</code> is <code>s</code> without the last consecutive <code>sat</code> satisfying bytes of <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-span_left"><a href="#val-span_left" class="anchor"></a><code><span class="keyword">val</span> span_left : (char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string * string</code></dt><dd><p><code>span_left sat s</code> is <code>(keep_left sat s, lose_left sat s)</code>.</p></dd></dl><dl><dt class="spec value" id="val-span_right"><a href="#val-span_right" class="anchor"></a><code><span class="keyword">val</span> span_right : (char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string * string</code></dt><dd><p><code>span_right sat s</code> is <code>(lose_right sat s, keep_right sat s)</code>.</p></dd></dl></section><section><header><h3 id="break_sep"><a href="#break_sep" class="anchor"></a>Breaking with separators</h3></header><dl><dt class="spec value" id="val-cut_left"><a href="#val-cut_left" class="anchor"></a><code><span class="keyword">val</span> cut_left : sep:string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> (string * string) option</code></dt><dd><p><code>cut ~sep s</code> is either the pair <code>Some (l,r)</code> of the two (possibly empty) substrings of <code>s</code> that are delimited by the first match of the separator character <code>sep</code> or <code>None</code> if <code>sep</code> can't be matched in <code>s</code>. Matching starts from the left of <code>s</code>.</p><p>The invariant <code>l ^ sep ^ r = s</code> holds.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>sep</code> is the empty string.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-cut_right"><a href="#val-cut_right" class="anchor"></a><code><span class="keyword">val</span> cut_right : sep:string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> (string * string) option</code></dt><dd><p><code>cut_right ~sep s</code> is like <a href="index.html#val-cut_left"><code>cut_left</code></a> but matching starts on the right of <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-cuts_left"><a href="#val-cuts_left" class="anchor"></a><code><span class="keyword">val</span> cuts_left : ?&#8288;drop_empty:bool <span>&#45;&gt;</span> sep:string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string list</code></dt><dd><p><code>cuts_left sep s</code> is the list of all substrings of <code>s</code> that are delimited by matches of the non empty separator string <code>sep</code>. Empty substrings are omitted in the list if <code>drop_empty</code> is <code>true</code> (defaults to <code>false</code>).</p><p>Matching separators in <code>s</code> starts from the left of <code>s</code> (<code>rev</code> is <code>false</code>, default) or the end (<code>rev</code> is <code>true</code>). Once one is found, the separator is skipped and matching starts again, that is separator matches can't overlap. If there is no separator match in <code>s</code>, the list <code>[s]</code> is returned.</p><p>The following invariants hold:</p><ul><li><code>concat ~sep (cuts ~drop_empty:false ~sep s) = s</code></li><li><code>cuts ~drop_empty:false ~sep s &lt;&gt; []</code></li></ul><dl><dt>raises Invalid_argument</dt><dd><p>if <code>sep</code> is the empty string.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-cuts_right"><a href="#val-cuts_right" class="anchor"></a><code><span class="keyword">val</span> cuts_right : ?&#8288;drop_empty:bool <span>&#45;&gt;</span> sep:string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string list</code></dt><dd><p><code>cuts_right sep s</code> is like <a href="index.html#val-cuts_left"><code>cuts_left</code></a> but matching starts on the right of <code>s</code>.</p></dd></dl></section></section><section><header><h2 id="traversing"><a href="#traversing" class="anchor"></a>Traversing</h2></header><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : (char <span>&#45;&gt;</span> char) <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt><dd><p><code>map f s</code> is <code>s'</code> with <code>s'.[i] = f s.[i]</code> for all indices <code>i</code> of <code>s</code>. <code>f</code> is invoked in increasing index order.</p></dd></dl><dl><dt class="spec value" id="val-mapi"><a href="#val-mapi" class="anchor"></a><code><span class="keyword">val</span> mapi : (int <span>&#45;&gt;</span> char <span>&#45;&gt;</span> char) <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt><dd><p><code>mapi f s</code> is <code>s'</code> with <code>s'.[i] = f i s.[i]</code> for all indices <code>i</code> of <code>s</code>. <code>f</code> is invoked in increasing index order.</p></dd></dl></section><section><header><h2 id="fmt"><a href="#fmt" class="anchor"></a>Formatting</h2></header><dl><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val</span> pp : string <a href="../Fmt/index.html#type-t">Fmt.t</a></code></dt><dd><p><code>pp ppf s</code> prints <code>s</code>'s bytes on <code>ppf</code>.</p></dd></dl><dl><dt class="spec value" id="val-dump"><a href="#val-dump" class="anchor"></a><code><span class="keyword">val</span> dump : string <a href="../Fmt/index.html#type-t">Fmt.t</a></code></dt><dd><p><code>dump ppf s</code> prints <code>s</code> as a syntactically valid OCaml string on <code>ppf</code>.</p></dd></dl></section><section><header><h2 id="unique"><a href="#unique" class="anchor"></a>Uniqueness</h2></header><dl><dt class="spec value" id="val-uniquify"><a href="#val-uniquify" class="anchor"></a><code><span class="keyword">val</span> uniquify : string list <span>&#45;&gt;</span> string list</code></dt><dd><p><code>uniquify ss</code> is <code>ss</code> without duplicates, the list order is preserved.</p></dd></dl><dl><dt class="spec value" id="val-unique"><a href="#val-unique" class="anchor"></a><code><span class="keyword">val</span> unique : exists:(string <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> string <span>&#45;&gt;</span> (string,Â string) <a href="../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></code></dt><dd><p><code>unique ~exist n</code> is <code>n</code> if <code>exists n</code> is <code>false</code> or <code>r = strf
      &quot;%s~%d&quot; n d</code> with <code>d</code> the smallest integer in [<code>1</code>;<code>1e9</code>] such that <code>exists r</code> is <code>false</code> or an error if there is no such string.</p></dd></dl></section><section><header><h2 id="suggesting"><a href="#suggesting" class="anchor"></a>Suggesting</h2></header><dl><dt class="spec value" id="val-edit_distance"><a href="#val-edit_distance" class="anchor"></a><code><span class="keyword">val</span> edit_distance : string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> int</code></dt><dd><p><code>edit_distance s0 s1</code> is the number of single character edits (insertion, deletion, substitution) that are needed to change <code>s0</code> into <code>s1</code>.</p></dd></dl><dl><dt class="spec value" id="val-suggest"><a href="#val-suggest" class="anchor"></a><code><span class="keyword">val</span> suggest : ?&#8288;dist:int <span>&#45;&gt;</span> string list <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string list</code></dt><dd><p><code>suggest ~dist candidates s</code> are the elements of <code>candidates</code> whose <a href="index.html#val-edit_distance"><span>edit distance</span></a> is the smallest to <code>s</code> and at most at a distance of <code>dist</code> of <code>s</code> (defaults to <code>2</code>). If multiple results are returned the order of <code>candidates</code> is preserved.</p></dd></dl></section><section><header><h2 id="escunesc"><a href="#escunesc" class="anchor"></a>Escaping and unescaping bytes</h2><p>See also the <a href="Ascii/index.html#escunesc"><span>Converting to printable US-ASCII characters</span></a>.</p><p><b>XXX.</b> Limitation cannot escape/unescape multiple bytes (e.g. UTF-8 byte sequences). This could be achieved by tweaking the sigs to return integer pairs but that would allocate quite a bit.</p></header><dl><dt class="spec value" id="val-escaper"><a href="#val-escaper" class="anchor"></a><code><span class="keyword">val</span> escaper : (char <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> (bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> char <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt><dd><p><code>escaper char_len set_char</code> is a byte escaper that given a byte <code>c</code> uses <code>char_len c</code> bytes in the escaped form and uses <code>set_char b i c</code> to set the escaped form for <code>c</code> in <code>b</code> at index <code>i</code> returning the next writable index (no bounds check need to be performed). For any <code>b</code>, <code>c</code> and <code>i</code> the invariant <code>i + char_len c = set_char b i c</code> must hold.</p></dd></dl><dl><dt class="spec exception" id="exception-Illegal_escape"><a href="#exception-Illegal_escape" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Illegal_escape</span> <span class="keyword">of</span> int</code></dt><dd><p>See <a href="index.html#val-unescaper"><code>unescaper</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-unescaper"><a href="#val-unescaper" class="anchor"></a><code><span class="keyword">val</span> unescaper : (string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> (bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> string <span>&#45;&gt;</span> (string,Â int) <a href="../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></code></dt><dd><p><code>unescaper char_len_at set_char</code> is a byte unescaper that uses <code>char_len_at</code> to determine the length of a byte at a given index in the string to unescape and <code>set_char b k s i</code> to set at index <code>k</code> in <code>b</code> the unescaped character read at index <code>i</code> in <code>s</code>; and returns the next readable index in <code>s</code> (no bound check need to be performed). For any <code>b</code>, <code>s</code>, <code>k</code> and <code>i</code> the invariant <code>i
      + char_len_at s i = set_char b k s i</code>.</p><p>Both <code>char_len_at</code> and <code>set_char</code> may raise <code>Illegal_escape i</code> if the given index <code>i</code> has an illegal or truncated escape. The unescaper only uses this exception internally it returns <code>Error
      i</code> if it found an illegal escape at index <code>i</code>.</p></dd></dl></section><section><header><h2 id="ascii"><a href="#ascii" class="anchor"></a>Strings as US-ASCII character sequences</h2></header><dl><dt class="spec module" id="module-Ascii"><a href="#module-Ascii" class="anchor"></a><code><span class="keyword">module</span> <a href="Ascii/index.html">Ascii</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>US-ASCII string support.</p></dd></dl></section><section><header><h2 id="setmap"><a href="#setmap" class="anchor"></a>String map and sets</h2></header><dl><dt class="spec module" id="module-Set"><a href="#module-Set" class="anchor"></a><code><span class="keyword">module</span> <a href="Set/index.html">Set</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>String sets.</p></dd></dl><dl><dt class="spec module" id="module-Map"><a href="#module-Map" class="anchor"></a><code><span class="keyword">module</span> <a href="Map/index.html">Map</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>String maps.</p></dd></dl></section></div></body></html>