<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>dune (odoc.dune)</title><link rel="stylesheet" href="../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="index.html">Up</a> â€“ <a href="index.html">odoc</a> &#x00BB; dune</nav><header class="odoc-preamble"><h1 id="dune-and-odoc"><a href="#dune-and-odoc" class="anchor"></a>Dune and odoc</h1></header><nav class="odoc-toc"><ul><li><a href="#using_dune">Using Dune</a></li><li><a href="#library_wrapping">Dune's Library Wrapping</a></li><li><a href="#example">Example</a><ul><li><a href="#hand-written-top-level-module">Hand-Written Top-Level Module</a></li></ul></li></ul></nav><div class="odoc-content"><h2 id="using_dune"><a href="#using_dune" class="anchor"></a>Using Dune</h2><p>To create docs with <code>odoc</code> and Dune is straightforward, but there is an important point to know: Dune only creates docs for <em>public packages</em>, so you will need a <code>(public_name ...)</code> stanza in your libraries and a corresponding <code>lib.opam</code> file in the root of your project.</p><p>The following files are a simple example:</p><ul><li><p><code>dune-project</code></p><pre><code>(lang dune 2.0)</code></pre></li><li><p><code>dune</code></p><pre><code>(library
  (public_name lib))</code></pre></li><li><p><code>a.ml</code></p><pre><code>(** Module A *)

type t = int (** My type *)</code></pre></li><li><code>lib.opam</code> - this file need only <em>exist</em>, i.e., <code>touch lib.opam</code> is sufficient.</li></ul><p>Dune creates the docs for these with this command:</p><pre><code>$ dune build @doc</code></pre><p>and the results will be in <code>_build/default/_doc/_html/</code>.</p><h2 id="library_wrapping"><a href="#library_wrapping" class="anchor"></a>Dune's Library Wrapping</h2><p>Dune has a feature whereby a library may be exposed under a single top-level module. This makes use of an OCaml feature where the use of the compiler flag <code>-no-alias-deps</code> is used to avoid introducing dependencies between compilation units.</p><p>We aim to reduce the potential name clashes of modules by only exposing one main module for library users to use, encapsulating all other modules as submodules, while still retaining the usual way of writing OCaml code with one module per file. These individual files are still compiled, and installed, and available in the global namespace, but their names are prefixed with the library's name in order to reduce the possibility of clashes. These prefixed modules are not intended to be used directly, so Dune includes canonical tags for these modules for <code>odoc</code> to ensure they don't 'leak' into the documentation.</p><h2 id="example"><a href="#example" class="anchor"></a>Example</h2><p>Given two modules: <code>A</code> and <code>B</code>, with <code>B</code> referencing types declared in module <code>A</code>:</p><pre><code>(** Module A *)
type t</code></pre><pre><code>(** Module B *)
type t = A.t</code></pre><p>If these modules are to become part of a library called <code>Lib</code>, then Dune will compile these two as if their names were <code>Lib__A</code> and <code>Lib__B</code> and also create a file <code>lib.ml</code> containing the following:</p><pre><code>(** @canonical Lib.A *)
module A = Lib__A

(** @canonical Lib.B *)
module B = Lib__B</code></pre><p>This will be the one module intended to be used directly by the library's users. This module is in fact compiled <em>first</em>, using the compiler flag <code>--no-alias-deps</code>, which allows it to be compiled without requiring <code>Lib__A</code> and <code>Lib__B</code> to be compiled first.</p><p>Dune will then compile <code>a.ml</code> and <code>b.ml</code>, in that order, but ask the compiler to name them <code>Lib__A</code> and <code>Lib__B</code>. It also 'opens' the module <code>Lib</code>, which is what allows <code>B</code> to refer to <code>A.t</code>.</p><p>When <code>odoc</code> is used to produce documentation for this, firstly all modules are compiled, but only one module is considered to be visible: <code>Lib</code>. All others have double underscores meaning they are hidden. Only the non-hidden module <code>Lib</code> is linked, and during this process, the the modules <code>A</code> and <code>B</code> are expanded because they are aliases of hidden modules. All references to <code>Lib__A</code> and <code>Lib__B</code> are replaced with the canonical paths <code>Lib.A</code> and <code>Lib.B</code>, so in this way odoc presents the library as entirely contained within the module <code>Lib</code>.</p><h3 id="hand-written-top-level-module"><a href="#hand-written-top-level-module" class="anchor"></a>Hand-Written Top-Level Module</h3><p>In some cases it's desirable to hand-write the top-level library module. This is usually done because some of the modules within the library are intended to be internal only and not exposed. Dune will notice that a module exists with the name of the library (<code>lib.ml</code> in this case), so instead it will create the file <code>lib__.ml</code>. The contents of this are identical to the previous section, with aliases for all modules. The canonical tags on the aliases are, as before, to <code>Lib.A</code> and <code>Lib.B</code>. These are references to module aliases that should be present in <code>lib.ml</code>. If these are <em>not</em> there, <code>odoc</code> won't be able to resolve the canonical references, and any items from these modules that are exposed elsewhere will be hidden. If the items are type aliases they can be replaced, but otherwise they'll be rendered as unresolved links.</p><p>For example, consider the following module structure. First, the module <code>Unexposed</code> in file <code>unexposed.mli</code>:</p><pre><code>(** Unexposed module *)

type t</code></pre><p>The module <code>Wrapping</code>, in file <code>wrapping.mli</code>:</p><pre><code>(** Example of Dune's wrapping *)

type t = Unexposed.t

val f : Unexposed.t</code></pre><p>and the library module that only exposes the module <code>Wrapping</code>:</p><pre><code>module Wrapping = Wrapping</code></pre><p>This structure is rendered <a href="Odoc_examples/Wrapping/index.html">here</a>.</p></div></body></html>