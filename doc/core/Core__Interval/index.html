<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Core__Interval (core.Core__Interval)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">core</a> &#x00BB; Core__Interval</nav><h1>Module <code>Core__Interval</code></h1><p>Module for simple closed intervals over arbitrary types. Used by calling the <a href="../Core/Interval/Make/index.html"><span><code>Make</code></span></a> functor with a type that satisfies <a href="../../base/Base/Comparable/index.html"><span><code>Comparable</code></span></a> (for correctly ordering elements).</p><p>Note that the actual interface for intervals is in <a href="../Core/Interval_intf/module-type-Gen/index.html"><span><code>Interval_intf.Gen</code></span></a>, following a Core pattern of defining an interface once in a <code>Gen</code> module, then reusing it across monomorphic (<code>S</code>) and polymorphic (<code>S1</code>, <code>S2</code>, ... <code>SN</code>) variants, where <code>SN</code> denotes a signature of N parameters. Here, <code>S1</code> is included in this module because the signature of one <code>'a</code> parameter is the default.</p><p>See the documentation of <a href="../Core/Interval/Make/index.html"><span><code>Interval.Make</code></span></a> for a more detailed usage example.</p><nav class="toc"><ul><li><a href="#type-specialized-intervals">Type-specialized intervals</a><ul><li><a href="#signatures">Signatures</a></li><li><a href="#specialized-interval-types">Specialized interval types</a></li></ul></li></ul></nav></header><div><div class="spec include"><div class="doc"><h3 id="intervals-using-polymorphic-compare"><a href="#intervals-using-polymorphic-compare" class="anchor"></a>Intervals using polymorphic compare</h3><p>This part of the interface is for polymorphic intervals, which are well ordered by polymorphic compare. Using this with types that are not (like sets) will lead to crazy results.</p><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> 'a t</code></dt><dd><p>This type <code>t</code> supports bin-io and sexp conversion by way of the <code>[@@deriving bin_io, sexp]</code> extensions, which inline the relevant function signatures (like <code>bin_read_t</code> and <code>t_of_sexp</code>).</p></dd></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></span></summary><dl><dt class="spec value" id="val-bin_t"><a href="#val-bin_t" class="anchor"></a><code><span class="keyword">val</span> bin_t : <span class="type-var">'a</span> <a href="../../bin_prot/Bin_prot/Type_class/index.html#type-t">Bin_prot.Type_class.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="../../bin_prot/Bin_prot/Type_class/index.html#type-t">Bin_prot.Type_class.t</a></code></dt><dt class="spec value" id="val-bin_read_t"><a href="#val-bin_read_t" class="anchor"></a><code><span class="keyword">val</span> bin_read_t : <span class="type-var">'a</span> <a href="../../bin_prot/Bin_prot/Read/index.html#type-reader">Bin_prot.Read.reader</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="../../bin_prot/Bin_prot/Read/index.html#type-reader">Bin_prot.Read.reader</a></code></dt><dt class="spec value" id="val-__bin_read_t__"><a href="#val-__bin_read_t__" class="anchor"></a><code><span class="keyword">val</span> __bin_read_t__ : <span class="type-var">'a</span> <a href="../../bin_prot/Bin_prot/Read/index.html#type-reader">Bin_prot.Read.reader</a> <span>&#45;&gt;</span> (int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a>) <a href="../../bin_prot/Bin_prot/Read/index.html#type-reader">Bin_prot.Read.reader</a></code></dt><dt class="spec value" id="val-bin_reader_t"><a href="#val-bin_reader_t" class="anchor"></a><code><span class="keyword">val</span> bin_reader_t : <span class="type-var">'a</span> <a href="../../bin_prot/Bin_prot/Type_class/index.html#type-reader">Bin_prot.Type_class.reader</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="../../bin_prot/Bin_prot/Type_class/index.html#type-reader">Bin_prot.Type_class.reader</a></code></dt><dt class="spec value" id="val-bin_size_t"><a href="#val-bin_size_t" class="anchor"></a><code><span class="keyword">val</span> bin_size_t : <span class="type-var">'a</span> <a href="../../bin_prot/Bin_prot/Size/index.html#type-sizer">Bin_prot.Size.sizer</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="../../bin_prot/Bin_prot/Size/index.html#type-sizer">Bin_prot.Size.sizer</a></code></dt><dt class="spec value" id="val-bin_write_t"><a href="#val-bin_write_t" class="anchor"></a><code><span class="keyword">val</span> bin_write_t : <span class="type-var">'a</span> <a href="../../bin_prot/Bin_prot/Write/index.html#type-writer">Bin_prot.Write.writer</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="../../bin_prot/Bin_prot/Write/index.html#type-writer">Bin_prot.Write.writer</a></code></dt><dt class="spec value" id="val-bin_writer_t"><a href="#val-bin_writer_t" class="anchor"></a><code><span class="keyword">val</span> bin_writer_t : <span class="type-var">'a</span> <a href="../../bin_prot/Bin_prot/Type_class/index.html#type-writer">Bin_prot.Type_class.writer</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="../../bin_prot/Bin_prot/Type_class/index.html#type-writer">Bin_prot.Type_class.writer</a></code></dt><dt class="spec value" id="val-bin_shape_t"><a href="#val-bin_shape_t" class="anchor"></a><code><span class="keyword">val</span> bin_shape_t : <a href="../../bin_prot/Bin_prot/Shape/index.html#type-t">Bin_prot.Shape.t</a> <span>&#45;&gt;</span> <a href="../../bin_prot/Bin_prot/Shape/index.html#type-t">Bin_prot.Shape.t</a></code></dt><dt class="spec value" id="val-t_of_sexp"><a href="#val-t_of_sexp" class="anchor"></a><code><span class="keyword">val</span> t_of_sexp : (<a href="../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <a href="../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-sexp_of_t"><a href="#val-sexp_of_t" class="anchor"></a><code><span class="keyword">val</span> sexp_of_t : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a></code></dt></dl></details></div></div></div><dl><dt class="spec type" id="type-bound_"><a href="#type-bound_" class="anchor"></a><code><span class="keyword">type</span> 'a bound_</code><code> = <span class="type-var">'a</span></code></dt></dl><div><div class="spec include"><div class="doc"><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> 'a t</code></dt><dt class="spec type" id="type-bound"><a href="#type-bound" class="anchor"></a><code><span class="keyword">type</span> 'a bound</code></dt><dd><p><code>bound</code> is the type of points in the interval (and therefore of the bounds). <code>bound</code> is instantiated in two different ways below: in <code>module type S</code> as a monotype and in <code>module type S1</code> as <code>'a</code>.</p></dd></dl><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : <span class="type-var">'a</span> <a href="index.html#type-bound">bound</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-bound">bound</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>create l u</code> returns the interval with lower bound <code>l</code> and upper bound <code>u</code>, unless <code>l &gt; u</code>, in which case it returns the empty interval.</p></dd></dl><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val</span> empty : <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-intersect"><a href="#val-intersect" class="anchor"></a><code><span class="keyword">val</span> intersect : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-is_empty"><a href="#val-is_empty" class="anchor"></a><code><span class="keyword">val</span> is_empty : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-is_empty_or_singleton"><a href="#val-is_empty_or_singleton" class="anchor"></a><code><span class="keyword">val</span> is_empty_or_singleton : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-bounds"><a href="#val-bounds" class="anchor"></a><code><span class="keyword">val</span> bounds : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <a href="index.html#type-bound">bound</a> * <span class="type-var">'a</span> <a href="index.html#type-bound">bound</a>) option</code></dt><dt class="spec value" id="val-lbound"><a href="#val-lbound" class="anchor"></a><code><span class="keyword">val</span> lbound : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-bound">bound</a> option</code></dt><dt class="spec value" id="val-ubound"><a href="#val-ubound" class="anchor"></a><code><span class="keyword">val</span> ubound : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-bound">bound</a> option</code></dt><dt class="spec value" id="val-bounds_exn"><a href="#val-bounds_exn" class="anchor"></a><code><span class="keyword">val</span> bounds_exn : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-bound">bound</a> * <span class="type-var">'a</span> <a href="index.html#type-bound">bound</a></code></dt><dt class="spec value" id="val-lbound_exn"><a href="#val-lbound_exn" class="anchor"></a><code><span class="keyword">val</span> lbound_exn : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-bound">bound</a></code></dt><dt class="spec value" id="val-ubound_exn"><a href="#val-ubound_exn" class="anchor"></a><code><span class="keyword">val</span> ubound_exn : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-bound">bound</a></code></dt><dt class="spec value" id="val-convex_hull"><a href="#val-convex_hull" class="anchor"></a><code><span class="keyword">val</span> convex_hull : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>convex_hull ts</code> returns an interval whose upper bound is the greatest upper bound of the intervals in the list, and whose lower bound is the least lower bound of the list.</p><p>Suppose you had three intervals <code>a</code>, <code>b</code>, and <code>c</code>:</p><pre>             a:  (   )
             b:    (     )
             c:            ( )

          hull:  (           )</pre><p>In this case the hull goes from <code>lbound_exn a</code> to <code>ubound_exn c</code>.</p></dd></dl><dl><dt class="spec value" id="val-contains"><a href="#val-contains" class="anchor"></a><code><span class="keyword">val</span> contains : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-bound">bound</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-compare_value"><a href="#val-compare_value" class="anchor"></a><code><span class="keyword">val</span> compare_value : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-bound">bound</a> <span>&#45;&gt;</span> [ `Below | `Within | `Above | `Interval_is_empty ]</code></dt><dt class="spec value" id="val-bound"><a href="#val-bound" class="anchor"></a><code><span class="keyword">val</span> bound : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-bound">bound</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-bound">bound</a> option</code></dt><dd><p><code>bound t x</code> returns <code>None</code> iff <code>is_empty t</code>. If <code>bounds t = Some (a, b)</code>, then <code>bound</code> returns <code>Some y</code> where <code>y</code> is the element of <code>t</code> closest to <code>x</code>. I.e.:</p><pre>        y = a  if x &lt; a
        y = x  if a &lt;= x &lt;= b
        y = b  if x &gt; b</pre></dd></dl><dl><dt class="spec value" id="val-is_superset"><a href="#val-is_superset" class="anchor"></a><code><span class="keyword">val</span> is_superset : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> of_:<span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_superset i1 of_:i2</code> is whether i1 contains i2. The empty interval is contained in every interval.</p></dd></dl><dl><dt class="spec value" id="val-is_subset"><a href="#val-is_subset" class="anchor"></a><code><span class="keyword">val</span> is_subset : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> of_:<span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <a href="index.html#type-bound">bound</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-bound">bound</a>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>map t ~f</code> returns <code>create (f l) (f u)</code> if <code>bounds t = Some (l, u)</code>, and <code>empty</code> if <code>t</code> is empty. Note that if <code>f l &gt; f u</code>, the result of <code>map</code> is <code>empty</code>, by the definition of <code>create</code>.</p><p>If you think of an interval as a set of points, rather than a pair of its bounds, then <code>map</code> is not the same as the usual mathematical notion of mapping <code>f</code> over that set. For example, <code>map ~f:(fun x -&gt; x * x)</code> maps the interval <code>[-1,1]</code> to <code>[1,1]</code>, not to <code>[0,1]</code>.</p></dd></dl><dl><dt class="spec value" id="val-are_disjoint"><a href="#val-are_disjoint" class="anchor"></a><code><span class="keyword">val</span> are_disjoint : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> bool</code></dt><dd><p><code>are_disjoint ts</code> returns <code>true</code> iff the intervals in <code>ts</code> are pairwise disjoint.</p></dd></dl><dl><dt class="spec value" id="val-are_disjoint_as_open_intervals"><a href="#val-are_disjoint_as_open_intervals" class="anchor"></a><code><span class="keyword">val</span> are_disjoint_as_open_intervals : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> bool</code></dt><dd><p>Returns true iff a given set of intervals would be disjoint if considered as open intervals, e.g., <code>(3,4)</code> and <code>(4,5)</code> would count as disjoint according to this function.</p></dd></dl><dl><dt class="spec value" id="val-list_intersect"><a href="#val-list_intersect" class="anchor"></a><code><span class="keyword">val</span> list_intersect : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> list</code></dt><dd><p>Assuming that <code>ilist1</code> and <code>ilist2</code> are lists of disjoint intervals, <code>list_intersect
      ilist1 ilist2</code> considers the intersection <code>(intersect i1 i2)</code> of every pair of intervals <code>(i1, i2)</code>, with <code>i1</code> drawn from <code>ilist1</code> and <code>i2</code> from <code>ilist2</code>, returning just the non-empty intersections. By construction these intervals will be disjoint, too. For example:</p><pre><code class="ml">let i = Interval.create;;
list_intersect [i 4 7; i 9 15] [i 2 4; i 5 10; i 14 20];;
[(4, 4), (5, 7), (9, 10), (14, 15)]</code></pre><p>Raises an exception if either input list is non-disjoint.</p></dd></dl><dl><dt class="spec value" id="val-half_open_intervals_are_a_partition"><a href="#val-half_open_intervals_are_a_partition" class="anchor"></a><code><span class="keyword">val</span> half_open_intervals_are_a_partition : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> bool</code></dt><dd><p>Returns true if the intervals, when considered as half-open intervals, nestle up cleanly one to the next. I.e., if you sort the intervals by the lower bound, then the upper bound of the <code>n</code>th interval is equal to the lower bound of the <code>n+1</code>th interval. The intervals do not need to partition the entire space, they just need to partition their union.</p></dd></dl></div></div></div><div class="spec module" id="module-Set"><a href="#module-Set" class="anchor"></a><code><span class="keyword">module</span> <a href="Set/index.html">Set</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span> <span class="keyword">with</span> <span class="keyword">type</span> 'a <a href="Set/index.html#type-bound">bound</a> := <span class="type-var">'a</span> <a href="index.html#type-bound_">bound_</a> <span class="keyword">with</span> <span class="keyword">type</span> 'a <a href="Set/index.html#type-interval">interval</a> := <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></div></div></div></div><section><header><h3 id="type-specialized-intervals"><a href="#type-specialized-intervals" class="anchor"></a>Type-specialized intervals</h3><p>The module type <code>S</code> is used to define signatures for intervals over a specific type, like <code>Interval.Ofday</code> (whose bounds are <code>Time.Ofday.t</code>) or <code>Interval.Float</code>, whose bounds are floats.</p><p>Note the heavy use of destructive substitution, which removes the redefined type or module from the signature. This allows for clean type constraints in codebases, like Core's, where there are lots of types going by the same name (e.g., &quot;t&quot;).</p></header><section><header><h4 id="signatures"><a href="#signatures" class="anchor"></a>Signatures</h4><p>The following signatures are used for specifying the types of the type-specialized intervals.</p></header><div class="spec module-type" id="module-type-S1"><a href="#module-type-S1" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-S1/index.html">S1</a> = <a href="../Core/Interval_intf/index.html#module-type-S1">Core.Interval_intf.S1</a></code></div><div class="spec module-type" id="module-type-S"><a href="#module-type-S" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-S/index.html">S</a> : <a href="../Core/Interval_intf/index.html#module-type-S">Core.Interval_intf.S</a> <span class="keyword">with</span> <span class="keyword">type</span> 'a <a href="module-type-S/index.html#type-poly_t">poly_t</a> := <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span class="keyword">with</span> <span class="keyword">type</span> 'a <a href="module-type-S/index.html#type-poly_set">poly_set</a> := <span class="type-var">'a</span> <a href="Set/index.html#type-t">Set.t</a></code></div><dl><dt class="spec module-type" id="module-type-S_time"><a href="#module-type-S_time" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-S_time/index.html">S_time</a> : <a href="../Core/Interval_intf/index.html#module-type-S_time">Core.Interval_intf.S_time</a> <span class="keyword">with</span> <span class="keyword">type</span> 'a <a href="module-type-S_time/index.html#type-poly_t">poly_t</a> := <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span class="keyword">with</span> <span class="keyword">type</span> 'a <a href="module-type-S_time/index.html#type-poly_set">poly_set</a> := <span class="type-var">'a</span> <a href="Set/index.html#type-t">Set.t</a></code></dt><dd><p><code>S_time</code> is a signature that's used below to define the interfaces for <code>Time</code> and <code>Time_ns</code> without duplication.</p></dd></dl></section><section><header><h4 id="specialized-interval-types"><a href="#specialized-interval-types" class="anchor"></a>Specialized interval types</h4></header><div class="spec module" id="module-Ofday"><a href="#module-Ofday" class="anchor"></a><code><span class="keyword">module</span> <a href="Ofday/index.html">Ofday</a> : <a href="index.html#module-type-S">S</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="module-type-S/index.html#type-bound">bound</a> = <a href="../../core_kernel/Core_kernel__Time_intf/module-type-S/Time/Ofday/index.html#type-t">Core__.Import.Time.Ofday.t</a></code></div><div class="spec module" id="module-Ofday_ns"><a href="#module-Ofday_ns" class="anchor"></a><code><span class="keyword">module</span> <a href="Ofday_ns/index.html">Ofday_ns</a> : <a href="index.html#module-type-S">S</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="module-type-S/index.html#type-bound">bound</a> = <a href="../Core__Core_time_ns/Ofday/index.html#type-t">Core.Interval_intf.Time_ns.Ofday.t</a></code></div><div class="spec module" id="module-Time"><a href="#module-Time" class="anchor"></a><code><span class="keyword">module</span> <a href="Time/index.html">Time</a> : <a href="index.html#module-type-S_time">S_time</a> <span class="keyword">with</span> <span class="keyword">module</span> <a href="module-type-S_time/Time/index.html">Time</a> := <a href="../Core__/Import/index.html#module-Time">Core__.Import.Time</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="module-type-S_time/index.html#type-t">t</a> = <a href="../../core_kernel/Core_kernel__/Time_float/index.html#type-t">Core__.Import.Time.t</a> <a href="index.html#type-t">t</a></code></div><div class="spec module" id="module-Time_ns"><a href="#module-Time_ns" class="anchor"></a><code><span class="keyword">module</span> <a href="Time_ns/index.html">Time_ns</a> : <a href="index.html#module-type-S_time">S_time</a> <span class="keyword">with</span> <span class="keyword">module</span> <a href="module-type-S_time/Time/index.html">Time</a> := <a href="../Core/Interval_intf/index.html#module-Time_ns">Core.Interval_intf.Time_ns</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="module-type-S_time/index.html#type-t">t</a> = <a href="../Core__/Core_time_ns/index.html#type-t">Core.Interval_intf.Time_ns.t</a> <a href="index.html#type-t">t</a></code></div><div class="spec module" id="module-Float"><a href="#module-Float" class="anchor"></a><code><span class="keyword">module</span> <a href="Float/index.html">Float</a> : <a href="index.html#module-type-S">S</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="module-type-S/index.html#type-bound">bound</a> = <a href="../../core_kernel/Core_kernel/Float/index.html#type-t">Core__.Import.Float.t</a></code></div><div class="spec module" id="module-Int"><a href="#module-Int" class="anchor"></a><code><span class="keyword">module</span> <a href="Int/index.html">Int</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec module" id="module-Make"><a href="#module-Make" class="anchor"></a><code><span class="keyword">module</span> <a href="Make/index.html">Make</a> : <span class="keyword">functor</span> (<a href="Make/argument-1-Bound/index.html">Bound</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) <span>&#45;&gt;</span> <a href="index.html#module-type-S">S</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Make/index.html#type-bound">bound</a> = <a href="Make/argument-1-Bound/index.html#type-t">Bound.t</a></code></dt><dd><p><code>Interval.Make</code> is a functor that takes a type that you'd like to create intervals for and returns a module with functions over intervals of that type.</p></dd></dl><dl><dt class="spec module" id="module-Stable"><a href="#module-Stable" class="anchor"></a><code><span class="keyword">module</span> <a href="Stable/index.html">Stable</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p><code>Stable</code> is used to build stable protocols. It ensures backwards compatibility by checking the sexp and bin-io representations of a given module. Here it's also applied to the <code>Float</code>, <code>Int</code>, <code>Time</code>, <code>Time_ns</code>, and <code>Ofday</code> intervals.</p></dd></dl></section></section></div></body></html>