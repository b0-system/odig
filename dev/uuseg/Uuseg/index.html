<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Uuseg (uuseg.Uuseg)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">uuseg</a> &#x00BB; Uuseg</nav><h1>Module <code>Uuseg</code></h1><p>Unicode text segmentation.</p><p><code>Uuseg</code> segments Unicode text. It implements the locale independent Unicode text segmentation algorithms to detect grapheme cluster, word and sentence boundaries and the Unicode line breaking algorithm to detect line break opportunities.</p><p>The module is independent from any IO mechanism or Unicode text data structure and it can process text without a complete in-memory representation.</p><p>The supported Unicode version is determined by the <a href="index.html#val-unicode_version"><code>unicode_version</code></a> value.</p><p>Consult the <a href="index.html#basics"><span>basics</span></a>, <a href="index.html#limits"><span>limitations</span></a> and <a href="index.html#examples"><span>examples</span></a> of use.</p><p><b>Warning</b> Version 11.0.0 of UAX #29 grapheme cluster and word segmentation are not stricly conformant with respect to emojis see <a href="https://github.com/dbuenzli/uuseg/issues/5">this issue</a> for details.</p><p><em>v11.0.0 — Unicode version 11.0.0 — <a href="http://erratique.ch/software/uuseg">homepage</a></em></p><h4 id="references"><a href="#references" class="anchor"></a>References</h4><ul><li>The Unicode Consortium. <em><a href="http://www.unicode.org/versions/latest">The Unicode Standard</a></em>. (latest version)</li><li>Mark Davis. <em><a href="http://www.unicode.org/reports/tr29/">UAX #29 Unicode Text Segmentation</a></em>. (latest version)</li><li>Andy Heninger. <em><a href="http://www.unicode.org/reports/tr14/">UAX #14 Unicode Line Breaking Algorithm</a></em>. (latest version)</li><li>Web based <a href="http://unicode.org/cldr/utility/breaks.jsp">ICU break utility</a>.</li></ul><nav class="toc"><ul><li><a href="#segment">Segment</a></li><li><a href="#custom-segmenters">Custom segmenters</a></li><li><a href="#limits">Limitations</a></li><li><a href="#basics">Basics</a></li><li><a href="#examples">Examples</a></li></ul></nav></header><section><header><h2 id="segment"><a href="#segment" class="anchor"></a>Segment</h2></header><dl><dt class="spec value" id="val-unicode_version"><a href="#val-unicode_version" class="anchor"></a><code><span class="keyword">val</span> unicode_version : string</code></dt><dd><p><code>unicode_version</code> is the Unicode version supported by <code>Uuseg</code>.</p></dd></dl><dl><dt class="spec type" id="type-custom"><a href="#type-custom" class="anchor"></a><code><span class="keyword">type</span> custom</code></dt><dd><p>The type for custom segmenters. See <a href="index.html#val-custom"><code>custom</code></a>.</p></dd></dl><dl><dt class="spec type" id="type-boundary"><a href="#type-boundary" class="anchor"></a><code><span class="keyword">type</span> boundary</code> = <code>[ </code><table class="variant"><tr id="type-boundary.Grapheme_cluster" class="anchored"><td class="def constructor"><a href="#type-boundary.Grapheme_cluster" class="anchor"></a><code>| </code><code>`Grapheme_cluster</code></td></tr><tr id="type-boundary.Word" class="anchored"><td class="def constructor"><a href="#type-boundary.Word" class="anchor"></a><code>| </code><code>`Word</code></td></tr><tr id="type-boundary.Sentence" class="anchored"><td class="def constructor"><a href="#type-boundary.Sentence" class="anchor"></a><code>| </code><code>`Sentence</code></td></tr><tr id="type-boundary.Line_break" class="anchored"><td class="def constructor"><a href="#type-boundary.Line_break" class="anchor"></a><code>| </code><code>`Line_break</code></td></tr><tr id="type-boundary.Custom" class="anchored"><td class="def constructor"><a href="#type-boundary.Custom" class="anchor"></a><code>| </code><code>`Custom <span class="keyword">of</span> <a href="index.html#type-custom">custom</a></code></td></tr></table><code> ]</code></dt><dd><p>The type for boundaries.</p><ul><li><code>`Grapheme_cluster</code> determines <a href="http://www.unicode.org/glossary/#extended_grapheme_cluster">extended grapheme clusters</a> boundaries according to UAX 29 (corresponds, for most scripts, to user-perceived characters).</li><li><code>`Word</code> determines word boundaries according to UAX 29.</li><li><code>`Sentence</code> determines sentence boundaries according to UAX 29.</li><li><code>`Line_break</code> determines <a href="index.html#val-mandatory"><span>mandatory</span></a> line breaks and line break opportunities according to UAX 14.</li></ul></dd></dl><dl><dt class="spec value" id="val-pp_boundary"><a href="#val-pp_boundary" class="anchor"></a><code><span class="keyword">val</span> pp_boundary : <a href="../../ocaml/Stdlib/Format/index.html#type-formatter">Stdlib.Format.formatter</a> <span>&#45;&gt;</span> <a href="index.html#type-boundary">boundary</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp_boundary ppf b</code> prints an unspecified representation of <code>b</code> on <code>ppf</code>.</p></dd></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><p>The type for Unicode text segmenters.</p></dd></dl><dl><dt class="spec type" id="type-ret"><a href="#type-ret" class="anchor"></a><code><span class="keyword">type</span> ret</code> = <code>[ </code><table class="variant"><tr id="type-ret.Boundary" class="anchored"><td class="def constructor"><a href="#type-ret.Boundary" class="anchor"></a><code>| </code><code>`Boundary</code></td></tr><tr id="type-ret.Uchar" class="anchored"><td class="def constructor"><a href="#type-ret.Uchar" class="anchor"></a><code>| </code><code>`Uchar <span class="keyword">of</span> <a href="../../ocaml/Stdlib/Uchar/index.html#type-t">Stdlib.Uchar.t</a></code></td></tr><tr id="type-ret.Await" class="anchored"><td class="def constructor"><a href="#type-ret.Await" class="anchor"></a><code>| </code><code>`Await</code></td></tr><tr id="type-ret.End" class="anchored"><td class="def constructor"><a href="#type-ret.End" class="anchor"></a><code>| </code><code>`End</code></td></tr></table><code> ]</code></dt><dd><p>The type for segmenter results. See <a href="index.html#val-add"><code>add</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : [&lt; <a href="index.html#type-boundary">boundary</a> ] <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>create b</code> is an Unicode text segmenter for boundaries of type <code>b</code>.</p></dd></dl><dl><dt class="spec value" id="val-boundary"><a href="#val-boundary" class="anchor"></a><code><span class="keyword">val</span> boundary : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-boundary">boundary</a></code></dt><dd><p><code>boundary s</code> is the type of boundaries detected by <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-add"><a href="#val-add" class="anchor"></a><code><span class="keyword">val</span> add : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> [ `Uchar of <a href="../../ocaml/Stdlib/Uchar/index.html#type-t">Stdlib.Uchar.t</a> | `Await | `End ] <span>&#45;&gt;</span> <a href="index.html#type-ret">ret</a></code></dt><dd><p><code>add s v</code> is:</p><ul><li><code>`Boundary</code> if there is a boundary at that point in the sequence of characters. The client must then call <code>add</code> with <code>`Await</code> until <code>`Await</code> is returned.</li><li><code>`Uchar u</code> if <code>u</code> is the next character in the sequence. The client must then call <code>add</code> with <code>`Await</code> until <code>`Await</code> is returned.</li><li><code>`Await</code> when the segmenter is ready to add a new <code>`Uchar</code> or <code>`End</code>.</li><li><code>`End</code> when <code>`End</code> was added and all <code>`Boundary</code> and <code>`Uchar</code> were output.</li></ul><p>For <code>v</code> use <code>`Uchar u</code> to add a new character to the sequence to segment and <code>`End</code> to signal the end of sequence. After adding one of these two values always call <code>add</code> with <code>`Await</code> until <code>`Await</code> or <code>`End</code> is returned.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>`Uchar</code> or <code>`End</code> is added while that last add did not return <code>`Await</code> or if an <code>`Uchar</code> or <code>`End</code> is added after an <code>`End</code> was already added.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-mandatory"><a href="#val-mandatory" class="anchor"></a><code><span class="keyword">val</span> mandatory : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>mandatory s</code> is <code>true</code> if the last <code>`Boundary</code> returned by <a href="index.html#val-add"><code>add</code></a> was mandatory. This function only makes sense for <code>`Line_break</code> segmenters or <code>`Custom</code> segmenters that sport that notion. For other segmenters or if no <code>`Boundary</code> was returned so far, <code>true</code> is returned.</p></dd></dl><dl><dt class="spec value" id="val-copy"><a href="#val-copy" class="anchor"></a><code><span class="keyword">val</span> copy : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>copy s</code> is a copy of <code>s</code> in its current state. Subsequent <a href="index.html#val-add"><code>add</code></a>s on <code>s</code> do not affect the copy.</p></dd></dl><dl><dt class="spec value" id="val-pp_ret"><a href="#val-pp_ret" class="anchor"></a><code><span class="keyword">val</span> pp_ret : <a href="../../ocaml/Stdlib/Format/index.html#type-formatter">Stdlib.Format.formatter</a> <span>&#45;&gt;</span> [&lt; <a href="index.html#type-ret">ret</a> ] <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp_ret ppf v</code> prints an unspecified representation of <code>v</code> on <code>ppf</code>.</p></dd></dl></section><section><header><h2 id="custom-segmenters"><a href="#custom-segmenters" class="anchor"></a>Custom segmenters</h2></header><dl><dt class="spec value" id="val-custom"><a href="#val-custom" class="anchor"></a><code><span class="keyword">val</span> custom : ?&#8288;mandatory:(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> name:string <span>&#45;&gt;</span> create:(unit <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> copy:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> add:(<span class="type-var">'a</span> <span>&#45;&gt;</span> [ `Uchar of <a href="../../ocaml/Stdlib/Uchar/index.html#type-t">Stdlib.Uchar.t</a> | `Await | `End ] <span>&#45;&gt;</span> <a href="index.html#type-ret">ret</a>) <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-custom">custom</a></code></dt><dd><p><code>create ~mandatory ~name ~create ~copy ~add</code> is a custom segmenter.</p><ul><li><code>name</code> is a name to identify the segmenter.</li><li><code>create</code> is called when the segmenter is <a href="index.html#val-create"><span>created</span></a> it should return a custom segmenter value.</li><li><code>copy</code> is called with the segmenter value whenever the segmenter is <a href="index.html#val-copy"><span>copied</span></a>. It should return a copy of the segmenter value.</li><li><code>mandatory</code> is called with the segmenter value to define the result of the <a href="index.html#val-mandatory"><code>mandatory</code></a> function. Defaults always returns <code>true</code>.</li><li><code>add</code> is called with the segmenter value to define the result of the <a href="index.html#val-add"><code>add</code></a> value. The returned value should respect the semantics of <a href="index.html#val-add"><code>add</code></a>. Use the functions <a href="index.html#val-err_exp_await"><code>err_exp_await</code></a> and <a href="index.html#val-err_ended"><code>err_ended</code></a> to raise <code>Invalid_argument</code> exception in <a href="index.html#val-add"><code>add</code></a>s error cases.</li></ul></dd></dl><dl><dt class="spec value" id="val-err_exp_await"><a href="#val-err_exp_await" class="anchor"></a><code><span class="keyword">val</span> err_exp_await : [&lt; <a href="index.html#type-ret">ret</a> ] <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>err_exp_await fnd</code> should be used by custom segmenters when the client tries to <a href="index.html#val-add"><code>add</code></a> an <code>`Uchar</code> or <code>`End</code> while the last returned value was not an <code>`Await</code>.</p></dd></dl><dl><dt class="spec value" id="val-err_ended"><a href="#val-err_ended" class="anchor"></a><code><span class="keyword">val</span> err_ended : [&lt; <a href="index.html#type-ret">ret</a> ] <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>err_ended ()</code> should be used by custom segmenter when the client tries to <a href="index.html#val-add"><code>add</code></a> <code>`Uchar</code> or <code>`End</code> after <code>`End</code> was already added.</p></dd></dl></section><section><header><h2 id="limits"><a href="#limits" class="anchor"></a>Limitations</h2><p>A <code>`Grapheme_cluster</code> segmenter will always consume only a small bounded amount of memory on any text. Other segmenters will also do so on non-degenerate text, but it's possible to feed them with input that will make them buffer an arbitrary amount of characters.</p></header></section><section><header><h2 id="basics"><a href="#basics" class="anchor"></a>Basics</h2><p>A segmenter is a stateful filter that inputs a sequence of characters and outputs the same sequence except characters are interleaved with <code>`Boundary</code> values whenever the segmenter detects a boundary.</p><p>The function <a href="index.html#val-create"><code>create</code></a> returns a new segmenter for a given boundary type:</p><pre><code class="ml">let words = Uuseg.create `Word</code></pre><p>To add characters to the sequence to segment, call <a href="index.html#val-add"><code>add</code></a> on <code>words</code> with <code>`Uchar _</code>. To end the sequence call <a href="index.html#val-add"><code>add</code></a> on <code>words</code> with <code>`End</code>. The segmented sequence of characters is returned character by character, interleaved with <code>`Boundary</code> values at the appropriate places, by the successive calls to <a href="index.html#val-add"><code>add</code></a>.</p><p>The client and the segmenter must wait on each other to limit internal buffering: each time the client adds to the sequence by calling <a href="index.html#val-add"><code>add</code></a> with <code>`Uchar</code> or <code>`End</code> it must continue to call <a href="index.html#val-add"><code>add</code></a> with <code>`Await</code> until the segmenter returns <code>`Await</code> or <code>`End</code>. In practice this leads to the following kind of control flow:</p><pre><code class="ml">let rec add acc v = match Uuseg.add words v with
| `Uchar u -&gt; add (`Uchar u :: acc) `Await
| `Boundary -&gt; add (`B :: acc) `Await
| `Await | `End -&gt; acc</code></pre><p>For example to segment the sequence &lt;<code>U+0041</code>, <code>U+0020</code>, <code>U+0042</code>&gt; (<code>&quot;a b&quot;</code>) to a list of characters interleaved with <code>`B</code> values on word boundaries we can write:</p><pre><code class="ml">let uchar = `Uchar (Uchar.of_int u)
let seq = [uchar 0x0041; uchar 0x0020; uchar 0x0042]
let seq_words = List.rev (add (List.fold_left add [] seq) `End)</code></pre></header></section><section><header><h2 id="examples"><a href="#examples" class="anchor"></a>Examples</h2><p><code>utf_8_segments seg s</code> is the list of UTF-8 encoded <code>seg</code> segments of the UTF-8 encoded string <code>s</code>. This example uses <code>Uutf</code> to fold over the characters of <code>s</code> and to encode the characters in a standard OCaml buffer. Note that this function can be derived directly from <a href="../Uuseg_string/index.html#val-fold_utf_8"><code>Uuseg_string.fold_utf_8</code></a>.</p><pre><code class="ml">let utf_8_segments seg s =
  let b = Buffer.create 42 in
  let flush_segment acc =
    let segment = Buffer.contents b in
    Buffer.clear b; if segment = &quot;&quot; then acc else segment :: acc
  in
  let seg = Uuseg.create (seg :&gt; Uuseg.boundary) in
  let rec add acc v = match Uuseg.add seg v with
  | `Uchar u -&gt; Uutf.Buffer.add_utf_8 b u; add acc `Await
  | `Boundary -&gt; add (flush_segment acc) `Await
  | `Await -&gt; acc
  in
  let rec uchar acc _ = function
  | `Uchar _ as u -&gt; add acc u
  | `Malformed _ -&gt; add acc (`Uchar Uutf.u_rep)
  in
  List.rev (flush_segment (add (Uutf.String.fold_utf_8 uchar [] s) `End))</code></pre></header></section></div></body></html>