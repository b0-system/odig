<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Gmap (gmap.Gmap)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">gmap</a> &#x00BB; Gmap</nav><h1>Module <code>Gmap</code></h1><p>Heterogenous maps over a GADT.</p><p>The motivation for this library originated in the area of parsing binary network protocols, which often contain options and extensions in the form of tag, length, value encodings: the set of tags and corresponding values is specified in some Internet standard, and later extended by using a global registry. Examples are IP options, TCP options, DNS resource records, TLS hello extensions, X.509v3 extensions, ... These extension mechanisms usually include the invariant that each tag may only be present once.</p><p>A more naive approach is to use a variant type of all known tag-value combinations and storing these in an association list while parsing, but verifying the uniqueness invariant takes quadratic (<code>O(n^2)</code>) time, and retrieving a specific option is only doable in linear <code>O(n)</code> time. Additionally, variant packing/unpacking is required.</p><p>In gmap, <a href="https://en.wikipedia.org/wiki/Generalized_algebraic_data_type">GADTs</a> are used to provide key-dependent value types: each GADT constructor carries their value type. The underlying storage mechanism uses OCaml's stdlib <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Map.html">Map</a> type: Lookup takes <code>O(log n)</code> time. The above mentioned uniqueness invariant can be verified by only using <a href="module-type-S/index.html#val-update"><code>S.update</code></a> or <a href="module-type-S/index.html#val-add_unless_bound"><code>S.add_unless_bound</code></a> (respectively <a href="module-type-S/index.html#val-addb_unless_bound"><code>S.addb_unless_bound</code></a> for insertion).</p><p>A simple example:</p><pre><code class="ml">type _ k =
  | A : int k
  | B : string k

module K = struct
  type 'a t = 'a k

  let compare : type a b. a t -&gt; b t -&gt; (a, b) Gmap.Order.t = fun t t' -&gt;
    let open Gmap.Order in
    match t, t' with
    | A, A -&gt; Eq | A, _ -&gt; Lt | _, A -&gt; Gt
    | B, B -&gt; Eq

  let pp : type a. Format.formatter -&gt; a t -&gt; a -&gt; unit = fun ppf t v -&gt;
    match t, v with
    | A, x -&gt; Fmt.pf ppf &quot;A %d&quot; x
    | B, s -&gt; Fmt.pf ppf &quot;B %s&quot; s
end

module GM = Gmap.Make(K)</code></pre><p>Using <code>GM</code> is done as follows:</p><pre><code class="ml">match GM.find A m with
| Some x -&gt; x * x
| None -&gt; 0</code></pre><p><em>0.2.1 - <a href="https://github.com/hannesm/gmap">homepage</a></em></p></header><dl><dt class="spec module" id="module-Order"><a href="#module-Order" class="anchor"></a><code><span class="keyword">module</span> <a href="Order/index.html">Order</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Ordering.</p></dd></dl><dl><dt class="spec module-type" id="module-type-KEY"><a href="#module-type-KEY" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-KEY/index.html">KEY</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Key.</p></dd></dl><dl><dt class="spec module-type" id="module-type-S"><a href="#module-type-S" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-S/index.html">S</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Output signature of the functor <a href="Make/index.html"><code>Make</code></a></p></dd></dl><dl><dt class="spec module" id="module-Make"><a href="#module-Make" class="anchor"></a><code><span class="keyword">module</span> <a href="Make/index.html">Make</a> : <span class="keyword">functor</span> (<a href="Make/argument-1-Key/index.html">Key</a> : <a href="index.html#module-type-KEY">KEY</a>) <span>&#45;&gt;</span> <a href="index.html#module-type-S">S</a> <span class="keyword">with</span> <span class="keyword">type</span> 'a <a href="Make/index.html#type-key">key</a> = <span class="type-var">'a</span> <a href="Make/argument-1-Key/index.html#type-t">Key.t</a></code></dt><dd><p>Functor for heterogenous maps whose keys are provided by <code>Key</code>.</p></dd></dl></div></body></html>