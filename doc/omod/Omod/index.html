<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Omod (omod.Omod)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../index.html">omod</a> &#x00BB; Omod</nav><header class="odoc-preamble"><h1>Module <code><span>Omod</span></code></h1><p>Load installed modules in the toplevel.</p><p>See the <a href="#tutorial">Tutorial</a>.</p><p><em>v0.0.2 — <a href="http://erratique.ch/software/omod">homepage</a></em></p></header><nav class="odoc-toc"><ul><li><a href="#omod">Omod</a></li><li><a href="#assuming">Assuming loads</a></li><li><a href="#tutorial">Tutorial</a></li><li><a href="#loadsem">Load semantics and effects</a></li></ul></nav><div class="odoc-content"><h2 id="omod"><a href="#omod" class="anchor"></a>Omod</h2><div class="odoc-spec"><div class="spec type" id="type-fpath" class="anchored"><a href="#type-fpath" class="anchor"></a><code><span><span class="keyword">type</span> fpath</span><span> = string</span></code></div><div class="spec-doc"><p>The type for file paths.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-silent" class="anchored"><a href="#type-silent" class="anchor"></a><code><span><span class="keyword">type</span> silent</span><span> = </span><span>[ </span></code><table><tr id="type-silent.Yes" class="anchored"><td class="def constructor"><a href="#type-silent.Yes" class="anchor"></a><code><span>| </span></code><code><span>`Yes</span></code></td></tr><tr id="type-silent.Loads" class="anchored"><td class="def constructor"><a href="#type-silent.Loads" class="anchor"></a><code><span>| </span></code><code><span>`Loads</span></code></td></tr><tr id="type-silent.No" class="anchored"><td class="def constructor"><a href="#type-silent.No" class="anchor"></a><code><span>| </span></code><code><span>`No</span></code></td></tr></table><code><span> ]</span></code></div><div class="spec-doc"><p>The type for specifying silence. See <a href="#val-load"><code>load</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-load" class="anchored"><a href="#val-load" class="anchor"></a><code><span><span class="keyword">val</span> load : <span>?batch:bool <span class="arrow">&#45;&gt;</span></span> <span>?silent:<a href="#type-silent">silent</a> <span class="arrow">&#45;&gt;</span></span> <span>?force:bool <span class="arrow">&#45;&gt;</span></span> <span>?incs:bool <span class="arrow">&#45;&gt;</span></span> <span>?init:bool <span class="arrow">&#45;&gt;</span></span> <span>?dir:<a href="#type-fpath">fpath</a> <span class="arrow">&#45;&gt;</span></span>
<span>string <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>load ~batch ~silent ~force ~deps ~incs ~init ~dir &quot;M&quot;</code> loads module <code>M</code> and returns <code>true</code> if the load was successful; init files may however have failed to load. The exact side effects of this function are described <a href="#loadsem">here</a>. The optional parameters are as follows:</p><ul><li><code>batch</code> if <code>true</code> alternative load sequences error rather than interactively ask to select one. Defaults to <code>not !</code><code>Sys</code>.interactive.</li><li><code>silent</code> if <code>`All</code> nothing is logged except errors. If <code>`Loads</code> then load sequences are not logged but other diagnostic messages may be logged. If <code>`No</code> both load sequences and diagnostic messages are logged. Defaults to <code>`No</code>.</li><li><code>force</code> if <code>true</code> force the reload of objects. Defaults to <code>false</code>.</li><li><code>incs</code> if <code>true</code> directory includes should be added. Defaults to <code>true</code>. See load <a href="#loadsem">semantics</a> for details.</li><li><code>init</code> if <code>true</code> toplevel init files should be loaded, see the load <a href="#loadsem">semantics</a>. Defaults to <code>true</code>.</li><li><code>dir</code> is currently ignored.</li></ul><p>The full syntax for specifying the module to load is:</p><pre>[PKG.]M(@VARIANT)*</pre><ul><li><code>M</code> is always the top level (compilation unit) module name to load.</li><li><code>PKG</code> constrains <code>M</code> to be found in package <code>PKG</code>. Packages names are the name of directories just below omod's library directory (see <code>omod conf</code>, and <code>omod pkg</code> for a list).</li><li><code>@VARIANT</code> (repeatable) indicates that all ambiguities should be resolved according to variant <code>VARIANT</code>. This means that if an object can be found in multiple directories in a package directory <code>P</code>, the one that is rooted in the hierarchy starting at <code>P/VARIANT</code> or <code>P/@VARIANT</code> will be selected. If no ambiguity arises the parameter is ignored. See the <a href="#tutorial">tutorial</a> for an example.</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-loads" class="anchored"><a href="#val-loads" class="anchor"></a><code><span><span class="keyword">val</span> loads : <span>?batch:bool <span class="arrow">&#45;&gt;</span></span> <span>?silent:<a href="#type-silent">silent</a> <span class="arrow">&#45;&gt;</span></span> <span>?force:bool <span class="arrow">&#45;&gt;</span></span> <span>?incs:bool <span class="arrow">&#45;&gt;</span></span> <span>?init:bool <span class="arrow">&#45;&gt;</span></span> <span>?dir:<a href="#type-fpath">fpath</a>
<span class="arrow">&#45;&gt;</span></span> <span><span>string list</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>loads</code> is like <a href="#val-load"><code>load</code></a> but for a list of module specifications. Note that specified variants apply to all of the modules.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-help" class="anchored"><a href="#val-help" class="anchor"></a><code><span><span class="keyword">val</span> help : <span>unit <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>help ()</code> prints basic help on <code>stdout</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-status" class="anchored"><a href="#val-status" class="anchor"></a><code><span><span class="keyword">val</span> status : <span>unit <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>status ()</code> prints what is currently loaded by omod (including assumptions)</p></div></div><h2 id="assuming"><a href="#assuming" class="anchor"></a>Assuming loads</h2><p>This following can be used to assume that certain loads are already performed to prevent them from being (re)loaded by <a href="#val-load"><code>load</code></a> invocations.</p><div class="odoc-spec"><div class="spec value" id="val-assume_load" class="anchored"><a href="#val-assume_load" class="anchor"></a><code><span><span class="keyword">val</span> assume_load : <span>?batch:bool <span class="arrow">&#45;&gt;</span></span> <span>?silent:<a href="#type-silent">silent</a> <span class="arrow">&#45;&gt;</span></span> <span>?force:bool <span class="arrow">&#45;&gt;</span></span> <span>?incs:bool <span class="arrow">&#45;&gt;</span></span> <span>?init:bool <span class="arrow">&#45;&gt;</span></span>
<span>?dir:<a href="#type-fpath">fpath</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>assume_load</code> is like <a href="#val-load"><code>load</code></a> but assumes the corresponding load sequence was already performed.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-assume_loads" class="anchored"><a href="#val-assume_loads" class="anchor"></a><code><span><span class="keyword">val</span> assume_loads : <span>?batch:bool <span class="arrow">&#45;&gt;</span></span> <span>?silent:<a href="#type-silent">silent</a> <span class="arrow">&#45;&gt;</span></span> <span>?force:bool <span class="arrow">&#45;&gt;</span></span> <span>?incs:bool <span class="arrow">&#45;&gt;</span></span> <span>?init:bool
<span class="arrow">&#45;&gt;</span></span> <span>?dir:<a href="#type-fpath">fpath</a> <span class="arrow">&#45;&gt;</span></span> <span><span>string list</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>assume_loads</code> is like <a href="#val-loads"><code>loads</code></a> but assumes the corresponding load sequence was already performed.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-assume_inc" class="anchored"><a href="#val-assume_inc" class="anchor"></a><code><span><span class="keyword">val</span> assume_inc : <span><a href="#type-fpath">fpath</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>assume_inc dir</code> assumes that path <code>dir</code> has been included.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-assume_obj" class="anchored"><a href="#val-assume_obj" class="anchor"></a><code><span><span class="keyword">val</span> assume_obj : <span><a href="#type-fpath">fpath</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>assume_obj obj</code> assumes that file path <code>obj</code> has been loaded.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Private" class="anchored"><a href="#module-Private" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Private/index.html">Private</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Private definitions.</p></div></div><h2 id="tutorial"><a href="#tutorial" class="anchor"></a>Tutorial</h2><p>To use the toplevel helpers simply bring the <code>Omod</code> module in your scope: type or add the following line to your <code>~/.ocamlinit</code> file.</p><pre><code>#use &quot;omod.top&quot;</code></pre><p>If you are using <code>ocamlnat</code> you <a href="https://caml.inria.fr/mantis/view.php?id=7589">unfortunately</a> need to <code>#use</code> another file:</p><pre><code>#use &quot;omod.nattop&quot;</code></pre><p>It is also likely that <code>opam</code>'s initialization bits in <code>.ocamlinit</code> to find the file to <code>#use</code> won't work. So you need to invoke <code>ocamlnat</code> with <code>-noinit</code> and indicate where the file to <code>#use</code> can be found. The following invocation should work:</p><pre><code>rlwrap ocamlnat -I $OCAML_TOPLEVEL_PATH -noinit</code></pre><p>Now whenever you want to use a module named <code>M</code> invoke:</p><pre><code># Omod.load &quot;M&quot;</code></pre><p>This will recursively load its dependencies and toplevel init files. See <a href="#val-load"><code>load</code></a> for more options and details.</p><p>If you are using <code>omod</code> in scripts you should also specify the package <code>PKG</code> where <code>M</code> should be found using the <code>PKG.M</code> syntax. This because a further package install could also install a module <code>M</code> resulting in a load ambiguity and your script no longer working.</p><p>If you run into multiple load sequence resolutions, <code>Omod</code> interactively asks to choose one of the possible sequences. Assuming you have the package <code>ptime</code> installed this is an example:</p><pre><code># Omod.load &quot;Ptime_clock&quot;</code></pre><p>since <code>ptime</code> provides an <code>os</code> clock for your operating system and a <code>jsoo</code> clock for your browser.</p><p>The ambiguity can be automatically resolved by specfiying the variant you want explicitely (see <a href="#val-load"><code>load</code></a> for details) for example to directly request the OS clock you should issue:</p><pre><code># Omod.load &quot;Ptime_clock\@os&quot;</code></pre><p>In a script it would even be better to write:</p><pre><code># Omod.load &quot;ptime.Ptime_clock\@os&quot;</code></pre><p>Finally to list what was loaded by <code>Omod</code> type:</p><pre><code># Omod.status ()</code></pre><p>For information about how <code>Omod</code> locates packages, consult <code>omod conf --help</code>.</p><h2 id="loadsem"><a href="#loadsem" class="anchor"></a>Load semantics and effects</h2><ul><li>Loading an object means: load its dependencies, add its containing directory to the included directories (if <code>incs</code> is <code>true</code>), load the actual object and finally load its toplevel init file (if <code>init</code> is <code>true</code> and the file exists, see below).</li><li>The <em>toplevel init file</em> of an object with basename <code>o</code> is a file called <code>o_top_init.ml</code> in the same directory as the object.</li><li>If an object is available both as a standalone file (<code>cmo</code>, <code>cmx</code>) and in a library archive (<code>cma</code>, <code>cmxs</code>), <code>Omod</code> favours loading the library archive.</li><li>If an interface dependency cannot be resolved to an implementation but does resolve to a compiled interface, the dependency is assumed to be a mli-only compilation unit and the directory of the compiled interface is added to the includes (if <code>incs</code> is true).</li><li><p>The initalization performed by <code>omod.top</code> and <code>omod.nattop</code> <a href="#val-assume_load">assume</a> (with <code>incs:false</code> and <code>init:false</code>) the following modules:</p><ul><li><code>utop.UTop</code> if <code>omod.top</code> is <code>#use</code>d in <code>utop</code>.</li><li><code>ocaml.Toploop</code> if <code>omod.top</code> is <code>#use</code>d (not in <code>utop</code>).</li><li><code>ocaml.Opttoploop</code> if <code>omod.nattop</code> is <code>#use</code>d. .</li></ul></li><li>Load sequences with <code>vmthread</code> variants and objects of the form <code>m.p.ext</code> (profiling versions in the stdlib) are excluded from load sequence results. This reduces the load sequence from multiple occurences to a single candidate on many modules.</li><li>For <code>ocamlnat</code> dependency analysis is made on <code>cmx</code> and <code>cmxa</code> files, the suffixes of resulting objects is then mapped to <code>cmxs</code>. This assumes the corresponding files exist and their objects match.</li></ul></div></body></html>