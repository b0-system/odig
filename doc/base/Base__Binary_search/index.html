<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Base__Binary_search (base.Base__Binary_search)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">base</a> &#x00BB; Base__Binary_search</nav><h1>Module <code>Base__Binary_search</code></h1><p>General functions for performing binary searches over ordered sequences given <code>length</code> and <code>get</code> functions. These functions can be specialized and added to a data structure using the functors supplied in <code>Binary_searchable</code> and described in <code>Binary_searchable_intf</code>.</p><h4 id="examples"><a href="#examples" class="anchor"></a>Examples</h4><p>Below we assume that the function <code>get</code>, <code>length</code> and <code>compare</code> are in scope:</p><pre><code class="ml">(* find the index of an element [e] in [t] *)
binary_search t ~get ~length ~compare `First_equal_to e;

(* find the index where an element [e] should be inserted *)
binary_search t ~get ~length ~compare `First_greater_than_or_equal_to e;

(* find the index in [t] where all elements to the left are less than [e] *)
binary_search_segmented t ~get ~length ~segment_of:(fun e' -&gt;
  if compare e' e &lt;= 0 then `Left else `Right) `First_on_right</code></pre></header><dl><dt class="spec value" id="val-binary_search"><a href="#val-binary_search" class="anchor"></a><code><span class="keyword">val </span>binary_search : ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;len:int <span>&#45;&gt;</span> <span class="type-var">'t</span> <span>&#45;&gt;</span> length:(<span class="type-var">'t</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> get:(<span class="type-var">'t</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'elt</span>) <span>&#45;&gt;</span> compare:(<span class="type-var">'elt</span> <span>&#45;&gt;</span> <span class="type-var">'elt</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> [ `Last_strictly_less_than<span class="keyword"> | </span>`Last_less_than_or_equal_to<span class="keyword"> | </span>`Last_equal_to<span class="keyword"> | </span>`First_equal_to<span class="keyword"> | </span>`First_greater_than_or_equal_to<span class="keyword"> | </span>`First_strictly_greater_than ] <span>&#45;&gt;</span> <span class="type-var">'elt</span> <span>&#45;&gt;</span> int option</code></dt><dd><p><code>binary_search ?pos ?len t ~length ~get ~compare which elt</code> takes <code>t</code> that is sorted in nondecreasing order according to <code>compare</code>, where <code>compare</code> and <code>elt</code> divide <code>t</code> into three (possibly empty) segments:</p><pre>      |  &lt; elt  |  = elt  |  &gt; elt  |</pre><p><code>binary_search</code> returns the index in <code>t</code> of an element on the boundary of segments as specified by <code>which</code>. See the diagram below next to the <code>which</code> variants.</p><p>By default, <code>binary_search</code> searches the entire <code>t</code>. One can supply <code>?pos</code> or <code>?len</code> to search a slice of <code>t</code>.</p><p><code>binary_search</code> does not check that <code>compare</code> orders <code>t</code>, and behavior is unspecified if <code>compare</code> doesn't order <code>t</code>. Behavior is also unspecified if <code>compare</code> mutates <code>t</code>.</p></dd></dl><dl><dt class="spec value" id="val-binary_search_segmented"><a href="#val-binary_search_segmented" class="anchor"></a><code><span class="keyword">val </span>binary_search_segmented : ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;len:int <span>&#45;&gt;</span> <span class="type-var">'t</span> <span>&#45;&gt;</span> length:(<span class="type-var">'t</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> get:(<span class="type-var">'t</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'elt</span>) <span>&#45;&gt;</span> segment_of:(<span class="type-var">'elt</span> <span>&#45;&gt;</span> [ `Left<span class="keyword"> | </span>`Right ]) <span>&#45;&gt;</span> [ `Last_on_left<span class="keyword"> | </span>`First_on_right ] <span>&#45;&gt;</span> int option</code></dt><dd><p><code>binary_search_segmented ?pos ?len t ~length ~get ~segment_of which</code> takes a <code>segment_of</code> function that divides <code>t</code> into two (possibly empty) segments:</p><pre>      | segment_of elt = `Left | segment_of elt = `Right |</pre><p><code>binary_search_segmented</code> returns the index of the element on the boundary of the segments as specified by <code>which</code>: <code>`Last_on_left</code> yields the index of the last element of the left segment, while <code>`First_on_right</code> yields the index of the first element of the right segment. It returns <code>None</code> if the segment is empty.</p><p>By default, <code>binary_search</code> searches the entire <code>t</code>. One can supply <code>?pos</code> or <code>?len</code> to search a slice of <code>t</code>.</p><p><code>binary_search_segmented</code> does not check that <code>segment_of</code> segments <code>t</code> as in the diagram, and behavior is unspecified if <code>segment_of</code> doesn't segment <code>t</code>. Behavior is also unspecified if <code>segment_of</code> mutates <code>t</code>.</p></dd></dl></div></body></html>