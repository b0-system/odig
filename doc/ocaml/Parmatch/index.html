<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Parmatch (ocaml.Parmatch)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">ocaml</a> &#x00BB; Parmatch</nav><header class="odoc-preamble"><h1>Module <code><span>Parmatch</span></code></h1><p>Detection of partial matches and unused match cases.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec value" id="val-const_compare" class="anchored"><a href="#val-const_compare" class="anchor"></a><code><span><span class="keyword">val</span> const_compare : <span><a href="../Asttypes/index.html#type-constant">Asttypes.constant</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Asttypes/index.html#type-constant">Asttypes.constant</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>const_compare c1 c2</code> compares the actual values represented by <code>c1</code> and <code>c2</code>, while simply using <code>Stdlib.compare</code> would compare the representations.</p><p>cf. MPR#5758</p></div></div><div class="odoc-spec"><div class="spec value" id="val-le_pat" class="anchored"><a href="#val-le_pat" class="anchor"></a><code><span><span class="keyword">val</span> le_pat : <span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>le_pat p q</code> means: forall V, V matches q implies V matches p</p></div></div><div class="odoc-spec"><div class="spec value" id="val-le_pats" class="anchored"><a href="#val-le_pats" class="anchor"></a><code><span><span class="keyword">val</span> le_pats : <span><span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> list</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>le_pats (p1 .. pm) (q1 .. qn)</code> means: forall i &lt;= m, <code>le_pat pi qi</code></p></div></div><div class="odoc-spec"><div class="spec module" id="module-Compat" class="anchored"><a href="#module-Compat" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Compat/index.html">Compat</a></span><span> (<a href="Compat/argument-1-_/index.html">_</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Exported compatibility functor, abstracted over constructor equality</p></div></div><div class="odoc-spec"><div class="spec exception" id="exception-Empty" class="anchored"><a href="#exception-Empty" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Empty</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-lub" class="anchored"><a href="#val-lub" class="anchor"></a><code><span><span class="keyword">val</span> lub : <span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a></span></code></div><div class="spec-doc"><p><code>lub p q</code> is a pattern that matches all values matched by <code>p</code> and <code>q</code>. May raise <code>Empty</code>, when <code>p</code> and <code>q</code> are not compatible.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-lubs" class="anchored"><a href="#val-lubs" class="anchor"></a><code><span><span class="keyword">val</span> lubs : <span><span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> list</span></span></code></div><div class="spec-doc"><p><code>lubs [p1; ...; pn] [q1; ...; qk]</code>, where <code>n &lt; k</code>, is <code>[lub p1 q1; ...; lub pk qk]</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_mins" class="anchored"><a href="#val-get_mins" class="anchor"></a><code><span><span class="keyword">val</span> get_mins : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-set_args" class="anchored"><a href="#val-set_args" class="anchor"></a><code><span><span class="keyword">val</span> set_args : <span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> list</span></span></code></div><div class="spec-doc"><p>Those two functions recombine one pattern and its arguments: For instance: (_,_)::p1::p2::rem -&gt; (p1, p2)::rem The second one will replace mutable arguments by '_'</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_args_erase_mutable" class="anchored"><a href="#val-set_args_erase_mutable" class="anchor"></a><code><span><span class="keyword">val</span> set_args_erase_mutable : <span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> list</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-pat_of_constr" class="anchored"><a href="#val-pat_of_constr" class="anchor"></a><code><span><span class="keyword">val</span> pat_of_constr : <span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Types/index.html#type-constructor_description">Types.constructor_description</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-complete_constrs" class="anchored"><a href="#val-complete_constrs" class="anchor"></a><code><span><span class="keyword">val</span> complete_constrs : <span><span><a href="../Types/index.html#type-constructor_description">Types.constructor_description</a> <a href="../Typedtree/index.html#type-pattern_data">Typedtree.pattern_data</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../Types/index.html#type-constructor_tag">Types.constructor_tag</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Types/index.html#type-constructor_description">Types.constructor_description</a> list</span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-pat_explosion" class="anchored"><a href="#type-pat_explosion" class="anchor"></a><code><span><span class="keyword">type</span> pat_explosion</span><span> = </span></code><table><tr id="type-pat_explosion.PE_single" class="anchored"><td class="def variant constructor"><a href="#type-pat_explosion.PE_single" class="anchor"></a><code><span>| </span><span><span class="constructor">PE_single</span></span></code></td></tr><tr id="type-pat_explosion.PE_gadt_cases" class="anchored"><td class="def variant constructor"><a href="#type-pat_explosion.PE_gadt_cases" class="anchor"></a><code><span>| </span><span><span class="constructor">PE_gadt_cases</span></span></code></td></tr></table></div><div class="spec-doc"><p><code>ppat_of_type</code> builds an untyped pattern from its expected type, for explosion of wildcard patterns in Typecore.type_pat.</p><p>There are four interesting cases:</p><ul><li>the type is empty (<code>PT_empty</code>)</li><li>no further explosion is necessary (<code>PT_any</code>)</li><li>a single pattern is generated, from a record or tuple type or a single-variant type (<code>PE_single</code>)</li><li>an or-pattern is generated, in the case that all branches are GADT constructors (<code>PE_gadt_cases</code>).</li></ul></div></div><div class="odoc-spec"><div class="spec type" id="type-ppat_of_type" class="anchored"><a href="#type-ppat_of_type" class="anchor"></a><code><span><span class="keyword">type</span> ppat_of_type</span><span> = </span></code><table><tr id="type-ppat_of_type.PT_empty" class="anchored"><td class="def variant constructor"><a href="#type-ppat_of_type.PT_empty" class="anchor"></a><code><span>| </span><span><span class="constructor">PT_empty</span></span></code></td></tr><tr id="type-ppat_of_type.PT_any" class="anchored"><td class="def variant constructor"><a href="#type-ppat_of_type.PT_any" class="anchor"></a><code><span>| </span><span><span class="constructor">PT_any</span></span></code></td></tr><tr id="type-ppat_of_type.PT_pattern" class="anchored"><td class="def variant constructor"><a href="#type-ppat_of_type.PT_pattern" class="anchor"></a><code><span>| </span><span><span class="constructor">PT_pattern</span> <span class="keyword">of</span> <a href="#type-pat_explosion">pat_explosion</a> * <a href="../Parsetree/index.html#type-pattern">Parsetree.pattern</a> * <span><span>(string,Â <a href="../Types/index.html#type-constructor_description">Types.constructor_description</a>)</span> <a href="../Stdlib/Hashtbl/index.html#type-t">Hashtbl.t</a></span> * <span><span>(string,Â <a href="../Types/index.html#type-label_description">Types.label_description</a>)</span> <a href="../Stdlib/Hashtbl/index.html#type-t">Hashtbl.t</a></span></span></code></td></tr></table></div></div><div class="odoc-spec"><div class="spec value" id="val-ppat_of_type" class="anchored"><a href="#val-ppat_of_type" class="anchor"></a><code><span><span class="keyword">val</span> ppat_of_type : <span><a href="../Env/index.html#type-t">Env.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Types/index.html#type-type_expr">Types.type_expr</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ppat_of_type">ppat_of_type</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-pressure_variants" class="anchored"><a href="#val-pressure_variants" class="anchor"></a><code><span><span class="keyword">val</span> pressure_variants : <span><a href="../Env/index.html#type-t">Env.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> list</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-pressure_variants_in_computation_pattern" class="anchored"><a href="#val-pressure_variants_in_computation_pattern" class="anchor"></a><code><span><span class="keyword">val</span> pressure_variants_in_computation_pattern : <span><a href="../Env/index.html#type-t">Env.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span><a href="../Typedtree/index.html#type-computation">Typedtree.computation</a> <a href="../Typedtree/index.html#type-general_pattern">Typedtree.general_pattern</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-check_partial" class="anchored"><a href="#val-check_partial" class="anchor"></a><code><span><span class="keyword">val</span> check_partial : <span><span>(<span><span><span>(string,Â <a href="../Types/index.html#type-constructor_description">Types.constructor_description</a>)</span> <a href="../Stdlib/Hashtbl/index.html#type-t">Hashtbl.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(string,Â <a href="../Types/index.html#type-label_description">Types.label_description</a>)</span> <a href="../Stdlib/Hashtbl/index.html#type-t">Hashtbl.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Parsetree/index.html#type-pattern">Parsetree.pattern</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Location/index.html#type-t">Location.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span><a href="../Typedtree/index.html#type-value">Typedtree.value</a> <a href="../Typedtree/index.html#type-case">Typedtree.case</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="../Typedtree/index.html#type-partial">Typedtree.partial</a></span></code></div><div class="spec-doc"><p><code>check_partial pred loc caselist</code> and <code>check_unused refute pred caselist</code> are called with a function <code>pred</code> which will be given counter-example candidates: they may be partially ill-typed, and have to be type-checked to extract a valid counter-example. <code>pred</code> returns a valid counter-example or <code>None</code>. <code>refute</code> indicates that <code>check_unused</code> was called on a refutation clause.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-check_unused" class="anchored"><a href="#val-check_unused" class="anchor"></a><code><span><span class="keyword">val</span> check_unused : <span><span>(<span>bool <span class="arrow">&#45;&gt;</span></span> <span><span><span>(string,Â <a href="../Types/index.html#type-constructor_description">Types.constructor_description</a>)</span> <a href="../Stdlib/Hashtbl/index.html#type-t">Hashtbl.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(string,Â <a href="../Types/index.html#type-label_description">Types.label_description</a>)</span> <a href="../Stdlib/Hashtbl/index.html#type-t">Hashtbl.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Parsetree/index.html#type-pattern">Parsetree.pattern</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span><a href="../Typedtree/index.html#type-value">Typedtree.value</a> <a href="../Typedtree/index.html#type-case">Typedtree.case</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-irrefutable" class="anchored"><a href="#val-irrefutable" class="anchor"></a><code><span><span class="keyword">val</span> irrefutable : <span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-inactive" class="anchored"><a href="#val-inactive" class="anchor"></a><code><span><span class="keyword">val</span> inactive : <span>partial:<a href="../Typedtree/index.html#type-partial">Typedtree.partial</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>An inactive pattern is a pattern, matching against which can be duplicated, erased or delayed without change in observable behavior of the program. Patterns containing (lazy _) subpatterns or reads of mutable fields are active.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-check_ambiguous_bindings" class="anchored"><a href="#val-check_ambiguous_bindings" class="anchor"></a><code><span><span class="keyword">val</span> check_ambiguous_bindings : <span><span><span><a href="../Typedtree/index.html#type-value">Typedtree.value</a> <a href="../Typedtree/index.html#type-case">Typedtree.case</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-some_private_tag" class="anchored"><a href="#val-some_private_tag" class="anchor"></a><code><span><span class="keyword">val</span> some_private_tag : <a href="../Asttypes/index.html#type-label">Asttypes.label</a></span></code></div></div></div></body></html>