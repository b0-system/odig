<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>BatSubstring (batteries.BatSubstring)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">batteries</a> &#x00BB; BatSubstring</nav><header class="odoc-preamble"><h1>Module <code><span>BatSubstring</span></code></h1></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div><div class="spec-doc"><p><code>Substring.t</code> is the type of substrings of a basestring, an efficient representation of a piece of a string.</p><p>A substring (s,i,n) is valid if 0 &lt;= i &lt;= i+n &lt;= size s, or equivalently, 0 &lt;= i and 0 &lt;= n and i+n &lt;= size s.</p><p>A valid substring (s, i, n) represents the string s<code>i...i+n-1</code>.</p><p>Invariant in the implementation: Any value of type <code>Substring.t</code> is valid.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-empty" class="anchored"><a href="#val-empty" class="anchor"></a><code><span><span class="keyword">val</span> empty : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-to_string" class="anchored"><a href="#val-to_string" class="anchor"></a><code><span><span class="keyword">val</span> to_string : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>string sus</code> is the string s<code>i..i+n-1</code> represented by sus = (s, i, n).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_string" class="anchored"><a href="#val-of_string" class="anchor"></a><code><span><span class="keyword">val</span> of_string : <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-make" class="anchored"><a href="#val-make" class="anchor"></a><code><span><span class="keyword">val</span> make : <span>int <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-create" class="anchored"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-equal" class="anchored"><a href="#val-equal" class="anchor"></a><code><span><span class="keyword">val</span> equal : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Substring equality</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.1</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-of_input" class="anchored"><a href="#val-of_input" class="anchor"></a><code><span><span class="keyword">val</span> of_input : <span><a href="../BatIO/index.html#type-input">BatIO.input</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-substring" class="anchored"><a href="#val-substring" class="anchor"></a><code><span><span class="keyword">val</span> substring : <span>string <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>substring s o l</code> returns a substring with base-string <code>s</code>, offset <code>o</code> and length <code>l</code>. Arguments are checked for validity</p><p><code>substring s i n</code> creates the substring <code>(s, i, n)</code>, consisting of the substring of s with length n starting at i.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Inavlid_argument</span> <p>if <code>i&lt;0</code> or <code>n&lt;0</code> or <code>i+n &gt; size s</code>. Equivalent to <code>extract s i (Some n)</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-unsafe_substring" class="anchored"><a href="#val-unsafe_substring" class="anchor"></a><code><span><span class="keyword">val</span> unsafe_substring : <span>string <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>unsafe_substring</code> behaves like <code>substring</code>, but does not perform any sanity check on the position and length.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-extract" class="anchored"><a href="#val-extract" class="anchor"></a><code><span><span class="keyword">val</span> extract : <span>string <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><span>int option</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>extract s i None</code> creates the substring (s, i, size s-i) consisting of the tail of s starting at i.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if <code>i&lt;0</code> or <code>i &gt; size s</code>.</p><p><code>extract s i (Some n)</code> creates the substring (s, i, n), consisting of the substring of s with length n starting at i.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if <code>i&lt;0</code> or <code>n&lt;0</code> or <code>i+n &gt; size s</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-all" class="anchored"><a href="#val-all" class="anchor"></a><code><span><span class="keyword">val</span> all : <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>all s</code> is the substring <code>(s, 0, size s)</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-base" class="anchored"><a href="#val-base" class="anchor"></a><code><span><span class="keyword">val</span> base : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> string * int * int</span></code></div><div class="spec-doc"><p><code>base sus</code> is the concrete triple <code>(s, i, n)</code>, where <code>psus = (s, i,
    n)</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_empty" class="anchored"><a href="#val-is_empty" class="anchor"></a><code><span><span class="keyword">val</span> is_empty : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_empty (s, i, n)</code> true if the substring is empty (that is, <code>n = 0</code>).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-getc" class="anchored"><a href="#val-getc" class="anchor"></a><code><span><span class="keyword">val</span> getc : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(char * <a href="#type-t">t</a>)</span> option</span></span></code></div><div class="spec-doc"><p><code>getc sus</code> returns <code>Some(c, rst)</code> where <code>c</code> is the first character and <code>rst</code> the remainder of <code>sus</code>, if <code>sus</code> is non-empty; otherwise returns <code>None</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-first" class="anchored"><a href="#val-first" class="anchor"></a><code><span><span class="keyword">val</span> first : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>char option</span></span></code></div><div class="spec-doc"><p><code>first sus</code> returns <code>Some c</code> where <code>c</code> is the first character in <code>sus</code>, if <code>sus</code> is non-empty; otherwise returns <code>None</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-triml" class="anchored"><a href="#val-triml" class="anchor"></a><code><span><span class="keyword">val</span> triml : <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>triml k sus</code> returns sus less its leftmost k characters; or the empty string at the end of sus if it has less than k characters.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if <code>k &lt; 0</code>, even in the partial application <code>triml k</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-trimr" class="anchored"><a href="#val-trimr" class="anchor"></a><code><span><span class="keyword">val</span> trimr : <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>trimr k sus</code> returns sus less its rightmost k characters; or the empty string at the beginning of sus if it has less than k characters. </p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if <code>k &lt; 0</code>, even in the partial application <code>trimr k</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-get" class="anchored"><a href="#val-get" class="anchor"></a><code><span><span class="keyword">val</span> get : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> char</span></code></div><div class="spec-doc"><p><code>get sus k</code> returns the k'th character of the substring; that is, s(i+k) where sus = (s, i, n). </p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if <code>k&lt;0</code> or <code>k&gt;=n</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-size" class="anchored"><a href="#val-size" class="anchor"></a><code><span><span class="keyword">val</span> size : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>size (s, i, n)</code> returns the size of the substring, that is, <code>n</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-length" class="anchored"><a href="#val-length" class="anchor"></a><code><span><span class="keyword">val</span> length : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Equivalent to <a href="#val-size"><code>size</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-slice" class="anchored"><a href="#val-slice" class="anchor"></a><code><span><span class="keyword">val</span> slice : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><span>int option</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>slice sus i' None</code> returns the substring <code>(s, i+i', n-i')</code>, where <code>sus = (s, i, n)</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if <code>i' &lt; 0</code> or <code>i' &gt; n</code>.</p><p><code>slice sus i' (Some n')</code> returns the substring <code>(s, i+i', n')</code>, where <code>sus</code> = <code>(s, i, n)</code>. </p><p>@raise Invalid_argument</p><p>if <code>i' &lt; 0</code> or <code>n' &lt; 0</code> or <code>i'+n' &gt;= n</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-concat" class="anchored"><a href="#val-concat" class="anchor"></a><code><span><span class="keyword">val</span> concat : <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>concat suss</code> returns a string consisting of the concatenation of the substrings. Equivalent to <code>String.concat (List.map to_string
    suss)</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-explode" class="anchored"><a href="#val-explode" class="anchor"></a><code><span><span class="keyword">val</span> explode : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>char list</span></span></code></div><div class="spec-doc"><p><code>explode sus</code> returns the list of characters of sus, that is, <code>s(i), s(i+1), ..., s(i+n-1)</code> where <code>sus = (s, i, n)</code>. Equivalent to <code>String.explode (to_string ss)</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_prefix" class="anchored"><a href="#val-is_prefix" class="anchor"></a><code><span><span class="keyword">val</span> is_prefix : <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_prefix s1 s2</code> is true if <code>s1</code> is a prefix of <code>s2</code>. That is, if there exists a string <code>t</code> such that string <code>s1 ^ t = to_string s2</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-compare" class="anchored"><a href="#val-compare" class="anchor"></a><code><span><span class="keyword">val</span> compare : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>compare sus1 sus2</code> performs lexicographic comparison, using the standard ordering Char.compare on the characters.p Equivalent to, but more efficient than, <code>String.compare (to_string sus1)
    (to_string sus2)</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-index" class="anchored"><a href="#val-index" class="anchor"></a><code><span><span class="keyword">val</span> index : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>index sus c</code> returns the index of the first occurrence of <code>c</code> in <code>sus</code> or</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Not_found</span> <p>otherwise.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-index_from" class="anchored"><a href="#val-index_from" class="anchor"></a><code><span><span class="keyword">val</span> index_from : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>index_from sus i c</code> returns the index of the first occurrence of <code>c</code> in <code>sus</code> after the index <code>i</code> or </p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Not_found</span> <p>otherwise. If <code>i</code> is beyond the range of <code>sus</code>, </p><p>@raise Invalid_argument.</p><p>It is equivalent to <code>i + index (triml i sus) c</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-rindex" class="anchored"><a href="#val-rindex" class="anchor"></a><code><span><span class="keyword">val</span> rindex : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>rindex sus c</code> returns the index of the last occurrence of <code>c</code> in <code>sus</code> or</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Not_found</span> <p>otherwise.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-rindex_from" class="anchored"><a href="#val-rindex_from" class="anchor"></a><code><span><span class="keyword">val</span> rindex_from : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>index_from sus i c</code> returns the index of the last occurrence of <code>c</code> in <code>sus</code> before the index <code>i</code> or </p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Not_found</span> <p>otherwise. If <code>i</code> is beyond the range of <code>sus</code>, </p><p>@raise Invalid_argument.</p><p>It is equivalent to <code>rindex (trimr i sus) c</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-contains" class="anchored"><a href="#val-contains" class="anchor"></a><code><span><span class="keyword">val</span> contains : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>contains s c</code> tests if character <code>c</code> appears in the substring <code>s</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.1</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-dropl" class="anchored"><a href="#val-dropl" class="anchor"></a><code><span><span class="keyword">val</span> dropl : <span><span>(<span>char <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>dropl p sus</code> drops the longest prefix (left substring) of <code>sus</code> all of whose characters satisfy predicate <code>p</code>. If all characters do, it returns the empty substring <code>(s, i+n, 0)</code> where <code>sus = (s, i, n)</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-dropr" class="anchored"><a href="#val-dropr" class="anchor"></a><code><span><span class="keyword">val</span> dropr : <span><span>(<span>char <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>dropr p sus</code> drops the longest suffix (right substring) of sus all of whose characters satisfy predicate <code>p</code>. If all characters do, it returns the empty substring <code>(s, i, 0)</code> where <code>sus = (s, i, n)</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-takel" class="anchored"><a href="#val-takel" class="anchor"></a><code><span><span class="keyword">val</span> takel : <span><span>(<span>char <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>takel p sus</code> returns the longest prefix (left substring) of <code>sus</code> all of whose characters satisfy predicate <code>p</code>. That is, if the left-most character does not satisfy p, returns the empty <code>(s, i, 0)</code> where <code>sus = (s, i, n)</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-taker" class="anchored"><a href="#val-taker" class="anchor"></a><code><span><span class="keyword">val</span> taker : <span><span>(<span>char <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>taker p sus</code> returns the longest suffix (right substring) of <code>sus</code> all of whose characters satisfy predicate <code>p</code>. That is, if the right-most character satisfies <code>p</code>, returns the empty <code>(s, i+n, 0)</code> where <code>sus = (s, i, n)</code>.</p><p>Let <code>p</code> be a predicate and xxxxfyyyyfzzzz a string where all characters in xxxx and zzzz satisfy <code>p</code>, and f a character not satisfying <code>p</code>. Then</p><p>sus = xxxxfyyyyfzzzz sus = xxxxzzzz ------------------------------------------------------ dropl p sus = fyyyyfzzzz dropr p sus = xxxxfyyyyf takel p sus = xxxx xxxxzzzz taker p sus = zzzz xxxxzzzz</p><p>It also holds that <code>concat (takel p sus) (dropl p sus) = string sus</code> <code>concat (dropr p sus) (taker p sus) = string sus</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-splitl" class="anchored"><a href="#val-splitl" class="anchor"></a><code><span><span class="keyword">val</span> splitl : <span><span>(<span>char <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a> * <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>splitl p sus</code> splits <code>sus</code> into a pair <code>(sus1, sus2)</code> of substrings where <code>sus1</code> is the longest prefix (left substring) all of whose characters satisfy <code>p</code>, and <code>sus2</code> is the rest. That is, <code>sus2</code> begins with the leftmost character not satisfying <code>p</code>. Disregarding sideeffects, we have: <code>splitl p sus = (takel p sus,
    dropl p sus)</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-splitr" class="anchored"><a href="#val-splitr" class="anchor"></a><code><span><span class="keyword">val</span> splitr : <span><span>(<span>char <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a> * <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>splitr p sus</code> splits <code>sus</code> into a pair <code>(sus1, sus2)</code> of substrings where <code>sus2</code> is the longest suffix (right substring) all of whose characters satisfy <code>p</code>, and <code>sus1</code> is the rest. That is, <code>sus1</code> ends with the rightmost character not satisfying <code>p</code>. Disregarding sideeffects, we have: <code>splitr p sus = (dropr p sus,
    taker p sus)</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-split_at" class="anchored"><a href="#val-split_at" class="anchor"></a><code><span><span class="keyword">val</span> split_at : <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a> * <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>split_at sus k</code> returns the pair <code>(sus1, sus2)</code> of substrings, where <code>sus1</code> contains the first <code>k</code> characters of <code>sus</code>, and <code>sus2</code> contains the rest. </p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if <code>k &lt; 0</code> or <code>k &gt; size sus</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-span" class="anchored"><a href="#val-span" class="anchor"></a><code><span><span class="keyword">val</span> span : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>span sus1 sus2</code> returns a substring spanning from the start of <code>sus1</code> to the end of <code>sus2</code>, provided this is well-defined: <code>sus1</code> and <code>sus2</code> must have the same underlying string, and the start of <code>sus1</code> must not be to the right of the end of <code>sus2</code>; otherwise</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument.</span> <p>More precisely, if <code>base sus1 = (s,i,n)</code> and <code>base sus2 =
    (s',i',n')</code> and <code>s = s'</code> and <code>i &lt;= i'+n'</code>, then <code>base (span sus1
    sus2) = (s, i, i'+n'-i)</code>. This may be used to compute <code>span</code>, <code>union</code>, and <code>intersection</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-translate" class="anchored"><a href="#val-translate" class="anchor"></a><code><span><span class="keyword">val</span> translate : <span><span>(<span>char <span class="arrow">&#45;&gt;</span></span> char)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>translate f sus</code> applies <code>f</code> to every character of <code>sus</code>, from left to right, and returns the concatenation of the results. Equivalent to <code>String.of_list (List.map f (explode sus))</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-tokens" class="anchored"><a href="#val-tokens" class="anchor"></a><code><span><span class="keyword">val</span> tokens : <span><span>(<span>char <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> list</span></span></code></div><div class="spec-doc"><p><code>tokens p sus</code> returns the list of tokens in <code>sus</code>, from left to right, where a token is a non-empty maximal substring of <code>sus</code> not containing any delimiter, and a delimiter is a character satisfying <code>p</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fields" class="anchored"><a href="#val-fields" class="anchor"></a><code><span><span class="keyword">val</span> fields : <span><span>(<span>char <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> list</span></span></code></div><div class="spec-doc"><p><code>fields p sus</code> returns the list of fields in <code>sus</code>, from left to right, where a field is a (possibly empty) maximal substring of <code>sus</code> not containing any delimiter, and a delimiter is a character satisfying <code>p</code>.</p><p>Two tokens may be separated by more than one delimiter, whereas two fields are separated by exactly one delimiter. If the only delimiter is the character <code>'|'</code>, then &quot;abc||def&quot; contains two tokens: &quot;abc&quot; and &quot;def&quot; &quot;abc||def&quot; contains three fields: &quot;abc&quot; and &quot;&quot; and &quot;def&quot;</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_left" class="anchored"><a href="#val-fold_left" class="anchor"></a><code><span><span class="keyword">val</span> fold_left : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>fold_left f e sus</code> folds <code>f</code> over <code>sus</code> from left to right. That is, evaluates <code>f s.[i+n-1] (f ... (f s.[i+1] (f s.[i] e)) ...)</code> tail-recursively, where <code>sus = (s, i, n)</code>. Equivalent to <code>List.fold_left f e (explode sus)</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_lefti" class="anchored"><a href="#val-fold_lefti" class="anchor"></a><code><span><span class="keyword">val</span> fold_lefti : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>As <code>fold_left</code>, but with the index of the element as additional argument</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.3.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_right" class="anchored"><a href="#val-fold_right" class="anchor"></a><code><span><span class="keyword">val</span> fold_right : <span><span>(<span>char <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>fold_right f e sus</code> folds <code>f</code> over <code>sus</code> from right to left. That is, evaluates <code>f s.[i] (f s.[i+1] (f ... (f s.[i+n-1] e) ...))</code> tail-recursively, where <code>sus = (s, i, n)</code>. Equivalent to <code>List.fold_right f e (explode sus)</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_righti" class="anchored"><a href="#val-fold_righti" class="anchor"></a><code><span><span class="keyword">val</span> fold_righti : <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>As <code>fold_right</code>, but with the index of the element as additional argument</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.3.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-iter" class="anchored"><a href="#val-iter" class="anchor"></a><code><span><span class="keyword">val</span> iter : <span><span>(<span>char <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>iter f sus</code> applies <code>f</code> to all characters of <code>sus</code>, from left to right. Equivalent to <code>List.iter f (explode sus)</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-iteri" class="anchored"><a href="#val-iteri" class="anchor"></a><code><span><span class="keyword">val</span> iteri : <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Same as <a href="#val-iter"><code>iter</code></a>, but the function is applied to the index of the element as first argument (counting from 0), and the character itself as second argument.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.1</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-trim" class="anchored"><a href="#val-trim" class="anchor"></a><code><span><span class="keyword">val</span> trim : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>removes whitespace from left and right ends of input</p></div></div><div class="odoc-spec"><div class="spec value" id="val-split_on_char" class="anchored"><a href="#val-split_on_char" class="anchor"></a><code><span><span class="keyword">val</span> split_on_char : <span>char <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> list</span></span></code></div><div class="spec-doc"><p><code>split_on_char c ss</code> returns substrings of input <code>ss</code> as divided by <code>c</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-split_on_pipe" class="anchored"><a href="#val-split_on_pipe" class="anchor"></a><code><span><span class="keyword">val</span> split_on_pipe : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> list</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-split_on_dot" class="anchored"><a href="#val-split_on_dot" class="anchor"></a><code><span><span class="keyword">val</span> split_on_dot : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> list</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-split_on_comma" class="anchored"><a href="#val-split_on_comma" class="anchor"></a><code><span><span class="keyword">val</span> split_on_comma : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> list</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-split_on_slash" class="anchored"><a href="#val-split_on_slash" class="anchor"></a><code><span><span class="keyword">val</span> split_on_slash : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> list</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-enum" class="anchored"><a href="#val-enum" class="anchor"></a><code><span><span class="keyword">val</span> enum : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>char <a href="../BatEnum/index.html#type-t">BatEnum.t</a></span></span></code></div><div class="spec-doc"><p><code>enum ss</code> returns an enumeration of the characters represented by ss. It does no copying so beweare of mutating the original string.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.1</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-print" class="anchored"><a href="#val-print" class="anchor"></a><code><span><span class="keyword">val</span> print : <span><span><span class="type-var">'a</span> <a href="../BatIO/index.html#type-output">BatIO.output</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>print oc ss</code> prints <code>ss</code> to the output channel <code>oc</code></p></div></div></div></body></html>