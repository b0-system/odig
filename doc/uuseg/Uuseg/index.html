<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Uuseg (uuseg.Uuseg)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">uuseg</a> &#x00BB; Uuseg</nav><header class="odoc-preamble"><h1>Module <code><span>Uuseg</span></code></h1><p>Unicode text segmentation.</p><p><code>Uuseg</code> segments Unicode text. It implements the locale independent Unicode text segmentation algorithms to detect grapheme cluster, word and sentence boundaries and the Unicode line breaking algorithm to detect line break opportunities.</p><p>The module is independent from any IO mechanism or Unicode text data structure and it can process text without a complete in-memory representation.</p><p>The supported Unicode version is determined by the <a href="#val-unicode_version"><code>unicode_version</code></a> value.</p><p>Consult the <a href="#basics">basics</a>, <a href="#limits">limitations</a> and <a href="#examples">examples</a> of use.</p><p><em>Unicode version 13.0.0</em></p></header><nav class="odoc-toc"><ul><li><a href="#references">References</a></li><li><a href="#segment">Segment</a></li><li><a href="#custom-segmenters">Custom segmenters</a></li><li><a href="#limits">Limitations</a></li><li><a href="#basics">Basics</a></li><li><a href="#examples">Examples</a></li></ul></nav><div class="odoc-content"><h4 id="references"><a href="#references" class="anchor"></a>References</h4><ul><li>The Unicode Consortium. <em><a href="http://www.unicode.org/versions/latest">The Unicode Standard</a></em>. (latest version)</li><li>Mark Davis. <em><a href="http://www.unicode.org/reports/tr29/">UAX #29 Unicode Text Segmentation</a></em>. (latest version)</li><li>Andy Heninger. <em><a href="http://www.unicode.org/reports/tr14/">UAX #14 Unicode Line Breaking Algorithm</a></em>. (latest version)</li><li>Web based <a href="http://unicode.org/cldr/utility/breaks.jsp">ICU break utility</a>.</li></ul><h2 id="segment"><a href="#segment" class="anchor"></a>Segment</h2><div class="odoc-spec"><div class="spec value" id="val-unicode_version" class="anchored"><a href="#val-unicode_version" class="anchor"></a><code><span><span class="keyword">val</span> unicode_version : string</span></code></div><div class="spec-doc"><p><code>unicode_version</code> is the Unicode version supported by <code>Uuseg</code>.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-custom" class="anchored"><a href="#type-custom" class="anchor"></a><code><span><span class="keyword">type</span> custom</span></code></div><div class="spec-doc"><p>The type for custom segmenters. See <a href="#val-custom"><code>custom</code></a>.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-boundary" class="anchored"><a href="#type-boundary" class="anchor"></a><code><span><span class="keyword">type</span> boundary</span><span> = </span><span>[ </span></code><table><tr id="type-boundary.Grapheme_cluster" class="anchored"><td class="def constructor"><a href="#type-boundary.Grapheme_cluster" class="anchor"></a><code><span>| </span></code><code><span>`Grapheme_cluster</span></code></td></tr><tr id="type-boundary.Word" class="anchored"><td class="def constructor"><a href="#type-boundary.Word" class="anchor"></a><code><span>| </span></code><code><span>`Word</span></code></td></tr><tr id="type-boundary.Sentence" class="anchored"><td class="def constructor"><a href="#type-boundary.Sentence" class="anchor"></a><code><span>| </span></code><code><span>`Sentence</span></code></td></tr><tr id="type-boundary.Line_break" class="anchored"><td class="def constructor"><a href="#type-boundary.Line_break" class="anchor"></a><code><span>| </span></code><code><span>`Line_break</span></code></td></tr><tr id="type-boundary.Custom" class="anchored"><td class="def constructor"><a href="#type-boundary.Custom" class="anchor"></a><code><span>| </span></code><code><span>`Custom <span class="keyword">of</span> <a href="#type-custom">custom</a></span></code></td></tr></table><code><span> ]</span></code></div><div class="spec-doc"><p>The type for boundaries.</p><ul><li><code>`Grapheme_cluster</code> determines <a href="http://www.unicode.org/glossary/#extended_grapheme_cluster">extended grapheme clusters</a> boundaries according to UAX 29 (corresponds, for most scripts, to user-perceived characters).</li><li><code>`Word</code> determines word boundaries according to UAX 29.</li><li><code>`Sentence</code> determines sentence boundaries according to UAX 29.</li><li><code>`Line_break</code> determines <a href="#val-mandatory">mandatory</a> line breaks and line break opportunities according to UAX 14.</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_boundary" class="anchored"><a href="#val-pp_boundary" class="anchor"></a><code><span><span class="keyword">val</span> pp_boundary : <span><a href="../../ocaml/Stdlib/Format/index.html#type-formatter">Format.formatter</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-boundary">boundary</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>pp_boundary ppf b</code> prints an unspecified representation of <code>b</code> on <code>ppf</code>.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div><div class="spec-doc"><p>The type for Unicode text segmenters.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-ret" class="anchored"><a href="#type-ret" class="anchor"></a><code><span><span class="keyword">type</span> ret</span><span> = </span><span>[ </span></code><table><tr id="type-ret.Boundary" class="anchored"><td class="def constructor"><a href="#type-ret.Boundary" class="anchor"></a><code><span>| </span></code><code><span>`Boundary</span></code></td></tr><tr id="type-ret.Uchar" class="anchored"><td class="def constructor"><a href="#type-ret.Uchar" class="anchor"></a><code><span>| </span></code><code><span>`Uchar <span class="keyword">of</span> <a href="../../ocaml/Stdlib/Uchar/index.html#type-t">Uchar.t</a></span></code></td></tr><tr id="type-ret.Await" class="anchored"><td class="def constructor"><a href="#type-ret.Await" class="anchor"></a><code><span>| </span></code><code><span>`Await</span></code></td></tr><tr id="type-ret.End" class="anchored"><td class="def constructor"><a href="#type-ret.End" class="anchor"></a><code><span>| </span></code><code><span>`End</span></code></td></tr></table><code><span> ]</span></code></div><div class="spec-doc"><p>The type for segmenter results. See <a href="#val-add"><code>add</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-create" class="anchored"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : <span><span>[&lt; <a href="#type-boundary">boundary</a> ]</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>create b</code> is an Unicode text segmenter for boundaries of type <code>b</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-boundary" class="anchored"><a href="#val-boundary" class="anchor"></a><code><span><span class="keyword">val</span> boundary : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-boundary">boundary</a></span></code></div><div class="spec-doc"><p><code>boundary s</code> is the type of boundaries detected by <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-add" class="anchored"><a href="#val-add" class="anchor"></a><code><span><span class="keyword">val</span> add : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>[ <span>`Uchar of <a href="../../ocaml/Stdlib/Uchar/index.html#type-t">Uchar.t</a></span> <span>| `Await</span> <span>| `End</span> ]</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a></span></code></div><div class="spec-doc"><p><code>add s v</code> is:</p><ul><li><code>`Boundary</code> if there is a boundary at that point in the sequence of characters. The client must then call <code>add</code> with <code>`Await</code> until <code>`Await</code> is returned.</li><li><code>`Uchar u</code> if <code>u</code> is the next character in the sequence. The client must then call <code>add</code> with <code>`Await</code> until <code>`Await</code> is returned.</li><li><code>`Await</code> when the segmenter is ready to add a new <code>`Uchar</code> or <code>`End</code>.</li><li><code>`End</code> when <code>`End</code> was added and all <code>`Boundary</code> and <code>`Uchar</code> were output.</li></ul><p>For <code>v</code> use <code>`Uchar u</code> to add a new character to the sequence to segment and <code>`End</code> to signal the end of sequence. After adding one of these two values always call <code>add</code> with <code>`Await</code> until <code>`Await</code> or <code>`End</code> is returned.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if <code>`Uchar</code> or <code>`End</code> is added while that last add did not return <code>`Await</code> or if an <code>`Uchar</code> or <code>`End</code> is added after an <code>`End</code> was already added.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-mandatory" class="anchored"><a href="#val-mandatory" class="anchor"></a><code><span><span class="keyword">val</span> mandatory : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>mandatory s</code> is <code>true</code> if the last <code>`Boundary</code> returned by <a href="#val-add"><code>add</code></a> was mandatory. This function only makes sense for <code>`Line_break</code> segmenters or <code>`Custom</code> segmenters that sport that notion. For other segmenters or if no <code>`Boundary</code> was returned so far, <code>true</code> is returned.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-copy" class="anchored"><a href="#val-copy" class="anchor"></a><code><span><span class="keyword">val</span> copy : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>copy s</code> is a copy of <code>s</code> in its current state. Subsequent <a href="#val-add"><code>add</code></a>s on <code>s</code> do not affect the copy.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_ret" class="anchored"><a href="#val-pp_ret" class="anchor"></a><code><span><span class="keyword">val</span> pp_ret : <span><a href="../../ocaml/Stdlib/Format/index.html#type-formatter">Format.formatter</a> <span class="arrow">&#45;&gt;</span></span> <span><span>[&lt; <a href="#type-ret">ret</a> ]</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>pp_ret ppf v</code> prints an unspecified representation of <code>v</code> on <code>ppf</code>.</p></div></div><h2 id="custom-segmenters"><a href="#custom-segmenters" class="anchor"></a>Custom segmenters</h2><div class="odoc-spec"><div class="spec value" id="val-custom" class="anchored"><a href="#val-custom" class="anchor"></a><code><span><span class="keyword">val</span> custom : <span>?mandatory:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span>name:string <span class="arrow">&#45;&gt;</span></span> <span>create:<span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
<span>copy:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>add:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>[ <span>`Uchar of <a href="../../ocaml/Stdlib/Uchar/index.html#type-t">Uchar.t</a></span> <span>| `Await</span> <span>| `End</span> ]</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ret">ret</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-custom">custom</a></span></code></div><div class="spec-doc"><p><code>create ~mandatory ~name ~create ~copy ~add</code> is a custom segmenter.</p><ul><li><code>name</code> is a name to identify the segmenter.</li><li><code>create</code> is called when the segmenter is <a href="#val-create">created</a> it should return a custom segmenter value.</li><li><code>copy</code> is called with the segmenter value whenever the segmenter is <a href="#val-copy">copied</a>. It should return a copy of the segmenter value.</li><li><code>mandatory</code> is called with the segmenter value to define the result of the <a href="#val-mandatory"><code>mandatory</code></a> function. Defaults always returns <code>true</code>.</li><li><code>add</code> is called with the segmenter value to define the result of the <a href="#val-add"><code>add</code></a> value. The returned value should respect the semantics of <a href="#val-add"><code>add</code></a>. Use the functions <a href="#val-err_exp_await"><code>err_exp_await</code></a> and <a href="#val-err_ended"><code>err_ended</code></a> to raise <code>Invalid_argument</code> exception in <a href="#val-add"><code>add</code></a>s error cases.</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-err_exp_await" class="anchored"><a href="#val-err_exp_await" class="anchor"></a><code><span><span class="keyword">val</span> err_exp_await : <span><span>[&lt; <a href="#type-ret">ret</a> ]</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>err_exp_await fnd</code> should be used by custom segmenters when the client tries to <a href="#val-add"><code>add</code></a> an <code>`Uchar</code> or <code>`End</code> while the last returned value was not an <code>`Await</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-err_ended" class="anchored"><a href="#val-err_ended" class="anchor"></a><code><span><span class="keyword">val</span> err_ended : <span><span>[&lt; <a href="#type-ret">ret</a> ]</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>err_ended ()</code> should be used by custom segmenter when the client tries to <a href="#val-add"><code>add</code></a> <code>`Uchar</code> or <code>`End</code> after <code>`End</code> was already added.</p></div></div><h2 id="limits"><a href="#limits" class="anchor"></a>Limitations</h2><p>A <code>`Grapheme_cluster</code> segmenter will always consume only a small bounded amount of memory on any text. Other segmenters will also do so on non-degenerate text, but it's possible to feed them with input that will make them buffer an arbitrary amount of characters.</p><h2 id="basics"><a href="#basics" class="anchor"></a>Basics</h2><p>A segmenter is a stateful filter that inputs a sequence of characters and outputs the same sequence except characters are interleaved with <code>`Boundary</code> values whenever the segmenter detects a boundary.</p><p>The function <a href="#val-create"><code>create</code></a> returns a new segmenter for a given boundary type:</p><pre><code>let words = Uuseg.create `Word</code></pre><p>To add characters to the sequence to segment, call <a href="#val-add"><code>add</code></a> on <code>words</code> with <code>`Uchar _</code>. To end the sequence call <a href="#val-add"><code>add</code></a> on <code>words</code> with <code>`End</code>. The segmented sequence of characters is returned character by character, interleaved with <code>`Boundary</code> values at the appropriate places, by the successive calls to <a href="#val-add"><code>add</code></a>.</p><p>The client and the segmenter must wait on each other to limit internal buffering: each time the client adds to the sequence by calling <a href="#val-add"><code>add</code></a> with <code>`Uchar</code> or <code>`End</code> it must continue to call <a href="#val-add"><code>add</code></a> with <code>`Await</code> until the segmenter returns <code>`Await</code> or <code>`End</code>. In practice this leads to the following kind of control flow:</p><pre><code>let rec add acc v = match Uuseg.add words v with
| `Uchar u -&gt; add (`Uchar u :: acc) `Await
| `Boundary -&gt; add (`B :: acc) `Await
| `Await | `End -&gt; acc</code></pre><p>For example to segment the sequence &lt;<code>U+0041</code>, <code>U+0020</code>, <code>U+0042</code>&gt; (<code>&quot;a b&quot;</code>) to a list of characters interleaved with <code>`B</code> values on word boundaries we can write:</p><pre><code>let uchar = `Uchar (Uchar.of_int u)
let seq = [uchar 0x0041; uchar 0x0020; uchar 0x0042]
let seq_words = List.rev (add (List.fold_left add [] seq) `End)</code></pre><h2 id="examples"><a href="#examples" class="anchor"></a>Examples</h2><p><code>utf_8_segments seg s</code> is the list of UTF-8 encoded <code>seg</code> segments of the UTF-8 encoded string <code>s</code>. This example uses <code>Uutf</code> to fold over the characters of <code>s</code> and to encode the characters in a standard OCaml buffer. Note that this function can be derived directly from <a href="../Uuseg_string/index.html#val-fold_utf_8"><code>Uuseg_string.fold_utf_8</code></a>.</p><pre><code>let utf_8_segments seg s =
  let b = Buffer.create 42 in
  let flush_segment acc =
    let segment = Buffer.contents b in
    Buffer.clear b; if segment = &quot;&quot; then acc else segment :: acc
  in
  let seg = Uuseg.create (seg :&gt; Uuseg.boundary) in
  let rec add acc v = match Uuseg.add seg v with
  | `Uchar u -&gt; Uutf.Buffer.add_utf_8 b u; add acc `Await
  | `Boundary -&gt; add (flush_segment acc) `Await
  | `Await -&gt; acc
  in
  let rec uchar acc _ = function
  | `Uchar _ as u -&gt; add acc u
  | `Malformed _ -&gt; add acc (`Uchar Uutf.u_rep)
  in
  List.rev (flush_segment (add (Uutf.String.fold_utf_8 uchar [] s) `End))</code></pre></div></body></html>