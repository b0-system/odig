<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>CFStream__CFStream_stream (cfstream.CFStream__CFStream_stream)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">cfstream</a> &#x00BB; CFStream__CFStream_stream</nav><h1>Module <code>CFStream__CFStream_stream</code></h1><nav class="toc"><ul><li><a href="#constructors">Constructors</a></li><li><a href="#iterators">Iterators</a></li><li><a href="#scanners">Scanners</a></li><li><a href="#converters">Converters</a></li><li><a href="#data-interchange">Data Interchange</a></li><li><a href="#result.t's">Result.t's</a></li></ul></nav></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> 'a t</code><code> = <span class="type-var">'a</span> <a href="../../ocaml/Stdlib/Stream/index.html#type-t">Stdlib.Stream.t</a></code></dt><dd><p>Type of streams holding values of type <code>'a</code>.</p></dd></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../CFStream__/CFStream_streamable/index.html#module-type-S">CFStream__.CFStream_streamable.S</a> <span class="keyword">with</span> <span class="keyword">type</span> 'a <a href="../CFStream__/CFStream_streamable/module-type-S/index.html#type-t">t</a> := <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> 'a t</code></dt><dd><p>Type of the datastructure.</p></dd></dl><dl><dt class="spec value" id="val-to_stream"><a href="#val-to_stream" class="anchor"></a><code><span class="keyword">val</span> to_stream : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../ocaml/Stdlib/Stream/index.html#type-t">Stdlib.Stream.t</a></code></dt><dd><p>Return a stream containing all elements of given data structure. Exact semantics depend on implementation. For example, elements in stream may or may not be ordered.</p></dd></dl><dl><dt class="spec value" id="val-of_stream"><a href="#val-of_stream" class="anchor"></a><code><span class="keyword">val</span> of_stream : <span class="type-var">'a</span> <a href="../../ocaml/Stdlib/Stream/index.html#type-t">Stdlib.Stream.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Return a data structure containing all elements in given stream, fully consuming the stream. Exact semantics depend on implementation. For example, duplicate elements in input may be ignored if the data structure is a set.</p></dd></dl></details></div></div></div><dl><dt class="spec exception" id="exception-Failure"><a href="#exception-Failure" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Failure</span></code></dt><dd><p>Raised when asking for an element of an empty stream, and by <code>Genlex</code> parsers when none of the first components of the stream patterns is accepted.</p></dd></dl><dl><dt class="spec exception" id="exception-Error"><a href="#exception-Error" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Error</span> <span class="keyword">of</span> string</code></dt><dd><p>Raised by <code>Genlex</code> parsers when the first component of a stream pattern is accepted, but one of the following components is rejected.</p></dd></dl><dl><dt class="spec exception" id="exception-Expected_streams_of_equal_length"><a href="#exception-Expected_streams_of_equal_length" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Expected_streams_of_equal_length</span></code></dt><dd><p>Raised by operations working on more than one stream where all streams are expected to be of the same length.</p></dd></dl><dl><dt class="spec exception" id="exception-Premature_end_of_input"><a href="#exception-Premature_end_of_input" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Premature_end_of_input</span></code></dt><dd><p>Raised when an operation needs more elements from a stream than available.</p></dd></dl><dl><dt class="spec value" id="val-next"><a href="#val-next" class="anchor"></a><code><span class="keyword">val</span> next : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt><dd><p>Return first element in given stream if any and remove it from the stream.</p></dd></dl><dl><dt class="spec value" id="val-next_exn"><a href="#val-next_exn" class="anchor"></a><code><span class="keyword">val</span> next_exn : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Return first element in given stream and remove it from the stream.</p><dl><dt>raises Stream.Failure</dt><dd><p>if the stream is empty.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-peek"><a href="#val-peek" class="anchor"></a><code><span class="keyword">val</span> peek : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt><dd><p>Return first element of given stream without removing it from the stream, or <code>None</code> if the stream is empty.</p></dd></dl><dl><dt class="spec value" id="val-npeek"><a href="#val-npeek" class="anchor"></a><code><span class="keyword">val</span> npeek : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p><code>npeek s n</code> returns a list of the first <code>n</code> elements in stream <code>s</code>, or all of its remaining elements if less than <code>n</code> elements are available. The elements are not removed from the stream.</p></dd></dl><dl><dt class="spec value" id="val-junk"><a href="#val-junk" class="anchor"></a><code><span class="keyword">val</span> junk : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Discard first element of given stream or do nothing if the stream is empty.</p></dd></dl><dl><dt class="spec value" id="val-count"><a href="#val-count" class="anchor"></a><code><span class="keyword">val</span> count : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Return number of elements discarded from given stream.</p></dd></dl><dl><dt class="spec value" id="val-is_empty"><a href="#val-is_empty" class="anchor"></a><code><span class="keyword">val</span> is_empty : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>True if the stream is empty, else false.</p></dd></dl><section><header><h6 id="constructors"><a href="#constructors" class="anchor"></a>Constructors</h6></header><dl><dt class="spec value" id="val-from"><a href="#val-from" class="anchor"></a><code><span class="keyword">val</span> from : (int <span>&#45;&gt;</span> <span class="type-var">'a</span> option) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>from f</code> returns a stream whose <code>n</code>th element is determined by calling <code>f n</code>, which should return <code>Some x</code> to indicate value <code>x</code> or <code>None</code> to indicate the end of the stream. The stream is infinite if <code>f</code> never returns None.</p></dd></dl><dl><dt class="spec value" id="val-of_channel"><a href="#val-of_channel" class="anchor"></a><code><span class="keyword">val</span> of_channel : <a href="../../stdio/Stdio/In_channel/index.html#type-t">Core_kernel.In_channel.t</a> <span>&#45;&gt;</span> char <a href="index.html#type-t">t</a></code></dt><dd><p>Return a stream of characters by reading from the input channel. WARNING: Semantics unclear if the channel is closed before the stream reads all of its input. For example, the stream appears to return values although the channel has been closed.</p></dd></dl><dl><dt class="spec value" id="val-strings_of_channel"><a href="#val-strings_of_channel" class="anchor"></a><code><span class="keyword">val</span> strings_of_channel : ?&#8288;buffer_size:int <span>&#45;&gt;</span> <a href="../../stdio/Stdio/In_channel/index.html#type-t">Core_kernel.In_channel.t</a> <span>&#45;&gt;</span> string <a href="index.html#type-t">t</a></code></dt><dd><p>Return a stream of strings from the input. Each string has length at most <code>buffer_size</code>.</p></dd></dl><dl><dt class="spec value" id="val-range"><a href="#val-range" class="anchor"></a><code><span class="keyword">val</span> range : ?&#8288;until:int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <a href="index.html#type-t">t</a></code></dt><dd><p><code>range p until:q</code> creates a stream of integers <code>[p, p+1, ..., q]</code>. If <code>until</code> is omitted, the enumeration is not bounded. Behaviour is not-specified once <code>max_int</code> has been reached.</p></dd></dl><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val</span> empty : unit <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>The empty stream.</p></dd></dl><dl><dt class="spec value" id="val-init"><a href="#val-init" class="anchor"></a><code><span class="keyword">val</span> init : int <span>&#45;&gt;</span> f:(int <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>init n f</code> returns the stream <code>f 0; f 1; ... f (n-1)</code>.</p></dd></dl><dl><dt class="spec value" id="val-singleton"><a href="#val-singleton" class="anchor"></a><code><span class="keyword">val</span> singleton : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>singleton x</code> returns a stream containing the single value <code>x</code>.</p></dd></dl><dl><dt class="spec value" id="val-unfold"><a href="#val-unfold" class="anchor"></a><code><span class="keyword">val</span> unfold : <span class="type-var">'a</span> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'b</span> * <span class="type-var">'a</span>) option) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>unfold a0 f</code> returns the stream <code>b0; b1; ...; bn</code>, where</p><ul><li><code>Some (b0, a1) = f a0</code>,</li><li><code>Some (b1, a2) = f a1</code>,</li><li>...</li><li><code>Some (bn, a(n+1)) = f an</code>,</li><li><code>None = f a(n+1)</code></li></ul><p>The stream is infinite if <code>f</code> never returns None.</p></dd></dl><dl><dt class="spec value" id="val-unfoldi"><a href="#val-unfoldi" class="anchor"></a><code><span class="keyword">val</span> unfoldi : <span class="type-var">'a</span> <span>&#45;&gt;</span> f:(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'b</span> * <span class="type-var">'a</span>) option) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Indexed variant of <code>unfold</code></p></dd></dl><dl><dt class="spec value" id="val-of_lazy"><a href="#val-of_lazy" class="anchor"></a><code><span class="keyword">val</span> of_lazy : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> lazy_t <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt></dl></section><section><header><h6 id="iterators"><a href="#iterators" class="anchor"></a>Iterators</h6><p>Unless otherwise stated, functions in this section normally consume the entire stream. The exception is if a caller supplied function raises an exception, but that is not the normal intention of supplied functions.</p></header><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit</code></dt><dd><p><code>iter xs ~f</code> calls in turn <code>f x0</code>, <code>f x1</code>, ...</p></dd></dl><dl><dt class="spec value" id="val-iter2"><a href="#val-iter2" class="anchor"></a><code><span class="keyword">val</span> iter2 : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit</code></dt><dd><p>Like <code>iter</code> but operates on two streams. Stops when either stream becomes empty.</p></dd></dl><dl><dt class="spec value" id="val-iter2_exn"><a href="#val-iter2_exn" class="anchor"></a><code><span class="keyword">val</span> iter2_exn : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit</code></dt><dd><p>Like <code>iter2</code> except streams required to be of equal length.</p><dl><dt>raises Expected_streams_of_equal_length</dt><dd><p>if the two streams have different lengths, in which case there is no guarantee about which elements were consumed.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span class="keyword">val</span> fold : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> init:<span class="type-var">'b</span> <span>&#45;&gt;</span> f:(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p><code>fold xs ~init ~f</code> returns <code>f (...(f (f init x0) x1)...) xn</code>, that is for the stream <code>a0; a1; ...; an</code> does the following calculations:</p><ul><li>b1 = f init a0</li><li>b2 = f b1 a1</li><li>...</li><li>bn = f b(n-1) a(n-1)</li></ul><p>and returns <code>bn</code></p></dd></dl><dl><dt class="spec value" id="val-fold2"><a href="#val-fold2" class="anchor"></a><code><span class="keyword">val</span> fold2 : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> init:<span class="type-var">'c</span> <span>&#45;&gt;</span> f:(<span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>) <span>&#45;&gt;</span> <span class="type-var">'c</span></code></dt><dd><p>Like <code>fold</code> but operates on two streams. Processing continues until either stream becomes empty.</p></dd></dl><dl><dt class="spec value" id="val-fold2_exn"><a href="#val-fold2_exn" class="anchor"></a><code><span class="keyword">val</span> fold2_exn : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> init:<span class="type-var">'c</span> <span>&#45;&gt;</span> f:(<span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>) <span>&#45;&gt;</span> <span class="type-var">'c</span></code></dt><dd><p>Like <code>fold2</code> except streams required to be of equal length.</p><dl><dt>raises Expected_streams_of_equal_length</dt><dd><p>if the two streams have different lengths, in which case there is no guarantee about which elements were consumed.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-scanl"><a href="#val-scanl" class="anchor"></a><code><span class="keyword">val</span> scanl : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> init:<span class="type-var">'b</span> <span>&#45;&gt;</span> f:(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Like <code>fold</code> but all intermediate values are returned, not just the final value. If given stream <code>s</code> is <code>a0; a1; ...</code>, then <code>scanl f
    init s</code> is the stream containing</p><ul><li>b0 = init</li><li>b1 = f b0 a0</li><li>b2 = f b1 a1</li><li>... .</li></ul></dd></dl><dl><dt class="spec value" id="val-scan"><a href="#val-scan" class="anchor"></a><code><span class="keyword">val</span> scan : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>scan</code> is similar to <code>scanl</code> but without the <code>init</code> value: if <code>s</code> contains <code>x0</code>, <code>x1</code>, <code>x2</code> ..., <code>scan s ~f</code> contains</p><ul><li>y0 = x0</li><li>y1 = f y0 x1</li><li>y2 = f y1 x2</li><li>...</li></ul><p>For instance, <code>scan (1 -- 10) ~f:( * )</code> will produce an enumeration containing the successive values of the factorial function. Returns an empty stream if the input stream is empty as well.</p></dd></dl><dl><dt class="spec value" id="val-iteri"><a href="#val-iteri" class="anchor"></a><code><span class="keyword">val</span> iteri : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit</code></dt><dd><p>Indexed variants of the previous higher-order functions. The index provided to the <code>~f</code> argument is the count of the stream, that is the number of discarded elements before the reaching the current one. For functions iterating on two streams, the <code>~f</code> is thus provided two indices, since the current count may differ from one stream to another.</p></dd></dl><dl><dt class="spec value" id="val-iter2i_exn"><a href="#val-iter2i_exn" class="anchor"></a><code><span class="keyword">val</span> iter2i_exn : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-iter2i"><a href="#val-iter2i" class="anchor"></a><code><span class="keyword">val</span> iter2i : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-foldi"><a href="#val-foldi" class="anchor"></a><code><span class="keyword">val</span> foldi : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> init:<span class="type-var">'b</span> <span>&#45;&gt;</span> f:(int <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dt class="spec value" id="val-fold2i_exn"><a href="#val-fold2i_exn" class="anchor"></a><code><span class="keyword">val</span> fold2i_exn : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> init:<span class="type-var">'c</span> <span>&#45;&gt;</span> f:(int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>) <span>&#45;&gt;</span> <span class="type-var">'c</span></code></dt><dt class="spec value" id="val-fold2i"><a href="#val-fold2i" class="anchor"></a><code><span class="keyword">val</span> fold2i : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> init:<span class="type-var">'c</span> <span>&#45;&gt;</span> f:(int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>) <span>&#45;&gt;</span> <span class="type-var">'c</span></code></dt><dt class="spec value" id="val-reduce"><a href="#val-reduce" class="anchor"></a><code><span class="keyword">val</span> reduce : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>reduce xs ~f</code> returns <code>f (...(f (f x1 x2) x3)...) xn</code></p></dd></dl><dl><dt class="spec value" id="val-sum"><a href="#val-sum" class="anchor"></a><code><span class="keyword">val</span> sum : int <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>sum xs</code> returns the sum of the integers contained in <code>xs</code></p></dd></dl><dl><dt class="spec value" id="val-fsum"><a href="#val-fsum" class="anchor"></a><code><span class="keyword">val</span> fsum : float <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>fsum xs</code> returns the sum of the floats contained in <code>xs</code></p></dd></dl></section><section><header><h6 id="scanners"><a href="#scanners" class="anchor"></a>Scanners</h6><p>Operations that scan a stream for various purposes. Unlike iterators, these operations are not inherently meant to consume streams, although they do partially or fully, due to the nature of streams.</p></header><dl><dt class="spec value" id="val-exists"><a href="#val-exists" class="anchor"></a><code><span class="keyword">val</span> exists : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> bool</code></dt><dd><p><code>exists s ~f</code> returns <code>true</code> if there is some <code>x</code> in <code>s</code> such that <code>f x</code> is true. The stream is consumed through and including <code>x</code>.</p></dd></dl><dl><dt class="spec value" id="val-for_all"><a href="#val-for_all" class="anchor"></a><code><span class="keyword">val</span> for_all : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> bool</code></dt><dd><p><code>for_all s ~f</code> returns <code>true</code> if <code>f x</code> is true for every <code>x</code> in <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-find"><a href="#val-find" class="anchor"></a><code><span class="keyword">val</span> find : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt><dd><p><code>find e ~f</code> returns either <code>Some x</code> where <code>x</code> is the first element of <code>e</code> such that <code>f x</code> returns <code>true</code>, consuming the stream up to and including the found element, or <code>None</code> if no such element exists in the stream, consuming the whole stream in the search.</p><p>Since <code>find</code> (eagerly) consumes a prefix of the stream, it can be used several times on the same stream to find the next element.</p></dd></dl><dl><dt class="spec value" id="val-find_exn"><a href="#val-find_exn" class="anchor"></a><code><span class="keyword">val</span> find_exn : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Same as <code>find</code> except that it raises an exception <code>Not_found</code> instead of returning <code>None</code>.</p></dd></dl><dl><dt class="spec value" id="val-find_map"><a href="#val-find_map" class="anchor"></a><code><span class="keyword">val</span> find_map : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> option) <span>&#45;&gt;</span> <span class="type-var">'b</span> option</code></dt><dd><p>Similar to <code>find</code></p></dd></dl></section><section><header><h6 id="converters"><a href="#converters" class="anchor"></a>Converters</h6><p>Extract a subset of a stream or map a stream into another type of stream.</p></header><dl><dt class="spec value" id="val-take"><a href="#val-take" class="anchor"></a><code><span class="keyword">val</span> take : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> n:int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>take xs ~n</code> builds a fresh stream from <code>xs</code> containing the <code>d</code> first elements of <code>xs</code> where <code>d = min n l</code> and <code>l</code> is the length of <code>xs</code>. As it is fresh, the count of the resulting stream starts from <code>0</code> whatever the count of <code>xs</code> is.</p></dd></dl><dl><dt class="spec value" id="val-take_while"><a href="#val-take_while" class="anchor"></a><code><span class="keyword">val</span> take_while : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Same as <code>take</code> but takes elements from the input enum as long as <code>f</code> evaluates to <code>true</code>.</p></dd></dl><dl><dt class="spec value" id="val-drop"><a href="#val-drop" class="anchor"></a><code><span class="keyword">val</span> drop : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> n:int <span>&#45;&gt;</span> unit</code></dt><dd><p><code>drop xs ~n</code> is equivalent to calling <code>n</code> times <code>junk</code> on <code>xs</code>.</p></dd></dl><dl><dt class="spec value" id="val-drop_while"><a href="#val-drop_while" class="anchor"></a><code><span class="keyword">val</span> drop_while : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> unit</code></dt><dd><p>Similar to <code>drop</code>: <code>drop_while xs ~f</code> removes elements from <code>xs</code> and stops when <code>f</code> evals to false on the head element.</p></dd></dl><dl><dt class="spec value" id="val-skip"><a href="#val-skip" class="anchor"></a><code><span class="keyword">val</span> skip : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> n:int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Similar to <code>drop</code> but returns the stream in input (useful in chained composition).</p></dd></dl><dl><dt class="spec value" id="val-skip_while"><a href="#val-skip_while" class="anchor"></a><code><span class="keyword">val</span> skip_while : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Similar to <code>skip</code>: <code>skip_while xs ~f</code> removes elements from <code>xs</code> and stops when <code>f</code> evals to false on the head element.</p></dd></dl><dl><dt class="spec value" id="val-take_whilei"><a href="#val-take_whilei" class="anchor"></a><code><span class="keyword">val</span> take_whilei : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Indexed variants of the previous prefix/suffix constructors</p></dd></dl><dl><dt class="spec value" id="val-drop_whilei"><a href="#val-drop_whilei" class="anchor"></a><code><span class="keyword">val</span> drop_whilei : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-skip_whilei"><a href="#val-skip_whilei" class="anchor"></a><code><span class="keyword">val</span> skip_whilei : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-span"><a href="#val-span" class="anchor"></a><code><span class="keyword">val</span> span : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> * <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>span test e</code> produces two streams <code>(hd, tl)</code>, such that <code>hd</code> is the same as <code>take_while test e</code> and <code>tl</code> is the same as <code>skip_while test e</code>.</p></dd></dl><dl><dt class="spec value" id="val-group"><a href="#val-group" class="anchor"></a><code><span class="keyword">val</span> group : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="index.html#type-t">t</a></code></dt><dd><p><code>group xs f</code> applies <code>f</code> to the elements of <code>xs</code> and distribute them according to the return value of <code>f</code>. Let <code>ys</code> = <code>group xs
    f</code>, then <code>xs</code> = <code>concat ys</code> and in each stream <code>s</code> of <code>ys</code>, all values give the same value with <code>f</code>.</p></dd></dl><dl><dt class="spec value" id="val-group_by"><a href="#val-group_by" class="anchor"></a><code><span class="keyword">val</span> group_by : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> eq:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="index.html#type-t">t</a></code></dt><dd><p>Same as <code>group</code> but with a comparison function instead of a mapping.</p></dd></dl><dl><dt class="spec value" id="val-chunk2"><a href="#val-chunk2" class="anchor"></a><code><span class="keyword">val</span> chunk2 : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'a</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>Given a stream with items <code>x0, x1, x2, x3,...</code>, the returned stream will be pairs of items <code>(x0,x1), (x2,x3), ...</code>.</p><dl><dt>raises Premature_end_of_input</dt><dd><p>if input stream has an odd number of elements.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-chunk3"><a href="#val-chunk3" class="anchor"></a><code><span class="keyword">val</span> chunk3 : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'a</span> * <span class="type-var">'a</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>Like <code>chunk2</code> but for 3-tuples.</p></dd></dl><dl><dt class="spec value" id="val-chunk4"><a href="#val-chunk4" class="anchor"></a><code><span class="keyword">val</span> chunk4 : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'a</span> * <span class="type-var">'a</span> * <span class="type-var">'a</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>Like <code>chunk2</code> but for 4-tuples.</p></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-mapi"><a href="#val-mapi" class="anchor"></a><code><span class="keyword">val</span> mapi : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-map2_exn"><a href="#val-map2_exn" class="anchor"></a><code><span class="keyword">val</span> map2_exn : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>) <span>&#45;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-mapi2_exn"><a href="#val-mapi2_exn" class="anchor"></a><code><span class="keyword">val</span> mapi2_exn : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>) <span>&#45;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span class="keyword">val</span> filter : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-filter_map"><a href="#val-filter_map" class="anchor"></a><code><span class="keyword">val</span> filter_map : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> option) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-append"><a href="#val-append" class="anchor"></a><code><span class="keyword">val</span> append : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-concat"><a href="#val-concat" class="anchor"></a><code><span class="keyword">val</span> concat : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-concat_map"><a href="#val-concat_map" class="anchor"></a><code><span class="keyword">val</span> concat_map : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-combine"><a href="#val-combine" class="anchor"></a><code><span class="keyword">val</span> combine : (<span class="type-var">'a</span> <a href="index.html#type-t">t</a> * <span class="type-var">'b</span> <a href="index.html#type-t">t</a>) <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>combine</code> transforms a pair of streams into a stream of pairs of corresponding elements. If one stream is short, excess elements of the longer stream are ignored.</p></dd></dl><dl><dt class="spec value" id="val-uncombine"><a href="#val-uncombine" class="anchor"></a><code><span class="keyword">val</span> uncombine : (<span class="type-var">'a</span> * <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> * <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>uncombine</code> is the opposite of <code>combine</code></p></dd></dl><dl><dt class="spec value" id="val-merge"><a href="#val-merge" class="anchor"></a><code><span class="keyword">val</span> merge : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> cmp:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>merge test (a, b)</code> merge the elements from <code>a</code> and <code>b</code> into a single stream. At each step, <code>test</code> is applied to the first element of <code>a</code> and the first element of <code>b</code> to determine which should get first into the resulting stream. If <code>a</code> or <code>b</code> runs out of elements, the process will append all elements of the other stream to the result.</p></dd></dl><dl><dt class="spec value" id="val-partition"><a href="#val-partition" class="anchor"></a><code><span class="keyword">val</span> partition : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> * <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>partition e ~f</code> splits <code>e</code> into two streams, where the first stream have all the elements satisfying <code>f</code>, the second stream is opposite. The order of elements in the source stream is preserved.</p></dd></dl><dl><dt class="spec value" id="val-uniq"><a href="#val-uniq" class="anchor"></a><code><span class="keyword">val</span> uniq : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>uniq e</code> returns a duplicate of <code>e</code> with repeated values omitted. (similar to unix's <code>uniq</code> command)</p></dd></dl></section><section><header><h6 id="data-interchange"><a href="#data-interchange" class="anchor"></a>Data Interchange</h6><p>Convert/create a stream to/from another data structure.</p></header><dl><dt class="spec value" id="val-of_list"><a href="#val-of_list" class="anchor"></a><code><span class="keyword">val</span> of_list : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-to_list"><a href="#val-to_list" class="anchor"></a><code><span class="keyword">val</span> to_list : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dt class="spec value" id="val-of_array"><a href="#val-of_array" class="anchor"></a><code><span class="keyword">val</span> of_array : <span class="type-var">'a</span> array <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-to_array"><a href="#val-to_array" class="anchor"></a><code><span class="keyword">val</span> to_array : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> array</code></dt><dt class="spec value" id="val-of_hashtbl"><a href="#val-of_hashtbl" class="anchor"></a><code><span class="keyword">val</span> of_hashtbl : (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="../../core_kernel/Core_kernel/Hashtbl/index.html#type-t">Core_kernel.Hashtbl.t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-to_hashtbl"><a href="#val-to_hashtbl" class="anchor"></a><code><span class="keyword">val</span> to_hashtbl : (<span class="type-var">'a</span> * <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="../../core_kernel/Core_kernel/Hashtbl/index.html#type-t">Core_kernel.Hashtbl.t</a></code></dt><dt class="spec value" id="val-of_map"><a href="#val-of_map" class="anchor"></a><code><span class="keyword">val</span> of_map : (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>) <a href="../../core_kernel/Core_kernel/Map/index.html#type-t">Core_kernel.Map.t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-to_map"><a href="#val-to_map" class="anchor"></a><code><span class="keyword">val</span> to_map : (<span class="type-var">'a</span> * <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="../../core_kernel/Core_kernel__Map/Poly/index.html#type-t">Core_kernel.Map.Poly.t</a></code></dt><dt class="spec value" id="val-of_set"><a href="#val-of_set" class="anchor"></a><code><span class="keyword">val</span> of_set : (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="../../core_kernel/Core_kernel/Set/index.html#type-t">Core_kernel.Set.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-to_set"><a href="#val-to_set" class="anchor"></a><code><span class="keyword">val</span> to_set : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../core_kernel/Core_kernel__Set/Poly/index.html#type-t">Core_kernel.Set.Poly.t</a></code></dt><dt class="spec value" id="val-of_string"><a href="#val-of_string" class="anchor"></a><code><span class="keyword">val</span> of_string : string <span>&#45;&gt;</span> char <a href="index.html#type-t">t</a></code></dt></dl></section><section><header><h6 id="result.t's"><a href="#result.t's" class="anchor"></a>Result.t's</h6></header><dl><dt class="spec value" id="val-result_to_exn"><a href="#val-result_to_exn" class="anchor"></a><code><span class="keyword">val</span> result_to_exn : (<span class="type-var">'output</span>, <span class="type-var">'error</span>) <a href="../../core_kernel/Core_kernel/Result/index.html#type-t">Core_kernel.Result.t</a> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> error_to_exn:(<span class="type-var">'error</span> <span>&#45;&gt;</span> exn) <span>&#45;&gt;</span> <span class="type-var">'output</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Convert exception-less stream to exception-ful stream. Resulting stream raises exception at first error seen.</p></dd></dl><dl><dt class="spec module" id="module-Result"><a href="#module-Result" class="anchor"></a><code><span class="keyword">module</span> <a href="Result/index.html">Result</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Higher-order functions for streams of results</p></dd></dl><dl><dt class="spec module" id="module-Or_error"><a href="#module-Or_error" class="anchor"></a><code><span class="keyword">module</span> <a href="Or_error/index.html">Or_error</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Specialisation of <span class="xref-unresolved" title="unresolved reference to &quot;CFStream_stream.Result&quot;"><code>CFStream_stream</code>.Result</span> for <code>'a
    Or_error.t</code></p></dd></dl><div class="spec module" id="module-Infix"><a href="#module-Infix" class="anchor"></a><code><span class="keyword">module</span> <a href="Infix/index.html">Infix</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section></div></body></html>