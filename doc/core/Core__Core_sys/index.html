<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Core__Core_sys (core.Core__Core_sys)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">core</a> &#x00BB; Core__Core_sys</nav><h1>Module <code>Core__Core_sys</code></h1><p>System interface.</p><nav class="toc"><ul><li><a href="#optimization">Optimization</a></li></ul></nav></header><dl><dt class="spec value" id="val-argv"><a href="#val-argv" class="anchor"></a><code><span class="keyword">val </span>argv : string array</code></dt><dd><p>The command line arguments given to the process. The first element is the command name used to invoke the program. The following elements are the command-line arguments given to the program.</p></dd></dl><dl><dt class="spec value" id="val-executable_name"><a href="#val-executable_name" class="anchor"></a><code><span class="keyword">val </span>executable_name : string</code></dt><dd><p>The name of the file containing the executable currently running.</p></dd></dl><aside><p>For all of the following functions, <code>?follow_symlinks</code> defaults to <code>true</code>.</p></aside><dl><dt class="spec value" id="val-file_exists"><a href="#val-file_exists" class="anchor"></a><code><span class="keyword">val </span>file_exists : ?&#8288;follow_symlinks:bool <span>&#45;&gt;</span> string <span>&#45;&gt;</span> [ `Yes<span class="keyword"> | </span>`No<span class="keyword"> | </span>`Unknown ]</code></dt><dd><p><code>file_exists ~follow_symlinks path</code></p><p>Test whether the file in <code>path</code> exists on the file system. If <code>follow_symlinks</code> is <code>true</code> and <code>path</code> is a symlink the result concerns the target of the symlink.</p><p><code>`Unknown</code> is returned for files for which we cannot successfully determine whether they are on the system or not (e.g. files in directories to which we do not have read permission).</p></dd></dl><dl><dt class="spec value" id="val-file_exists_exn"><a href="#val-file_exists_exn" class="anchor"></a><code><span class="keyword">val </span>file_exists_exn : ?&#8288;follow_symlinks:bool <span>&#45;&gt;</span> string <span>&#45;&gt;</span> bool</code></dt><dd><p>Same as <code>file_exists</code> but blows up on <code>`Unknown</code></p></dd></dl><dl><dt class="spec value" id="val-is_directory"><a href="#val-is_directory" class="anchor"></a><code><span class="keyword">val </span>is_directory : ?&#8288;follow_symlinks:bool <span>&#45;&gt;</span> string <span>&#45;&gt;</span> [ `Yes<span class="keyword"> | </span>`No<span class="keyword"> | </span>`Unknown ]</code></dt><dd><p>Returns <code>`Yes</code> if the file exists and is a directory</p></dd></dl><dl><dt class="spec value" id="val-is_file"><a href="#val-is_file" class="anchor"></a><code><span class="keyword">val </span>is_file : ?&#8288;follow_symlinks:bool <span>&#45;&gt;</span> string <span>&#45;&gt;</span> [ `Yes<span class="keyword"> | </span>`No<span class="keyword"> | </span>`Unknown ]</code></dt><dd><p>Returns <code>`Yes</code> if the file exists and is a regular file</p></dd></dl><dl><dt class="spec value" id="val-is_directory_exn"><a href="#val-is_directory_exn" class="anchor"></a><code><span class="keyword">val </span>is_directory_exn : ?&#8288;follow_symlinks:bool <span>&#45;&gt;</span> string <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-is_file_exn"><a href="#val-is_file_exn" class="anchor"></a><code><span class="keyword">val </span>is_file_exn : ?&#8288;follow_symlinks:bool <span>&#45;&gt;</span> string <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-remove"><a href="#val-remove" class="anchor"></a><code><span class="keyword">val </span>remove : string <span>&#45;&gt;</span> unit</code></dt><dd><p>Remove the given file name from the file system.</p></dd></dl><dl><dt class="spec value" id="val-rename"><a href="#val-rename" class="anchor"></a><code><span class="keyword">val </span>rename : string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> unit</code></dt><dd><p>Rename a file. The first argument is the old name and the second is the new name. If there is already another file under the new name, <code>rename</code> may replace it, or raise an exception, depending on your operating system.</p></dd></dl><dl><dt class="spec value" id="val-getenv"><a href="#val-getenv" class="anchor"></a><code><span class="keyword">val </span>getenv : string <span>&#45;&gt;</span> string option</code></dt><dd><p>Return the value associated to a variable in the process environment. Return <code>None</code> if the variable is unbound.</p></dd></dl><dl><dt class="spec value" id="val-getenv_exn"><a href="#val-getenv_exn" class="anchor"></a><code><span class="keyword">val </span>getenv_exn : string <span>&#45;&gt;</span> string</code></dt><dt class="spec value" id="val-command"><a href="#val-command" class="anchor"></a><code><span class="keyword">val </span>command : string <span>&#45;&gt;</span> int</code></dt><dd><p>Execute the given shell command and return its exit code.</p></dd></dl><dl><dt class="spec value" id="val-command_exn"><a href="#val-command_exn" class="anchor"></a><code><span class="keyword">val </span>command_exn : string <span>&#45;&gt;</span> unit</code></dt><dd><p><code>command_exn command</code> runs <code>command</code> and then raises an exception if it returns with nonzero exit status.</p></dd></dl><dl><dt class="spec value" id="val-chdir"><a href="#val-chdir" class="anchor"></a><code><span class="keyword">val </span>chdir : string <span>&#45;&gt;</span> unit</code></dt><dd><p>Change the current working directory of the process.</p></dd></dl><dl><dt class="spec value" id="val-getcwd"><a href="#val-getcwd" class="anchor"></a><code><span class="keyword">val </span>getcwd : unit <span>&#45;&gt;</span> string</code></dt><dd><p>Return the current working directory of the process.</p></dd></dl><dl><dt class="spec value" id="val-readdir"><a href="#val-readdir" class="anchor"></a><code><span class="keyword">val </span>readdir : string <span>&#45;&gt;</span> string array</code></dt><dd><p>Return the names of all files present in the given directory. Names denoting the current directory and the parent directory (<code>&quot;.&quot;</code> and <code>&quot;..&quot;</code> in Unix) are not returned. Each string in the result is a file name rather than a complete path. There is no guarantee that the name strings in the resulting array will appear in any specific order; they are not, in particular, guaranteed to appear in alphabetical order.</p></dd></dl><dl><dt class="spec value" id="val-fold_dir"><a href="#val-fold_dir" class="anchor"></a><code><span class="keyword">val </span>fold_dir : init:<span class="type-var">'acc</span> <span>&#45;&gt;</span> f:(<span class="type-var">'acc</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'acc</span>) <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'acc</span></code></dt><dd><p>Call <code>readdir</code>, and fold over the elements of the array.</p><dl><dt>raises Sys_error</dt><dd><p>_ if readdir fails. As with <code>readdir</code>, <code>&quot;.&quot;</code> and <code>&quot;..&quot;</code> are not returned raises the same exception than opendir and closedir.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-ls_dir"><a href="#val-ls_dir" class="anchor"></a><code><span class="keyword">val </span>ls_dir : string <span>&#45;&gt;</span> string list</code></dt><dd><p>Same as <code>readdir</code>, but return a list rather than an array.</p></dd></dl><dl><dt class="spec value" id="val-interactive"><a href="#val-interactive" class="anchor"></a><code><span class="keyword">val </span>interactive : bool Core__.Import.ref</code></dt><dd><p>This reference is initially set to <code>false</code> in standalone programs and to <code>true</code> if the code is being executed under the interactive toplevel system <code>ocaml</code>.</p></dd></dl><dl><dt class="spec value" id="val-os_type"><a href="#val-os_type" class="anchor"></a><code><span class="keyword">val </span>os_type : string</code></dt><dd><p>Operating system currently executing the Caml program. One of</p><ul><li><code>&quot;Unix&quot;</code> (for all Unix versions, including Linux and Mac OS X),</li><li><code>&quot;Win32&quot;</code> (for MS-Windows, OCaml compiled with MSVC++ or Mingw),</li><li><code>&quot;Cygwin&quot;</code> (for MS-Windows, OCaml compiled with Cygwin).</li></ul></dd></dl><dl><dt class="spec value" id="val-word_size"><a href="#val-word_size" class="anchor"></a><code><span class="keyword">val </span>word_size : int</code></dt><dd><p>Size of one word on the machine currently executing the Caml program, in bits: 32 or 64.</p></dd></dl><dl><dt class="spec value" id="val-int_size"><a href="#val-int_size" class="anchor"></a><code><span class="keyword">val </span>int_size : int</code></dt><dd><p>Size of an int. It is 31 bits (resp. 63 bits) when using the OCaml compiler on a 32 bits (resp. 64 bits) platform. It may differ for other compilers, e.g. it is 32 bits when compiling to JavaScript. </p><dl><dt>since</dt><dd>4.03.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-big_endian"><a href="#val-big_endian" class="anchor"></a><code><span class="keyword">val </span>big_endian : bool</code></dt><dd><p>Whether the machine currently executing the Caml program is big-endian.</p></dd></dl><dl><dt class="spec exception" id="exception-Break"><a href="#exception-Break" class="anchor"></a><code><span class="keyword">exception </span></code><code><span class="exception">Break</span></code></dt><dd><p>Exception raised on interactive interrupt if <span class="xref-unresolved" title="unresolved reference to &quot;Sys.catch_break&quot;"><code>Sys</code>.catch_break</span> is on.</p></dd></dl><dl><dt class="spec value" id="val-catch_break"><a href="#val-catch_break" class="anchor"></a><code><span class="keyword">val </span>catch_break : bool <span>&#45;&gt;</span> unit</code></dt><dd><p>Warning: this function clobbers the Signal.int (SIGINT) handler. SIGINT is the signal that's sent to your program when you hit CTRL-C.</p><p>Warning: catch_break uses deep ocaml runtime magic to raise Sys.Break inside of the main execution context. Consider explicitly handling Signal.int instead. If all you want to do is terminate on CTRL-C you don't have to do any special setup, that's the default behavior.</p><p><code>catch_break</code> governs whether interactive interrupt (ctrl-C) terminates the program or raises the <code>Break</code> exception. Call <code>catch_break true</code> to enable raising <code>Break</code>, and <code>catch_break false</code> to let the system terminate the program on user interrupt.</p></dd></dl><dl><dt class="spec value" id="val-ocaml_version"><a href="#val-ocaml_version" class="anchor"></a><code><span class="keyword">val </span>ocaml_version : string</code></dt><dd><p><code>ocaml_version</code> is the version of Objective Caml. It is a string of the form <code>&quot;major.minor[.patchlevel][+additional-info]&quot;</code>, where <code>major</code>, <code>minor</code>, and <code>patchlevel</code> are integers, and <code>additional-info</code> is an arbitrary string. The <code>[.patchlevel]</code> and <code>[+additional-info]</code> parts may be absent.</p></dd></dl><dl><dt class="spec value" id="val-execution_mode"><a href="#val-execution_mode" class="anchor"></a><code><span class="keyword">val </span>execution_mode : unit <span>&#45;&gt;</span> [ `Bytecode<span class="keyword"> | </span>`Native ]</code></dt><dd><p><code>execution_mode</code> tests whether the code being executed was compiled natively or to bytecode.</p></dd></dl><dl><dt class="spec external" id="val-c_int_size"><a href="#val-c_int_size" class="anchor"></a><code><span class="keyword">val </span>c_int_size : unit <span>&#45;&gt;</span> int</code></dt><dd><p><code>c_int_size</code> returns the number of bits in a C <code>int</code>. Note that this can be different from <code>word_size</code>. For example, Linux x86-64 should have <code>word_size = 64</code>, but <code>c_int_size () = 32</code></p></dd></dl><dl><dt class="spec value" id="val-home_directory"><a href="#val-home_directory" class="anchor"></a><code><span class="keyword">val </span>home_directory : unit <span>&#45;&gt;</span> string</code></dt><dd><p>Return the home directory, using the <code>HOME</code> environment variable if that is defined, and if not, using the effective user's information in the Unix password database.</p></dd></dl><section><header><h6 id="optimization"><a href="#optimization" class="anchor"></a>Optimization</h6></header><dl><dt class="spec external" id="val-opaque_identity"><a href="#val-opaque_identity" class="anchor"></a><code><span class="keyword">val </span>opaque_identity : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>For the purposes of optimization, <code>opaque_identity</code> behaves like an unknown (and thus possibly side-effecting) function. At runtime, <code>opaque_identity</code> disappears altogether. A typical use of this function is to prevent pure computations from being optimized away in benchmarking loops. For example:</p><pre><code class="ml">for _round = 1 to 100_000 do
  ignore (Sys.opaque_identity (my_pure_computation ()))
done</code></pre></dd></dl></section></div></body></html>