<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Earley_core__Earley (earley.Earley_core__Earley)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">earley</a> &#x00BB; Earley_core__Earley</nav><h1>Module <code>Earley_core__Earley</code></h1><p>Earley is a parser combinator library implemented using the Earley algorithm. It focuses mainly on efficiency and is indended to be used in conjunction with the pa_ocaml parser and syntax extention mechanism.</p><nav class="toc"><ul><li><a href="#types-and-exceptions">Types and exceptions</a></li><li><a href="#atomic-parsers">Atomic parsers</a></li><li><a href="#blanks-management">Blanks management</a></li><li><a href="#support-for-recursive-grammars">Support for recursive grammars</a></li><li><a href="#parsing-functions">Parsing functions</a></li><li><a href="#debuging-and-flags">Debuging and flags</a></li><li><a href="#greedy-combinator">Greedy combinator</a></li><li><a href="#sequencing-combinators">Sequencing combinators</a></li></ul></nav></header><section><header><h3 id="types-and-exceptions"><a href="#types-and-exceptions" class="anchor"></a>Types and exceptions</h3></header><dl><dt class="spec type" id="type-grammar"><a href="#type-grammar" class="anchor"></a><code><span class="keyword">type</span> 'a grammar</code></dt><dd><p>Type of a parser (or grammar) producing a value of type <code>'a</code>.</p></dd></dl><dl><dt class="spec type" id="type-blank"><a href="#type-blank" class="anchor"></a><code><span class="keyword">type</span> blank</code><code> = <a href="../Earley_core/Input/index.html#type-buffer">Earley_core.Input.buffer</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="../Earley_core/Input/index.html#type-buffer">Earley_core.Input.buffer</a> * int</code></dt><dd><p>As <code>Earley</code> does scannerless parsing, a notion of <code>blank</code> function is used to discard meaningless parts of the input (e.g. comments or spaces). A <code>blank</code> function takes as input a <code>buffer</code> and a position (represented as an <code>int</code>) and returns a couple of a <code>buffer</code> and a position corresponding to the next meaningful character.</p><p>WARNING: a blank function must return a normalized pair (b,p), which means 0 &lt;= p &lt; Input.line_num b. You can use Input.normalize to ensure this.</p></dd></dl><dl><dt class="spec exception" id="exception-Parse_error"><a href="#exception-Parse_error" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Parse_error</span> <span class="keyword">of</span> <a href="../Earley_core/Input/index.html#type-buffer">Earley_core.Input.buffer</a> * int</code></dt><dd><p>The exception <code>Parse_error(buf,pos,msgs)</code> is raised whenever parsing fails. It contains the position <code>pos</code> (and the corresponding buffer <code>buf</code>) of the furthest reached position in the input.</p></dd></dl><dl><dt class="spec value" id="val-give_up"><a href="#val-give_up" class="anchor"></a><code><span class="keyword">val</span> give_up : unit <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>give_up ()</code> can be called by the user to force the parser to reject a possible parsing rule.</p></dd></dl><dl><dt class="spec value" id="val-handle_exception"><a href="#val-handle_exception" class="anchor"></a><code><span class="keyword">val</span> handle_exception : ?&#8288;error:(unit <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p><code>handle_exception fn v</code> applies the function <code>fn</code> to <code>v</code> and handles the <code>Parse_error</code> exception. In particular, a parse error message is presented to the user in case of a failure, then <code>error ()</code> is called. The default <code>error</code> is <code>fun () -&gt; exit 1</code>.</p></dd></dl></section><section><header><h3 id="atomic-parsers"><a href="#atomic-parsers" class="anchor"></a>Atomic parsers</h3></header><dl><dt class="spec value" id="val-char"><a href="#val-char" class="anchor"></a><code><span class="keyword">val</span> char : ?&#8288;name:string <span>&#45;&gt;</span> char <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a></code></dt><dd><p><code>char ~name c v</code> is a grammar that accepts only the character <code>c</code>, and returns <code>v</code> as a semantic value. An optional <code>name</code> can be given to the grammar for reference in error messages.</p></dd></dl><dl><dt class="spec value" id="val-string"><a href="#val-string" class="anchor"></a><code><span class="keyword">val</span> string : ?&#8288;name:string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a></code></dt><dd><p><code>string s v</code> is a grammar that accepts only the string <code>str</code>, and returns <code>v</code> as a semantic value. An optional <code>name</code> can be given to the grammar for reference in error messages.</p></dd></dl><dl><dt class="spec value" id="val-keyword"><a href="#val-keyword" class="anchor"></a><code><span class="keyword">val</span> keyword : ?&#8288;name:string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> (char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a></code></dt><dd><p><code>keyword s forbidden v</code> is simalar to string, but the parsing fails if <code>forbidden c</code> returns <code>true</code> when <code>c</code> is the next available character.</p></dd></dl><dl><dt class="spec value" id="val-eof"><a href="#val-eof" class="anchor"></a><code><span class="keyword">val</span> eof : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a></code></dt><dd><p><code>eof v</code> is a grammar that only accepts the end of file and returns <code>v</code> as a semantic value. Note that the end of file can be parsed one or more times (i.e. the input ends with infinitely many end of file symbols.</p></dd></dl><dl><dt class="spec value" id="val-any"><a href="#val-any" class="anchor"></a><code><span class="keyword">val</span> any : char <a href="index.html#type-grammar">grammar</a></code></dt><dd><p><code>any</code> is a grammar that accepts a single character (but fails on the end of file) and returns its value.</p></dd></dl><dl><dt class="spec value" id="val-in_charset"><a href="#val-in_charset" class="anchor"></a><code><span class="keyword">val</span> in_charset : ?&#8288;name:string <span>&#45;&gt;</span> <a href="../Earley_core/Charset/index.html#type-charset">Earley_core.Charset.charset</a> <span>&#45;&gt;</span> char <a href="index.html#type-grammar">grammar</a></code></dt><dd><p><code>in_charset cs</code> is a grammar that parses any character of the <code>cs</code> charset, and returns its value. An optional <code>name</code> can be given to the grammar for reference in error messages.</p></dd></dl><dl><dt class="spec value" id="val-not_in_charset"><a href="#val-not_in_charset" class="anchor"></a><code><span class="keyword">val</span> not_in_charset : ?&#8288;name:string <span>&#45;&gt;</span> <a href="../Earley_core/Charset/index.html#type-charset">Earley_core.Charset.charset</a> <span>&#45;&gt;</span> unit <a href="index.html#type-grammar">grammar</a></code></dt><dd><p><code>not_in_charset cs</code> is similar to <code>in_charset cs</code> but it accepts the characters that are not in <code>cs</code>.</p></dd></dl><dl><dt class="spec value" id="val-blank_not_in_charset"><a href="#val-blank_not_in_charset" class="anchor"></a><code><span class="keyword">val</span> blank_not_in_charset : ?&#8288;name:string <span>&#45;&gt;</span> <a href="../Earley_core/Charset/index.html#type-charset">Earley_core.Charset.charset</a> <span>&#45;&gt;</span> unit <a href="index.html#type-grammar">grammar</a></code></dt><dd><p><code>blank_not_in_charset cs</code> is the same as <code>not_in_charset</code> but testing with blank_test.</p></dd></dl><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val</span> empty : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a></code></dt><dd><p><code>empty v</code> is a grammar that does not parse anything and returns <code>v</code> as a semantic value. Note that this grammar never fails.</p></dd></dl><dl><dt class="spec type" id="type-fpos"><a href="#type-fpos" class="anchor"></a><code><span class="keyword">type</span> 'a fpos</code><code> = <a href="../Earley_core/Input/index.html#type-buffer">Earley_core.Input.buffer</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="../Earley_core/Input/index.html#type-buffer">Earley_core.Input.buffer</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>type for a function waiting for the start and end positions (i.e. buffer and index) of an item, in general resulting from parsing</p></dd></dl><dl><dt class="spec value" id="val-empty_pos"><a href="#val-empty_pos" class="anchor"></a><code><span class="keyword">val</span> empty_pos : <span class="type-var">'a</span> <a href="index.html#type-fpos">fpos</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a></code></dt><dd><p><code>empty_pos v</code> is similar to the above except that the action wait for the position of a complete sequence build using <code>fsequence</code> of <code>sequence</code>.</p><p>For instance, <code>sequence_position g1 g2 f</code> below can be defined as <code>fsequence g1 (fsequence g2 (empty_pos f'))</code>. where <code>f' = fun b p b' p' a2 a1 = f b p b' p' a1 a2</code> to give the result of g1 and g2 in the expected order.</p></dd></dl><dl><dt class="spec value" id="val-fail"><a href="#val-fail" class="anchor"></a><code><span class="keyword">val</span> fail : unit <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a></code></dt><dd><p><code>fail ()</code> is a grammar that always fail, whatever the input.</p></dd></dl><dl><dt class="spec value" id="val-black_box"><a href="#val-black_box" class="anchor"></a><code><span class="keyword">val</span> black_box : (<a href="../Earley_core/Input/index.html#type-buffer">Earley_core.Input.buffer</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> * <a href="../Earley_core/Input/index.html#type-buffer">Earley_core.Input.buffer</a> * int) <span>&#45;&gt;</span> <a href="../Earley_core/Charset/index.html#type-charset">Earley_core.Charset.charset</a> <span>&#45;&gt;</span> bool <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a></code></dt><dd><p><code>black_box fn cs accept_empty name</code> is a grammar that uses the function <code>fn</code> to parses the input buffer. <code>fn buf pos</code> should start parsing <code>buf</code> at position <code>pos</code>, and return a couple containing the new buffer and position of the first unread character. The character set <code>cs</code> must contain at least the characters that are accepted as first character by <code>fn</code>, and no less. The boolean <code>accept_empty</code> must be true if the function accept the empty string. The <code>name</code> argument is used for reference in error messages. Note that the functon <code>fn</code> should use <code>give_up ()</code> in case of a parse error.</p><p>WARNING: fn must return a triple (x,b,p) when (b,p) is normalized, which means 0 &lt;= p &lt; Input.line_num b. You can use Input.normalize to ensure this.</p></dd></dl><dl><dt class="spec value" id="val-debug"><a href="#val-debug" class="anchor"></a><code><span class="keyword">val</span> debug : string <span>&#45;&gt;</span> unit <a href="index.html#type-grammar">grammar</a></code></dt><dd><p><code>debug msg</code> is a dummy grammar that always succeeds and prints <code>msg</code> on <code>stderr</code> when used. It is useful for debugging.</p></dd></dl><dl><dt class="spec value" id="val-regexp"><a href="#val-regexp" class="anchor"></a><code><span class="keyword">val</span> regexp : ?&#8288;name:string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string array <a href="index.html#type-grammar">grammar</a></code></dt><dd><p><code>regexp ?name re</code> is a grammar that uses the regexp <code>re</code> to parse the input buffer. The value returnes is the array of the contents of the groups.</p></dd></dl></section><section><header><h3 id="blanks-management"><a href="#blanks-management" class="anchor"></a>Blanks management</h3></header><dl><dt class="spec value" id="val-no_blank"><a href="#val-no_blank" class="anchor"></a><code><span class="keyword">val</span> no_blank : <a href="index.html#type-blank">blank</a></code></dt><dd><p><code>no_blank</code> is a <code>blank</code> function that does not discard any character of the input buffer.</p></dd></dl><dl><dt class="spec value" id="val-blank_regexp"><a href="#val-blank_regexp" class="anchor"></a><code><span class="keyword">val</span> blank_regexp : string <span>&#45;&gt;</span> <a href="index.html#type-blank">blank</a></code></dt><dd><p><code>blank_regexp re</code> builds a blank from the regexp <code>re</code>.</p></dd></dl><dl><dt class="spec value" id="val-blank_grammar"><a href="#val-blank_grammar" class="anchor"></a><code><span class="keyword">val</span> blank_grammar : unit <a href="index.html#type-grammar">grammar</a> <span>&#45;&gt;</span> <a href="index.html#type-blank">blank</a> <span>&#45;&gt;</span> <a href="index.html#type-blank">blank</a></code></dt><dd><p><code>blank_grammar gr bl</code> produces a <code>blank</code> function using the grammar <code>gr</code> and the <code>blank</code> function <code>bl</code>. It parses as much of the input as possible using the grammar <code>gr</code> with the <code>blank</code> function <code>bl</code>, and returns the reached position.</p></dd></dl><dl><dt class="spec value" id="val-change_layout"><a href="#val-change_layout" class="anchor"></a><code><span class="keyword">val</span> change_layout : ?&#8288;old_blank_before:bool <span>&#45;&gt;</span> ?&#8288;new_blank_after:bool <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a> <span>&#45;&gt;</span> <a href="index.html#type-blank">blank</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a></code></dt><dd><p><code>change_layout ~old_blank_before  ~new_blank_after  gr bl</code> replaces the current <code>blank</code> function with <code>bl</code>, while parsing using the grammar <code>gr</code>. The optional parameter <code>old_blank_before</code> (<code>true</code> by default) forces the application of the old blank function, before starting to parse with <code>gr</code>. Note that the new blank function is always called before the first terminal of <code>gr</code>. Similarly, the opt- -ional parameter <code>new_blank_after</code> (<code>true</code> by default) forces a call to the new blank function after the end of the parsing of <code>gr</code>. Note that the old blank function is always called after the last terminal.</p></dd></dl><dl><dt class="spec value" id="val-no_blank_layout"><a href="#val-no_blank_layout" class="anchor"></a><code><span class="keyword">val</span> no_blank_layout : <span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a></code></dt><dd><p><code>change_layout ~oba gr bl</code> same as abobe but with no blank. It keeps the first char prediction and is therefore more efficient</p></dd></dl></section><section><header><h3 id="support-for-recursive-grammars"><a href="#support-for-recursive-grammars" class="anchor"></a>Support for recursive grammars</h3></header><dl><dt class="spec value" id="val-declare_grammar"><a href="#val-declare_grammar" class="anchor"></a><code><span class="keyword">val</span> declare_grammar : string <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a></code></dt><dd><p><code>declare_grammar name</code> returns a new grammar that can be used in the definition of other grammars, but that cannot be run on input before it has been initialized with <code>set_grammar</code>. The <code>name</code> argument is used for reference to the grammar in error messages.</p></dd></dl><dl><dt class="spec value" id="val-set_grammar"><a href="#val-set_grammar" class="anchor"></a><code><span class="keyword">val</span> set_grammar : <span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>set_grammar gr grdef</code> set the definiton of grammar <code>gr</code> (previously declared with <code>declare_grammar</code>) to be <code>grdef</code>. <code>Invalid_argument</code> is raised if <code>set_grammar</code> is used on a grammar that was not created with <code>declare_grammar</code>. The behavious is undefined if a grammar is set twice with <code>set_grammar</code>.</p></dd></dl></section><section><header><h3 id="parsing-functions"><a href="#parsing-functions" class="anchor"></a>Parsing functions</h3></header><dl><dt class="spec value" id="val-parse_buffer"><a href="#val-parse_buffer" class="anchor"></a><code><span class="keyword">val</span> parse_buffer : <span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a> <span>&#45;&gt;</span> <a href="index.html#type-blank">blank</a> <span>&#45;&gt;</span> <a href="../Earley_core/Input/index.html#type-buffer">Earley_core.Input.buffer</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>parse_buffer gr bl buf</code> parses the buffer <code>buf</code> using the grammar <code>gr</code> and the blank function <code>bl</code>. The exception <code>Parse_error</code> may be raised in case of error.</p></dd></dl><dl><dt class="spec value" id="val-parse_string"><a href="#val-parse_string" class="anchor"></a><code><span class="keyword">val</span> parse_string : ?&#8288;filename:string <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a> <span>&#45;&gt;</span> <a href="index.html#type-blank">blank</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>parse_string ~filename gr bl str</code> parses the string <code>str</code> using the grammar <code>gr</code> and the blank function <code>bl</code>. An optional <code>filename</code> can be provided for reference to the input in error messages. The exception <code>Parse_error</code> may be raised in case of error.</p></dd></dl><dl><dt class="spec value" id="val-parse_channel"><a href="#val-parse_channel" class="anchor"></a><code><span class="keyword">val</span> parse_channel : ?&#8288;filename:string <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a> <span>&#45;&gt;</span> <a href="index.html#type-blank">blank</a> <span>&#45;&gt;</span> <a href="../../ocaml/Stdlib/index.html#type-in_channel">Stdlib.in_channel</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>parse_channel ~filename gr bl ch</code> parses the contenst of the input channel <code>ch</code> using the grammar <code>gr</code> and the blank function <code>bl</code>. A <code>filename</code> can be provided for reference to the input in case of an error. <code>parse_channel</code> may raise the <code>Parse_error</code> exception.</p></dd></dl><dl><dt class="spec value" id="val-parse_file"><a href="#val-parse_file" class="anchor"></a><code><span class="keyword">val</span> parse_file : <span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a> <span>&#45;&gt;</span> <a href="index.html#type-blank">blank</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>parse_file gr bl fn</code> parses the file <code>fn</code> using the grammar <code>gr</code> and the blank function <code>bl</code>. The exception <code>Parse_error</code> may be raised in case of error.</p></dd></dl><dl><dt class="spec value" id="val-partial_parse_buffer"><a href="#val-partial_parse_buffer" class="anchor"></a><code><span class="keyword">val</span> partial_parse_buffer : <span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a> <span>&#45;&gt;</span> <a href="index.html#type-blank">blank</a> <span>&#45;&gt;</span> ?&#8288;blank_after:bool <span>&#45;&gt;</span> <a href="../Earley_core/Input/index.html#type-buffer">Earley_core.Input.buffer</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> * <a href="../Earley_core/Input/index.html#type-buffer">Earley_core.Input.buffer</a> * int</code></dt><dd><p><code>partial_parse_buffer gr bl buf pos</code> parses input from the buffer <code>buf</code> starting a position <code>pos</code>, using the grammar <code>gr</code> and the blank function <code>bl</code>. A triple is returned containing the new buffer, the position that was reached during parsing, and the semantic result of the parsing. The optional argument <code>blank_after</code>, <code>true</code> by default, indicates if the returned position if after the final blank or not. Note that this function should not be used in the defi- nition of a grammar using the <code>black_box</code> function.</p></dd></dl><dl><dt class="spec module" id="module-WithPP"><a href="#module-WithPP" class="anchor"></a><code><span class="keyword">module</span> <a href="WithPP/index.html">WithPP</a> : <span class="keyword">functor</span> (<a href="WithPP/argument-1-PP/index.html">PP</a> : <a href="../Earley_core/Input/index.html#module-type-Preprocessor">Earley_core.Input.Preprocessor</a>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>A functor providing support for using and <code>Input</code> preprocessor.</p></dd></dl></section><section><header><h3 id="debuging-and-flags"><a href="#debuging-and-flags" class="anchor"></a>Debuging and flags</h3></header><dl><dt class="spec value" id="val-debug_lvl"><a href="#val-debug_lvl" class="anchor"></a><code><span class="keyword">val</span> debug_lvl : int <a href="../../ocaml/Stdlib/index.html#type-ref">Stdlib.ref</a></code></dt><dd><p><code>debug_lvl</code> is a flag that can be set for <code>Earley</code> to display debug data on <code>stderr</code>. The default value is <code>0</code>, and bigger numbers acti- vate more and more debuging informations.</p></dd></dl><dl><dt class="spec value" id="val-warn_merge"><a href="#val-warn_merge" class="anchor"></a><code><span class="keyword">val</span> warn_merge : bool <a href="../../ocaml/Stdlib/index.html#type-ref">Stdlib.ref</a></code></dt><dd><p><code>warn_merge</code> is a flag that is used to choose whether warnings are displayed or not when an ambiguity is encountered while parsing. The default value is <code>true</code>.</p></dd></dl><dl><dt class="spec value" id="val-keep_all_names"><a href="#val-keep_all_names" class="anchor"></a><code><span class="keyword">val</span> keep_all_names : bool <a href="../../ocaml/Stdlib/index.html#type-ref">Stdlib.ref</a></code></dt><dd><p><code>keep_all_names</code> is false by default and allow for inlining grammar with a name to optimise parsing. When debugging, it is possible to set it to true (before all grammar constructions) for more accurate messages.</p></dd></dl></section><section><header><h3 id="greedy-combinator"><a href="#greedy-combinator" class="anchor"></a>Greedy combinator</h3></header><dl><dt class="spec value" id="val-greedy"><a href="#val-greedy" class="anchor"></a><code><span class="keyword">val</span> greedy : <span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a></code></dt><dd><p><code>greedy g</code> parses g in a greedy way: only the longest match is considered. Still ambigous if the longest match is not unique</p></dd></dl></section><section><header><h3 id="sequencing-combinators"><a href="#sequencing-combinators" class="anchor"></a>Sequencing combinators</h3></header><dl><dt class="spec value" id="val-sequence"><a href="#val-sequence" class="anchor"></a><code><span class="keyword">val</span> sequence : <span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-grammar">grammar</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>) <span>&#45;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-grammar">grammar</a></code></dt><dd><p><code>sequence g1 g2 f</code> is a grammar that first parses using <code>g1</code>, and then parses using <code>g2</code>. The results of the sequence is then obtained by applying <code>f</code> to the results of <code>g1</code> and <code>g2</code>.</p></dd></dl><dl><dt class="spec value" id="val-sequence_position"><a href="#val-sequence_position" class="anchor"></a><code><span class="keyword">val</span> sequence_position : <span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-grammar">grammar</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>) <a href="index.html#type-fpos">fpos</a> <span>&#45;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-grammar">grammar</a></code></dt><dd><p><code>sequence_position g1 g2 f</code> is a grammar that first parses using <code>g1</code>, and then parses using <code>g2</code>. The results of the sequence is then obtained by applying <code>f</code> to the results of <code>g1</code> and <code>g2</code>, and to the positions (i.e. buffer and index) of the corresponding parsed input.</p><p>Remark: <code>sequence g1 g2 f</code> is equivalent to <code>sequence_position g1 g2 (fun _ _ _ _ -&gt; f)</code>.</p></dd></dl><dl><dt class="spec value" id="val-fsequence"><a href="#val-fsequence" class="anchor"></a><code><span class="keyword">val</span> fsequence : <span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <a href="index.html#type-grammar">grammar</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-grammar">grammar</a></code></dt><dd><p><code>fsequence g1 g2</code> is a grammar that first parses using <code>g1</code>, and then parses using <code>g2</code>. The results of the sequence is then obtained by applying the result of <code>g1</code> to the result of <code>g2</code>.</p><p>Remark: <code>fsequence g1 g2</code> is equivalent to <code>sequence g1 g2 (fun x f -&gt; f x)</code>.</p></dd></dl><dl><dt class="spec value" id="val-fsequence_position"><a href="#val-fsequence_position" class="anchor"></a><code><span class="keyword">val</span> fsequence_position : <span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <a href="index.html#type-fpos">fpos</a> <a href="index.html#type-grammar">grammar</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-grammar">grammar</a></code></dt><dd><p>same as fsequence, but the result of <code>g2</code> also receive the position of the result of <code>g1</code>.</p></dd></dl><dl><dt class="spec value" id="val-fsequence_ignore"><a href="#val-fsequence_ignore" class="anchor"></a><code><span class="keyword">val</span> fsequence_ignore : <span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-grammar">grammar</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-grammar">grammar</a></code></dt><dd><p>same as fsequence, but the result of <code>g2</code> receives nothing, meaning we forget the result of <code>g1</code>.</p></dd></dl><dl><dt class="spec value" id="val-sequence3"><a href="#val-sequence3" class="anchor"></a><code><span class="keyword">val</span> sequence3 : <span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-grammar">grammar</a> <span>&#45;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-grammar">grammar</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'d</span>) <span>&#45;&gt;</span> <span class="type-var">'d</span> <a href="index.html#type-grammar">grammar</a></code></dt><dd><p><code>sequence3</code> is similar to <code>sequence</code>, but it composes three grammars into a sequence.</p><p>Remark: <code>sequence3 g1 g2 g3 f</code> is equivalent to <code>sequence (sequence g1 g2 f) g3 (fun f x -&gt; f x)</code>.</p></dd></dl><dl><dt class="spec value" id="val-simple_dependent_sequence"><a href="#val-simple_dependent_sequence" class="anchor"></a><code><span class="keyword">val</span> simple_dependent_sequence : <span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-grammar">grammar</a>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-grammar">grammar</a></code></dt><dd><p><code>simple_dependent_sequence g1 g2</code> is a grammar that first parses using <code>g1</code>, which returns a value <code>a</code>, and then continues to parse with <code>g2 a</code> and return its result.</p></dd></dl><dl><dt class="spec value" id="val-dependent_sequence"><a href="#val-dependent_sequence" class="anchor"></a><code><span class="keyword">val</span> dependent_sequence : (<span class="type-var">'a</span> * <span class="type-var">'b</span>) <a href="index.html#type-grammar">grammar</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>) <a href="index.html#type-grammar">grammar</a>) <span>&#45;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-grammar">grammar</a></code></dt><dd><p><code>dependent_sequence g1 g2</code> is a grammar that first parses using <code>g1</code>, which returns a value <code>(a,b)</code>, and then continues to parse with <code>g2 a</code> and return its result applied to <code>b</code>. compared to the above function, allow memoizing the second grammar</p></dd></dl><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : <span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a> <a href="index.html#type-grammar">grammar</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a></code></dt><dd><p>= fun g -&gt; dependent_sequence g (fun x -&gt; x)</p></dd></dl><dl><dt class="spec value" id="val-option"><a href="#val-option" class="anchor"></a><code><span class="keyword">val</span> option : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a></code></dt><dd><p><code>option v g</code> tries to parse the input as <code>g</code>, and returns <code>v</code> in case of failure.</p></dd></dl><dl><dt class="spec value" id="val-fixpoint"><a href="#val-fixpoint" class="anchor"></a><code><span class="keyword">val</span> fixpoint : <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <a href="index.html#type-grammar">grammar</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a></code></dt><dd><p><code>fixpoint v g</code> parses a repetition of one or more times the input parsed by <code>g</code>. The value <code>v</code> is used as the initial value (i.e. to finish the sequence).</p><p>if parsing X with g returns a function gX, parsing X Y Z with fixpoint a g will return gX (gY (gZ a)).</p><p>This consumes stack proportinal to the input length ! use revfixpoint ...</p></dd></dl><dl><dt class="spec value" id="val-fixpoint'"><a href="#val-fixpoint'" class="anchor"></a><code><span class="keyword">val</span> fixpoint' : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-grammar">grammar</a> <span>&#45;&gt;</span> (<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a></code></dt><dt class="spec value" id="val-fixpoint1"><a href="#val-fixpoint1" class="anchor"></a><code><span class="keyword">val</span> fixpoint1 : <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <a href="index.html#type-grammar">grammar</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a></code></dt><dd><p>as <code>fixpoint</code> but parses at leat once with the given grammar</p></dd></dl><dl><dt class="spec value" id="val-fixpoint1'"><a href="#val-fixpoint1'" class="anchor"></a><code><span class="keyword">val</span> fixpoint1' : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-grammar">grammar</a> <span>&#45;&gt;</span> (<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a></code></dt><dt class="spec value" id="val-list0"><a href="#val-list0" class="anchor"></a><code><span class="keyword">val</span> list0 : <span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a> <span>&#45;&gt;</span> unit <a href="index.html#type-grammar">grammar</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <a href="index.html#type-grammar">grammar</a></code></dt><dd><p><code>listN g sep</code> parses sequences of <code>g</code> separated by <code>sep</code> of length at least <code>N</code>, for <code>N=0,1</code> or <code>2</code>.</p></dd></dl><dl><dt class="spec value" id="val-list1"><a href="#val-list1" class="anchor"></a><code><span class="keyword">val</span> list1 : <span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a> <span>&#45;&gt;</span> unit <a href="index.html#type-grammar">grammar</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <a href="index.html#type-grammar">grammar</a></code></dt><dt class="spec value" id="val-list2"><a href="#val-list2" class="anchor"></a><code><span class="keyword">val</span> list2 : <span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a> <span>&#45;&gt;</span> unit <a href="index.html#type-grammar">grammar</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <a href="index.html#type-grammar">grammar</a></code></dt><dt class="spec value" id="val-alternatives"><a href="#val-alternatives" class="anchor"></a><code><span class="keyword">val</span> alternatives : <span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a> list <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a></code></dt><dd><p><code>alternatives [g1;...;gn]</code> tries to parse using all the grammars <code>[g1;...;gn]</code> and keeps only the first success.</p></dd></dl><dl><dt class="spec value" id="val-apply"><a href="#val-apply" class="anchor"></a><code><span class="keyword">val</span> apply : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-grammar">grammar</a></code></dt><dd><p><code>apply f g</code> applies function <code>f</code> to the value returned by the grammar <code>g</code>.</p></dd></dl><dl><dt class="spec value" id="val-apply_position"><a href="#val-apply_position" class="anchor"></a><code><span class="keyword">val</span> apply_position : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <a href="index.html#type-fpos">fpos</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-grammar">grammar</a></code></dt><dd><p><code>apply_position f g</code> applies function <code>f</code> to the value returned by the grammar <code>g</code> and the positions at the beginning and at the end of the input parsed input.</p></dd></dl><dl><dt class="spec value" id="val-position"><a href="#val-position" class="anchor"></a><code><span class="keyword">val</span> position : <span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a> <span>&#45;&gt;</span> (string * int * int * int * int * <span class="type-var">'a</span>) <a href="index.html#type-grammar">grammar</a></code></dt><dd><p><code>position g</code> tranforms the grammar <code>g</code> to add information about the position of the parsed text.</p></dd></dl><dl><dt class="spec value" id="val-test"><a href="#val-test" class="anchor"></a><code><span class="keyword">val</span> test : ?&#8288;name:string <span>&#45;&gt;</span> <a href="../Earley_core/Charset/index.html#type-t">Earley_core.Charset.t</a> <span>&#45;&gt;</span> (<a href="../Earley_core/Input/index.html#type-buffer">Earley_core.Input.buffer</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> * bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a></code></dt><dd><p><code>test c f</code> perform a test <code>f</code> on the input buffer. Do not parse anything (position are unchanged). The charset <code>c</code> should contains all character accepted as at the position given to f</p></dd></dl><dl><dt class="spec value" id="val-blank_test"><a href="#val-blank_test" class="anchor"></a><code><span class="keyword">val</span> blank_test : ?&#8288;name:string <span>&#45;&gt;</span> <a href="../Earley_core/Charset/index.html#type-t">Earley_core.Charset.t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * bool) <a href="index.html#type-fpos">fpos</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a></code></dt><dd><p><code>blank_test c f</code> same as above except that <code>f</code> is applied to <code>buf' pos' buf pos</code> where <code>(buf', pos')</code> is the position before the blank. The charset c should contains all character accepted as at the position (buf,pos). This allow to test the presence of blank or even to read the blank and return some information</p></dd></dl><dl><dt class="spec value" id="val-with_blank_test"><a href="#val-with_blank_test" class="anchor"></a><code><span class="keyword">val</span> with_blank_test : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a></code></dt><dd><p>a test that fails if there is no blank</p></dd></dl><dl><dt class="spec value" id="val-no_blank_test"><a href="#val-no_blank_test" class="anchor"></a><code><span class="keyword">val</span> no_blank_test : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a></code></dt><dd><p>a test that fails if there are some blank</p></dd></dl><dl><dt class="spec value" id="val-grammar_family"><a href="#val-grammar_family" class="anchor"></a><code><span class="keyword">val</span> grammar_family : ?&#8288;param_to_string:(<span class="type-var">'a</span> <span>&#45;&gt;</span> string) <span>&#45;&gt;</span> string <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-grammar">grammar</a>) * ((<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-grammar">grammar</a>) <span>&#45;&gt;</span> unit)</code></dt><dd><p><code>grammar_family to_str name</code> returns a pair <code>(gs, set_gs)</code>, where <code>gs</code> is a finite family of grammars parametrized by a value of type <code>'a</code>. A name <code>name</code> is to be provided for the family, and an optional function <code>to_str</code> can be provided to print the parameter and display better error messages.</p></dd></dl><aside><pre><code class="ml">(* Declare the grammar family *)
let (gr, set_gr) = grammar_family to_str name in

... code using grammars of gr to define mutually recursive grammars ...
... the grammars in gr cannot be used in &quot;left position&quot; ...
... (same restriction as for declare_grammar ...

(* Define the grammar family *)
let _ = set_gr the_grammars

... now the new family can be used ...</code></pre></aside><dl><dt class="spec value" id="val-grammar_prio"><a href="#val-grammar_prio" class="anchor"></a><code><span class="keyword">val</span> grammar_prio : ?&#8288;param_to_string:(<span class="type-var">'b</span> <span>&#45;&gt;</span> string) <span>&#45;&gt;</span> string <span>&#45;&gt;</span> (<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-grammar">grammar</a>) * ((((<span class="type-var">'b</span> <span>&#45;&gt;</span> bool) * <span class="type-var">'c</span> <a href="index.html#type-grammar">grammar</a>) list * (<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-grammar">grammar</a> list)) <span>&#45;&gt;</span> unit)</code></dt><dd><p>Similar to the previous one, with an optimization. <code>grammar_prio to_str name</code> returns a pair <code>(gs, set_gs)</code>, where <code>gs</code> is a finite family of grammars parametrized by a value of type <code>'a</code>. <code>set_gs</code> requires two lists of grammars to set the value of the grammar:</p><ul><li>the first list are grammar that can only be activated by the parameter (if the given function return true)</li><li>the second list is used as for grammar family</li></ul></dd></dl><dl><dt class="spec value" id="val-grammar_prio_family"><a href="#val-grammar_prio_family" class="anchor"></a><code><span class="keyword">val</span> grammar_prio_family : ?&#8288;param_to_string:((<span class="type-var">'a</span> * <span class="type-var">'b</span>) <span>&#45;&gt;</span> string) <span>&#45;&gt;</span> string <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-grammar">grammar</a>) * ((<span class="type-var">'a</span> <span>&#45;&gt;</span> ((<span class="type-var">'b</span> <span>&#45;&gt;</span> bool) * <span class="type-var">'c</span> <a href="index.html#type-grammar">grammar</a>) list * (<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-grammar">grammar</a> list)) <span>&#45;&gt;</span> unit)</code></dt><dd><p>A mixture of the two above</p></dd></dl><dl><dt class="spec value" id="val-accept_empty"><a href="#val-accept_empty" class="anchor"></a><code><span class="keyword">val</span> accept_empty : <span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>accept_empty g</code> returns <code>true</code> if the grammar <code>g</code> accepts the empty input and <code>false</code> otherwise.</p></dd></dl><dl><dt class="spec value" id="val-grammar_info"><a href="#val-grammar_info" class="anchor"></a><code><span class="keyword">val</span> grammar_info : <span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a> <span>&#45;&gt;</span> bool * <a href="../Earley_core/Charset/index.html#type-t">Earley_core.Charset.t</a></code></dt><dt class="spec value" id="val-give_name"><a href="#val-give_name" class="anchor"></a><code><span class="keyword">val</span> give_name : string <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-grammar">grammar</a></code></dt><dd><p>give a name to the grammar. Usefull for debugging.</p></dd></dl></section></div></body></html>