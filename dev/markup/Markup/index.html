<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Markup (markup.Markup)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">markup</a> &#x00BB; Markup</nav><h1>Module <code>Markup</code></h1><p>Error-recovering streaming HTML and XML parsers and writers.</p><p>Markup.ml is an HTML and XML parsing and serialization library. It:</p><ul><li>Is error-recovering, so you can get a best-effort parse of malformed input.</li><li>Reports all errors before recovery, so you can get strict parsing instead.</li><li>Conforms closely to the XML grammar and HTML parser from the respective specifications.</li><li>Accepts document fragments, but can be told to accept only full documents.</li><li>Detects character encodings automatically.</li><li>Supports both simple synchronous (this module) and non-blocking usage (<code>Markup_lwt</code>).</li><li>Is streaming and lazy. Partial input is processed as soon as received, but only as needed.</li><li>Does one pass over the input and emits a stream of SAX-style parsing signals. A helper (<a href="index.html#val-tree"><code>tree</code></a>) allows that to be easily converted into DOM-style trees.</li></ul><p>The usage is straightforward. For example:</p><pre><code class="ml">open Markup

(* Correct and pretty-print HTML. *)
channel stdin
|&gt; parse_html |&gt; signals |&gt; pretty_print
|&gt; write_html |&gt; to_channel stdout

(* Show up to 10 XML well-formedness errors to the user. Stop after
   the 10th, without reading more input. *)
let report =
  let count = ref 0 in
  fun location error -&gt;
    error |&gt; Error.to_string ~location |&gt; prerr_endline;
    count := !count + 1;
    if !count &gt;= 10 then raise_notrace Exit

string &quot;some xml&quot; |&gt; parse_xml ~report |&gt; signals |&gt; drain

(* Load HTML into a custom document tree data type. *)
type html = Text of string | Element of string * html list

file &quot;some_file&quot;
|&gt; fst
|&gt; parse_html
|&gt; signals
|&gt; tree
  ~text:(fun ss -&gt; Text (String.concat &quot;&quot; ss))
  ~element:(fun (_, name) _ children -&gt; Element (name, children))</code></pre><p>The interface is centered around four functions. In pseudocode:</p><pre><code class="ml">val parse_html : char stream   -&gt; signal stream
val write_html : signal stream -&gt; char stream
val parse_xml  : char stream   -&gt; signal stream
val write_xml  : signal stream -&gt; char stream</code></pre><p>Most of the remaining functions create streams from, or write streams to, strings, files, and channels, or manipulate streams, such as <a href="index.html#val-next"><code>next</code></a> and the combinators <a href="index.html#val-map"><code>map</code></a> and <a href="index.html#val-fold"><code>fold</code></a>.</p><p>Apart from this module, Markup.ml provides two other top-level modules:</p><ul class="modules"><li><code>Markup_lwt</code></li><li><code>Markup_lwt_unix</code></li></ul><p>Most of the interface of <code>Markup_lwt</code> is specified in signature <a href="module-type-ASYNCHRONOUS/index.html"><code>ASYNCHRONOUS</code></a>, which will be shared with a <code>Markup_async</code> module, should it be implemented.</p><p>Markup.ml is developed on <a href="https://github.com/aantron/markup.ml">GitHub</a> and distributed under the <a href="https://github.com/aantron/markup.ml/blob/master/LICENSE.md">BSD license</a>. This documentation is for version 0.8.0 of the library. Documentation for older versions can be found on the <a href="https://github.com/aantron/markup.ml/releases">releases page</a>.</p><nav class="toc"><ul><li><a href="#streams">Streams</a></li><li><a href="#errors">Errors</a></li><li><a href="#encodings">Encodings</a></li><li><a href="#signals">Signals</a></li><li><a href="#parsers">Parsers</a></li><li><a href="#xml">XML</a></li><li><a href="#html">HTML</a></li><li><a href="#input-sources">Input sources</a></li><li><a href="#output-destinations">Output destinations</a></li><li><a href="#stream-operations">Stream operations</a></li><li><a href="#utility">Utility</a></li><li><a href="#namespaces">Namespaces</a></li><li><a href="#asynchronous-interface">Asynchronous interface</a></li><li><a href="#conformance-status">Conformance status</a><ul><li><a href="#to-be-corrected:">To be corrected:</a></li><li><a href="#to-remain:">To remain:</a></li></ul></li></ul></nav></header><section><header><h3 id="streams"><a href="#streams" class="anchor"></a>Streams</h3></header><dl><dt class="spec type" id="type-async"><a href="#type-async" class="anchor"></a><code><span class="keyword">type</span> async</code></dt><dt class="spec type" id="type-sync"><a href="#type-sync" class="anchor"></a><code><span class="keyword">type</span> sync</code></dt><dd><p>Phantom types for use with <code>('a, 's) stream</code> in place of <code>'s</code>. See explanation below.</p></dd></dl><dl><dt class="spec type" id="type-stream"><a href="#type-stream" class="anchor"></a><code><span class="keyword">type</span> ('a, 's) stream</code></dt><dd><p>Streams of elements of type <code>'a</code>.</p><p>In simple usage, when using only this module <code>Markup</code>, the additional type parameter <code>'s</code> is always <code>sync</code>, and there is no need to consider it further.</p><p>However, if you are using <code>Markup_lwt</code>, you may create some <code>async</code> streams. The difference between the two is that <a href="index.html#val-next"><code>next</code></a> on a <code>sync</code> stream retrieves an element before <a href="index.html#val-next"><code>next</code></a> &quot;returns,&quot; while <a href="index.html#val-next"><code>next</code></a> on an <code>async</code> stream might not retrieve an element until later. As a result, it is not safe to pass an <code>async</code> stream where a <code>sync</code> stream is required. The phantom types are used to make the type checker catch such errors at compile time.</p></dd></dl></section><section><header><h3 id="errors"><a href="#errors" class="anchor"></a>Errors</h3><p>The parsers recover from errors automatically. If that is sufficient, you can ignore this section. However, if you want stricter behavior, or need to debug parser output, use optional argument <code>?report</code> of the parsers, and look in module <a href="Error/index.html"><code>Error</code></a>.</p></header><dl><dt class="spec type" id="type-location"><a href="#type-location" class="anchor"></a><code><span class="keyword">type</span> location</code><code> = int * int</code></dt><dd><p>Line and column for parsing errors. Both numbers are one-based.</p></dd></dl><dl><dt class="spec module" id="module-Error"><a href="#module-Error" class="anchor"></a><code><span class="keyword">module</span> <a href="Error/index.html">Error</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Error type and <code>to_string</code> function.</p></dd></dl></section><section><header><h3 id="encodings"><a href="#encodings" class="anchor"></a>Encodings</h3><p>The parsers detect encodings automatically. If you need to specify an encoding, use optional argument <code>?encoding</code> of the parsers, and look in module <a href="Encoding/index.html"><code>Encoding</code></a>.</p></header><dl><dt class="spec module" id="module-Encoding"><a href="#module-Encoding" class="anchor"></a><code><span class="keyword">module</span> <a href="Encoding/index.html">Encoding</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Common Internet encodings such as UTF-8 and UTF-16; also includes some less popular encodings that are sometimes used for XML.</p></dd></dl></section><section><header><h3 id="signals"><a href="#signals" class="anchor"></a>Signals</h3></header><dl><dt class="spec type" id="type-name"><a href="#type-name" class="anchor"></a><code><span class="keyword">type</span> name</code><code> = string * string</code></dt><dd><p>Expanded name: a namespace URI followed by a local name.</p></dd></dl><dl><dt class="spec type" id="type-xml_declaration"><a href="#type-xml_declaration" class="anchor"></a><code><span class="keyword">type</span> xml_declaration</code><code> = </code><code>{</code><table class="record"><tr id="type-xml_declaration.version" class="anchored"><td class="def field"><a href="#type-xml_declaration.version" class="anchor"></a><code>version : string;</code></td></tr><tr id="type-xml_declaration.encoding" class="anchored"><td class="def field"><a href="#type-xml_declaration.encoding" class="anchor"></a><code>encoding : string option;</code></td></tr><tr id="type-xml_declaration.standalone" class="anchored"><td class="def field"><a href="#type-xml_declaration.standalone" class="anchor"></a><code>standalone : bool option;</code></td></tr></table><code>}</code></dt><dd><p>Representation of an XML declaration, i.e. <code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</code>.</p></dd></dl><dl><dt class="spec type" id="type-doctype"><a href="#type-doctype" class="anchor"></a><code><span class="keyword">type</span> doctype</code><code> = </code><code>{</code><table class="record"><tr id="type-doctype.doctype_name" class="anchored"><td class="def field"><a href="#type-doctype.doctype_name" class="anchor"></a><code>doctype_name : string option;</code></td></tr><tr id="type-doctype.public_identifier" class="anchored"><td class="def field"><a href="#type-doctype.public_identifier" class="anchor"></a><code>public_identifier : string option;</code></td></tr><tr id="type-doctype.system_identifier" class="anchored"><td class="def field"><a href="#type-doctype.system_identifier" class="anchor"></a><code>system_identifier : string option;</code></td></tr><tr id="type-doctype.raw_text" class="anchored"><td class="def field"><a href="#type-doctype.raw_text" class="anchor"></a><code>raw_text : string option;</code></td></tr><tr id="type-doctype.force_quirks" class="anchored"><td class="def field"><a href="#type-doctype.force_quirks" class="anchor"></a><code>force_quirks : bool;</code></td></tr></table><code>}</code></dt><dd><p>Representation of a document type declaration. The HTML parser fills in all fields besides <code>raw_text</code>. The XML parser reads declarations roughly, and fills only the <code>raw_text</code> field with the text found in the declaration.</p></dd></dl><dl><dt class="spec type" id="type-signal"><a href="#type-signal" class="anchor"></a><code><span class="keyword">type</span> signal</code> = <code>[ </code><table class="variant"><tr id="type-signal.Start_element" class="anchored"><td class="def constructor"><a href="#type-signal.Start_element" class="anchor"></a><code>| </code><code>`Start_element <span class="keyword">of</span> <a href="index.html#type-name">name</a> * (<a href="index.html#type-name">name</a> * string) list</code></td></tr><tr id="type-signal.End_element" class="anchored"><td class="def constructor"><a href="#type-signal.End_element" class="anchor"></a><code>| </code><code>`End_element</code></td></tr><tr id="type-signal.Text" class="anchored"><td class="def constructor"><a href="#type-signal.Text" class="anchor"></a><code>| </code><code>`Text <span class="keyword">of</span> string list</code></td></tr><tr id="type-signal.Doctype" class="anchored"><td class="def constructor"><a href="#type-signal.Doctype" class="anchor"></a><code>| </code><code>`Doctype <span class="keyword">of</span> <a href="index.html#type-doctype">doctype</a></code></td></tr><tr id="type-signal.Xml" class="anchored"><td class="def constructor"><a href="#type-signal.Xml" class="anchor"></a><code>| </code><code>`Xml <span class="keyword">of</span> <a href="index.html#type-xml_declaration">xml_declaration</a></code></td></tr><tr id="type-signal.PI" class="anchored"><td class="def constructor"><a href="#type-signal.PI" class="anchor"></a><code>| </code><code>`PI <span class="keyword">of</span> string * string</code></td></tr><tr id="type-signal.Comment" class="anchored"><td class="def constructor"><a href="#type-signal.Comment" class="anchor"></a><code>| </code><code>`Comment <span class="keyword">of</span> string</code></td></tr></table><code> ]</code></dt><dd><p>Parsing signals. The parsers emit them according to the following grammar:</p><pre><code class="ml">doc     ::= `Xml? misc* `Doctype? misc* element misc*
misc    ::= `PI | `Comment
element ::= `Start_element content* `End_element
content ::= `Text | element | `PI | `Comment</code></pre><p>As a result, emitted <code>`Start_element</code> and <code>`End_element</code> signals are always balanced, and, if there is an XML declaration, it is the first signal.</p><p>If parsing with <code>~context:`Document</code>, the signal sequence will match the <code>doc</code> production until the first error. If parsing with <code>~context:`Fragment</code>, it will match <code>content*</code>. If <code>~context</code> is not specified, the parser will pick one of the two by examining the input.</p><p>As an example, if the XML parser is parsing</p><pre><code class="ml">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;root&gt;text&lt;nested&gt;more text&lt;/nested&gt;&lt;/root&gt;</code></pre><p>it will emit the signal sequence</p><pre><code class="ml">`Xml {version = &quot;1.0&quot;; encoding = None; standalone = None}
`Start_element ((&quot;&quot;, &quot;root&quot;), [])
`Text [&quot;text&quot;]
`Start_element ((&quot;&quot;, &quot;nested&quot;), [])
`Text [&quot;more text&quot;]
`End_element
`End_element</code></pre><p>The <code>`Text</code> signal carries a <code>string list</code> instead of a single <code>string</code> because on 32-bit platforms, OCaml strings cannot be larger than 16MB. In case the parsers encounter a very long sequence of text, one whose length exceeds about <code>Sys.max_string_length / 2</code>, they will emit a <code>`Text</code> signal with several strings.</p></dd></dl><dl><dt class="spec type" id="type-content_signal"><a href="#type-content_signal" class="anchor"></a><code><span class="keyword">type</span> content_signal</code> = <code>[ </code><table class="variant"><tr id="type-content_signal.Start_element" class="anchored"><td class="def constructor"><a href="#type-content_signal.Start_element" class="anchor"></a><code>| </code><code>`Start_element <span class="keyword">of</span> <a href="index.html#type-name">name</a> * (<a href="index.html#type-name">name</a> * string) list</code></td></tr><tr id="type-content_signal.End_element" class="anchored"><td class="def constructor"><a href="#type-content_signal.End_element" class="anchor"></a><code>| </code><code>`End_element</code></td></tr><tr id="type-content_signal.Text" class="anchored"><td class="def constructor"><a href="#type-content_signal.Text" class="anchor"></a><code>| </code><code>`Text <span class="keyword">of</span> string list</code></td></tr></table><code> ]</code></dt><dd><p>A restriction of type <a href="index.html#type-signal"><code>signal</code></a> to only elements and text, i.e. no comments, processing instructions, or declarations. This can be useful for pattern matching in applications that only care about the content and element structure of a document. See the helper <a href="index.html#val-content"><code>content</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-signal_to_string"><a href="#val-signal_to_string" class="anchor"></a><code><span class="keyword">val</span> signal_to_string : [&lt; <a href="index.html#type-signal">signal</a> ] <span>&#45;&gt;</span> string</code></dt><dd><p>Provides a human-readable representation of signals for debugging.</p></dd></dl></section><section><header><h3 id="parsers"><a href="#parsers" class="anchor"></a>Parsers</h3></header><dl><dt class="spec type" id="type-parser"><a href="#type-parser" class="anchor"></a><code><span class="keyword">type</span> 's parser</code></dt><dd><p>An <code>'s parser</code> is a thin wrapper around a <code>(signal, 's) stream</code> that supports access to additional information that is not carried directly in the stream, such as source locations.</p></dd></dl><dl><dt class="spec value" id="val-signals"><a href="#val-signals" class="anchor"></a><code><span class="keyword">val</span> signals : <span class="type-var">'s</span> <a href="index.html#type-parser">parser</a> <span>&#45;&gt;</span> (<a href="index.html#type-signal">signal</a>,Â <span class="type-var">'s</span>) <a href="index.html#type-stream">stream</a></code></dt><dd><p>Converts a parser to its underlying signal stream.</p></dd></dl><dl><dt class="spec value" id="val-location"><a href="#val-location" class="anchor"></a><code><span class="keyword">val</span> location : <span class="type-var">_</span> <a href="index.html#type-parser">parser</a> <span>&#45;&gt;</span> <a href="index.html#type-location">location</a></code></dt><dd><p>Evaluates to the location of the last signal emitted on the parser's signal stream. If no signals have yet been emitted, evaluates to <code>(1, 1)</code>.</p></dd></dl></section><section><header><h3 id="xml"><a href="#xml" class="anchor"></a>XML</h3></header><dl><dt class="spec value" id="val-parse_xml"><a href="#val-parse_xml" class="anchor"></a><code><span class="keyword">val</span> parse_xml : ?&#8288;report:(<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="Error/index.html#type-t">Error.t</a> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> ?&#8288;encoding:<a href="Encoding/index.html#type-t">Encoding.t</a> <span>&#45;&gt;</span> ?&#8288;namespace:(string <span>&#45;&gt;</span> string option) <span>&#45;&gt;</span> ?&#8288;entity:(string <span>&#45;&gt;</span> string option) <span>&#45;&gt;</span> ?&#8288;context:[&lt; `Document | `Fragment ] <span>&#45;&gt;</span> (char,Â <span class="type-var">'s</span>) <a href="index.html#type-stream">stream</a> <span>&#45;&gt;</span> <span class="type-var">'s</span> <a href="index.html#type-parser">parser</a></code></dt><dd><p>Creates a parser that converts an XML byte stream to a signal stream.</p><p>For simple usage, <code>string &quot;foo&quot; |&gt; parse_xml |&gt; signals</code>.</p><p>If <code>~report</code> is provided, <code>report</code> is called for every error encountered. You may raise an exception in <code>report</code>, and it will propagate to the code reading the signal stream.</p><p>If <code>~encoding</code> is <em>not</em> specified, the parser detects the input encoding automatically. Otherwise, the given encoding is used.</p><p><code>~namespace</code> is called when the parser is unable to resolve a namespace prefix. If it evaluates to <code>Some s</code>, the parser maps the prefix to <code>s</code>. Otherwise, the parser reports <code>`Bad_namespace</code>.</p><p><code>~entity</code> is called when the parser is unable to resolve an entity reference. If it evaluates to <code>Some s</code>, the parser inserts <code>s</code> into the text or attribute being parsed without any further parsing of <code>s</code>. <code>s</code> is assumed to be encoded in UTF-8. If <code>entity</code> evaluates to <code>None</code> instead, the parser reports <code>`Bad_token</code>. See <a href="index.html#val-xhtml_entity"><code>xhtml_entity</code></a> if you are parsing XHTML.</p><p>The meaning of <code>~context</code> is described at <a href="index.html#type-signal"><code>signal</code></a>, above.</p></dd></dl><dl><dt class="spec value" id="val-write_xml"><a href="#val-write_xml" class="anchor"></a><code><span class="keyword">val</span> write_xml : ?&#8288;report:((<a href="index.html#type-signal">signal</a> * int) <span>&#45;&gt;</span> <a href="Error/index.html#type-t">Error.t</a> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> ?&#8288;prefix:(string <span>&#45;&gt;</span> string option) <span>&#45;&gt;</span> ([&lt; <a href="index.html#type-signal">signal</a> ],Â <span class="type-var">'s</span>) <a href="index.html#type-stream">stream</a> <span>&#45;&gt;</span> (char,Â <span class="type-var">'s</span>) <a href="index.html#type-stream">stream</a></code></dt><dd><p>Converts an XML signal stream to a byte stream.</p><p>If <code>~report</code> is provided, it is called for every error encountered. The first argument is a pair of the signal causing the error and its index in the signal stream. You may raise an exception in <code>report</code>, and it will propagate to the code reading the byte stream.</p><p><code>~prefix</code> is called when the writer is unable to find a prefix in scope for a namespace URI. If it evaluates to <code>Some s</code>, the writer uses <code>s</code> for the URI. Otherwise, the writer reports <code>`Bad_namespace</code>.</p></dd></dl></section><section><header><h3 id="html"><a href="#html" class="anchor"></a>HTML</h3></header><dl><dt class="spec value" id="val-parse_html"><a href="#val-parse_html" class="anchor"></a><code><span class="keyword">val</span> parse_html : ?&#8288;report:(<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="Error/index.html#type-t">Error.t</a> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> ?&#8288;encoding:<a href="Encoding/index.html#type-t">Encoding.t</a> <span>&#45;&gt;</span> ?&#8288;context:[&lt; `Document | `Fragment of string ] <span>&#45;&gt;</span> (char,Â <span class="type-var">'s</span>) <a href="index.html#type-stream">stream</a> <span>&#45;&gt;</span> <span class="type-var">'s</span> <a href="index.html#type-parser">parser</a></code></dt><dd><p>Similar to <a href="index.html#val-parse_xml"><code>parse_xml</code></a>, but parses HTML with embedded SVG and MathML, never emits signals <code>`Xml</code> or <code>`PI</code>, and <code>~context</code> has a different type on tag <code>`Fragment</code>.</p><p>For HTML fragments, you should specify the enclosing element, e.g. <code>`Fragment &quot;body&quot;</code>. This is because, when parsing HTML, error recovery and the interpretation of text depend on the current element. For example, the text</p><pre><code class="ml">foo&lt;/bar&gt;</code></pre><p>parses differently in <code>title</code> elements than in <code>p</code> elements. In the former, it is parsed as <code>foo&lt;/bar&gt;</code>, while in the latter, it is <code>foo</code> followed by a parse error due to unmatched tag <code>&lt;/bar&gt;</code>. To get these behaviors, set <code>~context</code> to <code>`Fragment &quot;title&quot;</code> and <code>`Fragment &quot;p&quot;</code>, respectively.</p><p>If you use <code>`Fragment &quot;svg&quot;</code>, the fragment is assumed to be SVG markup. Likewise, <code>`Fragment &quot;math&quot;</code> causes the parser to parse MathML markup.</p><p>If <code>~context</code> is omitted, the parser guesses it from the input stream. For example, if the first signal would be <code>`Doctype</code>, the context is set to <code>`Document</code>, but if the first signal would be <code>`Start_element &quot;td&quot;</code>, the context is set to <code>`Fragment &quot;tr&quot;</code>. If the first signal would be <code>`Start_element &quot;g&quot;</code>, the context is set to <code>`Fragment &quot;svg&quot;</code>.</p></dd></dl><dl><dt class="spec value" id="val-write_html"><a href="#val-write_html" class="anchor"></a><code><span class="keyword">val</span> write_html : ([&lt; <a href="index.html#type-signal">signal</a> ],Â <span class="type-var">'s</span>) <a href="index.html#type-stream">stream</a> <span>&#45;&gt;</span> (char,Â <span class="type-var">'s</span>) <a href="index.html#type-stream">stream</a></code></dt><dd><p>Similar to <a href="index.html#val-write_xml"><code>write_xml</code></a>, but emits HTML5 instead of XML.</p></dd></dl></section><section><header><h3 id="input-sources"><a href="#input-sources" class="anchor"></a>Input sources</h3></header><dl><dt class="spec value" id="val-string"><a href="#val-string" class="anchor"></a><code><span class="keyword">val</span> string : string <span>&#45;&gt;</span> (char,Â <a href="index.html#type-sync">sync</a>) <a href="index.html#type-stream">stream</a></code></dt><dd><p>Evaluates to a stream that retrieves successive bytes from the given string.</p></dd></dl><dl><dt class="spec value" id="val-buffer"><a href="#val-buffer" class="anchor"></a><code><span class="keyword">val</span> buffer : <a href="../../ocaml/Stdlib/Buffer/index.html#type-t">Stdlib.Buffer.t</a> <span>&#45;&gt;</span> (char,Â <a href="index.html#type-sync">sync</a>) <a href="index.html#type-stream">stream</a></code></dt><dd><p>Evaluates to a stream that retrieves successive bytes from the given buffer. Be careful of changing the buffer while it is being iterated by the stream.</p></dd></dl><dl><dt class="spec value" id="val-channel"><a href="#val-channel" class="anchor"></a><code><span class="keyword">val</span> channel : <a href="../../ocaml/Stdlib/Pervasives/index.html#type-in_channel">Stdlib.Pervasives.in_channel</a> <span>&#45;&gt;</span> (char,Â <a href="index.html#type-sync">sync</a>) <a href="index.html#type-stream">stream</a></code></dt><dd><p>Evaluates to a stream that retrieves bytes from the given channel. If the channel cannot be read, the next read of the stream results in raising <code>Sys_error</code>.</p><p>Note that this input source is synchronous because <code>Pervasives.in_channel</code> reads are blocking. For non-blocking channels, see <code>Markup_lwt_unix</code>.</p></dd></dl><dl><dt class="spec value" id="val-file"><a href="#val-file" class="anchor"></a><code><span class="keyword">val</span> file : string <span>&#45;&gt;</span> (char,Â <a href="index.html#type-sync">sync</a>) <a href="index.html#type-stream">stream</a> * (unit <span>&#45;&gt;</span> unit)</code></dt><dd><p><code>file path</code> opens the file at <code>path</code>, then evaluates to a pair <code>s, close</code>, where reading from stream <code>s</code> retrieves successive bytes from the file, and calling <code>close ()</code> closes the file.</p><p>The file is closed automatically if <code>s</code> is read to completion, or if reading <code>s</code> raises an exception. It is not necessary to call <code>close ()</code> in these cases.</p><p>If the file cannot be opened, raises <code>Sys_error</code> immediately. If the file cannot be read, reading the stream raises <code>Sys_error</code>.</p></dd></dl><dl><dt class="spec value" id="val-fn"><a href="#val-fn" class="anchor"></a><code><span class="keyword">val</span> fn : (unit <span>&#45;&gt;</span> char option) <span>&#45;&gt;</span> (char,Â <a href="index.html#type-sync">sync</a>) <a href="index.html#type-stream">stream</a></code></dt><dd><p><code>fn f</code> is a stream that retrives bytes by calling <code>f ()</code>. If the call results in <code>Some c</code>, the stream emits <code>c</code>. If the call results in <code>None</code>, the stream is considered to have ended.</p><p>This is actually an alias for <a href="index.html#type-stream"><code>stream</code></a>, restricted to type <code>char</code>.</p></dd></dl></section><section><header><h3 id="output-destinations"><a href="#output-destinations" class="anchor"></a>Output destinations</h3></header><dl><dt class="spec value" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span class="keyword">val</span> to_string : (char,Â <a href="index.html#type-sync">sync</a>) <a href="index.html#type-stream">stream</a> <span>&#45;&gt;</span> string</code></dt><dd><p>Eagerly retrieves bytes from the given stream and assembles a string.</p></dd></dl><dl><dt class="spec value" id="val-to_buffer"><a href="#val-to_buffer" class="anchor"></a><code><span class="keyword">val</span> to_buffer : (char,Â <a href="index.html#type-sync">sync</a>) <a href="index.html#type-stream">stream</a> <span>&#45;&gt;</span> <a href="../../ocaml/Stdlib/Buffer/index.html#type-t">Stdlib.Buffer.t</a></code></dt><dd><p>Eagerly retrieves bytes from the given stream and places them into a buffer.</p></dd></dl><dl><dt class="spec value" id="val-to_channel"><a href="#val-to_channel" class="anchor"></a><code><span class="keyword">val</span> to_channel : <a href="../../ocaml/Stdlib/Pervasives/index.html#type-out_channel">Stdlib.Pervasives.out_channel</a> <span>&#45;&gt;</span> (char,Â <a href="index.html#type-sync">sync</a>) <a href="index.html#type-stream">stream</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Eagerly retrieves bytes from the given stream and writes them to the given channel. If writing fails, raises <code>Sys_error</code>.</p></dd></dl><dl><dt class="spec value" id="val-to_file"><a href="#val-to_file" class="anchor"></a><code><span class="keyword">val</span> to_file : string <span>&#45;&gt;</span> (char,Â <a href="index.html#type-sync">sync</a>) <a href="index.html#type-stream">stream</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Eagerly retrieves bytes from the given stream and writes them to the given file. If writing fails, or the file cannot be opened, raises <code>Sys_error</code>. Note that the file is truncated (cleared) before writing. If you wish to append to file, open it with the appropriate flags and use <code>to_channel</code> on the resulting channel.</p></dd></dl></section><section><header><h3 id="stream-operations"><a href="#stream-operations" class="anchor"></a>Stream operations</h3></header><dl><dt class="spec value" id="val-stream"><a href="#val-stream" class="anchor"></a><code><span class="keyword">val</span> stream : (unit <span>&#45;&gt;</span> <span class="type-var">'a</span> option) <span>&#45;&gt;</span> (<span class="type-var">'a</span>,Â <a href="index.html#type-sync">sync</a>) <a href="index.html#type-stream">stream</a></code></dt><dd><p><code>stream f</code> creates a stream that repeatedly calls <code>f ()</code>. Each time <code>f ()</code> evaluates to <code>Some v</code>, the next item in the stream is <code>v</code>. The first time <code>f ()</code> evaluates to <code>None</code>, the stream ends.</p></dd></dl><dl><dt class="spec value" id="val-next"><a href="#val-next" class="anchor"></a><code><span class="keyword">val</span> next : (<span class="type-var">'a</span>,Â <a href="index.html#type-sync">sync</a>) <a href="index.html#type-stream">stream</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt><dd><p>Retrieves the next item in the stream, if any, and removes it from the stream.</p></dd></dl><dl><dt class="spec value" id="val-peek"><a href="#val-peek" class="anchor"></a><code><span class="keyword">val</span> peek : (<span class="type-var">'a</span>,Â <a href="index.html#type-sync">sync</a>) <a href="index.html#type-stream">stream</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt><dd><p>Retrieves the next item in the stream, if any, but does not remove the item from the stream.</p></dd></dl><dl><dt class="spec value" id="val-transform"><a href="#val-transform" class="anchor"></a><code><span class="keyword">val</span> transform : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> list * <span class="type-var">'a</span> option) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'b</span>,Â <span class="type-var">'s</span>) <a href="index.html#type-stream">stream</a> <span>&#45;&gt;</span> (<span class="type-var">'c</span>,Â <span class="type-var">'s</span>) <a href="index.html#type-stream">stream</a></code></dt><dd><p><code>transform f init s</code> lazily creates a stream by repeatedly applying <code>f acc v</code>, where <code>acc</code> is an accumulator whose initial value is <code>init</code>, and <code>v</code> is consecutive values of <code>s</code>. Each time, <code>f acc v</code> evaluates to a pair <code>(vs, maybe_acc')</code>. The values <code>vs</code> are added to the result stream. If <code>maybe_acc'</code> is <code>Some acc'</code>, the accumulator is set to <code>acc'</code>. Otherwise, if <code>maybe_acc'</code> is <code>None</code>, the result stream ends.</p></dd></dl><dl><dt class="spec value" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span class="keyword">val</span> fold : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'b</span>,Â <a href="index.html#type-sync">sync</a>) <a href="index.html#type-stream">stream</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>fold f init s</code> eagerly folds over the items <code>v</code>, <code>v'</code>, <code>v''</code>, ... of <code>s</code>, i.e. evaluates <code>f (f (f init v) v') v''</code>...</p></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> (<span class="type-var">'a</span>,Â <span class="type-var">'s</span>) <a href="index.html#type-stream">stream</a> <span>&#45;&gt;</span> (<span class="type-var">'b</span>,Â <span class="type-var">'s</span>) <a href="index.html#type-stream">stream</a></code></dt><dd><p><code>map f s</code> lazily applies <code>f</code> to each item of <code>s</code>, and produces the resulting stream.</p></dd></dl><dl><dt class="spec value" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span class="keyword">val</span> filter : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> (<span class="type-var">'a</span>,Â <span class="type-var">'s</span>) <a href="index.html#type-stream">stream</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>,Â <span class="type-var">'s</span>) <a href="index.html#type-stream">stream</a></code></dt><dd><p><code>filter f s</code> is <code>s</code> without the items for which <code>f</code> evaluates to <code>false</code>. <code>filter</code> is lazy.</p></dd></dl><dl><dt class="spec value" id="val-filter_map"><a href="#val-filter_map" class="anchor"></a><code><span class="keyword">val</span> filter_map : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> option) <span>&#45;&gt;</span> (<span class="type-var">'a</span>,Â <span class="type-var">'s</span>) <a href="index.html#type-stream">stream</a> <span>&#45;&gt;</span> (<span class="type-var">'b</span>,Â <span class="type-var">'s</span>) <a href="index.html#type-stream">stream</a></code></dt><dd><p><code>filter_map f s</code> lazily applies <code>f</code> to each item <code>v</code> of <code>s</code>. If <code>f v</code> evaluates to <code>Some v'</code>, the result stream has <code>v'</code>. If <code>f v</code> evaluates to <code>None</code>, no item corresponding to <code>v</code> appears in the result stream.</p></dd></dl><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : (<span class="type-var">'a</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> (<span class="type-var">'a</span>,Â <a href="index.html#type-sync">sync</a>) <a href="index.html#type-stream">stream</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>iter f s</code> eagerly applies <code>f</code> to each item of <code>s</code>, i.e. evaluates <code>f v; f v'; f v''</code>...</p></dd></dl><dl><dt class="spec value" id="val-drain"><a href="#val-drain" class="anchor"></a><code><span class="keyword">val</span> drain : (<span class="type-var">'a</span>,Â <a href="index.html#type-sync">sync</a>) <a href="index.html#type-stream">stream</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>drain s</code> eagerly consumes <code>s</code>. This is useful for observing side effects, such as parsing errors, when you don't care about the parsing signals themselves. It is equivalent to <code>iter ignore s</code>.</p></dd></dl><dl><dt class="spec value" id="val-of_list"><a href="#val-of_list" class="anchor"></a><code><span class="keyword">val</span> of_list : <span class="type-var">'a</span> list <span>&#45;&gt;</span> (<span class="type-var">'a</span>,Â <a href="index.html#type-sync">sync</a>) <a href="index.html#type-stream">stream</a></code></dt><dd><p>Produces a (lazy) stream from the given list.</p></dd></dl><dl><dt class="spec value" id="val-to_list"><a href="#val-to_list" class="anchor"></a><code><span class="keyword">val</span> to_list : (<span class="type-var">'a</span>,Â <a href="index.html#type-sync">sync</a>) <a href="index.html#type-stream">stream</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>Eagerly converts the given stream to a list.</p></dd></dl></section><section><header><h3 id="utility"><a href="#utility" class="anchor"></a>Utility</h3></header><dl><dt class="spec value" id="val-content"><a href="#val-content" class="anchor"></a><code><span class="keyword">val</span> content : ([&lt; <a href="index.html#type-signal">signal</a> ],Â <span class="type-var">'s</span>) <a href="index.html#type-stream">stream</a> <span>&#45;&gt;</span> (<a href="index.html#type-content_signal">content_signal</a>,Â <span class="type-var">'s</span>) <a href="index.html#type-stream">stream</a></code></dt><dd><p>Converts a <a href="index.html#type-signal"><code>signal</code></a> stream into a <a href="index.html#type-content_signal"><code>content_signal</code></a> stream by filtering out all signals besides <code>`Start_element</code>, <code>`End_element</code>, and <code>`Text</code>.</p></dd></dl><dl><dt class="spec value" id="val-tree"><a href="#val-tree" class="anchor"></a><code><span class="keyword">val</span> tree : ?&#8288;text:(string list <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> ?&#8288;element:(<a href="index.html#type-name">name</a> <span>&#45;&gt;</span> (<a href="index.html#type-name">name</a> * string) list <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> ?&#8288;comment:(string <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> ?&#8288;pi:(string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> ?&#8288;xml:(<a href="index.html#type-xml_declaration">xml_declaration</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> ?&#8288;doctype:(<a href="index.html#type-doctype">doctype</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> ([&lt; <a href="index.html#type-signal">signal</a> ],Â <a href="index.html#type-sync">sync</a>) <a href="index.html#type-stream">stream</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt><dd><p>This function's type signature may look intimidating, but it is actually easy to use. It is best introduced by example:</p><pre><code class="ml">type my_dom = Text of string | Element of name * my_dom list

&quot;&lt;p&gt;HTML5 is &lt;em&gt;easy&lt;/em&gt; to parse&quot;
|&gt; string
|&gt; parse_html
|&gt; signals
|&gt; tree
  ~text:(fun ss -&gt; Text (String.concat &quot;&quot; ss))
  ~element:(fun (name, _) children -&gt; Element (name, children))</code></pre><p>results in the structure</p><pre><code class="ml">Element (&quot;p&quot; [
  Text &quot;HTML5 is &quot;;
  Element (&quot;em&quot;, [Text &quot;easy&quot;]);
  Text &quot; to parse&quot;])</code></pre><p>Formally, <code>tree</code> assembles a tree data structure of type <code>'a</code> from a signal stream. The stream is parsed according to the following grammar:</p><pre><code class="ml">stream  ::= node*
node    ::= element | `Text | `Comment | `PI | `Xml | `Doctype
element ::= `Start_element node* `End_element</code></pre><p>Each time <code>trees</code> matches a production of <code>node</code>, it calls the corresponding function to convert the node into your tree type <code>'a</code>. For example, when <code>trees</code> matches <code>`Text ss</code>, it calls <code>~text ss</code>, if <code>~text</code> is supplied. Similarly, when <code>trees</code> matches <code>element</code>, it calls <code>~element name attributes children</code>, if <code>~element</code> is supplied.</p><p>See <a href="index.html#val-trees"><code>trees</code></a> if the input stream might have multiple top-level trees. This function <code>tree</code> only retrieves the first one.</p></dd></dl><dl><dt class="spec value" id="val-trees"><a href="#val-trees" class="anchor"></a><code><span class="keyword">val</span> trees : ?&#8288;text:(string list <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> ?&#8288;element:(<a href="index.html#type-name">name</a> <span>&#45;&gt;</span> (<a href="index.html#type-name">name</a> * string) list <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> ?&#8288;comment:(string <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> ?&#8288;pi:(string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> ?&#8288;xml:(<a href="index.html#type-xml_declaration">xml_declaration</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> ?&#8288;doctype:(<a href="index.html#type-doctype">doctype</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> ([&lt; <a href="index.html#type-signal">signal</a> ],Â <span class="type-var">'s</span>) <a href="index.html#type-stream">stream</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>,Â <span class="type-var">'s</span>) <a href="index.html#type-stream">stream</a></code></dt><dd><p>Like <a href="index.html#val-tree"><code>tree</code></a>, but converts all top-level trees, not only the first one. The trees are emitted on the resulting stream, in the sequence that they appear in the input.</p></dd></dl><dl><dt class="spec type" id="type-node"><a href="#type-node" class="anchor"></a><code><span class="keyword">type</span> 'a node</code> = <code>[ </code><table class="variant"><tr id="type-node.Element" class="anchored"><td class="def constructor"><a href="#type-node.Element" class="anchor"></a><code>| </code><code>`Element <span class="keyword">of</span> <a href="index.html#type-name">name</a> * (<a href="index.html#type-name">name</a> * string) list * <span class="type-var">'a</span> list</code></td></tr><tr id="type-node.Text" class="anchored"><td class="def constructor"><a href="#type-node.Text" class="anchor"></a><code>| </code><code>`Text <span class="keyword">of</span> string</code></td></tr><tr id="type-node.Doctype" class="anchored"><td class="def constructor"><a href="#type-node.Doctype" class="anchor"></a><code>| </code><code>`Doctype <span class="keyword">of</span> <a href="index.html#type-doctype">doctype</a></code></td></tr><tr id="type-node.Xml" class="anchored"><td class="def constructor"><a href="#type-node.Xml" class="anchor"></a><code>| </code><code>`Xml <span class="keyword">of</span> <a href="index.html#type-xml_declaration">xml_declaration</a></code></td></tr><tr id="type-node.PI" class="anchored"><td class="def constructor"><a href="#type-node.PI" class="anchor"></a><code>| </code><code>`PI <span class="keyword">of</span> string * string</code></td></tr><tr id="type-node.Comment" class="anchored"><td class="def constructor"><a href="#type-node.Comment" class="anchor"></a><code>| </code><code>`Comment <span class="keyword">of</span> string</code></td></tr></table><code> ]</code></dt><dd><p>See <a href="index.html#val-from_tree"><code>from_tree</code></a> below.</p></dd></dl><dl><dt class="spec value" id="val-from_tree"><a href="#val-from_tree" class="anchor"></a><code><span class="keyword">val</span> from_tree : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-node">node</a>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> (<a href="index.html#type-signal">signal</a>,Â <a href="index.html#type-sync">sync</a>) <a href="index.html#type-stream">stream</a></code></dt><dd><p>Deconstructs tree data structures of type <code>'a</code> into signal streams. The function argument is applied to each data structure node. For example,</p><pre><code class="ml">type my_dom = Text of string | Element of string * my_dom list

let dom =
  Element (&quot;p&quot;, [
    Text &quot;HTML5 is &quot;;
    Element (&quot;em&quot;, [Text &quot;easy&quot;]);
    Text &quot; to parse&quot;])

dom |&gt; from_tree (function
  | Text s -&gt; `Text s
  | Element (name, children) -&gt; `Element ((&quot;&quot;, name), [], children))</code></pre><p>results in the signal stream</p><pre><code class="ml">`Start_element ((&quot;&quot;, &quot;p&quot;), [])
`Text [&quot;HTML5 is &quot;]
`Start_element ((&quot;&quot;, &quot;em&quot;), [])
`Text [&quot;easy&quot;]
`End_element
`Text &quot; to parse&quot;
`End_element</code></pre></dd></dl><dl><dt class="spec value" id="val-elements"><a href="#val-elements" class="anchor"></a><code><span class="keyword">val</span> elements : (<a href="index.html#type-name">name</a> <span>&#45;&gt;</span> (<a href="index.html#type-name">name</a> * string) list <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> ([&lt; <a href="index.html#type-signal">signal</a> ] <span class="keyword">as</span> a,Â <span class="type-var">'s</span>) <a href="index.html#type-stream">stream</a> <span>&#45;&gt;</span> ((<span class="type-var">'a</span>,Â <span class="type-var">'s</span>) <a href="index.html#type-stream">stream</a>,Â <span class="type-var">'s</span>) <a href="index.html#type-stream">stream</a></code></dt><dd><p><code>elements f s</code> scans the signal stream <code>s</code> for <code>`Start_element (name, attributes)</code> signals that satisfy <code>f name attributes</code>. Each such matching signal is the beginning of a substream that ends with the corresponding <code>`End_element</code> signal. The result of <code>elements f s</code> is the stream of these substreams.</p><p>Matches don't nest. If there is a matching element contained in another matching element, only the top one results in a substream.</p><p>Code using <code>elements</code> does not have to read each substream to completion, or at all. However, once the using code has tried to get the next substream, it should not try to read a previous one.</p></dd></dl><dl><dt class="spec value" id="val-text"><a href="#val-text" class="anchor"></a><code><span class="keyword">val</span> text : ([&lt; <a href="index.html#type-signal">signal</a> ],Â <span class="type-var">'s</span>) <a href="index.html#type-stream">stream</a> <span>&#45;&gt;</span> (char,Â <span class="type-var">'s</span>) <a href="index.html#type-stream">stream</a></code></dt><dd><p>Extracts all the text in a signal stream by discarding all markup. For each <code>`Text ss</code> signal, the result stream has the bytes of the strings <code>ss</code>, and all other signals are ignored.</p></dd></dl><dl><dt class="spec value" id="val-trim"><a href="#val-trim" class="anchor"></a><code><span class="keyword">val</span> trim : ([&gt; <a href="index.html#type-content_signal">content_signal</a> ] <span class="keyword">as</span> a,Â <span class="type-var">'s</span>) <a href="index.html#type-stream">stream</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>,Â <span class="type-var">'s</span>) <a href="index.html#type-stream">stream</a></code></dt><dd><p>Trims insignificant whitespace in an HTML signal stream. Whitespace around flow (&quot;block&quot;) content does not matter, but whitespace in phrasing (&quot;inline&quot;) content does. So, if the input stream is</p><pre><code class="ml">&lt;div&gt;
 &lt;p&gt;
  &lt;em&gt;foo&lt;/em&gt; bar
 &lt;/p&gt;
&lt;/div&gt;</code></pre><p>passing it through <code>Markup.trim</code> will result in</p><pre><code class="ml">&lt;div&gt;&lt;p&gt;&lt;em&gt;foo&lt;/em&gt; bar&lt;/p&gt;&lt;/div&gt;</code></pre><p>Note that whitespace around the <code>&lt;/em&gt;</code> tag was preserved.</p></dd></dl><dl><dt class="spec value" id="val-normalize_text"><a href="#val-normalize_text" class="anchor"></a><code><span class="keyword">val</span> normalize_text : ([&gt; `Text of string list ] <span class="keyword">as</span> a,Â <span class="type-var">'s</span>) <a href="index.html#type-stream">stream</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>,Â <span class="type-var">'s</span>) <a href="index.html#type-stream">stream</a></code></dt><dd><p>Concatenates adjacent <code>`Text</code> signals, then eliminates all empty strings, then all <code>`Text []</code> signals. Signals besides <code>`Text</code> are unaffected. Note that signal streams emitted by the parsers already have normalized text. This function is useful when you are inserting text into a signal stream after parsing, or generating streams from scratch, and would like to clean up the <code>`Text</code> signals.</p></dd></dl><dl><dt class="spec value" id="val-pretty_print"><a href="#val-pretty_print" class="anchor"></a><code><span class="keyword">val</span> pretty_print : ([&gt; <a href="index.html#type-content_signal">content_signal</a> ] <span class="keyword">as</span> a,Â <span class="type-var">'s</span>) <a href="index.html#type-stream">stream</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>,Â <span class="type-var">'s</span>) <a href="index.html#type-stream">stream</a></code></dt><dd><p>Adjusts the whitespace in the <code>`Text</code> signals in the given stream so that the output appears nicely-indented when the stream is converted to bytes and written.</p><p>This function is aware of the significance of whitespace in HTML, so it avoids changing the whitespace in phrasing (&quot;inline&quot;) content. For example, pretty printing</p><pre><code class="ml">&lt;div&gt;&lt;p&gt;&lt;em&gt;foo&lt;/em&gt;bar&lt;/p&gt;&lt;/div&gt;</code></pre><p>results in</p><pre><code class="ml">&lt;div&gt;
 &lt;p&gt;
  &lt;em&gt;foo&lt;/em&gt;bar
 &lt;/p&gt;
&lt;/div&gt;</code></pre><p>Note that no whitespace was inserted around <code>&lt;em&gt;</code> and <code>&lt;/em&gt;</code>, because doing so would create a word break that wasn't present in the original stream.</p></dd></dl><dl><dt class="spec value" id="val-html5"><a href="#val-html5" class="anchor"></a><code><span class="keyword">val</span> html5 : ([&lt; <a href="index.html#type-signal">signal</a> ],Â <span class="type-var">'s</span>) <a href="index.html#type-stream">stream</a> <span>&#45;&gt;</span> (<a href="index.html#type-signal">signal</a>,Â <span class="type-var">'s</span>) <a href="index.html#type-stream">stream</a></code></dt><dd><p>Converts a signal stream into an HTML5 signal stream by stripping any document type declarations, XML declarations, and processing instructions, and prefixing the HTML5 doctype declaration. This is useful when converting between XHTML and HTML.</p></dd></dl><dl><dt class="spec value" id="val-xhtml"><a href="#val-xhtml" class="anchor"></a><code><span class="keyword">val</span> xhtml : ?&#8288;dtd:[&lt; `Strict_1_0 | `Transitional_1_0 | `Frameset_1_0 | `Strict_1_1 ] <span>&#45;&gt;</span> ([&lt; <a href="index.html#type-signal">signal</a> ],Â <span class="type-var">'s</span>) <a href="index.html#type-stream">stream</a> <span>&#45;&gt;</span> (<a href="index.html#type-signal">signal</a>,Â <span class="type-var">'s</span>) <a href="index.html#type-stream">stream</a></code></dt><dd><p>Similar to <a href="index.html#val-html5"><code>html5</code></a>, but does not strip processing instructions, and prefixes an XHTML document type declaration and an XML declaration. The <code>~dtd</code> argument specifies which DTD to refer to in the doctype declaration. The default is <code>`Strict_1_1</code>.</p></dd></dl><dl><dt class="spec value" id="val-xhtml_entity"><a href="#val-xhtml_entity" class="anchor"></a><code><span class="keyword">val</span> xhtml_entity : string <span>&#45;&gt;</span> string option</code></dt><dd><p>Translates XHTML entities. This function is for use with the <code>~entity</code> argument of <a href="index.html#val-parse_xml"><code>parse_xml</code></a> when parsing XHTML.</p></dd></dl><dl><dt class="spec value" id="val-strings_to_bytes"><a href="#val-strings_to_bytes" class="anchor"></a><code><span class="keyword">val</span> strings_to_bytes : (string,Â <span class="type-var">'s</span>) <a href="index.html#type-stream">stream</a> <span>&#45;&gt;</span> (char,Â <span class="type-var">'s</span>) <a href="index.html#type-stream">stream</a></code></dt><dd><p><code>strings_to_bytes s</code> is the stream of all the bytes of all strings in <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-compare_locations"><a href="#val-compare_locations" class="anchor"></a><code><span class="keyword">val</span> compare_locations : <a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-location">location</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Orders locations according to their appearance in an input stream, i.e. first by line, and then, for locations on the same line, by column.</p></dd></dl></section><section><header><h3 id="namespaces"><a href="#namespaces" class="anchor"></a>Namespaces</h3></header><dl><dt class="spec module" id="module-Ns"><a href="#module-Ns" class="anchor"></a><code><span class="keyword">module</span> <a href="Ns/index.html">Ns</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Common namespace URIs.</p></dd></dl></section><section><header><h3 id="asynchronous-interface"><a href="#asynchronous-interface" class="anchor"></a>Asynchronous interface</h3></header><dl><dt class="spec module-type" id="module-type-ASYNCHRONOUS"><a href="#module-type-ASYNCHRONOUS" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-ASYNCHRONOUS/index.html">ASYNCHRONOUS</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Markup.ml interface for monadic I/O libraries such as Lwt and Async.</p></dd></dl></section><section><header><h3 id="conformance-status"><a href="#conformance-status" class="anchor"></a>Conformance status</h3><p>The HTML parser seeks to implement <a href="https://www.w3.org/TR/html5/syntax.html">section 8 of the HTML5 specification</a>. That section describes a parser, part of a full-blown user agent, that is building up a DOM representation of an HTML document. Markup.ml is neither inherently part of a user agent, nor does it build up a DOM representation. With respect to section 8 of HTML5, Markup.ml is concerned with only the syntax. When that section requires that the user agent perform an action, Markup.ml emits enough information for a hypothetical user agent based on it to be able to decide to perform this action. Likewise, Markup.ml seeks to emit enough information for a hypothetical user agent to build up a conforming DOM.</p><p>The XML parser seeks to be a non-validating implementation of the <a href="https://www.w3.org/TR/xml/">XML</a> and <a href="https://www.w3.org/TR/xml-names/">Namespaces in XML</a> specifications.</p><p>This rest of this section lists known deviations from HTML5, XML, and Namespaces in XML. Some of these deviations are meant to be corrected in future versions of Markup.ml, while others will probably remain. The latter satisfy some or all of the following properties:</p><ul><li>They require non-local adjustment, especially of past nodes. For example, adjusting the start signal of the root node mid-way through the signal stream is difficult for a one-pass parser.</li><li>They are minor. Users implementing less than a conforming browser typically don't care about them. They typically have to do with obscure error recovery. There are no deviations affecting the parsing of well-formed input.</li><li>They can easily be corrected by code written over Markup.ml that builds up a DOM or maintains other auxiliary data structures during parsing.</li></ul></header><section><header><h4 id="to-be-corrected:"><a href="#to-be-corrected:" class="anchor"></a>To be corrected:</h4><ul><li>XML: There is no attribute value normalization.</li><li>HTML: <em>foster parenting</em> is not implemented, because it requires non-local adjustments.</li><li>HTML: Quirks mode is not honored. This affects the interaction between automatic closing of <code>p</code> elements and opening of <code>table</code> elements.</li><li>HTML: The parser has non-standard recovery from unmatched closing <code>form</code> tags in <a href="https://github.com/aantron/markup.ml/commit/0bf4f1b">some situations</a>.</li><li>HTML: The parser ignores interactions between <code>form</code> and <code>template</code>.</li><li>HTML: The form translation for <code>isindex</code> is completely ignored. <code>isindex</code> is handled as an unknown element.</li></ul></header></section><section><header><h4 id="to-remain:"><a href="#to-remain:" class="anchor"></a>To remain:</h4><ul><li>HTML: Except when detecting encodings, the parser does not try to read <code>&lt;meta&gt;</code> tags for encoding declarations. The user of Markup.ml should read these, if necessary. They are part of the emitted signal stream.</li><li>HTML: <code>noscript</code> elements are always parsed, as are <code>script</code> elements. For conforming behavior, if the user of Markup.ml &quot;supports scripts,&quot; the user should serialize the content of <code>noscript</code> to a <code>`Text</code> signal using <code>write_html</code>.</li><li>HTML: Elements such as <code>title</code> that belong in <code>head</code>, but are found between <code>head</code> and <code>body</code>, are not moved into <code>head</code>.</li><li>HTML: <code>&lt;html&gt;</code> tags found in the body do not have their attributes added to the <code>`Start_element &quot;html&quot;</code> signal emitted at the beginning of the document.</li></ul></header></section></section></div></body></html>