<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Priority_queue (async_kernel.Async_kernel__Timing_wheel_ns.Priority_queue)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">async_kernel</a> &#x00BB; <a href="../index.html">Async_kernel__Timing_wheel_ns</a> &#x00BB; Priority_queue</nav><h1>Module <code>Async_kernel__Timing_wheel_ns.Priority_queue</code></h1><p>Timing wheel is implemented as a priority queue in which the keys are non-negative integers corresponding to the intervals of time. The priority queue is unlike a typical priority queue in that rather than having a &quot;delete min&quot; operation, it has a nondecreasing minimum allowed key, which corresponds to the current time, and an <code>increase_min_allowed_key</code> operation, which implements <code>advance_clock</code>. <code>increase_min_allowed_key</code> as a side effect removes all elements from the timing wheel whose key is smaller than the new minimum, which implements firing the alarms whose time has expired.</p><p>Adding elements to and removing elements from a timing wheel takes constant time, unlike a heap-based priority queue which takes log(N), where N is the number of elements in the heap. <code>increase_min_allowed_key</code> takes time proportional to the amount of increase in the min-allowed key, as compared to log(N) for a heap. It is these performance differences that motivate the existence of timing wheels and make them a good choice for maintaing a set of alarms. With a timing wheel, one can support any number of alarms paying constant overhead per alarm, while paying a small constant overhead per unit of time passed.</p><p>As the minimum allowed key increases, the timing wheel does a lazy radix sort of the element keys, with level 0 handling the least significant <code>b_0</code> bits in a key, and each subsequent level <code>i</code> handling the next most significant <code>b_i</code> bits. The levels hold increasingly larger ranges of keys, where the union of all the levels can hold any key from <code>min_allowed_key t</code> to <code>max_allowed_key t</code>. When a key is added to the timing wheel, it is added at the lowest possible level that can store the key. As the minimum allowed key increases, timing-wheel elements move down levels until they reach level 0, and then are eventually removed.</p></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> 'a t</code></dt></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></span></summary><dl><dt class="spec value" id="val-sexp_of_t"><a href="#val-sexp_of_t" class="anchor"></a><code><span class="keyword">val</span> sexp_of_t : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a></code></dt></dl></details></div></div></div><dl><dt class="spec type" id="type-priority_queue"><a href="#type-priority_queue" class="anchor"></a><code><span class="keyword">type</span> 'a priority_queue</code><code> = <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt></dl><div class="spec module" id="module-Key"><a href="#module-Key" class="anchor"></a><code><span class="keyword">module</span> <a href="Key/index.html">Key</a> : <a href="../../../core_kernel/Core_kernel/Timing_wheel_ns_intf/index.html#module-type-Interval_num">Core_kernel.Timing_wheel_ns_intf.Interval_num</a></code></div><div class="spec module" id="module-Elt"><a href="#module-Elt" class="anchor"></a><code><span class="keyword">module</span> <a href="Elt/index.html">Elt</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../../../base/Base/Invariant/index.html#module-type-S1">Core_kernel__.Import.Invariant.S1</a> <span class="keyword">with</span> <span class="keyword">type</span> 'a <a href="../../../base/Base/Invariant/module-type-S1/index.html#type-t">t</a> := <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> 'a t</code></dt></dl><dl><dt class="spec value" id="val-invariant"><a href="#val-invariant" class="anchor"></a><code><span class="keyword">val</span> invariant : <span class="type-var">'a</span> <a href="../../../base/Base__/Invariant_intf/index.html#type-inv">Base__.Invariant_intf.inv</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="../../../base/Base__/Invariant_intf/index.html#type-inv">Base__.Invariant_intf.inv</a></code></dt></dl></details></div></div></div><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : ?&#8288;level_bits:<a href="../Level_bits/index.html#type-t">Level_bits.t</a> <span>&#45;&gt;</span> <a href="../../../core_kernel/Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>create ?level_bits ()</code> creates a new empty timing wheel, <code>t</code>, with <code>length t = 0</code> and <code>min_allowed_key t = 0</code>.</p></dd></dl><dl><dt class="spec value" id="val-length"><a href="#val-length" class="anchor"></a><code><span class="keyword">val</span> length : <span class="type-var">_</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../core_kernel/Core_kernel__/Import/index.html#type-int">Core_kernel__.Import.int</a></code></dt><dd><p><code>length t</code> returns the number of elements in the timing wheel.</p></dd></dl><dl><dt class="spec value" id="val-is_empty"><a href="#val-is_empty" class="anchor"></a><code><span class="keyword">val</span> is_empty : <span class="type-var">_</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../core_kernel/Core_kernel__/Import/index.html#type-bool">Core_kernel__.Import.bool</a></code></dt><dd><p><code>is_empty t</code> is <code>length t = 0</code></p></dd></dl><dl><dt class="spec value" id="val-min_allowed_key"><a href="#val-min_allowed_key" class="anchor"></a><code><span class="keyword">val</span> min_allowed_key : <span class="type-var">_</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="Key/index.html#type-t">Key.t</a></code></dt><dd><p><code>min_allowed_key t</code> is the minimum key that can be stored in <code>t</code>. This only indicates the possibility; there need not be an element <code>elt</code> in <code>t</code> with <code>Elt.key
        elt = min_allowed_key t</code>. This is not the same as the &quot;min_key&quot; operation in a typical priority queue.</p><p><code>min_allowed_key t</code> can increase over time, via calls to <code>increase_min_allowed_key</code>. It is guaranteed that <code>min_allowed_key t &lt;=
        Key.max_representable</code>.</p></dd></dl><dl><dt class="spec value" id="val-max_allowed_key"><a href="#val-max_allowed_key" class="anchor"></a><code><span class="keyword">val</span> max_allowed_key : <span class="type-var">_</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="Key/index.html#type-t">Key.t</a></code></dt><dd><p><code>max_allowed_key t</code> is the maximum allowed key that can be stored in <code>t</code>. As <code>min_allowed_key</code> increases, so does <code>max_allowed_key</code>; however it is not the case that <code>max_allowed_key t - min_allowed_key t</code> is a constant. It is guaranteed that <code>max_allowed_key t &gt;= min (Key.max_representable, min_allowed_key t + 2^B - 1</code>, where <code>B</code> is the sum of the b_i in <code>level_bits</code>. It is also guaranteed that <code>max_allowed_key t &lt;= Key.max_representable</code>.</p></dd></dl><dl><dt class="spec value" id="val-min_elt"><a href="#val-min_elt" class="anchor"></a><code><span class="keyword">val</span> min_elt : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="Elt/index.html#type-t">Elt.t</a> <a href="../../../core_kernel/Core_kernel__/Import/index.html#type-option">Core_kernel__.Import.option</a></code></dt><dd><p><code>min_elt t</code> returns an element in <code>t</code> that has the minimum key, if <code>t</code> is nonempty. <code>min_elt</code> takes time proportional to the size of the timing-wheel data structure in the worst case. It is implemented via a linear search.</p><p><code>min_key t</code> returns the key of <code>min_elt t</code>, if any.</p></dd></dl><dl><dt class="spec value" id="val-min_key"><a href="#val-min_key" class="anchor"></a><code><span class="keyword">val</span> min_key : <span class="type-var">_</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="Key/index.html#type-t">Key.t</a> <a href="../../../core_kernel/Core_kernel__/Import/index.html#type-option">Core_kernel__.Import.option</a></code></dt><dt class="spec value" id="val-add"><a href="#val-add" class="anchor"></a><code><span class="keyword">val</span> add : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> key:<a href="Key/index.html#type-t">Key.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="Elt/index.html#type-t">Elt.t</a></code></dt><dd><p><code>add t ~key value</code> adds a new value to <code>t</code> and returns an element that can later be supplied to <code>remove</code> the element from <code>t</code>. <code>add</code> raises if <code>key &lt;
        min_allowed_key t || key &gt; max_allowed_key t</code>.</p></dd></dl><dl><dt class="spec value" id="val-remove"><a href="#val-remove" class="anchor"></a><code><span class="keyword">val</span> remove : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="Elt/index.html#type-t">Elt.t</a> <span>&#45;&gt;</span> <a href="../../../core_kernel/Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a></code></dt><dd><p><code>remove t elt</code> removes <code>elt</code> from <code>t</code>. It is an error if <code>elt</code> is not currently in <code>t</code>, and this error may or may not be detected.</p></dd></dl><dl><dt class="spec value" id="val-change_key"><a href="#val-change_key" class="anchor"></a><code><span class="keyword">val</span> change_key : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="Elt/index.html#type-t">Elt.t</a> <span>&#45;&gt;</span> key:<a href="Key/index.html#type-t">Key.t</a> <span>&#45;&gt;</span> <a href="../../../core_kernel/Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a></code></dt><dd><p><code>change_key t elt ~key</code> changes the key of <code>elt</code> to <code>key</code>. <code>change_key</code> raises if <code>not (mem t elt) || key &lt; min_allowed_key t || key &gt; max_allowed_key t</code>.</p></dd></dl><dl><dt class="spec value" id="val-clear"><a href="#val-clear" class="anchor"></a><code><span class="keyword">val</span> clear : <span class="type-var">_</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../core_kernel/Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a></code></dt><dd><p><code>clear t</code> removes all elts from <code>t</code>.</p></dd></dl><dl><dt class="spec value" id="val-mem"><a href="#val-mem" class="anchor"></a><code><span class="keyword">val</span> mem : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="Elt/index.html#type-t">Elt.t</a> <span>&#45;&gt;</span> <a href="../../../core_kernel/Core_kernel__/Import/index.html#type-bool">Core_kernel__.Import.bool</a></code></dt><dt class="spec value" id="val-increase_min_allowed_key"><a href="#val-increase_min_allowed_key" class="anchor"></a><code><span class="keyword">val</span> increase_min_allowed_key : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> key:<a href="Key/index.html#type-t">Key.t</a> <span>&#45;&gt;</span> handle_removed:(<span class="type-var">'a</span> <a href="Elt/index.html#type-t">Elt.t</a> <span>&#45;&gt;</span> <a href="../../../core_kernel/Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a>) <span>&#45;&gt;</span> <a href="../../../core_kernel/Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a></code></dt><dd><p><code>increase_min_allowed_key t ~key ~handle_removed</code> increases the minimum allowed key in <code>t</code> to <code>key</code>, and removes all elements with keys less than <code>key</code>, applying <code>handle_removed</code> to each element that is removed. If <code>key &lt;= min_allowed_key t</code>, then <code>increase_min_allowed_key</code> does nothing. Otherwise, if <code>increase_min_allowed_key</code> returns successfully, <code>min_allowed_key t = key</code>.</p><p><code>increase_min_allowed_key</code> raises if <code>key &gt; Key.max_representable</code>.</p><p><code>increase_min_allowed_key</code> takes time proportional to <code>key - min_allowed_key t</code>, although possibly less time.</p><p>Behavior is unspecified if <code>handle_removed</code> accesses <code>t</code> in any way other than <code>Elt</code> functions.</p></dd></dl><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <a href="Elt/index.html#type-t">Elt.t</a> <span>&#45;&gt;</span> <a href="../../../core_kernel/Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a>) <span>&#45;&gt;</span> <a href="../../../core_kernel/Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a></code></dt></dl></div></body></html>