<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Binary_search (base.Base.Binary_search)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">base</a> &#x00BB; <a href="../index.html">Base</a> &#x00BB; Binary_search</nav><header class="odoc-preamble"><h1>Module <code><span>Base.Binary_search</span></code></h1><p>Functions for performing binary searches over ordered sequences given <code>length</code> and <code>get</code> functions.</p><p>These functions can be specialized and added to a data structure using the functors supplied in <a href="../Binary_searchable/index.html"><code>Binary_searchable</code></a> and described in <span class="xref-unresolved"><code>Binary_searchable_intf</code></span>.</p></header><nav class="odoc-toc"><ul><li><a href="#examples">Examples</a></li></ul></nav><div class="odoc-content"><h3 id="examples"><a href="#examples" class="anchor"></a>Examples</h3><p>Below we assume that the functions <code>get</code>, <code>length</code> and <code>compare</code> are in scope:</p><pre><code>(* Find the index of an element [e] in [t] *)
binary_search t ~get ~length ~compare `First_equal_to e;

(* Find the index where an element [e] should be inserted *)
binary_search t ~get ~length ~compare `First_greater_than_or_equal_to e;

(* Find the index in [t] where all elements to the left are less than [e] *)
binary_search_segmented t ~get ~length ~segment_of:(fun e' -&gt;
  if compare e' e &lt;= 0 then `Left else `Right) `First_on_right</code></pre><div class="odoc-spec"><div class="spec value" id="val-binary_search" class="anchored"><a href="#val-binary_search" class="anchor"></a><code><span><span class="keyword">val</span> binary_search : <span>?pos:int <span class="arrow">&#45;&gt;</span></span> <span>?len:int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'t</span> <span class="arrow">&#45;&gt;</span></span> <span>length:<span>(<span><span class="type-var">'t</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span>
<span>get:<span>(<span><span class="type-var">'t</span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'elt</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>compare:<span>(<span><span class="type-var">'elt</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'key</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span>
<span><span>[ `Last_strictly_less_than <span>| `Last_less_than_or_equal_to</span> <span>| `Last_equal_to</span> <span>| `First_equal_to</span> <span>| `First_greater_than_or_equal_to</span> <span>| `First_strictly_greater_than</span> ]</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'key</span> <span class="arrow">&#45;&gt;</span></span> <span>int option</span></span></code></div><div class="spec-doc"><p><code>binary_search ?pos ?len t ~length ~get ~compare which elt</code> takes <code>t</code> that is sorted in increasing order according to <code>compare</code>, where <code>compare</code> and <code>elt</code> divide <code>t</code> into three (possibly empty) segments:</p><pre>      |  &lt; elt  |  = elt  |  &gt; elt  |</pre><p><code>binary_search</code> returns the index in <code>t</code> of an element on the boundary of segments as specified by <code>which</code>. See the diagram below next to the <code>which</code> variants.</p><p>By default, <code>binary_search</code> searches the entire <code>t</code>. One can supply <code>?pos</code> or <code>?len</code> to search a slice of <code>t</code>.</p><p><code>binary_search</code> does not check that <code>compare</code> orders <code>t</code>, and behavior is unspecified if <code>compare</code> doesn't order <code>t</code>. Behavior is also unspecified if <code>compare</code> mutates <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-binary_search_segmented" class="anchored"><a href="#val-binary_search_segmented" class="anchor"></a><code><span><span class="keyword">val</span> binary_search_segmented : <span>?pos:int <span class="arrow">&#45;&gt;</span></span> <span>?len:int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'t</span> <span class="arrow">&#45;&gt;</span></span> <span>length:<span>(<span><span class="type-var">'t</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span>
<span>get:<span>(<span><span class="type-var">'t</span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'elt</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>segment_of:<span>(<span><span class="type-var">'elt</span> <span class="arrow">&#45;&gt;</span></span> <span>[ `Left <span>| `Right</span> ]</span>)</span> <span class="arrow">&#45;&gt;</span></span>
<span><span>[ `Last_on_left <span>| `First_on_right</span> ]</span> <span class="arrow">&#45;&gt;</span></span> <span>int option</span></span></code></div><div class="spec-doc"><p><code>binary_search_segmented ?pos ?len t ~length ~get ~segment_of which</code> takes a <code>segment_of</code> function that divides <code>t</code> into two (possibly empty) segments:</p><pre>      | segment_of elt = `Left | segment_of elt = `Right |</pre><p><code>binary_search_segmented</code> returns the index of the element on the boundary of the segments as specified by <code>which</code>: <code>`Last_on_left</code> yields the index of the last element of the left segment, while <code>`First_on_right</code> yields the index of the first element of the right segment. It returns <code>None</code> if the segment is empty.</p><p>By default, <code>binary_search</code> searches the entire <code>t</code>. One can supply <code>?pos</code> or <code>?len</code> to search a slice of <code>t</code>.</p><p><code>binary_search_segmented</code> does not check that <code>segment_of</code> segments <code>t</code> as in the diagram, and behavior is unspecified if <code>segment_of</code> doesn't segment <code>t</code>. Behavior is also unspecified if <code>segment_of</code> mutates <code>t</code>.</p></div></div></div></body></html>