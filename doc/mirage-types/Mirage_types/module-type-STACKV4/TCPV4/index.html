<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>TCPV4 (mirage-types.Mirage_types.STACKV4.TCPV4)</title><link rel="stylesheet" href="../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../../index.html">mirage-types</a> &#x00BB; <a href="../../index.html">Mirage_types</a> &#x00BB; <a href="../index.html">STACKV4</a> &#x00BB; TCPV4</nav><h1>Module <code>STACKV4.TCPV4</code></h1></header><dl><dt class="spec type" id="type-error#row"><a href="#type-error#row" class="anchor"></a><code><span class="keyword">type</span> error#row</code></dt><dd><p>The type for TCP errors.</p></dd></dl><dl><dt class="spec type" id="type-error"><a href="#type-error" class="anchor"></a><code><span class="keyword">and</span> error</code> = <span class="keyword">private</span> <code>[&gt; </code><table class="variant"><tr id="type-error.Mirage_protocols.Tcp.error" class="anchored"><td class="def type"><a href="#type-error.Mirage_protocols.Tcp.error" class="anchor"></a><code>| </code><code><a href="../../../../mirage-protocols/Mirage_protocols/Tcp/index.html#type-error">Mirage_protocols.Tcp.error</a></code></td></tr></table><code> ]</code></dt><dd><p>The type for TCP errors.</p></dd></dl><dl><dt class="spec type" id="type-write_error#row"><a href="#type-write_error#row" class="anchor"></a><code><span class="keyword">type</span> write_error#row</code></dt><dd><p>The type for TCP write errors.</p></dd></dl><dl><dt class="spec type" id="type-write_error"><a href="#type-write_error" class="anchor"></a><code><span class="keyword">and</span> write_error</code> = <span class="keyword">private</span> <code>[&gt; </code><table class="variant"><tr id="type-write_error.Mirage_protocols.Tcp.write_error" class="anchored"><td class="def type"><a href="#type-write_error.Mirage_protocols.Tcp.write_error" class="anchor"></a><code>| </code><code><a href="../../../../mirage-protocols/Mirage_protocols/Tcp/index.html#type-write_error">Mirage_protocols.Tcp.write_error</a></code></td></tr></table><code> ]</code></dt><dd><p>The type for TCP write errors.</p></dd></dl><dl><dt class="spec type" id="type-buffer"><a href="#type-buffer" class="anchor"></a><code><span class="keyword">type</span> buffer</code><code> = <a href="../index.html#type-buffer">buffer</a></code></dt><dd><p>The type for memory buffers.</p></dd></dl><dl><dt class="spec type" id="type-ipaddr"><a href="#type-ipaddr" class="anchor"></a><code><span class="keyword">type</span> ipaddr</code><code> = <a href="../index.html#type-ipv4addr">ipv4addr</a></code></dt><dd><p>The type for IP address representations.</p></dd></dl><dl><dt class="spec type" id="type-ipinput"><a href="#type-ipinput" class="anchor"></a><code><span class="keyword">type</span> ipinput</code></dt><dd><p>The type for input function continuation to pass onto the underlying <a href="../../../../mirage-protocols/Mirage_protocols/module-type-IP/index.html"><code>Mirage_protocols.IP</code></a> stack. This will normally be a NOOP for a conventional kernel, but a direct implementation will parse the buffer.</p></dd></dl><dl><dt class="spec type" id="type-flow"><a href="#type-flow" class="anchor"></a><code><span class="keyword">type</span> flow</code></dt><dd><p>A flow represents the state of a single TCPv4 stream that is connected to an endpoint.</p></dd></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../../../../mirage-device/Mirage_device/index.html#module-type-S">Mirage_device.S</a></code></span></summary><dl><dt class="spec type" id="type-io"><a href="#type-io" class="anchor"></a><code><span class="keyword">type</span> +'a io</code></dt><dd><p>The type for potentially blocking I/O operation</p></dd></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><p>The type representing the internal state of the device</p></dd></dl><dl><dt class="spec value" id="val-disconnect"><a href="#val-disconnect" class="anchor"></a><code><span class="keyword">val</span> disconnect : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit <a href="index.html#type-io">io</a></code></dt><dd><p>Disconnect from the device. While this might take some time to complete, it can never result in an error.</p></dd></dl></details></div></div></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../../../../mirage-flow/Mirage_flow/index.html#module-type-S">Mirage_flow.S</a> <span class="keyword">with</span> <span class="keyword">type</span> 'a <a href="../../../../mirage-flow/Mirage_flow/module-type-S/index.html#type-io">io</a> := <span class="type-var">'a</span> <a href="index.html#type-io">io</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../../../../mirage-flow/Mirage_flow/module-type-S/index.html#type-buffer">buffer</a> := <a href="index.html#type-buffer">buffer</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../../../../mirage-flow/Mirage_flow/module-type-S/index.html#type-flow">flow</a> := <a href="index.html#type-flow">flow</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../../../../mirage-flow/Mirage_flow/module-type-S/index.html#type-error">error</a> := <a href="index.html#type-error">error</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../../../../mirage-flow/Mirage_flow/module-type-S/index.html#type-write_error">write_error</a> := <a href="index.html#type-write_error">write_error</a></code></span></summary><dl><dt class="spec type" id="type-io"><a href="#type-io" class="anchor"></a><code><span class="keyword">type</span> +'a io</code></dt><dd><p>The type for potentially blocking I/O operations.</p></dd></dl><dl><dt class="spec type" id="type-error"><a href="#type-error" class="anchor"></a><code><span class="keyword">type</span> error</code></dt><dd><p>The type for flow errors.</p></dd></dl><dl><dt class="spec value" id="val-pp_error"><a href="#val-pp_error" class="anchor"></a><code><span class="keyword">val</span> pp_error : <a href="index.html#type-error">error</a> <a href="../../../../fmt/Fmt/index.html#type-t">Fmt.t</a></code></dt><dd><p><code>pp_error</code> is the pretty-printer for errors.</p></dd></dl><dl><dt class="spec type" id="type-write_error"><a href="#type-write_error" class="anchor"></a><code><span class="keyword">type</span> write_error</code> = <span class="keyword">private</span> <code>[&gt; </code><table class="variant"><tr id="type-write_error.Mirage_flow.write_error" class="anchored"><td class="def type"><a href="#type-write_error.Mirage_flow.write_error" class="anchor"></a><code>| </code><code><a href="../../../../mirage-flow/Mirage_flow/index.html#type-write_error">Mirage_flow.write_error</a></code></td></tr></table><code> ]</code></dt><dd><p>The type for write errors.</p></dd></dl><dl><dt class="spec value" id="val-pp_write_error"><a href="#val-pp_write_error" class="anchor"></a><code><span class="keyword">val</span> pp_write_error : <a href="index.html#type-write_error">write_error</a> <a href="../../../../fmt/Fmt/index.html#type-t">Fmt.t</a></code></dt><dd><p><code>pp_write_error</code> is the pretty-printer for write errors.</p></dd></dl><dl><dt class="spec type" id="type-buffer"><a href="#type-buffer" class="anchor"></a><code><span class="keyword">type</span> buffer</code></dt><dd><p>The type for memory buffer.</p></dd></dl><dl><dt class="spec type" id="type-flow"><a href="#type-flow" class="anchor"></a><code><span class="keyword">type</span> flow</code></dt><dd><p>The type for flows. A flow represents the state of a single reliable stream that is connected to an endpoint.</p></dd></dl><dl><dt class="spec value" id="val-read"><a href="#val-read" class="anchor"></a><code><span class="keyword">val</span> read : <a href="index.html#type-flow">flow</a> <span>&#45;&gt;</span> (<a href="index.html#type-buffer">buffer</a> <a href="../../../../mirage-flow/Mirage_flow/index.html#type-or_eof">Mirage_flow.or_eof</a>, <a href="index.html#type-error">error</a>) <a href="../../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a> <a href="index.html#type-io">io</a></code></dt><dd><p><code>read flow</code> blocks until some data is available and returns a fresh buffer containing it.</p><p>The returned buffer will be of a size convenient to the flow implementation, but will always have at least 1 byte.</p><p>If the remote endpoint calls <code>close</code> then calls to <code>read</code> will keep returning data until all the in-flight data has been read. <code>read flow</code> will return <code>`Eof</code> when the remote endpoint has called <code>close</code> and when there is no more in-flight data.</p></dd></dl><dl><dt class="spec value" id="val-write"><a href="#val-write" class="anchor"></a><code><span class="keyword">val</span> write : <a href="index.html#type-flow">flow</a> <span>&#45;&gt;</span> <a href="index.html#type-buffer">buffer</a> <span>&#45;&gt;</span> (unit, <a href="index.html#type-write_error">write_error</a>) <a href="../../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a> <a href="index.html#type-io">io</a></code></dt><dd><p><code>write flow buffer</code> writes a buffer to the flow. There is no indication when the buffer has actually been read and, therefore, it must not be reused. The contents may be transmitted in separate packets, depending on the underlying transport. The result <code>Ok ()</code> indicates success, <code>Error `Closed</code> indicates that the connection is now closed and therefore the data could not be written. Other errors are possible.</p></dd></dl><dl><dt class="spec value" id="val-writev"><a href="#val-writev" class="anchor"></a><code><span class="keyword">val</span> writev : <a href="index.html#type-flow">flow</a> <span>&#45;&gt;</span> <a href="index.html#type-buffer">buffer</a> list <span>&#45;&gt;</span> (unit, <a href="index.html#type-write_error">write_error</a>) <a href="../../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a> <a href="index.html#type-io">io</a></code></dt><dd><p><code>writev flow buffers</code> writes a sequence of buffers to the flow. There is no indication when the buffers have actually been read and, therefore, they must not be reused. The result <code>Ok ()</code> indicates success, <code>Error `Closed</code> indicates that the connection is now closed and therefore the data could not be written. Other errors are possible.</p></dd></dl><dl><dt class="spec value" id="val-close"><a href="#val-close" class="anchor"></a><code><span class="keyword">val</span> close : <a href="index.html#type-flow">flow</a> <span>&#45;&gt;</span> unit <a href="index.html#type-io">io</a></code></dt><dd><p><code>close flow</code> flushes all pending writes and signals the remote endpoint that there will be no future writes. Once the remote endpoint has read all pending data, it is expected that calls to <code>read</code> on the remote return <code>`Eof</code>.</p><p>Note it is still possible for the remote endpoint to <code>write</code> to the flow and for the local endpoint to call <code>read</code>. This state where the local endpoint has called <code>close</code> but the remote endpoint has not called <code>close</code> is similar to that of a half-closed TCP connection or a Unix socket after <code>shutdown(SHUTDOWN_WRITE)</code>.</p><p><code>close flow</code> waits until the remote endpoint has also called <code>close</code> before returning. At this point no data can flow in either direction and resources associated with the flow can be freed.</p></dd></dl></details></div></div></div><dl><dt class="spec value" id="val-dst"><a href="#val-dst" class="anchor"></a><code><span class="keyword">val</span> dst : <a href="index.html#type-flow">flow</a> <span>&#45;&gt;</span> <a href="index.html#type-ipaddr">ipaddr</a> * int</code></dt><dd><p>Get the destination IPv4 address and destination port that a flow is currently connected to.</p></dd></dl><dl><dt class="spec value" id="val-write_nodelay"><a href="#val-write_nodelay" class="anchor"></a><code><span class="keyword">val</span> write_nodelay : <a href="index.html#type-flow">flow</a> <span>&#45;&gt;</span> <a href="index.html#type-buffer">buffer</a> <span>&#45;&gt;</span> (unit, <a href="index.html#type-write_error">write_error</a>) <a href="../../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a> <a href="index.html#type-io">io</a></code></dt><dd><p><code>write_nodelay flow buffer</code> writes the contents of <code>buffer</code> to the flow. The thread blocks until all data has been successfully transmitted to the remote endpoint. Buffering within the stack is minimized in this mode. Note that this API will change in a future revision to be a per-flow attribute instead of a separately exposed function.</p></dd></dl><dl><dt class="spec value" id="val-writev_nodelay"><a href="#val-writev_nodelay" class="anchor"></a><code><span class="keyword">val</span> writev_nodelay : <a href="index.html#type-flow">flow</a> <span>&#45;&gt;</span> <a href="index.html#type-buffer">buffer</a> list <span>&#45;&gt;</span> (unit, <a href="index.html#type-write_error">write_error</a>) <a href="../../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a> <a href="index.html#type-io">io</a></code></dt><dd><p><code>writev_nodelay flow buffers</code> writes the contents of <code>buffers</code> to the flow. The thread blocks until all data has been successfully transmitted to the remote endpoint. Buffering within the stack is minimized in this mode. Note that this API will change in a future revision to be a per-flow attribute instead of a separately exposed function.</p></dd></dl><dl><dt class="spec value" id="val-create_connection"><a href="#val-create_connection" class="anchor"></a><code><span class="keyword">val</span> create_connection : ?&#8288;keepalive:<a href="../../../../mirage-protocols/Mirage_protocols/Keepalive/index.html#type-t">Mirage_protocols.Keepalive.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<a href="index.html#type-ipaddr">ipaddr</a> * int) <span>&#45;&gt;</span> (<a href="index.html#type-flow">flow</a>, <a href="index.html#type-error">error</a>) <a href="../../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a> <a href="index.html#type-io">io</a></code></dt><dd><p><code>create_connection ~keepalive t (addr,port)</code> opens a TCPv4 connection to the specified endpoint.</p><p>If the optional argument <code>?keepalive</code> is provided then TCP keep-alive messages will be sent to the server when the connection is idle. If no responses are received then eventually the connection will be disconnected: <code>read</code> will return <code>Ok `Eof</code> and write will return <code>Error `Closed</code></p></dd></dl><dl><dt class="spec type" id="type-listener"><a href="#type-listener" class="anchor"></a><code><span class="keyword">type</span> listener</code><code> = </code><code>{</code><table class="record"><tr id="type-listener.process" class="anchored"><td class="def field"><a href="#type-listener.process" class="anchor"></a><code>process : <a href="index.html#type-flow">flow</a> <span>&#45;&gt;</span> unit <a href="index.html#type-io">io</a>;</code></td><td class="doc"><p>process a connected flow</p></td></tr><tr id="type-listener.keepalive" class="anchored"><td class="def field"><a href="#type-listener.keepalive" class="anchor"></a><code>keepalive : <a href="../../../../mirage-protocols/Mirage_protocols/Keepalive/index.html#type-t">Mirage_protocols.Keepalive.t</a> option;</code></td><td class="doc"><p>optional TCP keepalive configuration</p></td></tr></table><code>}</code></dt><dd><p>A TCP listener on a particular port</p></dd></dl><dl><dt class="spec value" id="val-input"><a href="#val-input" class="anchor"></a><code><span class="keyword">val</span> input : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> listeners:(int <span>&#45;&gt;</span> <a href="index.html#type-listener">listener</a> option) <span>&#45;&gt;</span> <a href="index.html#type-ipinput">ipinput</a></code></dt><dd><p><code>input t listeners</code> returns an input function continuation to be passed to the underlying <a href="../../../../mirage-protocols/Mirage_protocols/module-type-IP/index.html"><code>Mirage_protocols.IP</code></a> stack.</p><p>When the stack receives a TCP SYN (i.e. a connection request) to a particular <code>port</code>, it will evaluate <code>listeners port</code>:</p><ul><li>If <code>listeners port</code> is <code>None</code>, the input function will return an RST to refuse the connection.</li><li>If <code>listeners port</code> is <code>Some listener</code> then the connection will be accepted and the resulting flow will be processed by <code>listener.process</code>. If <code>listener.keepalive</code> is <code>Some configuration</code> then the TCP keep-alive <code>configuration</code> will be applied before calling <code>listener.process</code>.</li></ul></dd></dl></div></body></html>