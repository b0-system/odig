<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Parmatch (ocaml.Parmatch)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">ocaml</a> &#x00BB; Parmatch</nav><h1>Module <code>Parmatch</code></h1><p>Detection of partial matches and unused match cases.</p></header><dl><dt class="spec value" id="val-omega"><a href="#val-omega" class="anchor"></a><code><span class="keyword">val</span> omega : <a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a></code></dt><dd><p>aka. &quot;Tpat_any&quot; or &quot;_&quot;</p></dd></dl><dl><dt class="spec value" id="val-omegas"><a href="#val-omegas" class="anchor"></a><code><span class="keyword">val</span> omegas : int <span>&#45;&gt;</span> <a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> list</code></dt><dd><p><code>List.init (fun _ -&gt; omega)</code></p></dd></dl><dl><dt class="spec value" id="val-omega_list"><a href="#val-omega_list" class="anchor"></a><code><span class="keyword">val</span> omega_list : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> list</code></dt><dd><p><code>List.map (fun _ -&gt; omega)</code></p></dd></dl><dl><dt class="spec value" id="val-normalize_pat"><a href="#val-normalize_pat" class="anchor"></a><code><span class="keyword">val</span> normalize_pat : <a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> <span>&#45;&gt;</span> <a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a></code></dt><dd><p>Keep only the &quot;head&quot; of a pattern: all arguments are replaced by <code>omega</code>, so are variables.</p></dd></dl><dl><dt class="spec value" id="val-const_compare"><a href="#val-const_compare" class="anchor"></a><code><span class="keyword">val</span> const_compare : <a href="../Asttypes/index.html#type-constant">Asttypes.constant</a> <span>&#45;&gt;</span> <a href="../Asttypes/index.html#type-constant">Asttypes.constant</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>const_compare c1 c2</code> compares the actual values represented by <code>c1</code> and <code>c2</code>, while simply using <code>Stdlib.compare</code> would compare the representations.</p><p>cf. MPR#5758</p></dd></dl><dl><dt class="spec value" id="val-le_pat"><a href="#val-le_pat" class="anchor"></a><code><span class="keyword">val</span> le_pat : <a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> <span>&#45;&gt;</span> <a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>le_pat p q</code> means: forall V, V matches q implies V matches p</p></dd></dl><dl><dt class="spec value" id="val-le_pats"><a href="#val-le_pats" class="anchor"></a><code><span class="keyword">val</span> le_pats : <a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> list <span>&#45;&gt;</span> <a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> list <span>&#45;&gt;</span> bool</code></dt><dd><p><code>le_pats (p1 .. pm) (q1 .. qn)</code> means: forall i &lt;= m, <code>le_pat pi qi</code></p></dd></dl><dl><dt class="spec module" id="module-Compat"><a href="#module-Compat" class="anchor"></a><code><span class="keyword">module</span> <a href="Compat/index.html">Compat</a> : <span class="keyword">functor</span> (<a href="Compat/argument-1-Constr/index.html">Constr</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Exported compatibility functor, abstracted over constructor equality</p></dd></dl><dl><dt class="spec exception" id="exception-Empty"><a href="#exception-Empty" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Empty</span></code></dt></dl><dl><dt class="spec value" id="val-lub"><a href="#val-lub" class="anchor"></a><code><span class="keyword">val</span> lub : <a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> <span>&#45;&gt;</span> <a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> <span>&#45;&gt;</span> <a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a></code></dt><dd><p><code>lub p q</code> is a pattern that matches all values matched by <code>p</code> and <code>q</code>. May raise <code>Empty</code>, when <code>p</code> and <code>q</code> are not compatible.</p></dd></dl><dl><dt class="spec value" id="val-lubs"><a href="#val-lubs" class="anchor"></a><code><span class="keyword">val</span> lubs : <a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> list <span>&#45;&gt;</span> <a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> list <span>&#45;&gt;</span> <a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> list</code></dt><dd><p><code>lubs [p1; ...; pn] [q1; ...; qk]</code>, where <code>n &lt; k</code>, is <code>[lub p1 q1; ...; lub pk qk]</code>.</p></dd></dl><dl><dt class="spec value" id="val-get_mins"><a href="#val-get_mins" class="anchor"></a><code><span class="keyword">val</span> get_mins : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dt class="spec value" id="val-set_args"><a href="#val-set_args" class="anchor"></a><code><span class="keyword">val</span> set_args : <a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> <span>&#45;&gt;</span> <a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> list <span>&#45;&gt;</span> <a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> list</code></dt><dd><p>Those two functions recombine one pattern and its arguments: For instance: (_,_)::p1::p2::rem -&gt; (p1, p2)::rem The second one will replace mutable arguments by '_'</p></dd></dl><dl><dt class="spec value" id="val-set_args_erase_mutable"><a href="#val-set_args_erase_mutable" class="anchor"></a><code><span class="keyword">val</span> set_args_erase_mutable : <a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> <span>&#45;&gt;</span> <a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> list <span>&#45;&gt;</span> <a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> list</code></dt><dt class="spec value" id="val-pat_of_constr"><a href="#val-pat_of_constr" class="anchor"></a><code><span class="keyword">val</span> pat_of_constr : <a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> <span>&#45;&gt;</span> <a href="../Types/index.html#type-constructor_description">Types.constructor_description</a> <span>&#45;&gt;</span> <a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a></code></dt><dt class="spec value" id="val-complete_constrs"><a href="#val-complete_constrs" class="anchor"></a><code><span class="keyword">val</span> complete_constrs : <a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> <span>&#45;&gt;</span> <a href="../Types/index.html#type-constructor_tag">Types.constructor_tag</a> list <span>&#45;&gt;</span> <a href="../Types/index.html#type-constructor_description">Types.constructor_description</a> list</code></dt><dt class="spec value" id="val-ppat_of_type"><a href="#val-ppat_of_type" class="anchor"></a><code><span class="keyword">val</span> ppat_of_type : <a href="../Env/index.html#type-t">Env.t</a> <span>&#45;&gt;</span> <a href="../Types/index.html#type-type_expr">Types.type_expr</a> <span>&#45;&gt;</span> <a href="../Parsetree/index.html#type-pattern">Parsetree.pattern</a> * (string, <a href="../Types/index.html#type-constructor_description">Types.constructor_description</a>) <a href="../Stdlib/Hashtbl/index.html#type-t">Stdlib.Hashtbl.t</a> * (string, <a href="../Types/index.html#type-label_description">Types.label_description</a>) <a href="../Stdlib/Hashtbl/index.html#type-t">Stdlib.Hashtbl.t</a></code></dt><dd><p><code>ppat_of_type</code> builds an untyped or-pattern from its expected type. May raise <code>Empty</code> when <code>type_expr</code> is an empty variant</p></dd></dl><dl><dt class="spec value" id="val-pressure_variants"><a href="#val-pressure_variants" class="anchor"></a><code><span class="keyword">val</span> pressure_variants : <a href="../Env/index.html#type-t">Env.t</a> <span>&#45;&gt;</span> <a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> list <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-check_partial"><a href="#val-check_partial" class="anchor"></a><code><span class="keyword">val</span> check_partial : ((string, <a href="../Types/index.html#type-constructor_description">Types.constructor_description</a>) <a href="../Stdlib/Hashtbl/index.html#type-t">Stdlib.Hashtbl.t</a> <span>&#45;&gt;</span> (string, <a href="../Types/index.html#type-label_description">Types.label_description</a>) <a href="../Stdlib/Hashtbl/index.html#type-t">Stdlib.Hashtbl.t</a> <span>&#45;&gt;</span> <a href="../Parsetree/index.html#type-pattern">Parsetree.pattern</a> <span>&#45;&gt;</span> <a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> option) <span>&#45;&gt;</span> <a href="../Location/index.html#type-t">Location.t</a> <span>&#45;&gt;</span> <a href="../Typedtree/index.html#type-case">Typedtree.case</a> list <span>&#45;&gt;</span> <a href="../Typedtree/index.html#type-partial">Typedtree.partial</a></code></dt><dt class="spec value" id="val-check_unused"><a href="#val-check_unused" class="anchor"></a><code><span class="keyword">val</span> check_unused : (bool <span>&#45;&gt;</span> (string, <a href="../Types/index.html#type-constructor_description">Types.constructor_description</a>) <a href="../Stdlib/Hashtbl/index.html#type-t">Stdlib.Hashtbl.t</a> <span>&#45;&gt;</span> (string, <a href="../Types/index.html#type-label_description">Types.label_description</a>) <a href="../Stdlib/Hashtbl/index.html#type-t">Stdlib.Hashtbl.t</a> <span>&#45;&gt;</span> <a href="../Parsetree/index.html#type-pattern">Parsetree.pattern</a> <span>&#45;&gt;</span> <a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> option) <span>&#45;&gt;</span> <a href="../Typedtree/index.html#type-case">Typedtree.case</a> list <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-irrefutable"><a href="#val-irrefutable" class="anchor"></a><code><span class="keyword">val</span> irrefutable : <a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-inactive"><a href="#val-inactive" class="anchor"></a><code><span class="keyword">val</span> inactive : partial:<a href="../Typedtree/index.html#type-partial">Typedtree.partial</a> <span>&#45;&gt;</span> <a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>An inactive pattern is a pattern, matching against which can be duplicated, erased or delayed without change in observable behavior of the program. Patterns containing (lazy _) subpatterns or reads of mutable fields are active.</p></dd></dl><dl><dt class="spec value" id="val-check_ambiguous_bindings"><a href="#val-check_ambiguous_bindings" class="anchor"></a><code><span class="keyword">val</span> check_ambiguous_bindings : <a href="../Typedtree/index.html#type-case">Typedtree.case</a> list <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-some_private_tag"><a href="#val-some_private_tag" class="anchor"></a><code><span class="keyword">val</span> some_private_tag : <a href="../Asttypes/index.html#type-label">Asttypes.label</a></code></dt></dl></div></body></html>