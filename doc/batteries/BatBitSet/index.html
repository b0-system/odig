<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>BatBitSet (batteries.BatBitSet)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">batteries</a> &#x00BB; BatBitSet</nav><header class="odoc-preamble"><h1>Module <code><span>BatBitSet</span></code></h1><p>Efficient bit sets.</p><p>A bitset is an array of boolean values that can be accessed with indexes like an array but provides a better memory usage (divided by Sys.word_size; either 32 or 64) for a very small speed trade-off. It can provide efficient storage of dense sets of nonnegative integers near zero. Sparse sets should use <a href="../BatSet/index.html"><code>BatSet</code></a>, sets with large ranges of contiguous ints should use <a href="../BatISet/index.html"><code>BatISet</code></a>.</p><ul class="at-tags"><li class="author"><span class="at-tag">author</span> Nicolas Cannasse</li></ul><ul class="at-tags"><li class="author"><span class="at-tag">author</span> David Teller (Boilerplate code)</li></ul></header><nav class="odoc-toc"><ul><li><a href="#in-place-update">In-place Update</a></li><li><a href="#return-new-bitset">Return new bitset</a></li><li><a href="#boilerplate-code">Boilerplate code</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-empty" class="anchored"><a href="#val-empty" class="anchor"></a><code><span><span class="keyword">val</span> empty : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Create an empty bitset of capacity 0, the bitset will automatically expand when needed.</p><p>Example: <code>BitSet.empty ()</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-create" class="anchored"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Create an empty bitset with at least an initial capacity (in number of bits).</p><p>Example: <code>BitSet.create 0 = BitSet.empty ()</code></p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>on negative capacity</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-create_full" class="anchored"><a href="#val-create_full" class="anchor"></a><code><span><span class="keyword">val</span> create_full : <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Create a full bitset with at least initial capacity (in number of bits). All the bit under the defined capacity will be set.</p><p>Example: <code>BitSet.count (BitSet.create_full n) = n</code></p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>on negative capacity</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-copy" class="anchored"><a href="#val-copy" class="anchor"></a><code><span><span class="keyword">val</span> copy : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Copy a bitset : further modifications of first one will not affect the copy.</p><p>Example: <code>
    let a = Bitset.create 8 in
    let b = BitSet.copy a in
    BitSet.set a 6;
    BitSet.mem a 6 &amp;&amp; not (BitSet.mem b 6)</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-mem" class="anchored"><a href="#val-mem" class="anchor"></a><code><span><span class="keyword">val</span> mem : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>mem s n</code> returns true if nth-bit in the bitset <code>s</code> is set, or false otherwise.</p><p>Example: <code>let a = BitSet.create_full 256 in not (BitSet.mem a 300)</code></p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>on negative index (<code>n &lt; 0</code>)</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-count" class="anchored"><a href="#val-count" class="anchor"></a><code><span><span class="keyword">val</span> count : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>count s</code> returns the number of bits set in the bitset <code>s</code>. Also known as Population Count, or <code>cardinal</code> for sets.</p><p>Example: <code>BitSet.count (BitSet.of_list [6;4;2;2;1]) = 4</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-next_set_bit" class="anchored"><a href="#val-next_set_bit" class="anchor"></a><code><span><span class="keyword">val</span> next_set_bit : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int option</span></span></code></div><div class="spec-doc"><p><code>next_set_bit s n</code> returns <code>Some m</code> when <code>m</code> is the next set element with index greater than or equal <code>n</code>, or None if no such element exists (i.e. <code>n</code> is greater than the largest element)</p><p>More efficient than scanning with repeated <code>BitSet.mem</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>on negative index (<code>n &lt; 0</code>)</p></li></ul></div></div><h6 id="in-place-update"><a href="#in-place-update" class="anchor"></a>In-place Update</h6><p>These functions modify an existing bitset.</p><div class="odoc-spec"><div class="spec value" id="val-set" class="anchored"><a href="#val-set" class="anchor"></a><code><span><span class="keyword">val</span> set : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set s n</code> sets the <code>n</code>th-bit in the bitset <code>s</code> to true.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>on negative index (<code>n &lt; 0</code>)</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-unset" class="anchored"><a href="#val-unset" class="anchor"></a><code><span><span class="keyword">val</span> unset : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>unset s n</code> sets the <code>n</code>th-bit in the bitset <code>s</code> to false.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>on negative index (<code>n &lt; 0</code>)</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-put" class="anchored"><a href="#val-put" class="anchor"></a><code><span><span class="keyword">val</span> put : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>bool <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>put s v n</code> sets the nth-bit in the bitset <code>s</code> to <code>v</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>on negative index (<code>n &lt; 0</code>)</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-toggle" class="anchored"><a href="#val-toggle" class="anchor"></a><code><span><span class="keyword">val</span> toggle : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>toggle s n</code> changes the nth-bit value in the bitset <code>s</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>on negative index (<code>n &lt; 0</code>)</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-intersect" class="anchored"><a href="#val-intersect" class="anchor"></a><code><span><span class="keyword">val</span> intersect : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>intersect s t</code> sets <code>s</code> to the intersection of the sets <code>s</code> and <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unite" class="anchored"><a href="#val-unite" class="anchor"></a><code><span><span class="keyword">val</span> unite : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>unite s t</code> sets <code>s</code> to the union of the sets <code>s</code> and <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-differentiate" class="anchored"><a href="#val-differentiate" class="anchor"></a><code><span><span class="keyword">val</span> differentiate : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>differentiate s t</code> removes the elements of <code>t</code> from <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-differentiate_sym" class="anchored"><a href="#val-differentiate_sym" class="anchor"></a><code><span><span class="keyword">val</span> differentiate_sym : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>differentiate_sym s t</code> sets <code>s</code> to the symmetrical difference of the sets <code>s</code> and <code>t</code>.</p></div></div><h6 id="return-new-bitset"><a href="#return-new-bitset" class="anchor"></a>Return new bitset</h6><p>These functions return a new bitset that shares nothing with the input bitset. This is not as efficient as the in-place update.</p><div class="odoc-spec"><div class="spec value" id="val-add" class="anchored"><a href="#val-add" class="anchor"></a><code><span><span class="keyword">val</span> add : <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>add n s</code> returns a copy of <code>s</code> with bit <code>n</code> true.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>on negative index (<code>n &lt; 0</code>)</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-remove" class="anchored"><a href="#val-remove" class="anchor"></a><code><span><span class="keyword">val</span> remove : <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>remove n s</code> returns a copy of <code>s</code> with bit <code>n</code> false.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>on negative index (<code>n &lt; 0</code>)</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-inter" class="anchored"><a href="#val-inter" class="anchor"></a><code><span><span class="keyword">val</span> inter : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>inter s t</code> returns the intersection of sets <code>s</code> and <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-union" class="anchored"><a href="#val-union" class="anchor"></a><code><span><span class="keyword">val</span> union : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>union s t</code> return the union of sets <code>s</code> and <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-diff" class="anchored"><a href="#val-diff" class="anchor"></a><code><span><span class="keyword">val</span> diff : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>diff s t</code> returns <code>s</code>-<code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sym_diff" class="anchored"><a href="#val-sym_diff" class="anchor"></a><code><span><span class="keyword">val</span> sym_diff : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>sym_diff s t</code> returns the symmetrical difference of <code>s</code> and <code>t</code>.</p></div></div><h6 id="boilerplate-code"><a href="#boilerplate-code" class="anchor"></a>Boilerplate code</h6><div class="odoc-spec"><div class="spec value" id="val-print" class="anchored"><a href="#val-print" class="anchor"></a><code><span><span class="keyword">val</span> print : <span><span><span class="type-var">'a</span> <a href="../BatInnerIO/index.html#type-output">BatInnerIO.output</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-enum" class="anchored"><a href="#val-enum" class="anchor"></a><code><span><span class="keyword">val</span> enum : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <a href="../BatEnum/index.html#type-t">BatEnum.t</a></span></span></code></div><div class="spec-doc"><p><code>enum s</code> returns an enumeration of bits which are set in the bitset <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_enum" class="anchored"><a href="#val-of_enum" class="anchor"></a><code><span><span class="keyword">val</span> of_enum : <span>?cap:int <span class="arrow">&#45;&gt;</span></span> <span><span>int <a href="../BatEnum/index.html#type-t">BatEnum.t</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_enum ~cap e</code> builds a bitset of capacity <code>cap</code> an enumeration of ints <code>e</code>.</p><p>Note: Performance of this function may be poor if enumeration is in increasing order and the max.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_list" class="anchored"><a href="#val-of_list" class="anchor"></a><code><span><span class="keyword">val</span> of_list : <span>?cap:int <span class="arrow">&#45;&gt;</span></span> <span><span>int list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>As <code>of_enum</code>, but from a list</p></div></div><div class="odoc-spec"><div class="spec value" id="val-compare" class="anchored"><a href="#val-compare" class="anchor"></a><code><span><span class="keyword">val</span> compare : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>compare s1 s2</code> compares two bitsets using a lexicographic ordering. Highest bit indexes are compared first. The capacity of the bitsets is not important for this comparison, only the bits starting with the highest set bit and going down.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-equal" class="anchored"><a href="#val-equal" class="anchor"></a><code><span><span class="keyword">val</span> equal : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>equal s1 s2</code> returns true if, and only if, all bits values in s1 are the same as in s2.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-ord" class="anchored"><a href="#val-ord" class="anchor"></a><code><span><span class="keyword">val</span> ord : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../BatOrd/index.html#type-order">BatOrd.order</a></span></code></div><div class="spec-doc"><p><code>ord s1 s2</code> returns <code>BatOrd.Lt</code>, <code>BatOrd.Eq</code> or <code>BatOrd.Gt</code> if <code>compare s1 s2</code> is, respectively, <code>&lt; 0</code>, <code>0</code> or <code>&gt; 0</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-capacity" class="anchored"><a href="#val-capacity" class="anchor"></a><code><span><span class="keyword">val</span> capacity : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Internals</p><p><code>capacity s</code> returns the number of bits, both set and unset, stored in <code>s</code>. This is guaranteed to be larger than the largest element (set bit index) in <code>s</code>.</p></div></div></div></body></html>