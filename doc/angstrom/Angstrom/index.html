<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Angstrom (angstrom.Angstrom)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">angstrom</a> &#x00BB; Angstrom</nav><h1>Module <code>Angstrom</code></h1><p>Parser combinators built for speed and memory-efficiency.</p><p>Angstrom is a parser-combinator library that provides monadic and applicative interfaces for constructing parsers with unbounded lookahead. Its parsers can consume input incrementally, whether in a blocking or non-blocking environment. To achieve efficient incremental parsing, Angstrom offers both a buffered and unbuffered interface to input streams, with the <a href="Unbuffered/index.html"><code>Unbuffered</code></a> interface enabling zero-copy IO. With these features and low-level iteration parser primitives like <a href="index.html#val-take_while"><code>take_while</code></a> and <a href="index.html#val-skip_while"><code>skip_while</code></a>, Angstrom makes it easy to write efficient, expressive, and reusable parsers suitable for high-performance applications.</p><nav class="toc"><ul><li><a href="#basic-parsers">Basic parsers</a></li><li><a href="#combinators">Combinators</a></li><li><a href="#alternatives">Alternatives</a></li><li><a href="#monadic/applicative-interface">Monadic/Applicative interface</a></li><li><a href="#running">Running</a></li></ul></nav></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> +'a t</code></dt><dd><p>A parser for values of type <code>'a</code>.</p></dd></dl><dl><dt class="spec type" id="type-bigstring"><a href="#type-bigstring" class="anchor"></a><code><span class="keyword">type</span> bigstring</code><code> = (char, <a href="../../ocaml/Bigarray/index.html#type-int8_unsigned_elt">Bigarray.int8_unsigned_elt</a>, <a href="../../ocaml/Bigarray/index.html#type-c_layout">Bigarray.c_layout</a>) <a href="../../ocaml/Bigarray/Array1/index.html#type-t">Bigarray.Array1.t</a></code></dt></dl><section><header><h3 id="basic-parsers"><a href="#basic-parsers" class="anchor"></a>Basic parsers</h3></header><dl><dt class="spec value" id="val-peek_char"><a href="#val-peek_char" class="anchor"></a><code><span class="keyword">val</span> peek_char : char option <a href="index.html#type-t">t</a></code></dt><dd><p><code>peek_char</code> accepts any char and returns it, or returns <code>None</code> if the end of input has been reached.</p><p>This parser does not advance the input. Use it for lookahead.</p></dd></dl><dl><dt class="spec value" id="val-peek_char_fail"><a href="#val-peek_char_fail" class="anchor"></a><code><span class="keyword">val</span> peek_char_fail : char <a href="index.html#type-t">t</a></code></dt><dd><p><code>peek_char_fail</code> accepts any char and returns it. If end of input has been reached, it will fail.</p><p>This parser does not advance the input. Use it for lookahead.</p></dd></dl><dl><dt class="spec value" id="val-peek_string"><a href="#val-peek_string" class="anchor"></a><code><span class="keyword">val</span> peek_string : int <span>&#45;&gt;</span> string <a href="index.html#type-t">t</a></code></dt><dd><p><code>peek_string n</code> accepts exactly <code>n</code> characters and returns them as a string. If there is not enough input, it will fail.</p><p>This parser does not advance the input. Use it for lookahead.</p></dd></dl><dl><dt class="spec value" id="val-char"><a href="#val-char" class="anchor"></a><code><span class="keyword">val</span> char : char <span>&#45;&gt;</span> char <a href="index.html#type-t">t</a></code></dt><dd><p><code>char c</code> accepts <code>c</code> and returns it.</p></dd></dl><dl><dt class="spec value" id="val-not_char"><a href="#val-not_char" class="anchor"></a><code><span class="keyword">val</span> not_char : char <span>&#45;&gt;</span> char <a href="index.html#type-t">t</a></code></dt><dd><p><code>not_char</code> accepts any character that is not <code>c</code> and returns the matched character.</p></dd></dl><dl><dt class="spec value" id="val-any_char"><a href="#val-any_char" class="anchor"></a><code><span class="keyword">val</span> any_char : char <a href="index.html#type-t">t</a></code></dt><dd><p><code>any_char</code> accepts any character and returns it.</p></dd></dl><dl><dt class="spec value" id="val-satisfy"><a href="#val-satisfy" class="anchor"></a><code><span class="keyword">val</span> satisfy : (char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> char <a href="index.html#type-t">t</a></code></dt><dd><p><code>satisfy f</code> accepts any character for which <code>f</code> returns <code>true</code> and returns the accepted character.</p></dd></dl><dl><dt class="spec value" id="val-string"><a href="#val-string" class="anchor"></a><code><span class="keyword">val</span> string : string <span>&#45;&gt;</span> string <a href="index.html#type-t">t</a></code></dt><dd><p><code>string s</code> accepts <code>s</code> exactly and returns it.</p></dd></dl><dl><dt class="spec value" id="val-string_ci"><a href="#val-string_ci" class="anchor"></a><code><span class="keyword">val</span> string_ci : string <span>&#45;&gt;</span> string <a href="index.html#type-t">t</a></code></dt><dd><p><code>string_ci s</code> accepts <code>s</code>, ignoring case, and returns the matched string, preserving the case of the original input.</p></dd></dl><dl><dt class="spec value" id="val-skip"><a href="#val-skip" class="anchor"></a><code><span class="keyword">val</span> skip : (char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> unit <a href="index.html#type-t">t</a></code></dt><dd><p><code>skip f</code> accepts any character for which <code>f</code> returns <code>true</code> and discards the accepted character. <code>skip f</code> is equivalent to <code>satisfy f</code> but discards the accepted character.</p></dd></dl><dl><dt class="spec value" id="val-skip_while"><a href="#val-skip_while" class="anchor"></a><code><span class="keyword">val</span> skip_while : (char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> unit <a href="index.html#type-t">t</a></code></dt><dd><p><code>skip_while f</code> accepts input as long as <code>f</code> returns <code>true</code> and discards the accepted characters.</p></dd></dl><dl><dt class="spec value" id="val-take"><a href="#val-take" class="anchor"></a><code><span class="keyword">val</span> take : int <span>&#45;&gt;</span> string <a href="index.html#type-t">t</a></code></dt><dd><p><code>take n</code> accepts exactly <code>n</code> characters of input and returns them as a string.</p></dd></dl><dl><dt class="spec value" id="val-take_while"><a href="#val-take_while" class="anchor"></a><code><span class="keyword">val</span> take_while : (char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> string <a href="index.html#type-t">t</a></code></dt><dd><p><code>take_while f</code> accepts input as long as <code>f</code> returns <code>true</code> and returns the accepted characters as a string.</p><p>This parser does not fail. If <code>f</code> returns <code>false</code> on the first character, it will return the empty string.</p></dd></dl><dl><dt class="spec value" id="val-take_while1"><a href="#val-take_while1" class="anchor"></a><code><span class="keyword">val</span> take_while1 : (char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> string <a href="index.html#type-t">t</a></code></dt><dd><p><code>take_while f</code> accepts input as long as <code>f</code> returns <code>true</code> and returns the accepted characters as a string.</p><p>This parser requires that <code>f</code> return <code>true</code> for at least one character of input, and will fail otherwise.</p></dd></dl><dl><dt class="spec value" id="val-take_till"><a href="#val-take_till" class="anchor"></a><code><span class="keyword">val</span> take_till : (char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> string <a href="index.html#type-t">t</a></code></dt><dd><p><code>take_till f</code> accepts input as long as <code>f</code> returns <code>false</code> and returns the accepted characters as a string.</p><p>This parser does not fail. If <code>f</code> returns <code>true</code> on the first character, it will return the empty string.</p></dd></dl><dl><dt class="spec value" id="val-take_bigstring"><a href="#val-take_bigstring" class="anchor"></a><code><span class="keyword">val</span> take_bigstring : int <span>&#45;&gt;</span> <a href="index.html#type-bigstring">bigstring</a> <a href="index.html#type-t">t</a></code></dt><dd><p><code>take_bigstring n</code> accepts exactly <code>n</code> characters of input and returns them as a newly allocated bigstring.</p></dd></dl><dl><dt class="spec value" id="val-take_bigstring_while"><a href="#val-take_bigstring_while" class="anchor"></a><code><span class="keyword">val</span> take_bigstring_while : (char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <a href="index.html#type-bigstring">bigstring</a> <a href="index.html#type-t">t</a></code></dt><dd><p><code>take_bigstring_while f</code> accepts input as long as <code>f</code> returns <code>true</code> and returns the accepted characters as a newly allocated bigstring.</p><p>This parser does not fail. If <code>f</code> returns <code>false</code> on the first character, it will return the empty bigstring.</p></dd></dl><dl><dt class="spec value" id="val-take_bigstring_while1"><a href="#val-take_bigstring_while1" class="anchor"></a><code><span class="keyword">val</span> take_bigstring_while1 : (char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <a href="index.html#type-bigstring">bigstring</a> <a href="index.html#type-t">t</a></code></dt><dd><p><code>take_bigstring_while f</code> accepts input as long as <code>f</code> returns <code>true</code> and returns the accepted characters as a newly allocated bigstring.</p><p>This parser requires that <code>f</code> return <code>true</code> for at least one character of input, and will fail otherwise.</p></dd></dl><dl><dt class="spec value" id="val-take_bigstring_till"><a href="#val-take_bigstring_till" class="anchor"></a><code><span class="keyword">val</span> take_bigstring_till : (char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <a href="index.html#type-bigstring">bigstring</a> <a href="index.html#type-t">t</a></code></dt><dd><p><code>take_bigstring_till f</code> accepts input as long as <code>f</code> returns <code>false</code> and returns the accepted characters as a newly allocated bigstring.</p><p>This parser does not fail. If <code>f</code> returns <code>true</code> on the first character, it will return the empty bigstring.</p></dd></dl><dl><dt class="spec value" id="val-advance"><a href="#val-advance" class="anchor"></a><code><span class="keyword">val</span> advance : int <span>&#45;&gt;</span> unit <a href="index.html#type-t">t</a></code></dt><dd><p><code>advance n</code> advances the input <code>n</code> characters, failing if the remaining input is less than <code>n</code>.</p></dd></dl><dl><dt class="spec value" id="val-end_of_line"><a href="#val-end_of_line" class="anchor"></a><code><span class="keyword">val</span> end_of_line : unit <a href="index.html#type-t">t</a></code></dt><dd><p><code>end_of_input</code> accepts either a line feed <code>\n</code>, or a carriage return followed by a line feed <code>\r\n</code> and returns unit.</p></dd></dl><dl><dt class="spec value" id="val-at_end_of_input"><a href="#val-at_end_of_input" class="anchor"></a><code><span class="keyword">val</span> at_end_of_input : bool <a href="index.html#type-t">t</a></code></dt><dd><p><code>at_end_of_input</code> returns whether the end of the end of input has been reached. This parser always succeeds.</p></dd></dl><dl><dt class="spec value" id="val-end_of_input"><a href="#val-end_of_input" class="anchor"></a><code><span class="keyword">val</span> end_of_input : unit <a href="index.html#type-t">t</a></code></dt><dd><p><code>end_of_input</code> succeeds if all the input has been consumed, and fails otherwise.</p></dd></dl><dl><dt class="spec value" id="val-scan"><a href="#val-scan" class="anchor"></a><code><span class="keyword">val</span> scan : <span class="type-var">'state</span> <span>&#45;&gt;</span> (<span class="type-var">'state</span> <span>&#45;&gt;</span> char <span>&#45;&gt;</span> <span class="type-var">'state</span> option) <span>&#45;&gt;</span> (string * <span class="type-var">'state</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>scan init f</code> consumes until <code>f</code> returns <code>None</code>. Returns the final state before <code>None</code> and the accumulated string</p></dd></dl><dl><dt class="spec value" id="val-scan_state"><a href="#val-scan_state" class="anchor"></a><code><span class="keyword">val</span> scan_state : <span class="type-var">'state</span> <span>&#45;&gt;</span> (<span class="type-var">'state</span> <span>&#45;&gt;</span> char <span>&#45;&gt;</span> <span class="type-var">'state</span> option) <span>&#45;&gt;</span> <span class="type-var">'state</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>scan init f</code> Like <code>scan</code> but only returns the final state before <code>None</code>. Much more efficient than <code>scan</code></p></dd></dl><dl><dt class="spec value" id="val-scan_string"><a href="#val-scan_string" class="anchor"></a><code><span class="keyword">val</span> scan_string : <span class="type-var">'state</span> <span>&#45;&gt;</span> (<span class="type-var">'state</span> <span>&#45;&gt;</span> char <span>&#45;&gt;</span> <span class="type-var">'state</span> option) <span>&#45;&gt;</span> string <a href="index.html#type-t">t</a></code></dt><dd><p><code>scan init f</code> Like <code>scan</code> but discards the final state and returns the accumulated string</p></dd></dl><dl><dt class="spec value" id="val-any_uint8"><a href="#val-any_uint8" class="anchor"></a><code><span class="keyword">val</span> any_uint8 : int <a href="index.html#type-t">t</a></code></dt><dd><p><code>any_uint8</code> accepts any byte and returns it as an unsigned int8.</p></dd></dl><dl><dt class="spec value" id="val-any_int8"><a href="#val-any_int8" class="anchor"></a><code><span class="keyword">val</span> any_int8 : int <a href="index.html#type-t">t</a></code></dt><dd><p><code>any_int8</code> accepts any byte and returns it as a signed int8.</p></dd></dl><dl><dt class="spec module" id="module-BE"><a href="#module-BE" class="anchor"></a><code><span class="keyword">module</span> <a href="BE/index.html">BE</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Big endian parsers</p></dd></dl><dl><dt class="spec module" id="module-LE"><a href="#module-LE" class="anchor"></a><code><span class="keyword">module</span> <a href="LE/index.html">LE</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Little endian parsers</p></dd></dl></section><section><header><h3 id="combinators"><a href="#combinators" class="anchor"></a>Combinators</h3></header><dl><dt class="spec value" id="val-option"><a href="#val-option" class="anchor"></a><code><span class="keyword">val</span> option : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>option v p</code> runs <code>p</code>, returning the result of <code>p</code> if it succeeds and <code>v</code> if it fails.</p></dd></dl><dl><dt class="spec value" id="val-list"><a href="#val-list" class="anchor"></a><code><span class="keyword">val</span> list : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list <a href="index.html#type-t">t</a></code></dt><dd><p><code>list ps</code> runs each <code>p</code> in <code>ps</code> in sequence, returning a list of results of each <code>p</code>.</p></dd></dl><dl><dt class="spec value" id="val-count"><a href="#val-count" class="anchor"></a><code><span class="keyword">val</span> count : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <a href="index.html#type-t">t</a></code></dt><dd><p><code>count n p</code> runs <code>p</code> <code>n</code> times, returning a list of the results.</p></dd></dl><dl><dt class="spec value" id="val-many"><a href="#val-many" class="anchor"></a><code><span class="keyword">val</span> many : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <a href="index.html#type-t">t</a></code></dt><dd><p><code>many p</code> runs <code>p</code> <i>zero</i> or more times and returns a list of results from the runs of <code>p</code>.</p></dd></dl><dl><dt class="spec value" id="val-many1"><a href="#val-many1" class="anchor"></a><code><span class="keyword">val</span> many1 : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <a href="index.html#type-t">t</a></code></dt><dd><p><code>many1 p</code> runs <code>p</code> <i>one</i> or more times and returns a list of results from the runs of <code>p</code>.</p></dd></dl><dl><dt class="spec value" id="val-many_till"><a href="#val-many_till" class="anchor"></a><code><span class="keyword">val</span> many_till : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <a href="index.html#type-t">t</a></code></dt><dd><p><code>many_till p e</code> runs parser <code>p</code> <i>zero</i> or more times until action <code>e</code> succeeds and returns the list of result from the runs of <code>p</code>.</p></dd></dl><dl><dt class="spec value" id="val-sep_by"><a href="#val-sep_by" class="anchor"></a><code><span class="keyword">val</span> sep_by : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> list <a href="index.html#type-t">t</a></code></dt><dd><p><code>sep_by s p</code> runs <code>p</code> <i>zero</i> or more times, interspersing runs of <code>s</code> in between.</p></dd></dl><dl><dt class="spec value" id="val-sep_by1"><a href="#val-sep_by1" class="anchor"></a><code><span class="keyword">val</span> sep_by1 : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> list <a href="index.html#type-t">t</a></code></dt><dd><p><code>sep_by1 s p</code> runs <code>p</code> <i>one</i> or more times, interspersing runs of <code>s</code> in between.</p></dd></dl><dl><dt class="spec value" id="val-skip_many"><a href="#val-skip_many" class="anchor"></a><code><span class="keyword">val</span> skip_many : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit <a href="index.html#type-t">t</a></code></dt><dd><p><code>skip_many p</code> runs <code>p</code> <i>zero</i> or more times, discarding the results.</p></dd></dl><dl><dt class="spec value" id="val-skip_many1"><a href="#val-skip_many1" class="anchor"></a><code><span class="keyword">val</span> skip_many1 : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit <a href="index.html#type-t">t</a></code></dt><dd><p><code>skip_many1 p</code> runs <code>p</code> <i>one</i> or more times, discarding the results.</p></dd></dl><dl><dt class="spec value" id="val-fix"><a href="#val-fix" class="anchor"></a><code><span class="keyword">val</span> fix : (<span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>fix f</code> computes the fixpoint of <code>f</code> and runs the resultant parser. The argument that <code>f</code> receives is the result of <code>fix f</code>, which <code>f</code> must use, paradoxically, to define <code>fix f</code>.</p><p><code>fix</code> is useful when constructing parsers for inductively-defined types such as sequences, trees, etc. Consider for example the implementation of the <a href="index.html#val-many"><code>many</code></a> combinator defined in this library:</p><pre><code class="ml">let many p =
  fix (fun m -&gt;
    (cons &lt;$&gt; p &lt;*&gt; m) &lt;|&gt; return [])</code></pre><p><code>many p</code> is a parser that will run <code>p</code> zero or more times, accumulating the result of every run into a list, returning the result. It's defined by passing <code>fix</code> a function. This function assumes its argument <code>m</code> is a parser that behaves exactly like <code>many p</code>. You can see this in the expression comprising the left hand side of the alternative operator <code>&lt;|&gt;</code>. This expression runs the parser <code>p</code> followed by the parser <code>m</code>, and after which the result of <code>p</code> is cons'd onto the list that <code>m</code> produces. The right-hand side of the alternative operator provides a base case for the combinator: if <code>p</code> fails and the parse cannot proceed, return an empty list.</p><p>Another way to illustrate the uses of <code>fix</code> is to construct a JSON parser. Assuming that parsers exist for the basic types such as <code>false</code>, <code>true</code>, <code>null</code>, strings, and numbers, the question then becomes how to define a parser for objects and arrays? Both contain values that are themselves JSON values, so it seems as though it's impossible to write a parser that will accept JSON objects and arrays before writing a parser for JSON values as a whole.</p><p>This is the exact situation that <code>fix</code> was made for. By defining the parsers for arrays and objects within the function that you pass to <code>fix</code>, you will gain access to a parser that you can use to parse JSON values, the very parser you are defining!</p><pre><code class="ml">let json =
  fix (fun json -&gt;
    let arr = char '[' *&gt; sep_by (char ',') json &lt;* char ']' in
    let obj = char '{' *&gt; ... json ... &lt;* char '}' in
    choice [str; num; arr json, ...])</code></pre></dd></dl></section><section><header><h3 id="alternatives"><a href="#alternatives" class="anchor"></a>Alternatives</h3></header><dl><dt class="spec value" id="val-(&lt;|&gt;)"><a href="#val-(&lt;|&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&lt;|&gt;) : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>p &lt;|&gt; q</code> runs <code>p</code> and returns the result if succeeds. If <code>p</code> fails, then the input will be reset and <code>q</code> will run instead.</p></dd></dl><dl><dt class="spec value" id="val-choice"><a href="#val-choice" class="anchor"></a><code><span class="keyword">val</span> choice : ?&#8288;failure_msg:string <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>choice ?message ts</code> runs each parser in <code>ts</code> in order until one succeeds and returns that result. In the case that none of the parser succeeds, then the parser will fail with the message <code>failure_msg</code>, if provided, or a much less informative message otherwise.</p></dd></dl><dl><dt class="spec value" id="val-(&lt;?&gt;)"><a href="#val-(&lt;?&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&lt;?&gt;) : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>p &lt;?&gt; name</code> associates <code>name</code> with the parser <code>p</code>, which will be reported in the case of failure.</p></dd></dl><dl><dt class="spec value" id="val-commit"><a href="#val-commit" class="anchor"></a><code><span class="keyword">val</span> commit : unit <a href="index.html#type-t">t</a></code></dt><dd><p><code>commit</code> prevents backtracking beyond the current position of the input, allowing the manager of the input buffer to reuse the preceding bytes for other purposes.</p><p>The <a href="Unbuffered/index.html"><code>Unbuffered</code></a> parsing interface will report directly to the caller the number of bytes committed to the when returning a <a href="Unbuffered/index.html#type-state.Partial"><code>Unbuffered.state.Partial</code></a> state, allowing the caller to reuse those bytes for any purpose. The <a href="Buffered/index.html"><code>Buffered</code></a> will keep track of the region of committed bytes in its internal buffer and reuse that region to store additional input when necessary.</p></dd></dl></section><section><header><h3 id="monadic/applicative-interface"><a href="#monadic/applicative-interface" class="anchor"></a>Monadic/Applicative interface</h3></header><dl><dt class="spec value" id="val-return"><a href="#val-return" class="anchor"></a><code><span class="keyword">val</span> return : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>return v</code> creates a parser that will always succeed and return <code>v</code></p></dd></dl><dl><dt class="spec value" id="val-fail"><a href="#val-fail" class="anchor"></a><code><span class="keyword">val</span> fail : string <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>fail msg</code> creates a parser that will always fail with the message <code>msg</code></p></dd></dl><dl><dt class="spec value" id="val-(&gt;&gt;=)"><a href="#val-(&gt;&gt;=)" class="anchor"></a><code><span class="keyword">val</span> (&gt;&gt;=) : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>p &gt;&gt;= f</code> creates a parser that will run <code>p</code>, pass its result to <code>f</code>, run the parser that <code>f</code> produces, and return its result.</p></dd></dl><dl><dt class="spec value" id="val-(&gt;&gt;|)"><a href="#val-(&gt;&gt;|)" class="anchor"></a><code><span class="keyword">val</span> (&gt;&gt;|) : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>p &gt;&gt;| f</code> creates a parser that will run <code>p</code>, and if it succeeds with result <code>v</code>, will return <code>f v</code></p></dd></dl><dl><dt class="spec value" id="val-(&lt;*&gt;)"><a href="#val-(&lt;*&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&lt;*&gt;) : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>f &lt;*&gt; p</code> is equivalent to <code>f &gt;&gt;= fun f -&gt; p &gt;&gt;| f</code>.</p></dd></dl><dl><dt class="spec value" id="val-(&lt;$&gt;)"><a href="#val-(&lt;$&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&lt;$&gt;) : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>f &lt;$&gt; p</code> is equivalent to <code>p &gt;&gt;| f</code></p></dd></dl><dl><dt class="spec value" id="val-(*&gt;)"><a href="#val-(*&gt;)" class="anchor"></a><code><span class="keyword">val</span> (*&gt;) : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>p *&gt; q</code> runs <code>p</code>, discards its result and then runs <code>q</code>, and returns its result.</p></dd></dl><dl><dt class="spec value" id="val-(&lt;*)"><a href="#val-(&lt;*)" class="anchor"></a><code><span class="keyword">val</span> (&lt;*) : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>p &lt;* q</code> runs <code>p</code>, then runs <code>q</code>, discards its result, and returns the result of <code>p</code>.</p></dd></dl><dl><dt class="spec value" id="val-lift"><a href="#val-lift" class="anchor"></a><code><span class="keyword">val</span> lift : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-lift2"><a href="#val-lift2" class="anchor"></a><code><span class="keyword">val</span> lift2 : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-lift3"><a href="#val-lift3" class="anchor"></a><code><span class="keyword">val</span> lift3 : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'d</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'d</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-lift4"><a href="#val-lift4" class="anchor"></a><code><span class="keyword">val</span> lift4 : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'d</span> <span>&#45;&gt;</span> <span class="type-var">'e</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'d</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'e</span> <a href="index.html#type-t">t</a></code></dt><dd><p>The <code>liftn</code> family of functions promote functions to the parser monad. For any of these functions, the following equivalence holds:</p><pre><code class="ml">liftn f p1 ... pn = f &lt;$&gt; p1 &lt;*&gt; ... &lt;*&gt; pn</code></pre><p>These functions are more efficient than using the applicative interface directly, mostly in terms of memory allocation but also in terms of speed. Prefer them over the applicative interface, even when the arity of the function to be lifted exceeds the maximum <code>n</code> for which there is an implementation for <code>liftn</code>. In other words, if <code>f</code> has an arity of <code>5</code> but only <code>lift4</code> is provided, do the following:</p><pre><code class="ml">lift4 f m1 m2 m3 m4 &lt;*&gt; m5</code></pre><p>Even with the partial application, it will be more efficient than the applicative implementation.</p></dd></dl><dl><dt class="spec module" id="module-Unsafe"><a href="#module-Unsafe" class="anchor"></a><code><span class="keyword">module</span> <a href="Unsafe/index.html">Unsafe</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Unsafe Operations on Angstrom's Internal Buffer</p></dd></dl></section><section><header><h3 id="running"><a href="#running" class="anchor"></a>Running</h3></header><dl><dt class="spec value" id="val-parse_bigstring"><a href="#val-parse_bigstring" class="anchor"></a><code><span class="keyword">val</span> parse_bigstring : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-bigstring">bigstring</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, string) <a href="../../result/Result/index.html#type-result">Result.result</a></code></dt><dd><p><code>parse_bigstring t bs</code> runs <code>t</code> on <code>bs</code>. The parser will receive an <code>`Eof</code> after all of <code>bs</code> has been consumed. For use-cases requiring that the parser be fed input incrementally, see the <a href="Buffered/index.html"><code>Buffered</code></a> and <a href="Unbuffered/index.html"><code>Unbuffered</code></a> modules below.</p></dd></dl><dl><dt class="spec value" id="val-parse_string"><a href="#val-parse_string" class="anchor"></a><code><span class="keyword">val</span> parse_string : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> (<span class="type-var">'a</span>, string) <a href="../../result/Result/index.html#type-result">Result.result</a></code></dt><dd><p><code>parse_string t bs</code> runs <code>t</code> on <code>bs</code>. The parser will receive an <code>`Eof</code> after all of <code>bs</code> has been consumed. For use-cases requiring that the parser be fed input incrementally, see the <a href="Buffered/index.html"><code>Buffered</code></a> and <a href="Unbuffered/index.html"><code>Unbuffered</code></a> modules below.</p></dd></dl><dl><dt class="spec module" id="module-Buffered"><a href="#module-Buffered" class="anchor"></a><code><span class="keyword">module</span> <a href="Buffered/index.html">Buffered</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Buffered parsing interface.</p></dd></dl><dl><dt class="spec module" id="module-Unbuffered"><a href="#module-Unbuffered" class="anchor"></a><code><span class="keyword">module</span> <a href="Unbuffered/index.html">Unbuffered</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Unbuffered parsing interface.</p></dd></dl></section></div></body></html>