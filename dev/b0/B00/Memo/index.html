<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Memo (b0.B00.Memo)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">b0</a> &#x00BB; <a href="../index.html">B00</a> &#x00BB; Memo</nav><h1>Module <code>B00.Memo</code></h1><p>Build memoizer.</p><p>A memoizer ties together and environment, an operation cache, a guard and an executor.</p><nav class="toc"><ul><li><a href="#memo">Memoizer</a></li><li><a href="#fibers">Fibers</a></li><li><a href="#files">Files and directories</a></li><li><a href="#spawn">Memoizing tool spawns</a></li><li><a href="#futs">Future values</a></li></ul></nav></header><section><header><h2 id="memo"><a href="#memo" class="anchor"></a>Memoizer</h2></header><dl><dt class="spec type" id="type-feedback"><a href="#type-feedback" class="anchor"></a><code><span class="keyword">type</span> feedback</code> = <code>[ </code><table class="variant"><tr id="type-feedback.Fiber_exn" class="anchored"><td class="def constructor"><a href="#type-feedback.Fiber_exn" class="anchor"></a><code>| </code><code>`Fiber_exn <span class="keyword">of</span> exn * <a href="../../../ocaml/Stdlib/Printexc/index.html#type-raw_backtrace">Stdlib.Printexc.raw_backtrace</a></code></td></tr><tr id="type-feedback.Fiber_fail" class="anchored"><td class="def constructor"><a href="#type-feedback.Fiber_fail" class="anchor"></a><code>| </code><code>`Fiber_fail <span class="keyword">of</span> string</code></td></tr><tr id="type-feedback.Miss_tool" class="anchored"><td class="def constructor"><a href="#type-feedback.Miss_tool" class="anchor"></a><code>| </code><code>`Miss_tool <span class="keyword">of</span> <a href="../Tool/index.html#type-t">Tool.t</a> * string</code></td></tr><tr id="type-feedback.Op_cache_error" class="anchored"><td class="def constructor"><a href="#type-feedback.Op_cache_error" class="anchor"></a><code>| </code><code>`Op_cache_error <span class="keyword">of</span> <a href="../Op/index.html#type-t">Op.t</a> * string</code></td></tr><tr id="type-feedback.Op_complete" class="anchored"><td class="def constructor"><a href="#type-feedback.Op_complete" class="anchor"></a><code>| </code><code>`Op_complete <span class="keyword">of</span> <a href="../Op/index.html#type-t">Op.t</a> * [ `Did_not_write of <a href="../../B0_std/Fpath/index.html#type-t">B0_std.Fpath.t</a> list ]</code></td></tr></table><code> ]</code></dt><dd><p>The type for memoizer feedback.</p></dd></dl><dl><dt class="spec value" id="val-pp_feedback"><a href="#val-pp_feedback" class="anchor"></a><code><span class="keyword">val</span> pp_feedback : <a href="index.html#type-feedback">feedback</a> <a href="../../B0_std/Fmt/index.html#type-t">B0_std.Fmt.t</a></code></dt><dd><p><code>pp_feedback ppf</code> formats feedback.</p></dd></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><p>The type for memoizers. This ties together an environment, a aguard, an operation cache and an executor.</p></dd></dl><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : ?&#8288;clock:<a href="../../B0_std/Time/index.html#type-counter">B0_std.Time.counter</a> <span>&#45;&gt;</span> ?&#8288;cpu_clock:<a href="../../B0_std/Time/index.html#type-cpu_counter">B0_std.Time.cpu_counter</a> <span>&#45;&gt;</span> feedback:(<a href="index.html#type-feedback">feedback</a> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> cwd:<a href="../../B0_std/Fpath/index.html#type-t">B0_std.Fpath.t</a> <span>&#45;&gt;</span> <a href="../Env/index.html#type-t">Env.t</a> <span>&#45;&gt;</span> <a href="../Guard/index.html#type-t">Guard.t</a> <span>&#45;&gt;</span> <a href="../Op_cache/index.html#type-t">Op_cache.t</a> <span>&#45;&gt;</span> <a href="../Exec/index.html#type-t">Exec.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-memo"><a href="#val-memo" class="anchor"></a><code><span class="keyword">val</span> memo : ?&#8288;hash_fun:(<span class="keyword">module</span> <a href="../../B0_std/Hash/module-type-T/index.html">B0_std.Hash.T</a>) <span>&#45;&gt;</span> ?&#8288;env:<a href="../../B0_std/Os/Env/index.html#type-t">B0_std.Os.Env.t</a> <span>&#45;&gt;</span> ?&#8288;cwd:<a href="../../B0_std/Fpath/index.html#type-t">B0_std.Fpath.t</a> <span>&#45;&gt;</span> ?&#8288;cachedir:<a href="../../B0_std/Fpath/index.html#type-t">B0_std.Fpath.t</a> <span>&#45;&gt;</span> ?&#8288;max_spawn:int <span>&#45;&gt;</span> ?&#8288;feedback:([ <a href="index.html#type-feedback">feedback</a> | <a href="../File_cache/index.html#type-feedback">File_cache.feedback</a> | <a href="../Exec/index.html#type-feedback">Exec.feedback</a> ] <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> (<a href="index.html#type-t">t</a>, string) <a href="../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></code></dt><dd><p><code>memo</code> is a simpler <a href="index.html#val-create"><code>create</code></a></p><ul><li><code>hash_fun</code> defaults to <a href="../Op_cache/index.html#val-create"><code>Op_cache.create</code></a>'s default.</li><li><code>max_spawn</code> defaults to <a href="../Exec/index.html#val-create"><code>Exec.create</code></a>'s default.</li><li><code>env</code> defaults to <span class="xref-unresolved" title="unresolved reference to &quot;Os.Env.current&quot;"><span class="xref-unresolved" title="unresolved reference to &quot;Os.Env&quot;"><code>Os</code>.Env</span>.current</span></li><li><code>cwd</code> defaults to <span class="xref-unresolved" title="unresolved reference to &quot;Os.Dir.cwd&quot;"><span class="xref-unresolved" title="unresolved reference to &quot;Os.Dir&quot;"><code>Os</code>.Dir</span>.cwd</span></li><li><code>cachedir</code> defaults to <code>Fpath.(cwd / &quot;_b0&quot; / &quot;cache&quot;)</code></li><li><code>feedback</code> defaults formats feedback on stdout.</li></ul></dd></dl><dl><dt class="spec value" id="val-clock"><a href="#val-clock" class="anchor"></a><code><span class="keyword">val</span> clock : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../B0_std/Time/index.html#type-counter">B0_std.Time.counter</a></code></dt><dd><p><code>clock m</code> is <code>m</code>'s clock.</p></dd></dl><dl><dt class="spec value" id="val-cpu_clock"><a href="#val-cpu_clock" class="anchor"></a><code><span class="keyword">val</span> cpu_clock : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../B0_std/Time/index.html#type-cpu_counter">B0_std.Time.cpu_counter</a></code></dt><dd><p><code>cpu_clock m</code> is <code>m</code>'s cpu clock.</p></dd></dl><dl><dt class="spec value" id="val-env"><a href="#val-env" class="anchor"></a><code><span class="keyword">val</span> env : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Env/index.html#type-t">Env.t</a></code></dt><dd><p><code>env m</code> is <code>m</code>'s environment.</p></dd></dl><dl><dt class="spec value" id="val-op_cache"><a href="#val-op_cache" class="anchor"></a><code><span class="keyword">val</span> op_cache : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Op_cache/index.html#type-t">Op_cache.t</a></code></dt><dd><p><code>op_cache m</code> is <code>m</code>'s operation cache.</p></dd></dl><dl><dt class="spec value" id="val-guard"><a href="#val-guard" class="anchor"></a><code><span class="keyword">val</span> guard : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Guard/index.html#type-t">Guard.t</a></code></dt><dd><p><code>guard m</code> is <code>m</code>'s guard.</p></dd></dl><dl><dt class="spec value" id="val-exec"><a href="#val-exec" class="anchor"></a><code><span class="keyword">val</span> exec : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Exec/index.html#type-t">Exec.t</a></code></dt><dd><p><code>exec m</code> is <code>m</code>'s executors.</p></dd></dl><dl><dt class="spec value" id="val-hash_fun"><a href="#val-hash_fun" class="anchor"></a><code><span class="keyword">val</span> hash_fun : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="keyword">module</span> <a href="../../B0_std/Hash/module-type-T/index.html">B0_std.Hash.T</a>)</code></dt><dd><p><code>hash_fun m</code> is <code>m</code>'s hash function.</p></dd></dl><dl><dt class="spec value" id="val-stir"><a href="#val-stir" class="anchor"></a><code><span class="keyword">val</span> stir : block:bool <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>stir ~block m</code> runs the memoizer a bit. If <code>block</code> is <code>true</code> blocks until the memoizer is stuck with no operation to perform.</p></dd></dl><dl><dt class="spec value" id="val-finish"><a href="#val-finish" class="anchor"></a><code><span class="keyword">val</span> finish : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (unit, <a href="../../B0_std/Fpath/Set/index.html#type-t">B0_std.Fpath.Set.t</a>) <a href="../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></code></dt><dd><p><code>finish m</code> finishes the memoizer. This blocks until there are no operation to execute like <a href="index.html#val-stir"><code>stir</code></a> does. If no operations are left waiting this returns <code>Ok ()</code>. If there are remaining wiating operations it aborts them and returns <code>Error fs</code> with <code>fs</code> the files that never became ready and where not supposed to be written by the waiting operations.</p></dd></dl><dl><dt class="spec value" id="val-ops"><a href="#val-ops" class="anchor"></a><code><span class="keyword">val</span> ops : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Op/index.html#type-t">Op.t</a> list</code></dt><dd><p><code>ops m</code> is the list of operations that were submitted to the memoizer</p></dd></dl></section><section><header><h2 id="fibers"><a href="#fibers" class="anchor"></a>Fibers</h2></header><dl><dt class="spec type" id="type-fiber"><a href="#type-fiber" class="anchor"></a><code><span class="keyword">type</span> 'a fiber</code><code> = (<span class="type-var">'a</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit</code></dt><dd><p>The type for memoizer operation fibers.</p></dd></dl><dl><dt class="spec value" id="val-fail"><a href="#val-fail" class="anchor"></a><code><span class="keyword">val</span> fail : (<span class="type-var">'b</span>, <a href="../../../ocaml/Stdlib/Format/index.html#type-formatter">Stdlib.Format.formatter</a>, unit, <span class="type-var">'a</span>) <a href="../../../ocaml/Stdlib/index.html#type-format4">Stdlib.format4</a> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p><code>fail fmt ...</code> fails the fiber with the given error message.</p></dd></dl><dl><dt class="spec value" id="val-fail_error"><a href="#val-fail_error" class="anchor"></a><code><span class="keyword">val</span> fail_error : (<span class="type-var">'a</span>, string) <a href="../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>fail_error</code> fails the fiber with the given error.</p></dd></dl></section><section><header><h2 id="files"><a href="#files" class="anchor"></a>Files and directories</h2></header><dl><dt class="spec value" id="val-file_ready"><a href="#val-file_ready" class="anchor"></a><code><span class="keyword">val</span> file_ready : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../B0_std/Fpath/index.html#type-t">B0_std.Fpath.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>ready m p</code> declares path <code>p</code> to be ready, that is exists and is up-to-date in <code>b</code>. This is typically used with source files and files external to the build (e.g. installed libraries).</p></dd></dl><dl><dt class="spec value" id="val-wait_files"><a href="#val-wait_files" class="anchor"></a><code><span class="keyword">val</span> wait_files : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../B0_std/Fpath/index.html#type-t">B0_std.Fpath.t</a> list <span>&#45;&gt;</span> unit <a href="index.html#type-fiber">fiber</a></code></dt><dd><p><code>wait_files m files k</code> continues with <code>k ()</code> when <code>files</code> become ready. <b>FIXME</b> Unclear whether we really want this though this is kind of a <code>reads</code> constraint for a pure OCaml operation, but then we got <a href="index.html#val-read"><code>read</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-read"><a href="#val-read" class="anchor"></a><code><span class="keyword">val</span> read : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../B0_std/Fpath/index.html#type-t">B0_std.Fpath.t</a> <span>&#45;&gt;</span> string <a href="index.html#type-fiber">fiber</a></code></dt><dd><p><code>read m file k</code> reads the contents of file <code>file</code> as <code>s</code> when it becomes ready and continues with <code>k s</code>.</p></dd></dl><dl><dt class="spec value" id="val-write"><a href="#val-write" class="anchor"></a><code><span class="keyword">val</span> write : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> ?&#8288;salt:string <span>&#45;&gt;</span> ?&#8288;reads:<a href="../../B0_std/Fpath/index.html#type-t">B0_std.Fpath.t</a> list <span>&#45;&gt;</span> ?&#8288;mode:int <span>&#45;&gt;</span> <a href="../../B0_std/Fpath/index.html#type-t">B0_std.Fpath.t</a> <span>&#45;&gt;</span> (unit <span>&#45;&gt;</span> (string, string) <a href="../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a>) <span>&#45;&gt;</span> unit</code></dt><dd><p><code>write m ~reads file w</code> writes <code>file</code> with data <code>w ()</code> and mode <code>mode</code> (defaults to <code>0o644</code>) when <code>reads</code> are ready. <code>w</code>'s result must only depend on <code>reads</code> and <code>salt</code> (defaults to <code>&quot;&quot;</code>).</p></dd></dl><dl><dt class="spec value" id="val-mkdir"><a href="#val-mkdir" class="anchor"></a><code><span class="keyword">val</span> mkdir : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../B0_std/Fpath/index.html#type-t">B0_std.Fpath.t</a> <span>&#45;&gt;</span> unit <a href="index.html#type-fiber">fiber</a></code></dt><dd><p><code>mkdir m dir k</code> creates directory <code>dir</code> and continues with <code>k ()</code> at which point file <code>dir</code> is ready.</p></dd></dl></section><section><header><h2 id="spawn"><a href="#spawn" class="anchor"></a>Memoizing tool spawns</h2></header><dl><dt class="spec type" id="type-tool"><a href="#type-tool" class="anchor"></a><code><span class="keyword">type</span> tool</code></dt><dd><p>The type for memoized tools.</p></dd></dl><dl><dt class="spec type" id="type-cmd"><a href="#type-cmd" class="anchor"></a><code><span class="keyword">type</span> cmd</code></dt><dd><p>The type for memoized tool invocations.</p></dd></dl><dl><dt class="spec value" id="val-tool"><a href="#val-tool" class="anchor"></a><code><span class="keyword">val</span> tool : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Tool/index.html#type-t">Tool.t</a> <span>&#45;&gt;</span> <a href="../../B0_std/Cmd/index.html#type-t">B0_std.Cmd.t</a> <span>&#45;&gt;</span> <a href="index.html#type-cmd">cmd</a></code></dt><dd><p><code>tool m t</code> is tool <code>t</code> memoized. Use the resulting function to spawn the tool with the given arguments.</p></dd></dl><dl><dt class="spec value" id="val-spawn"><a href="#val-spawn" class="anchor"></a><code><span class="keyword">val</span> spawn : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> ?&#8288;reads:<a href="../../B0_std/Fpath/index.html#type-t">B0_std.Fpath.t</a> list <span>&#45;&gt;</span> ?&#8288;writes:<a href="../../B0_std/Fpath/index.html#type-t">B0_std.Fpath.t</a> list <span>&#45;&gt;</span> ?&#8288;env:<a href="../../B0_std/Os/Env/index.html#type-t">B0_std.Os.Env.t</a> <span>&#45;&gt;</span> ?&#8288;cwd:<a href="../../B0_std/Fpath/index.html#type-t">B0_std.Fpath.t</a> <span>&#45;&gt;</span> ?&#8288;stdin:<a href="../../B0_std/Fpath/index.html#type-t">B0_std.Fpath.t</a> <span>&#45;&gt;</span> ?&#8288;stdout:<a href="../Op/Spawn/index.html#type-stdo">Op.Spawn.stdo</a> <span>&#45;&gt;</span> ?&#8288;stderr:<a href="../Op/Spawn/index.html#type-stdo">Op.Spawn.stdo</a> <span>&#45;&gt;</span> ?&#8288;success_exits:<a href="../Op/Spawn/index.html#type-success_exits">Op.Spawn.success_exits</a> <span>&#45;&gt;</span> ?&#8288;k:(int <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <a href="index.html#type-cmd">cmd</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>spawn m ~reads ~writes ~env ~cwd ~stdin ~stdout ~stderr
      ~success_exits cmd</code> spawns <code>cmd</code> once <code>reads</code> files are ready and makes files <code>writes</code> ready if the spawn succeeds and the file exists. The rest of the arguments are:</p><ul><li><code>stdin</code> reads input from the given file. If unspecified reads from the standard input of the program running the build. <b>Warning.</b> The file is not automatically added to <code>reads</code>, this allows for example to use <span class="xref-unresolved" title="unresolved reference to &quot;Os.File.null&quot;"><span class="xref-unresolved" title="unresolved reference to &quot;Os.File&quot;"><code>Os</code>.File</span>.null</span>.</li><li><code>stdout</code> and <code>stderr</code>, the redirections for the standard outputs of the command, see <code>stdo</code>. <b>Warning.</b> File redirections are not automatically added to <code>writes</code>; this allows for example to use <span class="xref-unresolved" title="unresolved reference to &quot;Os.File.null&quot;"><span class="xref-unresolved" title="unresolved reference to &quot;Os.File&quot;"><code>Os</code>.File</span>.null</span>.</li><li><code>success_exits</code> the exit codes that determine if the build operation is successful (defaults to <code>0</code>, use <code>[]</code> to always succeed)</li><li><code>env</code>, environment variables added to the build environment. This overrides environment variables read by the tool in the build environment except for forced one. It also allows to specify environment that may not be mentioned by the running tool's <a href="../Tool/index.html#val-v"><span>environment specification</span></a>.</li><li><code>cwd</code> the current working directory. Default is <code>cwd</code>. In general it's better to avoid using relative file paths and tweaking the <code>cwd</code>. Construct your paths using the absolute <span class="xref-unresolved" title="unresolved reference to &quot;dirs&quot;"><span>directory functions</span></span> and make your invocations independent from the <code>cwd</code>.</li><li><code>k</code>, if specified a fiber invoked once the spawn has succesfully executed with the exit code.</li></ul><p><b>TODO.</b> More expressive power could by added by:</p><ol><li>Support to refine the read and write set after the operation returns.</li></ol><p><b>Note.</b> If the tool spawn acts on a sort of &quot;main&quot; file (e.g. a source file) it should be specified as the first element of <code>reads</code>, this is interpreted specially by certain build tracer.</p></dd></dl></section><section><header><h2 id="futs"><a href="#futs" class="anchor"></a>Future values</h2></header><dl><dt class="spec module" id="module-Fut"><a href="#module-Fut" class="anchor"></a><code><span class="keyword">module</span> <a href="Fut/index.html">Fut</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Future values.</p></dd></dl></section></div></body></html>