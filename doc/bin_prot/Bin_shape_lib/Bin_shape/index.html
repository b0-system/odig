<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Bin_shape (bin_prot.Bin_shape_lib.Bin_shape)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">bin_prot</a> &#x00BB; <a href="../index.html">Bin_shape_lib</a> &#x00BB; Bin_shape</nav><header class="odoc-preamble"><h1>Module <code><span>Bin_shape_lib.Bin_shape</span></code></h1></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div><div class="spec-doc"><p><code>Shape.t</code> are constructed by the <code>bin_shape</code> syntax extension from Ocaml type definitions &amp; expressions.</p><p>There is a direct mapping from ocaml type definition syntax to the corresponding <code>Shape.group</code> and from ocaml type expression syntax to the corresponding <code>Shape.t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sexp_of_t" class="anchored"><a href="#val-sexp_of_t" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_t : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a></span></code></div></div><p><code>Tid.t</code> &amp; <code>Vid.t</code> are identifiers for type-constructors &amp; type-vars. i.e. Given <code>type 'a t = ... </code></p><div class="odoc-spec"><div class="spec module" id="module-Tid" class="anchored"><a href="#module-Tid" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Tid/index.html">Tid</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Vid" class="anchored"><a href="#module-Vid" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Vid/index.html">Vid</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Location" class="anchored"><a href="#module-Location" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Location/index.html">Location</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p><code>Location.t</code> is required when constructing shapes for which evaluation might fail.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Uuid" class="anchored"><a href="#module-Uuid" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Uuid/index.html">Uuid</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p><code>Uuid.t</code> is used by <code>basetype</code> and <code>annotate</code>.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-group" class="anchored"><a href="#type-group" class="anchor"></a><code><span><span class="keyword">type</span> group</span></code></div><div class="spec-doc"><p>group of mutually recursive type definitions</p></div></div><div class="odoc-spec"><div class="spec value" id="val-group" class="anchored"><a href="#val-group" class="anchor"></a><code><span><span class="keyword">val</span> group : <span><a href="Location/index.html#type-t">Location.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<a href="Tid/index.html#type-t">Tid.t</a> * <span><a href="Vid/index.html#type-t">Vid.t</a> list</span> * <a href="#type-t">t</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-group">group</a></span></code></div><div class="spec-doc"><p>This function is generative; repeated calls create distinct groups</p></div></div><div class="odoc-spec"><div class="spec value" id="val-tuple" class="anchored"><a href="#val-tuple" class="anchor"></a><code><span><span class="keyword">val</span> tuple : <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-record" class="anchored"><a href="#val-record" class="anchor"></a><code><span><span class="keyword">val</span> record : <span><span><span>(string * <a href="#type-t">t</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-variant" class="anchored"><a href="#val-variant" class="anchor"></a><code><span><span class="keyword">val</span> variant : <span><span><span>(string * <span><a href="#type-t">t</a> list</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-poly_variant_row" class="anchored"><a href="#type-poly_variant_row" class="anchor"></a><code><span><span class="keyword">type</span> poly_variant_row</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-constr" class="anchored"><a href="#val-constr" class="anchor"></a><code><span><span class="keyword">val</span> constr : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> option</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-poly_variant_row">poly_variant_row</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-inherit_" class="anchored"><a href="#val-inherit_" class="anchor"></a><code><span><span class="keyword">val</span> inherit_ : <span><a href="Location/index.html#type-t">Location.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-poly_variant_row">poly_variant_row</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-poly_variant" class="anchored"><a href="#val-poly_variant" class="anchor"></a><code><span><span class="keyword">val</span> poly_variant : <span><a href="Location/index.html#type-t">Location.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-poly_variant_row">poly_variant_row</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-rec_app" class="anchored"><a href="#val-rec_app" class="anchor"></a><code><span><span class="keyword">val</span> rec_app : <span><a href="Tid/index.html#type-t">Tid.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>recursive apps within the current group</p></div></div><div class="odoc-spec"><div class="spec value" id="val-top_app" class="anchored"><a href="#val-top_app" class="anchor"></a><code><span><span class="keyword">val</span> top_app : <span><a href="#type-group">group</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="Tid/index.html#type-t">Tid.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>apps from outside the group</p></div></div><div class="odoc-spec"><div class="spec value" id="val-var" class="anchored"><a href="#val-var" class="anchor"></a><code><span><span class="keyword">val</span> var : <span><a href="Location/index.html#type-t">Location.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="Vid/index.html#type-t">Vid.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-basetype" class="anchored"><a href="#val-basetype" class="anchor"></a><code><span><span class="keyword">val</span> basetype : <span><a href="Uuid/index.html#type-t">Uuid.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Built-in types and types with custom serialization: i.e. int,list,... To avoid accidental protocol compatibility, pass a UUID as the <code>string</code> argument</p></div></div><p><code>a = annotate s t</code> creates a shape <code>a</code> distinguished, but dependent on shape <code>t</code>. Very much as <code>record [(s,t)]</code> does. But with <code>annotate</code> the ocaml record type does not exist.</p><div class="odoc-spec"><div class="spec value" id="val-annotate" class="anchored"><a href="#val-annotate" class="anchor"></a><code><span><span class="keyword">val</span> annotate : <span><a href="Uuid/index.html#type-t">Uuid.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><p><code>Shape.Canonical.t</code> is the result of <code>eval</code>uating a shape to a canonical form, and represents the shape of Ocaml types w.r.t. bin_io serialization.</p><p>The idea is that de-serialization is safe if the canonical-shape for the type produced by de-serialization is equivalent to the canonical-shape of the serialized type.</p><p>The representation is canonical, so equivalence is structural equality.</p><p><code>Canonical.t</code> also provides a useful human level description of a type.</p><p>A <code>Canonical.t</code> can be `digested' to a <code>Digest.t</code>, and except for nearly impossible hash collisions, equality of the digests implies equality of canonical-shapes and hence equivalence at the Shape.t level.</p><p><code>Canonical.t</code> may also be constructed with various functions: <code>annotate, basetype, tuple, record, variant, poly_variant, fix, recurse, ..</code> which might be used when setting up unit tests or expected shapes.</p><div class="odoc-spec"><div class="spec module" id="module-Digest" class="anchored"><a href="#module-Digest" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Digest/index.html">Digest</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Canonical" class="anchored"><a href="#module-Canonical" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Canonical/index.html">Canonical</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-eval" class="anchored"><a href="#val-eval" class="anchor"></a><code><span><span class="keyword">val</span> eval : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="Canonical/index.html#type-t">Canonical.t</a></span></code></div><div class="spec-doc"><p><code>eval t</code> returns the canonical-shape for a shape-expression <code>Shape.t</code>. Type aliases are expanded, so that no <code>Tid.t</code> or <code>Vid.t</code> have significance in the resulting canonical-shape. Type-recursion, including non-regular recursion, is translated to the de-bruijn representation used in canonical-shapes.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-eval_to_digest" class="anchored"><a href="#val-eval_to_digest" class="anchor"></a><code><span><span class="keyword">val</span> eval_to_digest : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="Digest/index.html#type-t">Digest.t</a></span></code></div><div class="spec-doc"><p><code>eval_to_digest t</code> returns a hash-value direct from the <code>Shape.t</code>, potentially avoiding the intermediate <code>Canonical.t</code> from being constructed. This is important as the size of a canonical-shape might be exponential in terms of the size of the shape expression. The following holds: <code> Digest.(eval_to_digest exp = Canonical.to_digest (eval exp)) </code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-eval_to_digest_string" class="anchored"><a href="#val-eval_to_digest_string" class="anchor"></a><code><span><span class="keyword">val</span> eval_to_digest_string : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>eval_to_digest_string t</code> == <code>Digest.to_hex (eval_to_digest t)</code> Convenience function useful for writing unit tests.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-For_typerep" class="anchored"><a href="#module-For_typerep" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="For_typerep/index.html">For_typerep</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div></div></body></html>