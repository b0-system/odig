<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Both_convert (async_rpc_kernel.Async_rpc_kernel__.Versioned_rpc.Both_convert)</title><link rel="stylesheet" href="../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../../index.html">async_rpc_kernel</a> &#x00BB; <a href="../../index.html">Async_rpc_kernel__</a> &#x00BB; <a href="../index.html">Versioned_rpc</a> &#x00BB; Both_convert</nav><h1>Module <code>Versioned_rpc.Both_convert</code></h1></header><aside><p><code>Both_convert</code> rpcs combine features of both caller-converts and callee-converts versioning schemes in such a way that one can smoothly add a new version of the rpc to a shared library, and it doesn't matter whether the callee or caller upgrades to the latest version of the shared library first, the new version will not be exercised until both sides support it.</p></aside><div class="spec module" id="module-Plain"><a href="#module-Plain" class="anchor"></a><code><span class="keyword">module</span> <a href="Plain/index.html">Plain</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Pipe_rpc"><a href="#module-Pipe_rpc" class="anchor"></a><code><span class="keyword">module</span> <a href="Pipe_rpc/index.html">Pipe_rpc</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-One_way"><a href="#module-One_way" class="anchor"></a><code><span class="keyword">module</span> <a href="One_way/index.html">One_way</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></div></body></html>