<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Digest (omod.Omod_support.Digest)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">omod</a> &#x00BB; <a href="../index.html">Omod_support</a> &#x00BB; Digest</nav><h1>Module <code>Omod_support.Digest</code></h1><p>Digests.</p></header><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> <a href="../../../ocaml/Stdlib/index.html#module-Digest">Stdlib.Digest</a></code></span></summary><aside><p>MD5 message digest.</p><p>This module provides functions to compute 128-bit 'digests' of arbitrary-length strings or files. The digests are of cryptographic quality: it is very hard, given a digest, to forge a string having that digest. The algorithm used is MD5. This module should not be used for secure and sensitive cryptographic applications. For these kind of applications more recent and stronger cryptographic primitives should be used instead.</p></aside><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code><code> = string</code></dt><dd><p>The type of digests: 16-character strings.</p></dd></dl><dl><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val</span> compare : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>The comparison function for 16-character digest, with the same specification as <a href="../../../ocaml/Stdlib/index.html#val-compare"><code>Stdlib.compare</code></a> and the implementation shared with <span class="xref-unresolved" title="unresolved reference to &quot;String.compare&quot;"><code>String</code>.compare</span>. Along with the type <code>t</code>, this function <code>compare</code> allows the module <code>Digest</code> to be passed as argument to the functors <span class="xref-unresolved" title="unresolved reference to &quot;Set.Make&quot;"><a href="index.html#module-Set"><code>Set</code></a>.Make</span> and <span class="xref-unresolved" title="unresolved reference to &quot;Map.Make&quot;"><a href="index.html#module-Map"><code>Map</code></a>.Make</span>.</p><dl><dt>since</dt><dd>4.00.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val</span> equal : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>The equal function for 16-character digest.</p><dl><dt>since</dt><dd>4.03.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-string"><a href="#val-string" class="anchor"></a><code><span class="keyword">val</span> string : string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Return the digest of the given string.</p></dd></dl><dl><dt class="spec value" id="val-bytes"><a href="#val-bytes" class="anchor"></a><code><span class="keyword">val</span> bytes : bytes <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Return the digest of the given byte sequence.</p><dl><dt>since</dt><dd>4.02.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-substring"><a href="#val-substring" class="anchor"></a><code><span class="keyword">val</span> substring : string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>Digest.substring s ofs len</code> returns the digest of the substring of <code>s</code> starting at index <code>ofs</code> and containing <code>len</code> characters.</p></dd></dl><dl><dt class="spec value" id="val-subbytes"><a href="#val-subbytes" class="anchor"></a><code><span class="keyword">val</span> subbytes : bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>Digest.subbytes s ofs len</code> returns the digest of the subsequence of <code>s</code> starting at index <code>ofs</code> and containing <code>len</code> bytes.</p><dl><dt>since</dt><dd>4.02.0</dd></dl></dd></dl><dl><dt class="spec external" id="val-channel"><a href="#val-channel" class="anchor"></a><code><span class="keyword">val</span> channel : <a href="../../../ocaml/Stdlib/index.html#type-in_channel">Stdlib.in_channel</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>If <code>len</code> is nonnegative, <code>Digest.channel ic len</code> reads <code>len</code> characters from channel <code>ic</code> and returns their digest, or raises <code>End_of_file</code> if end-of-file is reached before <code>len</code> characters are read. If <code>len</code> is negative, <code>Digest.channel ic len</code> reads all characters from <code>ic</code> until end-of-file is reached and return their digest.</p></dd></dl><dl><dt class="spec value" id="val-file"><a href="#val-file" class="anchor"></a><code><span class="keyword">val</span> file : string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Return the digest of the file whose name is given.</p></dd></dl><dl><dt class="spec value" id="val-output"><a href="#val-output" class="anchor"></a><code><span class="keyword">val</span> output : <a href="../../../ocaml/Stdlib/index.html#type-out_channel">Stdlib.out_channel</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Write a digest on the given output channel.</p></dd></dl><dl><dt class="spec value" id="val-input"><a href="#val-input" class="anchor"></a><code><span class="keyword">val</span> input : <a href="../../../ocaml/Stdlib/index.html#type-in_channel">Stdlib.in_channel</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Read a digest from the given input channel.</p></dd></dl><dl><dt class="spec value" id="val-to_hex"><a href="#val-to_hex" class="anchor"></a><code><span class="keyword">val</span> to_hex : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p>Return the printable hexadecimal representation of the given digest. Raise <code>Invalid_argument</code> if the argument is not exactly 16 bytes.</p></dd></dl><dl><dt class="spec value" id="val-from_hex"><a href="#val-from_hex" class="anchor"></a><code><span class="keyword">val</span> from_hex : string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Convert a hexadecimal representation back into the corresponding digest. Raise <code>Invalid_argument</code> if the argument is not exactly 32 hexadecimal characters.</p><dl><dt>since</dt><dd>4.00.0</dd></dl></dd></dl></details></div></div></div><dl><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val</span> pp : <a href="../../../ocaml/Stdlib/Format/index.html#type-formatter">Stdlib.Format.formatter</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp</code> formats digests.</p></dd></dl><dl><dt class="spec value" id="val-pp_opt"><a href="#val-pp_opt" class="anchor"></a><code><span class="keyword">val</span> pp_opt : <a href="../../../ocaml/Stdlib/Format/index.html#type-formatter">Stdlib.Format.formatter</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> option <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp_opt</code> formats optional digests.</p></dd></dl><dl><dt class="spec module" id="module-Set"><a href="#module-Set" class="anchor"></a><code><span class="keyword">module</span> <a href="Set/index.html">Set</a> : <a href="../../../ocaml/Stdlib/Set/index.html#module-type-S">Stdlib.Set.S</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../../../ocaml/Stdlib/Set/module-type-S/index.html#type-elt">elt</a> = <a href="index.html#type-t">t</a></code></dt><dd><p>Digest sets.</p></dd></dl><dl><dt class="spec module" id="module-Map"><a href="#module-Map" class="anchor"></a><code><span class="keyword">module</span> <a href="Map/index.html">Map</a> : <a href="../../../ocaml/Stdlib/Map/index.html#module-type-S">Stdlib.Map.S</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../../../ocaml/Stdlib/Map/module-type-S/index.html#type-key">key</a> = <a href="index.html#type-t">t</a></code></dt><dd><p>Digest maps.</p></dd></dl></div></body></html>