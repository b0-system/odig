<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>driver_dev (b0.driver_dev)</title><link rel="stylesheet" href="../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="index.html">Up</a> â€“ <a href="index.html">b0</a> &#x00BB; driver_dev</nav><header class="odoc-preamble"><h1 id="b0-driver-development-manual"><a href="#b0-driver-development-manual" class="anchor"></a>B0 driver development manual</h1><p>A B0 driver like <code>b0</code> or <code>d0</code> is an executable that provides a service on the definitions of a B0 file. This manual shows how to develop a custom driver for B0 files.</p></header><nav class="odoc-toc"><ul><li><a href="#overview">Overview</a></li><li><a href="#library">The driver library</a></li><li><a href="#fixme">FIXME</a></li></ul></nav><div class="odoc-content"><h2 id="overview"><a href="#overview" class="anchor"></a>Overview</h2><p>The B0 file needs to be compiled and made accessible to the driver executable. At the moment the OCaml <a href="../ocaml/Dynlink/index.html"><code>Dynlink</code></a> API is not being used. Instead the driver executable relinks its objects with a compilation of the B0 file to produce another executable that is executed to run the driver on the definitions.</p><p>With the help of the <a href="B0_driver/index.html"><code>B0_driver</code></a> module this all happens transparently in the <code>.drivers</code> directory of the <code>_b0</code> directory.</p><h2 id="library"><a href="#library" class="anchor"></a>The driver library</h2><p>For your driver to access a B0 file you need to create an OCaml library which has all the objects of your driver and registers its <code>main</code> function by calling <a href="B0_driver/index.html#val-set"><code>B0_driver.set</code></a>.</p><p>Source wise a typical driver source structure is:</p><pre><code>src/mydriver_main.ml
src/mydriver_main_run.ml</code></pre><p>The <code>mydriver_main.ml</code> file implements and registers the driver. It's compiled object should be part of your driver library. Here's a minimal example :</p><pre><code>open B0_std
open Cmdliner

let driver =
  let name = &quot;mydriver&quot; and version = &quot;v0.0.2-12-g2e7fa30e&quot; in
  let libs = [&quot;mydriver&quot; (* other needed libraries can be added here *) ] in
  B0_driver.create ~name ~version ~libs

let my_driver conf = Fmt.pr &quot;Running %s!@.&quot;; B0_driver.Exit.ok
let my_driver =
  let doc = &quot;My driver&quot; in
  let sdocs = Manpage.s_common_options in
  let exits = B0_driver.Exit.Info.base_cmd in
  let man = [ `S Manpage.s_description; &quot;$(mname) does not much.&quot; ] in
  B0_driver.with_b0_file ~driver (Term.const unit_cmd),
  Term.info &quot;mydriver&quot; ~version:&quot;v0.0.2-12-g2e7fa30e&quot; ~doc ~sdocs ~exits ~man

let main () = Term.eval mydriver
let () = B0_driver.set driver ~main</code></pre><p>The <code>mydriver_main_run.ml</code> file defines your driver executable when it has no B0 file linked in. It's the program that runs your driver without the B0 file linked in. It should simply be:</p><pre><code>let () =
  let module D = Mydriver_main (* make sure we link it *) in
  if !Sys.interactive then () else B0_driver.run ~has_b0_file:false</code></pre><p>A few things to note:</p><ul><li>Your driver library must be installed and available in the <code>OCAMLPATH</code> under the name you gave in to <a href="B0_driver/index.html"><code>B0_driver</code></a>.</li><li>The driver library's directory is not added to the includes for compiling the B0 file. This prevents drivers from adding declarations to the compilation environment since using them in a B0 file would then break other drivers. New declarations must always be explicitely imported in the B0 file by using the <code>#require</code> directive.</li></ul><h2 id="fixme"><a href="#fixme" class="anchor"></a>FIXME</h2><p>The driver dance seems to be a bit slow for now. Even for the up-to-date dance we get into the 43ms <code>b0 unit list</code>. But there's room for improvement. Here are different things to consider that could be done.</p><ul><li>Cold driver compilation. I think we get hit a bit by the executable link phase (globally 500ms, but the compilation spawn takes 480ms). Investigate what makes OCaml linking faster. Maybe a mono cmo ? Alternatively consider using <code>Dylink</code> once it gets lib support, but then what about platforms that don't support it.</li><li>The various timing obtained with <code>b0 file log --stats</code> and <code>b0 -v -v</code> don't add up to what <code>time b0</code> reports. Investigate, is it the execv ? June 2020: maybe it is/was <a href="https://github.com/ocaml/ocaml/issues/9705#issuecomment-649096985">that</a>. Also see how much toplevel init takes (how ?).</li><li>Try to jump directly into the compiled driver executable and let it auto verify and auto recompile if needed ? This could allow to share part of the hash cache in the future.</li><li>Maybe go back to use an ad-hoc stamp for driver compilation rather than use B00 itself.</li></ul></div></body></html>