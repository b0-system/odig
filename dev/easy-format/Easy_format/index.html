<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Easy_format (easy-format.Easy_format)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">easy-format</a> &#x00BB; Easy_format</nav><h1>Module <code>Easy_format</code></h1><p>Easy_format: indentation made easy.</p></header><aside><p>This module provides a functional, simplified layer over the Format module of the standard library.</p><p>Input data must be first modelled as a tree using 3 kinds of nodes:</p><ul><li>atoms</li><li>lists</li><li>labelled nodes</li></ul><p>Atoms represent any text that is guaranteed to be printed as-is. Lists can model any sequence of items such as arrays of data or lists of definitions that are labelled with something like &quot;int main&quot;, &quot;let x =&quot; or &quot;x:&quot;.</p></aside><dl><dt class="spec type" id="type-wrap"><a href="#type-wrap" class="anchor"></a><code><span class="keyword">type</span> wrap</code> = <code>[ </code><table class="variant"><tr id="type-wrap.Wrap_atoms" class="anchored"><td class="def constructor"><a href="#type-wrap.Wrap_atoms" class="anchor"></a><code>| </code><code>`Wrap_atoms</code></td></tr><tr id="type-wrap.Always_wrap" class="anchored"><td class="def constructor"><a href="#type-wrap.Always_wrap" class="anchor"></a><code>| </code><code>`Always_wrap</code></td></tr><tr id="type-wrap.Never_wrap" class="anchored"><td class="def constructor"><a href="#type-wrap.Never_wrap" class="anchor"></a><code>| </code><code>`Never_wrap</code></td></tr><tr id="type-wrap.Force_breaks" class="anchored"><td class="def constructor"><a href="#type-wrap.Force_breaks" class="anchor"></a><code>| </code><code>`Force_breaks</code></td></tr><tr id="type-wrap.Force_breaks_rec" class="anchored"><td class="def constructor"><a href="#type-wrap.Force_breaks_rec" class="anchor"></a><code>| </code><code>`Force_breaks_rec</code></td></tr><tr id="type-wrap.No_breaks" class="anchored"><td class="def constructor"><a href="#type-wrap.No_breaks" class="anchor"></a><code>| </code><code>`No_breaks</code></td></tr></table><code> ]</code></dt><dd><p>List wrapping conditions:</p><ul><li><code>`Wrap_atoms</code>: wrap if the list contains only atoms</li><li><code>`Always_wrap</code>: always wrap when needed</li><li><code>`Never_wrap</code>: never wrap, i.e. the list is either horizontal or vertical</li><li><code>`Force_breaks</code>: align vertically, i.e. always break line between list items and align the left edge of each item.</li><li><code>`Force_breaks_rec</code>: same as <code>`Force_breaks</code> but turns any wrappable ancestor node's wrap property (<code>`Wrap_atoms</code> or <code>`Always_wrap</code>) into <code>`Force_breaks</code>.</li><li><code>`No_breaks</code>: align horizontally, i.e. never break line between list items</li></ul></dd></dl><dl><dt class="spec type" id="type-label_break"><a href="#type-label_break" class="anchor"></a><code><span class="keyword">type</span> label_break</code> = <code>[ </code><table class="variant"><tr id="type-label_break.Auto" class="anchored"><td class="def constructor"><a href="#type-label_break.Auto" class="anchor"></a><code>| </code><code>`Auto</code></td></tr><tr id="type-label_break.Always" class="anchored"><td class="def constructor"><a href="#type-label_break.Always" class="anchor"></a><code>| </code><code>`Always</code></td></tr><tr id="type-label_break.Always_rec" class="anchored"><td class="def constructor"><a href="#type-label_break.Always_rec" class="anchor"></a><code>| </code><code>`Always_rec</code></td></tr><tr id="type-label_break.Never" class="anchored"><td class="def constructor"><a href="#type-label_break.Never" class="anchor"></a><code>| </code><code>`Never</code></td></tr></table><code> ]</code></dt><dd><p>When to break the line after a <code>Label</code>:</p><ul><li><code>Auto</code>: break after the label if there's not enough room</li><li><code>Always</code>: always break after the label</li><li><code>Always_rec</code>: always break after the label and force breaks in all parent lists and labels, similarly to <code>`Force_breaks_rec</code> for lists.</li><li><code>Never</code>: never break after the label</li></ul></dd></dl><dl><dt class="spec type" id="type-style_name"><a href="#type-style_name" class="anchor"></a><code><span class="keyword">type</span> style_name</code><code> = string</code></dt><dt class="spec type" id="type-style"><a href="#type-style" class="anchor"></a><code><span class="keyword">type</span> style</code><code> = </code><code>{</code><table class="record"><tr id="type-style.tag_open" class="anchored"><td class="def field"><a href="#type-style.tag_open" class="anchor"></a><code>tag_open : string;</code></td></tr><tr id="type-style.tag_close" class="anchored"><td class="def field"><a href="#type-style.tag_close" class="anchor"></a><code>tag_close : string;</code></td></tr></table><code>}</code></dt><dd><p>Pair of opening and closing tags that are inserted around text after pretty-printing.</p></dd></dl><dl><dt class="spec type" id="type-atom_param"><a href="#type-atom_param" class="anchor"></a><code><span class="keyword">type</span> atom_param</code><code> = </code><code>{</code><table class="record"><tr id="type-atom_param.atom_style" class="anchored"><td class="def field"><a href="#type-atom_param.atom_style" class="anchor"></a><code>atom_style : <a href="index.html#type-style_name">style_name</a> option;</code></td><td class="doc"><p>Default: <code>None</code></p></td></tr></table><code>}</code></dt></dl><dl><dt class="spec value" id="val-atom"><a href="#val-atom" class="anchor"></a><code><span class="keyword">val</span> atom : <a href="index.html#type-atom_param">atom_param</a></code></dt></dl><dl><dt class="spec type" id="type-list_param"><a href="#type-list_param" class="anchor"></a><code><span class="keyword">type</span> list_param</code><code> = </code><code>{</code><table class="record"><tr id="type-list_param.space_after_opening" class="anchored"><td class="def field"><a href="#type-list_param.space_after_opening" class="anchor"></a><code>space_after_opening : bool;</code></td><td class="doc"><p>Whether there must be some whitespace after the opening string. Default: <code>true</code></p></td></tr><tr id="type-list_param.space_after_separator" class="anchored"><td class="def field"><a href="#type-list_param.space_after_separator" class="anchor"></a><code>space_after_separator : bool;</code></td><td class="doc"><p>Whether there must be some whitespace after the item separators. Default: <code>true</code></p></td></tr><tr id="type-list_param.space_before_separator" class="anchored"><td class="def field"><a href="#type-list_param.space_before_separator" class="anchor"></a><code>space_before_separator : bool;</code></td><td class="doc"><p>Whether there must be some whitespace before the item separators. Default: <code>false</code></p></td></tr><tr id="type-list_param.separators_stick_left" class="anchored"><td class="def field"><a href="#type-list_param.separators_stick_left" class="anchor"></a><code>separators_stick_left : bool;</code></td><td class="doc"><p>Whether the separators must stick to the item on the left. Default: <code>true</code></p></td></tr><tr id="type-list_param.space_before_closing" class="anchored"><td class="def field"><a href="#type-list_param.space_before_closing" class="anchor"></a><code>space_before_closing : bool;</code></td><td class="doc"><p>Whether there must be some whitespace before the closing string. Default: <code>true</code></p></td></tr><tr id="type-list_param.stick_to_label" class="anchored"><td class="def field"><a href="#type-list_param.stick_to_label" class="anchor"></a><code>stick_to_label : bool;</code></td><td class="doc"><p>Whether the opening string should be fused with the preceding label. Default: <code>true</code></p></td></tr><tr id="type-list_param.align_closing" class="anchored"><td class="def field"><a href="#type-list_param.align_closing" class="anchor"></a><code>align_closing : bool;</code></td><td class="doc"><p>Whether the beginning of the closing string must be aligned with the beginning of the opening string (stick_to_label = false) or with the beginning of the label if any (stick_to_label = true). Default: <code>true</code></p></td></tr><tr id="type-list_param.wrap_body" class="anchored"><td class="def field"><a href="#type-list_param.wrap_body" class="anchor"></a><code>wrap_body : <a href="index.html#type-wrap">wrap</a>;</code></td><td class="doc"><p>Defines under which conditions the list body may be wrapped, i.e. allow several lines and several list items per line. Default: <code>`Wrap_atoms</code></p></td></tr><tr id="type-list_param.indent_body" class="anchored"><td class="def field"><a href="#type-list_param.indent_body" class="anchor"></a><code>indent_body : int;</code></td><td class="doc"><p>Extra indentation of the list body. Default: <code>2</code></p></td></tr><tr id="type-list_param.list_style" class="anchored"><td class="def field"><a href="#type-list_param.list_style" class="anchor"></a><code>list_style : <a href="index.html#type-style_name">style_name</a> option;</code></td><td class="doc"><p>Default: <code>None</code></p></td></tr><tr id="type-list_param.opening_style" class="anchored"><td class="def field"><a href="#type-list_param.opening_style" class="anchor"></a><code>opening_style : <a href="index.html#type-style_name">style_name</a> option;</code></td><td class="doc"><p>Default: <code>None</code></p></td></tr><tr id="type-list_param.body_style" class="anchored"><td class="def field"><a href="#type-list_param.body_style" class="anchor"></a><code>body_style : <a href="index.html#type-style_name">style_name</a> option;</code></td><td class="doc"><p>Default: <code>None</code></p></td></tr><tr id="type-list_param.separator_style" class="anchored"><td class="def field"><a href="#type-list_param.separator_style" class="anchor"></a><code>separator_style : <a href="index.html#type-style_name">style_name</a> option;</code></td><td class="doc"><p>Default: <code>None</code></p></td></tr><tr id="type-list_param.closing_style" class="anchored"><td class="def field"><a href="#type-list_param.closing_style" class="anchor"></a><code>closing_style : <a href="index.html#type-style_name">style_name</a> option;</code></td><td class="doc"><p>Default: <code>None</code></p></td></tr></table><code>}</code></dt><dd><p>List-formatting parameters. Always derive a new set of parameters from an existing record. See <a href="index.html#val-list"><code>Easy_format.list</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-list"><a href="#val-list" class="anchor"></a><code><span class="keyword">val</span> list : <a href="index.html#type-list_param">list_param</a></code></dt><dd><p>Default list-formatting parameters, using the default values described in the type definition above.</p><p>In order to make code compatible with future versions of the library, the record inheritance syntax should be used, e.g. <code> { list with align_closing = false } </code>. If new record fields are added, the program would still compile and work as before.</p></dd></dl><dl><dt class="spec type" id="type-label_param"><a href="#type-label_param" class="anchor"></a><code><span class="keyword">type</span> label_param</code><code> = </code><code>{</code><table class="record"><tr id="type-label_param.label_break" class="anchored"><td class="def field"><a href="#type-label_param.label_break" class="anchor"></a><code>label_break : <a href="index.html#type-label_break">label_break</a>;</code></td><td class="doc"><p>Whether to break the line after the label. Introduced in version 1.2.0. Default: <code>`Auto</code></p></td></tr><tr id="type-label_param.space_after_label" class="anchored"><td class="def field"><a href="#type-label_param.space_after_label" class="anchor"></a><code>space_after_label : bool;</code></td><td class="doc"><p>Whether there must be some whitespace after the label. Default: <code>true</code></p></td></tr><tr id="type-label_param.indent_after_label" class="anchored"><td class="def field"><a href="#type-label_param.indent_after_label" class="anchor"></a><code>indent_after_label : int;</code></td><td class="doc"><p>Extra indentation before the item that comes after a label. Default: <code>2</code></p></td></tr><tr id="type-label_param.label_style" class="anchored"><td class="def field"><a href="#type-label_param.label_style" class="anchor"></a><code>label_style : <a href="index.html#type-style_name">style_name</a> option;</code></td><td class="doc"><p>Default: <code>None</code></p></td></tr></table><code>}</code></dt><dd><p>Label-formatting parameters. Always derive a new set of parameters from an existing record. See <a href="index.html#val-label"><code>Easy_format.label</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-label"><a href="#val-label" class="anchor"></a><code><span class="keyword">val</span> label : <a href="index.html#type-label_param">label_param</a></code></dt><dd><p>Default label-formatting parameters, using the default values described in the type definition above.</p><p>In order to make code compatible with future versions of the library, the record inheritance syntax should be used, e.g. <code> { label with indent_after_label = 0 } </code>. If new record fields are added, the program would still compile and work as before.</p></dd></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code><code> = </code><table class="variant"><tr id="type-t.Atom" class="anchored"><td class="def constructor"><a href="#type-t.Atom" class="anchor"></a><code>| </code><code><span class="constructor">Atom</span> <span class="keyword">of</span> string * <a href="index.html#type-atom_param">atom_param</a></code></td><td class="doc"><p>Plain string normally without line breaks.</p></td></tr><tr id="type-t.List" class="anchored"><td class="def constructor"><a href="#type-t.List" class="anchor"></a><code>| </code><code><span class="constructor">List</span> <span class="keyword">of</span> string * string * string * <a href="index.html#type-list_param">list_param</a> * <a href="index.html#type-t">t</a> list</code></td><td class="doc"><p><code>List ((opening, separator, closing, param), nodes)</code></p></td></tr><tr id="type-t.Label" class="anchored"><td class="def constructor"><a href="#type-t.Label" class="anchor"></a><code>| </code><code><span class="constructor">Label</span> <span class="keyword">of</span> <a href="index.html#type-t">t</a> * <a href="index.html#type-label_param">label_param</a> * <a href="index.html#type-t">t</a></code></td><td class="doc"><p><code>Label ((label, param), node)</code>: labelled node.</p></td></tr><tr id="type-t.Custom" class="anchored"><td class="def constructor"><a href="#type-t.Custom" class="anchor"></a><code>| </code><code><span class="constructor">Custom</span> <span class="keyword">of</span> <a href="../../ocaml/Stdlib/Format/index.html#type-formatter">Stdlib.Format.formatter</a> <span>&#45;&gt;</span> unit</code></td><td class="doc"><p>User-defined printing function that allows to use the Format module directly if necessary. It is responsible for leaving the formatter in a clean state.</p></td></tr></table></dt><dd><p>The type of the tree to be pretty-printed. Each node contains its own formatting parameters.</p><p>Detail of a list node <code>List ((opening, separator, closing, param), nodes)</code>:</p><ul><li><code>opening</code>: opening string such as <code>&quot;\{&quot;</code> <code>&quot;[&quot;</code> <code>&quot;(&quot;</code> <code>&quot;begin&quot;</code> <code>&quot;&quot;</code> etc.</li><li><code>separator</code>: node separator such as <code>&quot;;&quot;</code> <code>&quot;,&quot;</code> <code>&quot;&quot;</code> <code>&quot;+&quot;</code> <code>&quot;|&quot;</code> etc.</li><li><code>closing</code>: closing string such as <code>&quot;\}&quot;</code> <code>&quot;]&quot;</code> <code>&quot;)&quot;</code> <code>&quot;end&quot;</code> <code>&quot;&quot;</code> etc.</li><li><code>nodes</code>: elements of the list.</li></ul></dd></dl><dl><dt class="spec type" id="type-escape"><a href="#type-escape" class="anchor"></a><code><span class="keyword">type</span> escape</code> = <code>[ </code><table class="variant"><tr id="type-escape.None" class="anchored"><td class="def constructor"><a href="#type-escape.None" class="anchor"></a><code>| </code><code>`None</code></td></tr><tr id="type-escape.Escape" class="anchored"><td class="def constructor"><a href="#type-escape.Escape" class="anchor"></a><code>| </code><code>`Escape <span class="keyword">of</span> (string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></td></tr><tr id="type-escape.Escape_string" class="anchored"><td class="def constructor"><a href="#type-escape.Escape_string" class="anchor"></a><code>| </code><code>`Escape_string <span class="keyword">of</span> string <span>&#45;&gt;</span> string</code></td></tr></table><code> ]</code></dt><dt class="spec type" id="type-styles"><a href="#type-styles" class="anchor"></a><code><span class="keyword">type</span> styles</code><code> = (<a href="index.html#type-style_name">style_name</a> * <a href="index.html#type-style">style</a>) list</code></dt></dl><dl><dt class="spec module" id="module-Pretty"><a href="#module-Pretty" class="anchor"></a><code><span class="keyword">module</span> <a href="Pretty/index.html">Pretty</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The regular pretty-printing functions</p></dd></dl><dl><dt class="spec module" id="module-Compact"><a href="#module-Compact" class="anchor"></a><code><span class="keyword">module</span> <a href="Compact/index.html">Compact</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>No spacing or newlines other than those in the input data or those produced by <code>Custom</code> printing.</p></dd></dl></div></body></html>