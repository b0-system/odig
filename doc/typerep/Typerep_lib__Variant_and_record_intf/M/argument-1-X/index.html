<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>1-X (typerep.Typerep_lib__Variant_and_record_intf.M.1-X)</title><link rel="stylesheet" href="../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../../index.html">typerep</a> &#x00BB; <a href="../../index.html">Typerep_lib__Variant_and_record_intf</a> &#x00BB; <a href="../index.html">M</a> &#x00BB; 1-X</nav><h1>Parameter <code>M.1-X</code></h1></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> 'a t</code></dt><dd><p>This functor is essentially there because we use this same interface in different contexts, with different types for <code>'a t</code>.</p><p>1) One use case for it is where <code>'a X.t = 'a Typerep.t</code>. These interfaces are then part of the type witness built for a type containing a record or a variant in its structure. <code>traverse</code> will give a way of accessing the type representation for the arguments of a variant or record type.</p><p>2) Another use case is for building &quot;staged generic computations&quot;. In that case, the type <code>'a X.t</code> is the type of the computation that is being built. <code>traverse</code> returns the computation built for the argument. The interface no longer exports the typerep of the arguments in hopes of enforcing that no typerep traversal happens at runtime if the computation happen to be a function.</p></dd></dl></div></body></html>