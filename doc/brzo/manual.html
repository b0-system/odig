<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>manual (brzo.manual)</title><link rel="stylesheet" href="../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="index.html">Up</a> – <a href="index.html">brzo</a> &#x00BB; manual</nav><header class="odoc-preamble"><h1 id="brzo-manual"><a href="#brzo-manual" class="anchor"></a>Brzo manual</h1><p><em>Quick-setting builds – Builds ideas, not scaffolds.</em></p></header><nav class="odoc-toc"><ul><li><a href="#intro">Introduction</a><ul><li><a href="#intro_philosophy">Philosophy</a></li><li><a href="#intro_start">Getting started</a></li><li><a href="#intro_doc">Design documentation</a></li><li><a href="#intro_start_2">Selecting domains and outcomes</a></li><li><a href="#intro_clean">Cleaning up</a></li><li><a href="#intro_next">Where to go next ?</a></li></ul></li><li><a href="#overview">Conceptual overview</a><ul><li><a href="#root">Root</a></li><li><a href="#source_files">Source files</a></li><li><a href="#domains">Domains and selection</a></li><li><a href="#outcomes">Outcomes</a></li><li><a href="#actions">Outcome actions</a><ul><li><a href="#action_exec">Program execution action</a></li><li><a href="#action_browser">Browser action</a></li><li><a href="#action_pdf">PDF viewer action</a></li></ul></li></ul></li><li><a href="#editor_support">Editor support</a><ul><li><a href="#emacs">Emacs</a></li></ul></li><li><a href="#brzo_file"><code>BRZO</code> files</a><ul><li><a href="#brzo_file_keys">Keys</a></li></ul></li><li><a href="#c_domain">C domain</a><ul><li><a href="#c_doc">Doc outcome</a></li><li><a href="#c_brzo_file"><code>BRZO</code> file keys</a></li></ul></li><li><a href="#cmark_domain">Cmark domain</a><ul><li><a href="#cmark_exec">Exec outcome</a></li><li><a href="#cmark_doc">Doc outcome</a></li><li><a href="#cmark_brzo_file"><code>BRZO</code> file keys</a></li></ul></li><li><a href="#latex_domain">L<sup>A</sup>T<sub>E</sub>X domain</a><ul><li><a href="#latex_exec">Exec outcome</a></li><li><a href="#latex_doc">Doc outcome</a></li><li><a href="#latex_listing">Listing outcome</a></li><li><a href="#latex_brzo_file"><code>BRZO</code> file keys</a></li><li><a href="#latex_bibdoi"><code>.bibdoi</code> files</a></li></ul></li><li><a href="#ocaml_domain">OCaml domain</a><ul><li><a href="#ocaml_exec">Exec outcome</a><ul><li><a href="#ocaml_exec_native_byte">Byte and native code targets</a></li><li><a href="#ocaml_exec_html">HTML target</a></li><li><a href="#ocaml_exec_html_2">Node target</a></li></ul></li><li><a href="#ocaml_doc">Doc outcome</a></li><li><a href="#ocaml_top">Top outcome</a><ul><li><a href="#ocaml_exec_native_byte_2">Byte and native code targets</a></li><li><a href="#ocaml_top_html">HTML target</a></li></ul></li><li><a href="#ocaml_utop">Utop outcome</a></li><li><a href="#ocaml_brzo_file"><code>BRZO</code> file keys</a></li><li><a href="#ocaml_compilation">Best-effort compilation</a></li><li><a href="#ocaml_dep_resolution">Best-effort dependency resolution</a><ul><li><a href="#ocaml_comp_deps">Compilation dependencies</a></li><li><a href="#ocaml_link_deps">Link dependencies</a></li><li><a href="#ocaml_external_deps">External dependencies and restrictions</a></li><li><a href="#ocaml_resolution_improvements">Comments and limitations</a></li></ul></li></ul></li></ul></nav><div class="odoc-content"><h2 id="intro"><a href="#intro" class="anchor"></a>Introduction</h2><h3 id="intro_philosophy"><a href="#intro_philosophy" class="anchor"></a>Philosophy</h3><p><code>brzo</code> lets you think about your ideas, not the bureaucracy needed to execute them. It is a simple build tool made for exploratory design and learning. It is <em>unsuitable</em> for building software distributions.</p><p>With this goal in mind <code>brzo</code> curtails configuration options and favors heuristics and advices over formal configuration.</p><p>If you find yourself fighting with the tool or seeking more control it likely means your ideas have grown into a project that needs a proper build infrastructure. <code>brzo</code> should be gleefully ditched at that point.</p><h3 id="intro_start"><a href="#intro_start" class="anchor"></a>Getting started</h3><p>In a simple directory structure, a bare <code>brzo</code> invocation should succeed in building and executing your source files. For example, assuming you have <code>brzo</code> and an OCaml compiler in your executable path:</p><pre>&gt; touch BRZO
&gt; cat &gt; echo.ml &lt;&lt;EOCAML
let echo oc ss = output_string oc (String.concat &quot; &quot; ss ^ &quot;\n&quot;)
let () = echo stdout (List.tl (Array.to_list Sys.argv))
EOCAML
&gt; brzo -- 'Quick!'
'Quick!'</pre><p>Not very impressive, but illustrates that a bare <code>brzo</code> invocation goes through the following ordered steps:</p><ol><li>Find the <em>root</em>: starting from the current directory and upwards, stop at the first directory with a <code>BRZO</code> file.</li><li>Collect source files in the file hierarchy pinned at the root and determine from their extensions a <em>domain</em>. A domain determines a build logic. It usually corresponds to a particular language.</li><li>Using the domain's build logic, compile the source files to an executable <em>outcome artefact</em>.</li><li>Run the outcome artefact with the provided command line arguments.</li></ol><p>To understand which root, source files and domain <code>brzo</code> determines, the following commands can be used:</p><pre>brzo root      # show root directory
brzo sources   # show source files considered
brzo domain    # show selected domain</pre><p>If some directories or files get in the way during source file collection you can include and exclude them with the <code>-i</code> and <code>-x</code> options and/or via a <a href="#brzo_file"><code>BRZO</code> file</a>:</p><pre>brzo -x attic   # excludes paths prefixed by 'attic' (relative to the root)</pre><p>Play a bit with the <code>brzo source</code> command and these flags until you get the selection you desire. Relative paths given to these options are relative to the root.</p><p>The relative order between <code>-i</code> and <code>-x</code> options is irrelevant, the semantics is that all source file paths whose prefix match one of the <code>-i</code> options are gathered into a set and then all elements whose prefix match one of the <code>-x</code> option are removed from it. For example below the <code>-i</code> option is ineffective in both cases:</p><pre>brzo -i . -i attic -x attic   # excludes 'attic' prefixed paths
brzo -i . -x attic -i attic   # also excludes 'attic' prefixed paths</pre><p>In general <code>brzo</code> tries to be quiet on success so that it doesn't interfere with the standard outputs of the outcome action. However if you want to have a bit more information on <code>stderr</code> about what <code>brzo</code> is doing, use the <code>-v</code> option. Alternatively consult the build log after the build with the <code>log</code> command.</p><pre>brzo -v           # show build steps on stderr
brzo log          # show build operations of the last build
brzo log --help   # see more options to explore the build</pre><p><code>brzo</code>'s exit code will be that of your outcome program unless <code>brzo</code> fails in some way before it gets to execute it. In the latter case the exit code should be attributed and understood as <code>brzo</code>'s one. Exit codes of <code>brzo</code> and its subcommands are documented in <code>brzo --help</code>.</p><p>To only build the outcome, only perform the outcome action, locate the outcome artefact in the file system, delete the outcome build or see the outcome configuration, use the following invocations:</p><pre>brzo -b               # only build the outcome artefact
brzo -r -- 'Quick!'   # only run the outcome action (no build)
brzo --path           # path to the outcome artefact (built or not)
brzo -d               # delete the outcome build (but not the cache)
brzo --conf           # show determined configuration</pre><h3 id="intro_doc"><a href="#intro_doc" class="anchor"></a>Design documentation</h3><p>Domains provide a <em>documentation outcome</em> for designing your programs. This outcome builds and shows documentation about the source files; most likely using the domain's language documentation tool. It can be built and run by invoking:</p><pre>brzo --doc   # build and show documentation about source files</pre><h3 id="intro_start_2"><a href="#intro_start_2" class="anchor"></a>Selecting domains and outcomes</h3><p>You may not always be happy about <code>brzo</code>'s automatic <a href="#domains">domain selection</a>. Or you may want to switch between different domains in the same root or use domain specific outcomes and options.</p><p>In these cases you can specify the domain as the first argument to <code>brzo</code> or use a <a href="#brzo_file"><code>BRZO</code> file</a>.</p><pre>brzo ocaml -- 'Grunt!'   # force the use of the OCaml domain</pre><p>A domain can provide more options for the default outcomes. For example, the OCaml domain has options to compile the (default) executable outcome to different targets:</p><pre>brzo ocaml --byte -- 'Quick!'    # compile and execute a bytecode program
brzo ocaml --html -- 'Quick!'    # compile and execute an HTML program
brzo ocaml --native -- 'Quick!'  # compile and execute a native code program
brzo ocaml --node -- 'Quick!'    # compile and execute a JavaScript program</pre><p>Automatic domain selection provides only two build outcomes: <code>--exec</code> (default) and <code>--doc</code>. A specific domain can provide more outcomes. For example the OCaml domain has outcomes to run sources in toplevels:</p><pre>brzo ocaml --top          # compile and load in the OCaml toplevel
brzo ocaml --top --html   # compile and load in the HTML OCaml toplevel
brzo ocaml --utop         # compile and load in utop</pre><p>To list <a href="#domains">available domains</a>, their outcomes and options use:</p><pre>brzo --help          # see the DOMAIN COMMANDS section
brzo DOMAIN --help   # see the OUTCOMES and OUTCOME OPTIONS section</pre><h3 id="intro_clean"><a href="#intro_clean" class="anchor"></a>Cleaning up</h3><p>At that point you certainly noticed <code>brzo</code> creates a <code>_b0</code> directory at the brzo root. This directory has the outcome artefacts in their build directories usually of the form <code>_b0/brzo/DOMAIN-OUTCOME</code>, a build cache <code>_b0/.cache</code> used for incremental builds and the (binary) build log <code>_b0/brzo/.log</code>.</p><p>Outcome builds and artefacts can be deleted using the following invocations. Note that this does not delete cached build artefacts.</p><pre>brzo -d                # delete the build of default executable outcome
brzo ocaml --html -d   # delete the build of the OCaml HTML program outcome
brzo delete            # delete all outcomes builds (but not the cache)</pre><p>In general unless you hit a build logic bug (please report) it's better to refrain from deleting the <code>_b0</code> directory – get rid of &quot;<code>make clean</code>&quot; habits. If you think the cache is taking too much space use the <code>brzo cache</code> command to manage it:</p><pre>brzo cache stats    # show information about the cache
brzo cache gc       # only keep keys used by the last build
brzo cache trim     # trim to 50% of the current size
brzo cache delete   # delete all cache keys (but not the build outcomes)</pre><p>But if you <em>really</em> want to get rid of the <code>_b0</code> directory issue:</p><pre>brzo delete -c   # delete (clean) the _b0 directory</pre><h3 id="intro_next"><a href="#intro_next" class="anchor"></a>Where to go next ?</h3><p>Back to your ideas.</p><p><code>brzo</code> strives to provide a hassle and scaffolding free build experience. If it succeeds you should be able to stop here and simply use the tool.</p><p>But if you get tired of specifying arguments on the command line you may want to read the section about <a href="#brzo_file"><code>BRZO</code> files</a>. You may also want to give a look at <a href="#editor_support">configuring your editor</a>.</p><p>If a <code>brzo</code> invocation doesn't succeed or you are puzzled by an outcome result, it may be useful to go through the manual section of the domain you are using. You will get a better understanding on how it works and which domain specific outcomes, options and <code>BRZO</code> file keys it provides. A short list of links to these sections can be found <a href="#domains">here</a>.</p><p>The <a href="#overview">conceptual overview</a> of the next chapter expands slightly more formally on the material seen in this introduction.</p><h2 id="overview"><a href="#overview" class="anchor"></a>Conceptual overview</h2><p>Whenever <code>brzo</code> is executed to perform an outcome it proceeds through the following steps.</p><ol><li>Find the <a href="#root">root directory</a>.</li><li>Collect supported <a href="#source_files">source files</a> in the file hierarchy pinned at the root.</li><li><a href="#domains">Select</a> the build domain.</li><li>Using domain and <a href="#outcomes">outcome</a> specific logic, build an outcome artefact.</li><li>Perform an <a href="#actions">action</a> on the outcome artefact.</li></ol><h3 id="root"><a href="#root" class="anchor"></a>Root</h3><p>When <code>brzo</code> is invoked in a directory <code>cwd</code>, the root is the first directory, starting with <code>cwd</code> and moving upwards, that has a <a href="#brzo_file"><code>BRZO</code> file</a>. If none can be found the tool errors.</p><p>Alternatively the root directory can be forced without a <code>BRZO</code> file via the <code>--root</code> option or the <code>BRZO_ROOT</code> environment variable. Invoke <code>brzo root</code> to find out which root <code>brzo</code> determines.</p><h3 id="source_files"><a href="#source_files" class="anchor"></a>Source files</h3><p>The set of source files collected by <code>brzo</code> are the files which are deemed useful by any of the domains and whose paths are prefixed by the include prefixes specified by the <code>-i PATH</code> option and the <a href="#brzo_file_keys"><code>srcs-i</code></a> <code>BRZO</code> file key. They must also not be prefixed by any of the exclude prefixes specified by the <code>-x PATH</code> option and the <a href="#brzo_file_keys"><code>srcs-x</code></a> <code>BRZO</code> file key. If no <code>-i</code> or <code>srcs-x</code> is specified the root path is implied.</p><p>Relative file paths specified in these options are relative to the brzo root, not relative to the current working directory or <code>BRZO</code> file. Note that these are <em>prefixes</em>, globs are not supported.</p><p>The relative order between <code>-i</code> and <code>-x</code> options is irrelevant. The semantics is that all source files from the file system whose prefix match one of the <code>-i</code> options are collected into a set and then any element of that set whose prefix match any of the <code>-x</code> option is removed from it. Paths with dotfile, <code>_b0</code>, or <code>_build</code> <em>segments</em> are automatically excluded, this can be overriden by specifying them explictely via <code>-i</code>.</p><p>If a <code>-i</code> is specified on the command line and there's a corresponding path in the <code>srcs-x</code> key of the <code>BRZO</code> file, then the latter is removed. Dually if a <code>-x</code> is present on the command line and there's a corresponding path in the <code>srcs-i</code> key of the <code>BRZO</code> file, then the latter is removed (but that's by definition of the semantics anyways).</p><p>Invoke <code>brzo source</code> to find out the final source set and <code>brzo
--conf</code> to find out which includes and excludes are determined from the <code>BRZO</code> file and the command line.</p><h3 id="domains"><a href="#domains" class="anchor"></a>Domains and selection</h3><p>Brzo partitions build logics into <em>domains</em>. Domains broadly correspond to build logics for a given language, even though those can overlap, for example when we build mixed OCaml and C programs.</p><p>Unless the domain is explicitely specified on the command line by invoking a subcommand like <code>brzo ocaml</code> or at the root via a <a href="#brzo_file"><code>BRZO</code> file</a>, brzo selects a domain according to the following rules, applied in order:</p><ol><li><a href="#ocaml_domain"><code>ocaml</code> domain</a>, if a source file ends with <code>.ml</code>, <code>.mli</code>, <code>.mld</code>, <code>.mll</code> or <code>.mly</code>.</li><li><a href="#c_domain"><code>c</code> domain</a>, if a source file ends with <code>.h</code> or <code>.c</code>.</li><li><a href="#latex_domain"><code>latex</code> domain</a>, if a source file ends with <code>.tex</code>, <code>.sty</code>, <code>.bib</code> or <code>.bibdoi</code>.</li><li><a href="#cmark_domain"><code>cmark</code> domain</a>, if a source file ends with <code>.md</code>.</li></ol><p>Invoke <code>brzo domain</code> to find out which domain <code>brzo</code> determines.</p><h3 id="outcomes"><a href="#outcomes" class="anchor"></a>Outcomes</h3><p>Each <a href="#domains">domain</a> has a number of supported build <em>outcomes</em>. An outcome determines a build artefact and an <a href="#actions">action</a> performed on it.</p><p>Every domain defines at least two standard outcomes:</p><ul><li><code>--exec</code>, an outcomes that builds and runs the simplest expected executable program for the domain. This is the outcome performed on a <code>brzo</code>, <code>brzo --exec</code>, <code>brzo DOMAIN</code> or <code>brzo DOMAIN --exec</code> invocation.</li><li><code>--doc</code>, an outcome that produces and shows documentation for the source files considered for <code>exec</code>, usually using the language's documentation tool. This is the outcome performed on a <code>brzo --doc</code> or <code>brzo DOMAIN --doc</code> invocation. For documentation language domains (<code>cmark</code>, <code>latex</code>, etc.) this outcome is often aliased to <code>--exec</code>.</li></ul><p>Domains may provide additional outcomes. Use <code>brzo DOMAIN --help</code> and the domain specific sections of this manual <a href="#domains">listed here</a> to learn about them.</p><h3 id="actions"><a href="#actions" class="anchor"></a>Outcome actions</h3><p>Most outcome actions fall in one of the following categories.</p><h4 id="action_exec"><a href="#action_exec" class="anchor"></a>Program execution action</h4><p>In a program execution action, the action simply runs a built program and gives it the arguments you specify on the <code>brzo</code> invocation. Use <code>--</code> to separate execution arguments from those given to <code>brzo</code>, this allows optional arguments to be interpreted by your program and not by <code>brzo</code>:</p><pre>brzo --help      # this is brzo's help
brzo -- --help   # this is your program's help (if programmed to do so)</pre><h4 id="action_browser"><a href="#action_browser" class="anchor"></a>Browser action</h4><p>In a browser action, the action usually opens a local <code>file:</code> URI in your browser. The browser to use can be specified in the <code>BROWSER</code> environment variable or via the <code>--browser</code> option.</p><p>When the outcome is a web of HTML files, the opened URI is the directory in which these are rooted. <code>brzo</code> then tries to reload a tab whose address is rooted in the directory's hierarchy rather than the directory itself. The application used to show the URI can be kept in the background with the <code>--background</code> option.</p><p>Sadly, both tab prefix reload and <code>--background</code> are subject to severe platform limitations, it seems the whole idea of refreshing a tab with a given address from the cli is a total blind spot of browser makers – get in touch if you know <em>lightweight</em> workarounds.</p><h4 id="action_pdf"><a href="#action_pdf" class="anchor"></a>PDF viewer action</h4><p>In a PDF viewer action, the action opens a PDF file in a viewer. The viewer to use can be specified in the <code>PDFVIEWER</code> environment variable or via the <code>--pdf-viewer</code> option.</p><h2 id="editor_support"><a href="#editor_support" class="anchor"></a>Editor support</h2><h3 id="emacs"><a href="#emacs" class="anchor"></a>Emacs</h3><p>If you want to have <code>brzo</code> as a default <code>compile</code> command add one of the following to your <code>.emacs</code>:</p><pre>(require 'compile)
(setq compile-command &quot;brzo -b&quot;) ; Globally instead of the default make -k

; Only in a particular mode. Here caml-mode.
(add-hook 'caml-mode-hook
  (lambda ()
    (set (make-local-variable 'compile-command) &quot;brzo -b&quot;)))</pre><h2 id="brzo_file"><a href="#brzo_file" class="anchor"></a><code>BRZO</code> files</h2><p>A <code>BRZO</code> file determines a <a href="#root">root</a>, allows to guide domain specific logic and provides default values. It can be empty just for root marking. <code>BRZO</code> files can be modified programmatically, see <code>brzo
file --help</code> for more information.</p><p>To disable a <code>BRZO</code> file at the root use the option <code>--brzo-file</code> with <code>/dev/null</code>; doing this does not affect <a href="#root">root finding</a>.</p><p>A <code>BRZO</code> file is a sequence of <span class="xref-unresolved">s-expressions</span>. Here's a sample file:</p><pre>(domain c)             ; force the default domain to C
(srcs-i src)           ; limit source file collection to the src directory
(srcs-x src/attic)     ; exclude source files from src/attic
(ocaml                 ; OCaml domain specific options
  (outcome top))       ; force the default outcome to --top</pre><h3 id="brzo_file_keys"><a href="#brzo_file_keys" class="anchor"></a>Keys</h3><p>Relative file paths in the file are always relative to the root, not relative the <code>BRZO</code> file location – these may not coincide if the <code>--brzo-file</code> option is used to specify the <code>BRZO</code> file.</p><p>The following global keys are defined:</p><ul><li>(<em>domain</em> DOMAIN) use DOMAIN as the default build domain. Overriden by the first positional argument given to <code>brzo</code>, <a href="#domains">guessed</a> by default.</li><li>(<em>srcs-i</em> PATH...) include source files that match given path <em>prefixes</em> (no globs) on the file system. Paths can be removed from the <code>srcs-i</code> list from the command line by specifying them via the <code>-x
   PATH</code> option. If nothing is specified in the <code>BRZO</code> file and on the command line, defaults to the <a href="#root">root</a> path.</li><li>(<em>srcs-x</em> PATH...) exclude source files that match given path <em>prefixes</em> (no globs). Paths can be removed from the <code>srcs-x</code> list from the command line by specifying them with the <code>-i PATH</code> option. Paths with dotfile, <code>_b0</code> or <code>_build</code> segments are automatically excluded, this can be overriden by explicitly including them via <code>srcs-i</code> or <code>-i</code>.</li><li><p>(<em>DOMAIN</em> (<em>KEY</em> ...) ...) configuration key <em>KEY</em> specific to domain DOMAIN. See the <a href="#domains">domain</a> specific documentation for supported keys. The following keys are supported by all domains:</p><ul><li>(<em>outcome</em> OUTCOME), use OUTCOME as the default build outcome. Overriden by domain selection flags given to <code>brzo</code>, defaults to <code>exec</code>. The values allowed for this field depends on the domain.</li></ul></li></ul><h2 id="c_domain"><a href="#c_domain" class="anchor"></a>C domain</h2><h3 id="c_doc"><a href="#c_doc" class="anchor"></a>Doc outcome</h3><p>Build and show documentation about source files using <a href="http://www.doxygen.nl">Doxygen</a>.</p><p>Let <code>ROOT</code> be the root, <code>R</code> be its basename, <code>BUILD</code> the outcome build directory, <code>P</code> match file <em>paths</em> and <code>FILE</code> be the basename of <code>P</code>.</p><ol><li><p>Determine in <code>ROOT</code> a <a href="http://www.doxygen.nl/manual/config.html">Doxygen configuration file</a>. This is either, in order:</p><ol><li>The file mentioned via the <code>--doxyfile</code> option.</li><li>The file mentioned in the <code>BRZO</code> file key <em>c.doxyfile</em>, see <a href="#c_brzo_file">here</a>.</li><li>The file <code>ROOT/Doxyfile</code>.</li><li>Generate a <code>BUILD/Doxyfile</code> crafted for HTML output. Dot graphs are included if <code>dot</code> is available. This can be disabled using the <code>--use-dot=false</code> option or the <code>BRZO</code> file key <em>c.use-dot</em>, see <a href="#c_brzo_file">here</a>.</li></ol></li><li><p>Invoke <code>doxygen</code> on the configuration file found or generated at the preceeding step with the following overrides:</p><ol><li><code>OUTPUT_DIRECTORY</code> is set to <code>BUILD/o</code>.</li><li><code>INPUT</code> is set to the list of files matching <code>ROOT/P.h</code>, <code>ROOT/P.c</code> and <code>ROOT/P.md</code>.</li></ol></li><li><a href="#action_browser">Open directory</a> <code>BUILD/o/html/</code> in a browser.</li></ol><h3 id="c_brzo_file"><a href="#c_brzo_file" class="anchor"></a><code>BRZO</code> file keys</h3><p>C specific keys are found in the <em>c</em> dictionary. Here's an example that indicates that dot should not be used in the doxyfile automatically generated by <code>brzo</code>.</p><pre>(c (use-dot false))  ; Dot not generate dot dependency and call graphs</pre><p>The available keys are:</p><ul><li>(<em>doxyfile</em> PATH) use PATH for the <code>doxygen</code> configuration file.</li><li>(<em>use-dot</em> BOOL), specify whether the <code>dot</code> tool should be used or or not if the <code>Doxyfile</code> is automatically generated</li></ul><h2 id="cmark_domain"><a href="#cmark_domain" class="anchor"></a>Cmark domain</h2><p>Provides support for handling <a href="https://commonmark.org/">CommonMark</a> files via the <span class="xref-unresolved">cmark</span> tool.</p><h3 id="cmark_exec"><a href="#cmark_exec" class="anchor"></a>Exec outcome</h3><p>Build a web of HTML programs (HTML, JavaScript, CSS) and media files in a directory and open it in the user's browser.</p><p>Let <code>ROOT</code> be the root, <code>BUILD</code> the outcome build directory and <code>P</code> match file <em>paths</em>. The following steps are taken:</p><ol><li>Any <code>ROOT/P.ext</code> source file with <code>ext</code> in the set <code>B0_fexts</code>.www extension is copied over verbatim to the corresponding <code>BUILD/html/P.ext</code> path.</li><li>Any <code>ROOT/P.md</code> file is compiled to a <code>BUILD/html/P.html</code> file using the <span class="xref-unresolved"><code>cmark</code></span> tool. Any <code>.js</code> and <code>.css</code> file in <code>BUILD</code> is linked in the file. The page title is either the basename of the file without the extension or, if that results in <code>&quot;index&quot;</code>, the basename of the <code>.md</code> file's parent directory.</li><li><a href="#action_browser">Open directory</a> <code>BUILD</code> in a browser.</li></ol><h3 id="cmark_doc"><a href="#cmark_doc" class="anchor"></a>Doc outcome</h3><p>Aliased to <a href="#cmark_exec">exec outcome</a>.</p><h3 id="cmark_brzo_file"><a href="#cmark_brzo_file" class="anchor"></a><code>BRZO</code> file keys</h3><p>The cmark domain has no specific keys.</p><h2 id="latex_domain"><a href="#latex_domain" class="anchor"></a>L<sup>A</sup>T<sub>E</sub>X domain</h2><p>Provides support for handling the <a href="https://www.latex-project.org">L<sup>A</sup>T<sub>E</sub>X</a> document preparation system. The domain uses the <a href="http://xetex.sourceforge.net/">X<sub>Ǝ</sub>T<sub>E</sub>X</a> toolchain as it handles Unicode and UTF-8 out of the box; it is distributed with T<sub>E</sub>X Live.</p><h3 id="latex_exec"><a href="#latex_exec" class="anchor"></a>Exec outcome</h3><p>Create a PDF document from the L<sup>A</sup>T<sub>E</sub>X sources and open it in a PDF viewer.</p><p>Let <code>ROOT</code> be the root, <code>R</code> be the basename of <code>ROOT</code>, <code>BUILD</code> the outcome build directory and <code>P</code> match file <em>paths</em>. The following steps are taken:</p><ol><li>Any <code>ROOT/P.bibdoi</code> file is compiled to a <code>ROOT/P.brzo.bib</code> <a href="https://www.ctan.org/pkg/bibtex">BibT<sub>E</sub>X</a> file as described <a href="#latex_bibdoi">here</a>. This BibT<sub>E</sub>X file can be included in your <code>.tex</code> files. Do not edit it manually it will be overwritten by <code>brzo</code>.</li><li><p>Determine in <code>ROOT</code> a main <code>M.tex</code> file. This is either, in order:</p><ol><li>The file mentioned via the <code>--main</code> option</li><li>The file mentioned in the <code>BRZO</code> file key <em>latex.main</em>, see <a href="#latex_brzo_file">here</a>.</li><li>If there's a single <code>.tex</code> file, that file</li><li>A file whose basename is <code>main.tex</code></li><li>A file whose basename is <code>R.tex</code></li></ol></li><li>Compile <code>M.tex</code> to <code>BUILD/M.pdf</code> using <code>xelatex</code> until the fix point is reached.</li><li><a href="#action_pdf">Open file</a> <code>BUILD/M.pdf</code> in a PDF viewer.</li></ol><h3 id="latex_doc"><a href="#latex_doc" class="anchor"></a>Doc outcome</h3><p>Aliased to <a href="#latex_exec">exec outcome</a>.</p><h3 id="latex_listing"><a href="#latex_listing" class="anchor"></a>Listing outcome</h3><p>Creates a PDF document with some of the source files listed by <code>brzo
sources</code>. The list of supported source extensions is documented in <code>brzo latex --help</code> under the <code>--listing</code> option. Sources are assumed to be UTF-8 encoded.</p><p>Let <code>ROOT</code> be the root, <code>R</code> be the basename of <code>ROOT</code>, <code>BUILD</code> the outcome build directory and <code>P</code> match file <em>paths</em>. The following steps are taken:</p><ol><li>Generate a document <code>BUILD/R-listing.tex</code> which has one section for each source file <code>ROOT/P.ext</code> with <code>ext</code> in the supported source extensions. Source files are included using the <a href="https://www.ctan.org/pkg/listings">listings</a> package.</li><li>Compile <code>BUILD/R-listing.tex</code> to <code>BUILD/R-listing.pdf</code> using <code>xelatex</code> until the fix point is reached.</li><li><a href="#action_pdf">Open file</a> <code>BUILD/R-listing.pdf</code> in a PDF viewer.</li></ol><h3 id="latex_brzo_file"><a href="#latex_brzo_file" class="anchor"></a><code>BRZO</code> file keys</h3><p>L<sup>A</sup>T<sub>E</sub>X specific keys are found in the <em>latex</em> dictionary. Here's an example that indicates the main <code>.tex</code> file is <code>doc/manual.tex</code></p><pre>(latex (main doc/manual.tex))</pre><p>The available keys are:</p><ul><li>(<em>curl</em> CMD) use CMD to curl to resolve DOIs</li><li>(<em>doi-resolver</em> URI) use URI to resolve DOIs to BibT<sub>E</sub>X entries. Defaults to <code>https://doi.org</code>.</li><li>(<em>main</em> PATH), specify the main <code>.tex</code> file to be PATH.</li></ul><h3 id="latex_bibdoi"><a href="#latex_bibdoi" class="anchor"></a><code>.bibdoi</code> files</h3><p>A <code>.bibdoi</code> file is a list of <a href="https://www.doi.org/">DOI</a>s written as a sequence of <span class="xref-unresolved">s-expression</span> atoms. Here's a sample <code>.bibdoi</code> file:</p><pre>; Some useful references
10.1145/365230.365257
https://doi.org/10.2307/1968337</pre><p>As shown above one can specify DOI either by the DOI itself or by an URI in which case the DOI number is taken to be the URI path without the leading <code>/</code>.</p><p>Each DOI <code>D</code> in the file is resolved to a BibT<sub>E</sub>X entry using the following HTTP request:</p><pre>curl -LH &quot;Accept: application/x-bibtex; charset=utf-8&quot; https://doi.org/D</pre><p>The URI used for the resolving can be <a href="#latex_brzo_file">changed</a> in the <code>BRZO</code> file.</p><p>A <code>P.bibdoi</code> file defines a corresponding <code>P.brzo.bib</code> BibT<sub>E</sub>X file by concatenating the result of resolving each of its DOIs.</p><h2 id="ocaml_domain"><a href="#ocaml_domain" class="anchor"></a>OCaml domain</h2><p>Provides support for handling a set of <a href="https://ocaml.org">OCaml</a>, C and JavaScript files.</p><h3 id="ocaml_exec"><a href="#ocaml_exec" class="anchor"></a>Exec outcome</h3><p>Builds source files to an executable and runs it. There are four different outcome targets which define different kind of executables and actions:</p><ul><li><code>--byte</code>, compile a bytecode executable and run it in the terminal.</li><li><code>--html</code>, compile an HTML program and run it in a browser.</li><li><code>--native</code>, compile a native code executable and run it in the terminal.</li><li><code>--node</code>, compile a JavaScript program and run it in the terminal via <code>node</code>.</li></ul><p>Unless the target is explicitely specified <code>--native</code> is used if <code>ocamlopt</code> is available and <code>--byte</code> otherwise.</p><h4 id="ocaml_exec_native_byte"><a href="#ocaml_exec_native_byte" class="anchor"></a>Byte and native code targets</h4><p>Let <code>BUILD</code> be the outcome build directory.</p><ol><li>Using <a href="#ocaml_compilation">best-effort compilation</a> compile sources to objects and link them to a <code>BUILD/a.out</code> executable.</li><li><a href="#action_exec">Execute</a> <code>BUILD/a.out</code>.</li></ol><h4 id="ocaml_exec_html"><a href="#ocaml_exec_html" class="anchor"></a>HTML target</h4><p>Let <code>ROOT</code> be the root, <code>BUILD</code> the outcome build directory and <code>P</code> match file <em>paths</em>. The following steps are taken:</p><ol><li>Using <a href="#ocaml_compilation">best-effort compilation</a> compile sources to objects and link them to a <code>BUILD/a.out</code> bytecode executable.</li><li>Using <a href="http://ocsigen.org/js_of_ocaml"><code>js_of_ocaml</code></a> compile <code>BUILD/a.out</code> to <code>BUILD/a.js</code>.</li><li>Compile a shim for the action's environment and arguments to <code>BUILD/brzo_tty_glue.js</code>. Action arguments which correspond to files that exist on the file system are crunched to that shim in <code>js_of_ocaml</code>'s virtual file system so that they can be read by the HTML program.</li><li>Any <code>ROOT/P.ext</code> source file with <code>ext</code> in the set <code>B0_fexts</code>.www extension is copied over verbatim to the corresponding <code>BUILD/P.ext</code>.</li><li>If there is no <code>BUILD/index.html</code> file one is generated with any <code>BUILD/P.js</code> and <code>BUILD/P.css</code> files linked in the file, with <code>brzo_tty_glue.js</code> and <code>a.js</code> comming last.</li><li><a href="#action_browser">Open file</a> <code>BUILD/index.html</code> in a browser.</li></ol><h4 id="ocaml_exec_html_2"><a href="#ocaml_exec_html_2" class="anchor"></a>Node target</h4><p>Let <code>ROOT</code> be the root, <code>BUILD</code> the outcome build directory and <code>P</code> match file <em>paths</em>. The following steps are taken:</p><ol><li>Using <a href="#ocaml_compilation">best-effort compilation</a> compile sources to objects and link them to a <code>BUILD/a.out</code> bytecode executable.</li><li>Using <a href="http://ocsigen.org/js_of_ocaml"><code>js_of_ocaml</code></a> compile <code>BUILD/a.out</code> to <code>BUILD/a.out.js</code></li><li>Any <code>ROOT/P.js</code> source file is copied over verbatim to the corresponding <code>BUILD/P.js</code> file.</li><li>Using <code>jsoo_link</code> link the <code>BUILD/P.js</code> files and <code>BUILD/a.out.js</code> to <code>BUILD/a.js</code>.</li><li><a href="#action_exec">Execute</a> <code>BUILD/a.js</code> via <a href="https://nodejs.org"><code>node</code></a>.</li></ol><h3 id="ocaml_doc"><a href="#ocaml_doc" class="anchor"></a>Doc outcome</h3><p>Build and show documentation about source files using <code>odoc</code>.</p><p>Let <code>ROOT</code> be the root, <code>R</code> be its basename, <code>BUILD</code> the outcome build directory, <code>P</code> match file <em>paths</em> and <code>FILE</code> be the basename of <code>P</code>.</p><ol><li>Using <a href="#ocaml_compilation">best-effort compilation</a> produce a <code>BUILD/cmti/FILE.cmi</code> files for each <code>ROOT/P.mli</code> file. This produces <code>BUILD/cmti/FILE.cmti</code> as a side effect which is resolved for local <code>.odoc</code> dependencies and compiled to <code>BUILD/odoc/R/FILE.odoc</code>.</li><li>Compile any <code>ROOT/P.mld</code> file to <code>BUILD/odoc/R/page-FILE.odoc</code>.</li><li>Compile <code>ROOT/P.md</code> files to <code>BUILD/html/_docs/P.html</code> using the <span class="xref-unresolved"><code>cmark</code></span> tool (if available).</li><li>If there is no <code>index.mld</code> file produce one which links to the <code>.mli</code> module pages, <code>.mld</code> pages and the <code>.md</code> HTML documents and compile it to <code>BUILD/odoc/R/page-index.odoc</code></li><li>Generate from <code>.odoc</code> files the HTML for a package named <code>R</code> in <code>BUILD/html</code> using the user's odig odoc theme if set.</li><li><a href="#action_browser">Open directory</a> <code>BUILD/html/R/</code> in a browser.</li></ol><h3 id="ocaml_top"><a href="#ocaml_top" class="anchor"></a>Top outcome</h3><p>Build source files to object files and load them in the OCaml toplevel. There are four different outcome targets which define different actions:</p><ul><li><code>--byte</code>, compile to bytecode and load in <code>ocaml</code>.</li><li><code>--html</code>, compile to JavaScript and load in HTML OCaml toplevel.</li><li><code>--native</code>, compile to native code and load in <code>ocamlnat</code>.</li><li><code>--node</code>, unsupported for now.</li></ul><p>Unless the target is explicitely specified <code>--native</code> is used if <code>ocamlnat</code> is available and <code>--byte</code> otherwise.</p><h4 id="ocaml_exec_native_byte_2"><a href="#ocaml_exec_native_byte_2" class="anchor"></a>Byte and native code targets</h4><p>Let <code>ROOT</code> be the root, <code>BUILD</code> the outcome build directory and <code>P</code> match file <em>paths</em> and <code>FILE</code> be the base names of <code>P</code>.</p><ol><li>Using <a href="#ocaml_compilation">best-effort compilation</a> compile sources to objects and gather them in a <code>BUILD/brzo_top.ext</code> library archive with <code>ext</code> depending on the target.</li><li><a href="#action_exec">Execute</a> <code>ocaml</code> or <code>ocamlnat</code> with <code>BUILD/brzo_top.ext</code>, its <a href="#ocaml_link_deps">link dependencies</a> and <code>BUILD</code> as an include directory. If arguments are specified they are given to the toplevel program invocation.</li></ol><h4 id="ocaml_top_html"><a href="#ocaml_top_html" class="anchor"></a>HTML target</h4><p>Let <code>ROOT</code> be the root, <code>BUILD</code> the outcome build directory and <code>P</code> match file <em>paths</em>. The following steps are taken:</p><ol><li>Using <a href="#ocaml_compilation">best-effort compilation</a> compile sources to objects and link them to a <code>BUILD/a.out</code> bytecode executable.</li><li>Using <a href="http://ocsigen.org/js_of_ocaml"><code>js_of_ocaml</code></a> compile <code>BUILD/a.out</code> to <code>BUILD/a.js</code>.</li><li>TODO</li></ol><h3 id="ocaml_utop"><a href="#ocaml_utop" class="anchor"></a>Utop outcome</h3><p>Except for the <code>--native</code>, <code>--html</code> and <code>--node</code> targets which are not supported this behaves like the <a href="#ocaml_top">top outcome</a> but loads using the <a href="https://github.com/ocaml-community/utop">utop</a> tool rather than <code>ocaml</code>.</p><h3 id="ocaml_brzo_file"><a href="#ocaml_brzo_file" class="anchor"></a><code>BRZO</code> file keys</h3><p>OCaml specific keys are found in the <em>ocaml</em> dictionary. Here's an example that forces the executable target to <code>html</code> and constrains library resolution:</p><pre>(ocaml
  (target html)      ; Default to produce an HTML program
  (libs ptime/jsoo)) ; Force the use the js_of_ocaml support of ptime</pre><p>The available keys are:</p><ul><li>(<em>target</em> TARGET), specify either one of <em>byte</em>, <em>html</em>, <em>native</em> or <em>node</em>. Overriden by the <code>--byte</code>, <code>--html</code>, <code>--native</code> or <code>--node</code> domain options.</li><li>(<em>libs</em> LIB...) add ordered library search restrictions. A <code>LIB</code> is a relative path looked up in the root directories of <code>OCAMLPATH</code>, see <a href="#ocaml_external_deps">external dependency</a> resolution for details. Libraries specified on the command line via the <code>--lib LIB</code> option are added in order at the end of this list.</li><li>(<em>lock-libs</em> BOOL), specify whether dependency search should be restricted to the dependencies mentioned in <em>libs</em>. Overriden by <code>--lock-libs=BOOL</code> option.</li></ul><h3 id="ocaml_compilation"><a href="#ocaml_compilation" class="anchor"></a>Best-effort compilation</h3><p>Let <code>ROOT</code> be the root, <code>BUILD</code> the outcome build directory and <code>P</code> match file <em>paths</em> and <code>FILE</code> be the base names of <code>P</code>. The following steps are taken:</p><ol><li>Module dependencies of <code>ROOT/P.{mli,ml}</code> files are resolved and sources are compiled to objects <code>BUILD/FILE.ext</code> in the correct order using <a href="#ocaml_comp_deps">compilation dependency resolution</a>.</li><li><code>ROOT/P.c</code> C files are compiled to <code>BUILD/FILE.o</code></li><li>If <code>ROOT/.merlin</code> does not exist or exists and starts with <code>&quot;# Generated by brzo&quot;</code>, write an <code>ocamlmerlin</code> file there according to the dependency resolutions that were found.</li><li>According to the outcome proceed to the link phase with all the objects using <a href="#ocaml_link_deps">link dependency resolution</a>.</li></ol><p>Note that the build scheme is flat so you cannot have two same <code>FILE</code> names in different directories of the source tree. If this happens a warning is output and one of the files is arbitrarily dropped.</p><h3 id="ocaml_dep_resolution"><a href="#ocaml_dep_resolution" class="anchor"></a>Best-effort dependency resolution</h3><h4 id="ocaml_comp_deps"><a href="#ocaml_comp_deps" class="anchor"></a>Compilation dependencies</h4><p>Given an <code>.ml</code> or <code>.mli</code> file <code>SRC</code>, the set <code>CMIS</code> of <code>cmi</code> files that need to be visible to compile <code>SRC</code> is determined as follows.</p><ol><li><code>ocamldep -modules</code> is run on <code>SRC</code> to produce a set of module names <code>DS</code> to resolve to <code>cmi</code> files. <code>Stdlib</code> is added to this set. Modules names <code>L</code> that match OCaml sources in the brzo <code>ROOT</code> are removed from <code>DS</code>.</li><li>For each of the local resolutions <code>L</code> found at the preceeding step add <code>L.cmi</code> to <code>CMIS</code> and wait for its compilation. Get all the module names that are defined in <code>L.cmi</code> and remove these from <code>DS</code>.</li><li><p>For each remaining unresolved dependency <code>E</code> in <code>DS</code> perform an <a href="#ocaml_external_deps">external dependency resolution</a> for a file named <code>E.cmi</code>.</p><ul><li>If there a single match add this file to <code>CMIS</code>. Get the all the module names that are defined in <code>E.cmi</code> and remove these from <code>DS</code>.</li><li>If there's no match or more than one match put the resolution of <code>E</code> on hold and proceed with subsequent dependencies to see if it might resolve by later resolutions</li></ul><p>Repeat until there is no dependency left or it is not possible to find a <code>E.cmi</code> for the remaining ones. In that case if:</p><ul><li><code>E.cmi</code> cannot be found. Then keep the dependency unresolved and proceed.</li><li><code>E.cmi</code> resolves to more than one file. Fail the build and propose a dependency restriction to resolve the ambiguity.</li></ul></li><li>For all files <code>E.cmi</code> that were externally resolved and <code>L.cmi</code> files we then lookup their imported interfaces and perform a resolution for these module references and add them to <code>CMIS</code> and recursively; otherwise the build may fail because we may be missing type equations.</li></ol><p>At the end of this process if there are still remaining unresolved dependencies in <code>DS</code> we nevertheless proceed to compile with what we have found. If that fails we try to spellcheck these unresolved names with existing cmis in library directories and/or propose <code>opam</code> packages that could help (if available).</p><h4 id="ocaml_link_deps"><a href="#ocaml_link_deps" class="anchor"></a>Link dependencies</h4><p>The set of <code>cmi</code> files used to compile an object may have been over approximated by <a href="#ocaml_comp_deps">compilation dependency resolution</a>. However the OCaml compiler records in the object files exactly which ones were used. Therefore we read back the real compilation dependencies from the compiled objects.</p><p>We then hunt for <em>implementations</em> for these dependencies. We do so by performing <code>cmi</code> file lookups for them. If the file does not resolve locally an <a href="#ocaml_external_deps">external dependency resolution</a> is performed to find the cmi file. Once found this directory is scanned for a library archive that holds a corresponding implementation. If none is found the direct subdirectories are also looked up and if that fails an &quot;mli-only&quot; module is assumed.</p><p>Once an archive is selected this lookup procedure needs to be applied on each of the dependencies of the object files it contains and recursively so that linking does not fail.</p><p>Eventually this results in correctly sorted local objects and external archives that can be used for the final link step.</p><h4 id="ocaml_external_deps"><a href="#ocaml_external_deps" class="anchor"></a>External dependencies and restrictions</h4><p><code>brzo</code> assumes external OCaml library archives and objects are installed in root directories specified in the <code>OCAMLPATH</code> environment variable.</p><p>If the variable is undefined it defaults to:</p><pre>OCAMLPATH=$(opam var lib):$(ocamlc -where)
OCAMLPATH=$(opam var lib) # if opam is dirs coincide
OCAMLPATH=$(ocamlc -where) # if opam is available</pre><p>and in this case when <code>ocamlc -where</code> is used the <code>brzo</code> maps <code>ocaml</code> specially to it.</p><p>Filenames (e.g. <code>module.cmi</code>) are looked up on a best-effort basis in all root directories of <code>OCAMLPATH</code> and their subdirectories without order. In case such a file is found in multiple directories the build fails and <code>brzo</code> suggests library search restrictions.</p><p>Library search restrictions are specified with ordered <code>--lib LIB</code> options or in the <a href="#ocaml_brzo_file"><code>BRZO</code> file</a>. A library <code>LIB</code> is a relative file path used to order or restrict the search performed in the libraries of <code>OCAMLPATH</code>.</p><p>Let <code>OCAMLPATH=R1:R2</code> and <code>LIB1</code> and <code>LIB2</code> be library restrictions in that order. A library restriction <code>LIB1</code> has two effects:</p><ol><li>First before starting the build <code>brzo</code> checks that at least one of <code>R1/LIB1</code> or <code>R2/LIB1</code> exists. If neither does, the build fails and <code>LIB1</code> is spellchecked against existing directories in <code>R1</code> and <code>R2</code> and/or matched against uninstalled <code>opam</code> packages to propose an <code>opam</code> install (if available).</li><li><p>Whenever a filename resolution is ambiguous but has a candidate in an existing library restriction then resolution is forced to that candidate. More precisely the candidate that is prefixed by the <em>first</em> of the following paths is taken:</p><ol><li><code>R1/LIB1</code></li><li><code>R2/LIB1</code></li><li><code>R1/LIB2</code></li><li><code>R2/LIB2</code></li></ol></li></ol><p>Unless you have restrictions for all discovered dependencies, new installs in root directories of <code>OCAMLPATH</code> may introduce new ambiguities, resulting in builds ambiguously failing while they were previously succeeding. If you want to restrict the search to those directories defined as dependency restrictions use the <code>--lock-libs</code> option (see corresponding key in the <a href="#ocaml_brzo_file"><code>BRZO</code> file</a>).</p><p>For example the <code>ptime</code> package provides multiple implementation for the <code>Ptime_clock</code> module: one for your operating system and another one for your browser. This results in an ambiguous resolution when <code>Ptime_clock</code> is used in a source file. These libraries are respectively installed in these directories:</p><pre>$(opam var lib)/ptime/jsoo
$(opam var lib)/ptime/os</pre><p>In order to force the usage of the operating system clock library use:</p><pre>brzo ocaml --lib ptime/os</pre><p>or add the following to the <code>BRZO</code> file:</p><pre>(ocaml (libs ptime/os))</pre><p>If you'd rather compile for the browser use:</p><pre>brzo ocaml --html --lib ptime/jsoo</pre><p>The <code>BRZO</code> file can be edited programmatically and a failing build may suggest you to do either of:</p><pre>brzo file set ocaml.libs.v[0] ptime/os    # For the OS
brzo file set ocaml.libs.v[0] ptime/jsoo  # For the browser</pre><p>which will insert the library restriction at the beginning of the <code>ocaml.libs</code> dictionary key.</p><h4 id="ocaml_resolution_improvements"><a href="#ocaml_resolution_improvements" class="anchor"></a>Comments and limitations</h4><p>Here are a few points that should be taken into account or that could be improved.</p><ul><li>Dependency resolution can be made more precise with a more precise <code>ocamldep</code>. For example by keeping track of <code>open</code>s and the order in which modules are mentioned (see for example <a href="https://github.com/Octachron/codept">codept</a>). This would allow to make module name resolution path based (vs. unqualified) and thus more precise. That was the initial plan but eventually we decided to start with the simpler approach outlined above which we suspect is &quot;good enough&quot;. The over approximation is harmless and we get to look what was really resolved in the objects for the link step. We also avoid a potential combinatorial explosion.</li><li>Module names read in <code>M.cmi</code> files do not include those available through external module aliases: these would need further <code>.cmi</code> files resolution which we avoided for now. We conjecture again this is &quot;good enough&quot;. Libraries that do namespacing via modules aliases usually simply entice to open the toplevel namespacing module. As such the module names that are going to be reported by <code>ocamldep</code> will be these module names we will read in <code>M.cmi</code>.</li><li>Dependency wise for compilation, not resolving the external aliase in <code>M.cmi</code> to their cmis works as long as those have digested resolutions in the cmi: the stamp of <code>M.cmi</code> will change if the digest of the alias changes.</li><li>Module implementation resolution assumes all objects are in archives</li><li>C stubs are located where their archive is.</li><li>Variants. <code>dune</code> installs <code>cmi</code>s in every variant. Aswell as just above them. `ptime` at the moment does not include the variant independent iface.</li><li>Example of compilation dependency over-approximation: the brzo sources themselves are subject to it: <code>ocamldep</code> returns <code>Fpath</code> or <code>Fmt</code> on some of the sources which we resolve to the <code>opam</code> packages <code>fmt</code> and <code>fpath</code> if they are installed. However once we have compiled when we read back the imported interfaces those are not there because they actually come from <code>B0_std</code>. Thus these dependencies are not resoloved or used at link time.</li></ul></div></body></html>