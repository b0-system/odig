<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Raw_grammar (sexplib0.Sexplib0.Sexp.Private.Raw_grammar)</title><link rel="stylesheet" href="../../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../../index.html">sexplib0</a> &#x00BB; <a href="../../../index.html">Sexplib0</a> &#x00BB; <a href="../../index.html">Sexp</a> &#x00BB; <a href="../index.html">Private</a> &#x00BB; Raw_grammar</nav><header class="odoc-preamble"><h1>Module <code><span>Private.Raw_grammar</span></code></h1></header><nav class="odoc-toc"><ul><li><a href="#goals-and-non-goals">Goals and non-goals</a></li><li><a href="#encoding-of-generated-grammars-to-maximize-sharing">Encoding of generated grammars to maximize sharing</a></li><li><a href="#processing-of-grammars">Processing of grammars</a></li></ul></nav><div class="odoc-content"><div class="odoc-include"><p>This module defines the representation of S-expression grammars produced by <code>@@deriving sexp_grammar</code>. It introduces an AST to represent these grammars and a notion of &quot;group&quot; to represent the grammars of a mutually recursive set of OCaml type declaration.</p><p>The grammar for a given type expression can be constructed via: </p><pre><code>[%sexp_grammar: &lt;type&gt;]</code></pre><h4 id="goals-and-non-goals"><a href="#goals-and-non-goals" class="anchor"></a>Goals and non-goals</h4><p>Functionality goals: With post-processing, sexp grammars can be pretty-printed in a human-readable format and provides enough information to implement completion and validation tools.</p><p>Performance goals: <code>@@deriving sexp_grammar</code> adds minimal overhead and introduces no toplevel side effect. The compiler can lift the vast majority of ASTs generated by <code>@@deriving sexp_grammar</code> as global constants. Common sub-grammars are usually shared, particularly when they derive from multiple applications of the same functor.</p><p>Non-goals: Stability, although we will make changes backwards-compatible or at least provide a reasonable upgrade path.</p><p>In what follows, we describe how this is achieved.</p><h4 id="encoding-of-generated-grammars-to-maximize-sharing"><a href="#encoding-of-generated-grammars-to-maximize-sharing" class="anchor"></a>Encoding of generated grammars to maximize sharing</h4><p>A <code>group</code> contains the grammars for all types of a mutually recursive group of OCaml type declarations.</p><p>To ensure maximum sharing, a group is split into two parts:</p><ul><li>The <code>generic_group</code> depends only on the textual type declarations. Where the type declaration refers to an existing concrete type, the generic group takes a variable to represent the grammar of that type. This means that the compiler can lift each type declaration in the source code to a shared global constant.</li></ul><ul><li>The <code>group</code> binds the type variables of the <code>generic_group</code>, either to concrete grammars where the type declaration refers to a concrete type, or to another variable where the type declaration itself was polymorphic.</li></ul><p>To understand this point better, imagine the following type declaration </p><pre><code>type t = X of u</code></pre><p>were explicitly split into its <code>generic_group</code> and <code>group</code> parts: </p><pre><code>type 'u t_generic = X of 'u
type t = u t_generic</code></pre><p>If <code>u</code> came from a functor argument, it's easy to see that <code>t_generic</code> would be exactly the same in all applications of the functor and only <code>t</code> would vary. The grammar of <code>t_generic</code>, which is the biggest part, would be shared between all applications of the functor.</p><h4 id="processing-of-grammars"><a href="#processing-of-grammars" class="anchor"></a>Processing of grammars</h4><p>The <code>Raw_grammar.t</code> type optimizes for performance over ease of use. To help users process the raw grammars into a more usable form, we keep two identifiers in the generated grammars:</p><ul><li>The <code>generic_group_id</code> uniquely identifies a <code>generic_group</code>. It is a hash of the generic group itself. (It is okay that this scheme would conflate identical type declarations, because the resulting generic groups would be identical as well.)</li></ul><ul><li>The <code>group_id</code> uniquely identifies a <code>group</code>. It is a unique integer, generated lazily so that we don't create a side effect at module creation time.</li></ul><p>The exact processing would depend on the final application. We expect that a typical consumer of sexp grammars would define less-indirected equivalents of the <code>t</code> and <code>group</code> types, possibly re-using the <code>_ type_</code> and <code>Atom.t</code> types.</p><div class="odoc-spec"><div class="spec type" id="type-label" class="anchored"><a href="#type-label" class="anchor"></a><code><span><span class="keyword">type</span> label</span><span> = string</span></code></div><div class="spec-doc"><p>The label of a field, constructor, or constant.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-generic_group_id" class="anchored"><a href="#type-generic_group_id" class="anchor"></a><code><span><span class="keyword">type</span> generic_group_id</span><span> = string</span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-group_id" class="anchored"><a href="#type-group_id" class="anchor"></a><code><span><span class="keyword">type</span> group_id</span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-var_name" class="anchored"><a href="#type-var_name" class="anchor"></a><code><span><span class="keyword">type</span> var_name</span><span> = string</span></code></div><div class="spec-doc"><p>Variable names. These are used to improve readability of the printed grammars. Internally, we use numerical indices to represent variables; see <code>Implicit_var</code> below.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-type_name" class="anchored"><a href="#type-type_name" class="anchor"></a><code><span><span class="keyword">type</span> type_name</span><span> = string</span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Atom" class="anchored"><a href="#module-Atom" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Atom/index.html">Atom</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>A grammatical type which classifies atoms.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-type_" class="anchored"><a href="#type-type_" class="anchor"></a><code><span><span class="keyword">type</span> <span>'t type_</span></span><span> = </span></code><table><tr id="type-type_.Any" class="anchored"><td class="def variant constructor"><a href="#type-type_.Any" class="anchor"></a><code><span>| </span><span><span class="constructor">Any</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Any list or atom.</p><span class="comment-delim">*)</span></td></tr><tr id="type-type_.Apply" class="anchored"><td class="def variant constructor"><a href="#type-type_.Apply" class="anchor"></a><code><span>| </span><span><span class="constructor">Apply</span> <span class="keyword">of</span> <span><span class="type-var">'t</span> <a href="#type-type_">type_</a></span> * <span><span><span class="type-var">'t</span> <a href="#type-type_">type_</a></span> list</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Assign types to (explicit) type variables.</p><span class="comment-delim">*)</span></td></tr><tr id="type-type_.Atom" class="anchored"><td class="def variant constructor"><a href="#type-type_.Atom" class="anchor"></a><code><span>| </span><span><span class="constructor">Atom</span> <span class="keyword">of</span> <a href="Atom/index.html#type-t">Atom.t</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>An atom, in particular one of the given <a href="Atom/index.html#type-t"><code>Atom.t</code></a>.</p><span class="comment-delim">*)</span></td></tr><tr id="type-type_.Explicit_bind" class="anchored"><td class="def variant constructor"><a href="#type-type_.Explicit_bind" class="anchor"></a><code><span>| </span><span><span class="constructor">Explicit_bind</span> <span class="keyword">of</span> <span><a href="#type-var_name">var_name</a> list</span> * <span><span class="type-var">'t</span> <a href="#type-type_">type_</a></span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>In <code>Bind ([ &quot;a&quot;; &quot;b&quot; ], Explicit_var 0)</code>, <code>Explicit_var 0</code> is <code>&quot;a&quot;</code>. One must bind all available type variables: free variables are not permitted.</p><span class="comment-delim">*)</span></td></tr><tr id="type-type_.Explicit_var" class="anchored"><td class="def variant constructor"><a href="#type-type_.Explicit_var" class="anchor"></a><code><span>| </span><span><span class="constructor">Explicit_var</span> <span class="keyword">of</span> int</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Indices for type variables, e.g. <code>'a</code>, introduced by polymorphic definitions.</p><p>Unlike de Bruijn indices, these are always bound by the nearest ancestral <code>Explicit_bind</code>.</p><span class="comment-delim">*)</span></td></tr><tr id="type-type_.Grammar" class="anchored"><td class="def variant constructor"><a href="#type-type_.Grammar" class="anchor"></a><code><span>| </span><span><span class="constructor">Grammar</span> <span class="keyword">of</span> <span class="type-var">'t</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Embeds other types in a grammar.</p><span class="comment-delim">*)</span></td></tr><tr id="type-type_.Implicit_var" class="anchored"><td class="def variant constructor"><a href="#type-type_.Implicit_var" class="anchor"></a><code><span>| </span><span><span class="constructor">Implicit_var</span> <span class="keyword">of</span> int</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Indices for type constructors, e.g. <code>int</code>, in scope. Unlike de Bruijn indices, these are always bound by the <code>implicit_vars</code> of the nearest enclosing <code>generic_groups</code>.</p><span class="comment-delim">*)</span></td></tr><tr id="type-type_.List" class="anchored"><td class="def variant constructor"><a href="#type-type_.List" class="anchor"></a><code><span>| </span><span><span class="constructor">List</span> <span class="keyword">of</span> <span><span class="type-var">'t</span> <a href="#type-sequence_type">sequence_type</a></span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>A list of a certain form. Depending on the <a href="#type-sequence_type"><code>sequence_type</code></a>, this might correspond to an OCaml tuple, list, or embedded record.</p><span class="comment-delim">*)</span></td></tr><tr id="type-type_.Option" class="anchored"><td class="def variant constructor"><a href="#type-type_.Option" class="anchor"></a><code><span>| </span><span><span class="constructor">Option</span> <span class="keyword">of</span> <span><span class="type-var">'t</span> <a href="#type-type_">type_</a></span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>An optional value. Either syntax recognized by <code>option_of_sexp</code> is supported: <code>(Some 42)</code> or <code>(42)</code> for a value and <code>None</code> or <code>()</code> for no value.</p><span class="comment-delim">*)</span></td></tr><tr id="type-type_.Record" class="anchored"><td class="def variant constructor"><a href="#type-type_.Record" class="anchor"></a><code><span>| </span><span><span class="constructor">Record</span> <span class="keyword">of</span> <span><span class="type-var">'t</span> <a href="#type-record_type">record_type</a></span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>A list of lists, representing a record of the given <a href="#type-record_type"><code>record_type</code></a>. For validation, <code>Record recty</code> is equivalent to <code>List [Fields recty]</code>.</p><span class="comment-delim">*)</span></td></tr><tr id="type-type_.Recursive" class="anchored"><td class="def variant constructor"><a href="#type-type_.Recursive" class="anchor"></a><code><span>| </span><span><span class="constructor">Recursive</span> <span class="keyword">of</span> <a href="#type-type_name">type_name</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>A type in the same mutually recursive group, possibly the current one.</p><span class="comment-delim">*)</span></td></tr><tr id="type-type_.Union" class="anchored"><td class="def variant constructor"><a href="#type-type_.Union" class="anchor"></a><code><span>| </span><span><span class="constructor">Union</span> <span class="keyword">of</span> <span><span><span class="type-var">'t</span> <a href="#type-type_">type_</a></span> list</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Any sexp matching any of the given types. <a href="#type-type_.Variant"><code>Variant</code></a> should be preferred when possible, especially for complex types, since validation and other algorithms may behave exponentially.</p><p>One useful special case is <code>Union []</code>, the empty type. This is occasionally generated for things such as abstract types.</p><span class="comment-delim">*)</span></td></tr><tr id="type-type_.Variant" class="anchored"><td class="def variant constructor"><a href="#type-type_.Variant" class="anchor"></a><code><span>| </span><span><span class="constructor">Variant</span> <span class="keyword">of</span> <span><span class="type-var">'t</span> <a href="#type-variant_type">variant_type</a></span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>A sexp which matches the given <a href="#type-variant_type"><code>variant_type</code></a>.</p><span class="comment-delim">*)</span></td></tr></table></div><div class="spec-doc"><p>A grammatical type which classifies sexps. Corresponds to a non-terminal in a context-free grammar.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-sequence_type" class="anchored"><a href="#type-sequence_type" class="anchor"></a><code><span><span class="keyword">and</span> <span>'t sequence_type</span></span><span> = <span><span><span class="type-var">'t</span> <a href="#type-component">component</a></span> list</span></span></code></div><div class="spec-doc"><p>A grammatical type which classifies sequences of sexps. Here, a &quot;sequence&quot; may mean either a list on its own or, say, the sexps following a constructor in a list matching a <a href="#type-variant_type"><code>variant_type</code></a>.</p><p>Certain operations may greatly favor simple sequence types. For example, matching <code>List [ Many type_ ]</code> is easy for any type <code>type_</code> (assuming <code>type_</code> itself is easy), but <code>List [ Many type1; Many type2 ]</code> may require backtracking. Grammars derived from OCaml types will only have &quot;nice&quot; sequence types.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-component" class="anchored"><a href="#type-component" class="anchor"></a><code><span><span class="keyword">and</span> <span>'t component</span></span><span> = </span></code><table><tr id="type-component.One" class="anchored"><td class="def variant constructor"><a href="#type-component.One" class="anchor"></a><code><span>| </span><span><span class="constructor">One</span> <span class="keyword">of</span> <span><span class="type-var">'t</span> <a href="#type-type_">type_</a></span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Exactly one sexp of the given type.</p><span class="comment-delim">*)</span></td></tr><tr id="type-component.Optional" class="anchored"><td class="def variant constructor"><a href="#type-component.Optional" class="anchor"></a><code><span>| </span><span><span class="constructor">Optional</span> <span class="keyword">of</span> <span><span class="type-var">'t</span> <a href="#type-type_">type_</a></span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>One sexp of the given type, or nothing at all.</p><span class="comment-delim">*)</span></td></tr><tr id="type-component.Many" class="anchored"><td class="def variant constructor"><a href="#type-component.Many" class="anchor"></a><code><span>| </span><span><span class="constructor">Many</span> <span class="keyword">of</span> <span><span class="type-var">'t</span> <a href="#type-type_">type_</a></span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Any number of sexps, each of the given type.</p><span class="comment-delim">*)</span></td></tr><tr id="type-component.Fields" class="anchored"><td class="def variant constructor"><a href="#type-component.Fields" class="anchor"></a><code><span>| </span><span><span class="constructor">Fields</span> <span class="keyword">of</span> <span><span class="type-var">'t</span> <a href="#type-record_type">record_type</a></span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>A succession of lists, collectively defining a record of the given <a href="#type-record_type"><code>record_type</code></a>. The fields may appear in any order. The number of lists is not necessarily fixed, as some fields may be optional. In particular, if all fields are optional, there may be zero lists.</p><span class="comment-delim">*)</span></td></tr></table></div><div class="spec-doc"><p>Part of a sequence of sexps.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-variant_type" class="anchored"><a href="#type-variant_type" class="anchor"></a><code><span><span class="keyword">and</span> <span>'t variant_type</span></span><span> = </span><span>{</span></code><table><tr id="type-variant_type.ignore_capitalization" class="anchored"><td class="def record field"><a href="#type-variant_type.ignore_capitalization" class="anchor"></a><code><span>ignore_capitalization : bool;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>If true, the grammar is insensitive to the case of the first letter of the label. This matches the behavior of derived <code>sexp_of_t</code> functions.</p><span class="comment-delim">*)</span></td></tr><tr id="type-variant_type.alts" class="anchored"><td class="def record field"><a href="#type-variant_type.alts" class="anchor"></a><code><span>alts : <span><span>(<a href="#type-label">label</a> * <span><span class="type-var">'t</span> <a href="#type-sequence_type">sequence_type</a></span>)</span> list</span>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>An association list of labels (constructors) to sequence types. A matching sexp is a list whose head is the label as an atom and whose tail matches the given sequence type. As a special case, an alternative whose sequence is empty matches an atom rather than a list (i.e., <code>label</code> rather than <code>(label)</code>). This is in keeping with generated <code>t_of_sexp</code> functions.</p><p>As a workaround, to match <code>(label)</code> one could use <code>(&quot;label&quot;, [ Optional (Union []) ])</code>.</p><span class="comment-delim">*)</span></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p>A tagged union of grammatical types. Grammars derived from OCaml variants will have variant types.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-record_type" class="anchored"><a href="#type-record_type" class="anchor"></a><code><span><span class="keyword">and</span> <span>'t record_type</span></span><span> = </span><span>{</span></code><table><tr id="type-record_type.allow_extra_fields" class="anchored"><td class="def record field"><a href="#type-record_type.allow_extra_fields" class="anchor"></a><code><span>allow_extra_fields : bool;</span></code></td></tr><tr id="type-record_type.fields" class="anchored"><td class="def record field"><a href="#type-record_type.fields" class="anchor"></a><code><span>fields : <span><span>(<a href="#type-label">label</a> * <span><span class="type-var">'t</span> <a href="#type-field">field</a></span>)</span> list</span>;</span></code></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p>A collection of field definitions specifying a record type. Consists only of an association list from labels to fields.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-field" class="anchored"><a href="#type-field" class="anchor"></a><code><span><span class="keyword">and</span> <span>'t field</span></span><span> = </span><span>{</span></code><table><tr id="type-field.optional" class="anchored"><td class="def record field"><a href="#type-field.optional" class="anchor"></a><code><span>optional : bool;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>If true, the field is optional.</p><span class="comment-delim">*)</span></td></tr><tr id="type-field.args" class="anchored"><td class="def record field"><a href="#type-field.args" class="anchor"></a><code><span>args : <span><span class="type-var">'t</span> <a href="#type-sequence_type">sequence_type</a></span>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>A sequence type which the arguments to the field must match. An empty sequence is permissible but would not be generated for any OCaml type.</p><span class="comment-delim">*)</span></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p>A field in a record.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span><span> = </span></code><table><tr id="type-t.Ref" class="anchored"><td class="def variant constructor"><a href="#type-t.Ref" class="anchor"></a><code><span>| </span><span><span class="constructor">Ref</span> <span class="keyword">of</span> <a href="#type-type_name">type_name</a> * <a href="#type-group">group</a></span></code></td></tr><tr id="type-t.Inline" class="anchored"><td class="def variant constructor"><a href="#type-t.Inline" class="anchor"></a><code><span>| </span><span><span class="constructor">Inline</span> <span class="keyword">of</span> <span><a href="#type-t">t</a> <a href="#type-type_">type_</a></span></span></code></td></tr></table></div></div><div class="odoc-spec"><div class="spec type" id="type-group" class="anchored"><a href="#type-group" class="anchor"></a><code><span><span class="keyword">and</span> group</span><span> = </span><span>{</span></code><table><tr id="type-group.gid" class="anchored"><td class="def record field"><a href="#type-group.gid" class="anchor"></a><code><span>gid : <a href="#type-group_id">group_id</a>;</span></code></td></tr><tr id="type-group.generic_group" class="anchored"><td class="def record field"><a href="#type-group.generic_group" class="anchor"></a><code><span>generic_group : <a href="#type-generic_group">generic_group</a>;</span></code></td></tr><tr id="type-group.origin" class="anchored"><td class="def record field"><a href="#type-group.origin" class="anchor"></a><code><span>origin : string;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p><code>origin</code> provides a human-readable hint as to where the type was defined.</p><p>For a globally unique identifier, use <code>gid</code> instead.</p><p>See <code>ppx/ppx_sexp_conv/test/expect/test_origin.ml</code> for examples.</p><span class="comment-delim">*)</span></td></tr><tr id="type-group.apply_implicit" class="anchored"><td class="def record field"><a href="#type-group.apply_implicit" class="anchor"></a><code><span>apply_implicit : <span><a href="#type-t">t</a> list</span>;</span></code></td></tr></table><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-generic_group" class="anchored"><a href="#type-generic_group" class="anchor"></a><code><span><span class="keyword">and</span> generic_group</span><span> = </span><span>{</span></code><table><tr id="type-generic_group.implicit_vars" class="anchored"><td class="def record field"><a href="#type-generic_group.implicit_vars" class="anchor"></a><code><span>implicit_vars : <span><a href="#type-var_name">var_name</a> list</span>;</span></code></td></tr><tr id="type-generic_group.ggid" class="anchored"><td class="def record field"><a href="#type-generic_group.ggid" class="anchor"></a><code><span>ggid : <a href="#type-generic_group_id">generic_group_id</a>;</span></code></td></tr><tr id="type-generic_group.types" class="anchored"><td class="def record field"><a href="#type-generic_group.types" class="anchor"></a><code><span>types : <span><span>(<a href="#type-type_name">type_name</a> * <span><a href="#type-t">t</a> <a href="#type-type_">type_</a></span>)</span> list</span>;</span></code></td></tr></table><code><span>}</span></code></div></div></div><div class="odoc-spec"><div class="spec module" id="module-Builtin" class="anchored"><a href="#module-Builtin" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Builtin/index.html">Builtin</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-empty_sexp_grammar" class="anchored"><a href="#val-empty_sexp_grammar" class="anchor"></a><code><span><span class="keyword">val</span> empty_sexp_grammar : <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-opaque_sexp_grammar" class="anchored"><a href="#val-opaque_sexp_grammar" class="anchor"></a><code><span><span class="keyword">val</span> opaque_sexp_grammar : <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-fun_sexp_grammar" class="anchored"><a href="#val-fun_sexp_grammar" class="anchor"></a><code><span><span class="keyword">val</span> fun_sexp_grammar : <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-tuple2_sexp_grammar" class="anchored"><a href="#val-tuple2_sexp_grammar" class="anchor"></a><code><span><span class="keyword">val</span> tuple2_sexp_grammar : <a href="#type-t">t</a></span></code></div></div></div></body></html>