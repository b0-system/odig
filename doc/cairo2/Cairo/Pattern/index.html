<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Pattern (cairo2.Cairo.Pattern)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">cairo2</a> &#x00BB; <a href="../index.html">Cairo</a> &#x00BB; Pattern</nav><h1>Module <code>Cairo.Pattern</code></h1><p>Paint (and also mask and brush) with which cairo draws and associated function.</p></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type </span>'a t</code><code><span class="keyword"> constraint </span><span class="type-var">'a</span> = [&lt; `Solid<span class="keyword"> | </span>`Surface<span class="keyword"> | </span>`Gradient<span class="keyword"> | </span>`Linear<span class="keyword"> | </span>`Radial ]</code></dt><dd><p>This is the paint with which cairo draws. The primary use of patterns is as the source for all cairo drawing operations, although they can also be used as masks, that is, as the brush too.</p><p>A cairo pattern is created by using one of the many functions, of the form <code>Cairo.Pattern.create_type</code> or implicitly through <code>Cairo.set_source_*</code> functions.</p></dd></dl><dl><dt class="spec type" id="type-any"><a href="#type-any" class="anchor"></a><code><span class="keyword">type </span>any</code><code><span class="keyword"> = </span>[ `Solid<span class="keyword"> | </span>`Surface<span class="keyword"> | </span>`Gradient<span class="keyword"> | </span>`Linear<span class="keyword"> | </span>`Radial ] <a href="index.html#type-t">t</a></code></dt><dd><p><a href="../Group/index.html#val-pop"><code>Cairo.Group.pop</code></a> and <a href="../index.html#val-get_source"><code>Cairo.get_source</code></a> retrieve patterns whose properties we do not know. In this case, we can only assume the pattern has potentially all properties and the functions below may raise an exception if it turns out that the needed property is not present.</p></dd></dl><dl><dt class="spec value" id="val-add_color_stop_rgb"><a href="#val-add_color_stop_rgb" class="anchor"></a><code><span class="keyword">val </span>add_color_stop_rgb : [&gt; `Gradient ] <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> ?&#8288;ofs:float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> unit</code></dt><dd><p>Adds an opaque color stop to a gradient pattern. The offset <code>ofs</code> specifies the location along the gradient's control vector (default: <code>0.0</code>). For example, a linear gradient's control vector is from (x0,y0) to (x1,y1) while a radial gradient's control vector is from any point on the start circle to the corresponding point on the end circle.</p><p>The color is specified in the same way as in <a href="../index.html#val-set_source_rgb"><code>Cairo.set_source_rgb</code></a>.</p><p>If two (or more) stops are specified with identical offset values, they will be sorted according to the order in which the stops are added (stops added earlier will compare less than stops added later). This can be useful for reliably making sharp color transitions instead of the typical blend.</p></dd></dl><dl><dt class="spec value" id="val-add_color_stop_rgba"><a href="#val-add_color_stop_rgba" class="anchor"></a><code><span class="keyword">val </span>add_color_stop_rgba : [&gt; `Gradient ] <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> ?&#8288;ofs:float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> unit</code></dt><dd><p>Adds a translucent color stop to a gradient pattern. The offset specifies the location along the gradient's control vector. For example, a linear gradient's control vector is from (x0,y0) to (x1,y1) while a radial gradient's control vector is from any point on the start circle to the corresponding point on the end circle.</p><p>The color is specified in the same way as in <a href="../index.html#val-set_source_rgba"><code>Cairo.set_source_rgba</code></a>.</p><p>If two (or more) stops are specified with identical offset values, they will be sorted according to the order in which the stops are added (stops added earlier will compare less than stops added later). This can be useful for reliably making sharp color transitions instead of the typical blend.</p></dd></dl><dl><dt class="spec value" id="val-get_color_stop_count"><a href="#val-get_color_stop_count" class="anchor"></a><code><span class="keyword">val </span>get_color_stop_count : [&gt; `Gradient ] <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Return the number of color stops specified in the given gradient pattern.</p></dd></dl><dl><dt class="spec value" id="val-get_color_stop_rgba"><a href="#val-get_color_stop_rgba" class="anchor"></a><code><span class="keyword">val </span>get_color_stop_rgba : [&gt; `Gradient ] <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> idx:int <span>&#45;&gt;</span> float<span class="keyword"> * </span>float<span class="keyword"> * </span>float<span class="keyword"> * </span>float<span class="keyword"> * </span>float</code></dt><dd><p>Gets the color and offset information at the given index for a gradient pattern. Values of index are 0 to 1 less than the number returned by <a href="index.html#val-get_color_stop_count"><code>Cairo.Pattern.get_color_stop_count</code></a>.</p><dl><dt>returns</dt><dd><p>(offset, red, green, blue, alpha)</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-create_rgb"><a href="#val-create_rgb" class="anchor"></a><code><span class="keyword">val </span>create_rgb : float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> [ `Solid ] <a href="index.html#type-t">t</a></code></dt><dd><p><code>create_rgb r g b</code> creates a new <a href="index.html#type-t"><code>Cairo.Pattern.t</code></a> corresponding to an opaque color. The color components are floating point numbers in the range 0 to 1. If the values passed in are outside that range, they will be clamped.</p></dd></dl><dl><dt class="spec value" id="val-create_rgba"><a href="#val-create_rgba" class="anchor"></a><code><span class="keyword">val </span>create_rgba : float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> [ `Solid ] <a href="index.html#type-t">t</a></code></dt><dd><p><code>create_rgba r g b a</code> creates a new <a href="index.html#type-t"><code>Cairo.Pattern.t</code></a> corresponding to a translucent color. The color components are floating point numbers in the range 0 to 1. If the values passed in are outside that range, they will be clamped.</p></dd></dl><dl><dt class="spec value" id="val-get_rgba"><a href="#val-get_rgba" class="anchor"></a><code><span class="keyword">val </span>get_rgba : [&gt; `Solid ] <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> float<span class="keyword"> * </span>float<span class="keyword"> * </span>float<span class="keyword"> * </span>float</code></dt><dd><p>Return the solid color for a solid color pattern.</p><dl><dt>returns</dt><dd><p>(red, green, blue, alpha)</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-create_for_surface"><a href="#val-create_for_surface" class="anchor"></a><code><span class="keyword">val </span>create_for_surface : <a href="../Surface/index.html#type-t">Surface.t</a> <span>&#45;&gt;</span> [ `Surface ] <a href="index.html#type-t">t</a></code></dt><dd><p>Create a new <a href="index.html#type-t"><code>Cairo.Pattern.t</code></a> for the given surface.</p></dd></dl><dl><dt class="spec value" id="val-get_surface"><a href="#val-get_surface" class="anchor"></a><code><span class="keyword">val </span>get_surface : [ `Surface ] <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Surface/index.html#type-t">Surface.t</a></code></dt><dd><p>Gets the surface of a surface pattern.</p></dd></dl><dl><dt class="spec value" id="val-create_linear"><a href="#val-create_linear" class="anchor"></a><code><span class="keyword">val </span>create_linear : x0:float <span>&#45;&gt;</span> y0:float <span>&#45;&gt;</span> x1:float <span>&#45;&gt;</span> y1:float <span>&#45;&gt;</span> [ `Linear<span class="keyword"> | </span>`Gradient ] <a href="index.html#type-t">t</a></code></dt><dd><p>Create a new linear gradient <a href="index.html#type-t"><code>Cairo.Pattern.t</code></a> along the line defined by (x0, y0) and (x1, y1). Before using the gradient pattern, a number of color stops should be defined using <a href="index.html#val-add_color_stop_rgb"><code>Cairo.Pattern.add_color_stop_rgb</code></a> or <a href="index.html#val-add_color_stop_rgba"><code>Cairo.Pattern.add_color_stop_rgba</code></a>.</p><p>Note: The coordinates here are in pattern space. For a new pattern, pattern space is identical to user space, but the relationship between the spaces can be changed with <a href="index.html#val-set_matrix"><code>Cairo.Pattern.set_matrix</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-get_linear_points"><a href="#val-get_linear_points" class="anchor"></a><code><span class="keyword">val </span>get_linear_points : [&gt; `Linear<span class="keyword"> | </span>`Gradient ] <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> float<span class="keyword"> * </span>float<span class="keyword"> * </span>float<span class="keyword"> * </span>float</code></dt><dd><p>Gets the gradient endpoints for a linear gradient.</p><dl><dt>returns</dt><dd><p>(x0, y0, x1, y1).</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-create_radial"><a href="#val-create_radial" class="anchor"></a><code><span class="keyword">val </span>create_radial : x0:float <span>&#45;&gt;</span> y0:float <span>&#45;&gt;</span> r0:float <span>&#45;&gt;</span> x1:float <span>&#45;&gt;</span> y1:float <span>&#45;&gt;</span> r1:float <span>&#45;&gt;</span> [ `Radial<span class="keyword"> | </span>`Gradient ] <a href="index.html#type-t">t</a></code></dt><dd><p>Creates a new radial gradient <a href="index.html#type-t"><code>Cairo.Pattern.t</code></a> between the two circles defined by (cx0, cy0, radius0) and (cx1, cy1, radius1). Before using the gradient pattern, a number of color stops should be defined using <a href="index.html#val-add_color_stop_rgb"><code>Cairo.Pattern.add_color_stop_rgb</code></a> or <a href="index.html#val-add_color_stop_rgba"><code>Cairo.Pattern.add_color_stop_rgba</code></a>.</p><p>Note: The coordinates here are in pattern space. For a new pattern, pattern space is identical to user space, but the relationship between the spaces can be changed with <a href="index.html#val-set_matrix"><code>Cairo.Pattern.set_matrix</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-get_radial_circles"><a href="#val-get_radial_circles" class="anchor"></a><code><span class="keyword">val </span>get_radial_circles : [&gt; `Radial<span class="keyword"> | </span>`Gradient ] <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> float<span class="keyword"> * </span>float<span class="keyword"> * </span>float<span class="keyword"> * </span>float<span class="keyword"> * </span>float<span class="keyword"> * </span>float</code></dt><dd><p>Gets the gradient endpoint circles for a radial gradient, each specified as a center coordinate and a radius.</p><dl><dt>returns</dt><dd><p>(x0, y0, r0, x1, y1, r1).</p></dd></dl></dd></dl><dl><dt class="spec type" id="type-extend"><a href="#type-extend" class="anchor"></a><code><span class="keyword">type </span>extend</code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-extend.NONE" class="anchored"><td class="def constructor"><a href="#type-extend.NONE" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">NONE</span></code></td><td class="doc"><p>pixels outside of the source pattern are fully transparent.</p></td></tr><tr id="type-extend.REPEAT" class="anchored"><td class="def constructor"><a href="#type-extend.REPEAT" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">REPEAT</span></code></td><td class="doc"><p>the pattern is tiled by repeating.</p></td></tr><tr id="type-extend.REFLECT" class="anchored"><td class="def constructor"><a href="#type-extend.REFLECT" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">REFLECT</span></code></td><td class="doc"><p>the pattern is tiled by reflecting at the edges.</p></td></tr><tr id="type-extend.PAD" class="anchored"><td class="def constructor"><a href="#type-extend.PAD" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">PAD</span></code></td><td class="doc"><p>pixels outside of the pattern copy the closest pixel from the source.</p></td></tr></table></dt><dd><p>This is used to describe how pattern color/alpha will be determined for areas &quot;outside&quot; the pattern's natural area (for example, outside the surface bounds or outside the gradient geometry).</p></dd></dl><dl><dt class="spec value" id="val-set_extend"><a href="#val-set_extend" class="anchor"></a><code><span class="keyword">val </span>set_extend : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-extend">extend</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Sets the mode to be used for drawing outside the area of a pattern. See <a href="index.html#type-extend"><code>Cairo.Pattern.extend</code></a> for details on the semantics of each extend strategy.</p><p>The default extend mode is <code>NONE</code> for surface patterns and <code>PAD</code> for gradient patterns.</p></dd></dl><dl><dt class="spec value" id="val-get_extend"><a href="#val-get_extend" class="anchor"></a><code><span class="keyword">val </span>get_extend : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-extend">extend</a></code></dt><dd><p>Gets the current extend mode for a pattern. See <a href="index.html#type-extend"><code>Cairo.Pattern.extend</code></a> for details on the semantics of each extend strategy.</p></dd></dl><dl><dt class="spec type" id="type-filter"><a href="#type-filter" class="anchor"></a><code><span class="keyword">type </span>filter</code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-filter.FAST" class="anchored"><td class="def constructor"><a href="#type-filter.FAST" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">FAST</span></code></td><td class="doc"><p>A high-performance filter, with quality similar to NEAREST</p></td></tr><tr id="type-filter.GOOD" class="anchored"><td class="def constructor"><a href="#type-filter.GOOD" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">GOOD</span></code></td><td class="doc"><p>A reasonable-performance filter, with quality similar to BILINEAR</p></td></tr><tr id="type-filter.BEST" class="anchored"><td class="def constructor"><a href="#type-filter.BEST" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">BEST</span></code></td><td class="doc"><p>The highest-quality available, performance may not be suitable for interactive use.</p></td></tr><tr id="type-filter.NEAREST" class="anchored"><td class="def constructor"><a href="#type-filter.NEAREST" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">NEAREST</span></code></td><td class="doc"><p>Nearest-neighbor filtering</p></td></tr><tr id="type-filter.BILINEAR" class="anchored"><td class="def constructor"><a href="#type-filter.BILINEAR" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">BILINEAR</span></code></td><td class="doc"><p>Linear interpolation in two dimensions</p></td></tr></table></dt><dd><p>This is used to indicate what filtering should be applied when reading pixel values from patterns. See <a href="index.html#val-set_filter"><code>Cairo.Pattern.set_filter</code></a> for indicating the desired filter to be used with a particular pattern.</p></dd></dl><dl><dt class="spec value" id="val-set_filter"><a href="#val-set_filter" class="anchor"></a><code><span class="keyword">val </span>set_filter : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-filter">filter</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Sets the filter to be used for resizing when using this pattern. See <a href="index.html#type-filter"><code>Cairo.Pattern.filter</code></a> for details on each filter.</p><p>Note that you might want to control filtering even when you do not have an explicit <a href="index.html#type-t"><code>Cairo.Pattern.t</code></a> value (for example when using <a href="../index.html#val-set_source_surface"><code>Cairo.set_source_surface</code></a>). In these cases, it is convenient to use <a href="../index.html#val-get_source"><code>Cairo.get_source</code></a> to get access to the pattern that cairo creates implicitly. For example:</p><pre><code class="ml">Cairo.set_source_surface cr image x y;
Cairo.Pattern.set_filter (Cairo.get_source cr) Cairo.Pattern.NEAREST;</code></pre></dd></dl><dl><dt class="spec value" id="val-get_filter"><a href="#val-get_filter" class="anchor"></a><code><span class="keyword">val </span>get_filter : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-filter">filter</a></code></dt><dd><p>Gets the current filter for a pattern. See <a href="index.html#type-filter"><code>Cairo.Pattern.filter</code></a> for details on each filter.</p></dd></dl><dl><dt class="spec value" id="val-set_matrix"><a href="#val-set_matrix" class="anchor"></a><code><span class="keyword">val </span>set_matrix : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Matrix/index.html#type-t">Matrix.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Sets the pattern's transformation matrix to matrix. This matrix is a transformation from user space to pattern space.</p><p>When a pattern is first created it always has the identity matrix for its transformation matrix, which means that pattern space is initially identical to user space.</p><p>Important: Please note that the direction of this transformation matrix is from user space to pattern space. This means that if you imagine the flow from a pattern to user space (and on to device space), then coordinates in that flow will be transformed by the inverse of the pattern matrix.</p><p>For example, if you want to make a pattern appear twice as large as it does by default the correct code to use is:</p><pre><code class="ml">let matrix = Cairo.Matrix.init_scale 0.5 0.5 in
Cairo.Pattern.set_matrix pattern matrix;</code></pre></dd></dl><dl><dt class="spec value" id="val-get_matrix"><a href="#val-get_matrix" class="anchor"></a><code><span class="keyword">val </span>get_matrix : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Matrix/index.html#type-t">Matrix.t</a></code></dt><dd><p>Returns the pattern's transformation matrix.</p></dd></dl></div></body></html>