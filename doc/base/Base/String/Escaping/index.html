<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Escaping (base.Base.String.Escaping)</title><link rel="stylesheet" href="../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">base</a> &#x00BB; <a href="../../index.html">Base</a> &#x00BB; <a href="../index.html">String</a> &#x00BB; Escaping</nav><header class="odoc-preamble"><h1>Module <code><span>String.Escaping</span></code></h1><p>Operations for escaping and unescaping strings, with parameterized escape and escapeworthy characters. Escaping/unescaping using this module is more efficient than using Pcre. Benchmark code can be found in core/benchmarks/string_escaping.ml.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec value" id="val-escape_gen_exn" class="anchored"><a href="#val-escape_gen_exn" class="anchor"></a><code><span><span class="keyword">val</span> escape_gen_exn : <span>escapeworthy_map:<span><span>(char * char)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span>escape_char:char <span class="arrow">&#45;&gt;</span></span>
<span><span>(<span>string <span class="arrow">&#45;&gt;</span></span> string)</span> <a href="../../Staged/index.html#type-t">Staged.t</a></span></span></code></div><div class="spec-doc"><p><code>escape_gen_exn escapeworthy_map escape_char</code> returns a function that will escape a string <code>s</code> as follows: if <code>(c1,c2)</code> is in <code>escapeworthy_map</code>, then all occurrences of <code>c1</code> are replaced by <code>escape_char</code> concatenated to <code>c2</code>.</p><p>Raises an exception if <code>escapeworthy_map</code> is not one-to-one. If <code>escape_char</code> is not in <code>escapeworthy_map</code>, then it will be escaped to itself.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-escape_gen" class="anchored"><a href="#val-escape_gen" class="anchor"></a><code><span><span class="keyword">val</span> escape_gen : <span>escapeworthy_map:<span><span>(char * char)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span>escape_char:char <span class="arrow">&#45;&gt;</span></span>
<span><span>(<span>string <span class="arrow">&#45;&gt;</span></span> string)</span> <a href="../../Or_error/index.html#type-t">Or_error.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-escape" class="anchored"><a href="#val-escape" class="anchor"></a><code><span><span class="keyword">val</span> escape : <span>escapeworthy:<span>char list</span> <span class="arrow">&#45;&gt;</span></span> <span>escape_char:char <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>string <span class="arrow">&#45;&gt;</span></span> string)</span> <a href="../../Staged/index.html#type-t">Staged.t</a></span></span></code></div><div class="spec-doc"><p><code>escape ~escapeworthy ~escape_char s</code> is</p><pre><code>escape_gen_exn ~escapeworthy_map:(List.zip_exn escapeworthy escapeworthy)
  ~escape_char</code></pre><p>Duplicates and <code>escape_char</code> will be removed from <code>escapeworthy</code>. So, no exception will be raised</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unescape_gen_exn" class="anchored"><a href="#val-unescape_gen_exn" class="anchor"></a><code><span><span class="keyword">val</span> unescape_gen_exn : <span>escapeworthy_map:<span><span>(char * char)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span>escape_char:char <span class="arrow">&#45;&gt;</span></span>
<span><span>(<span>string <span class="arrow">&#45;&gt;</span></span> string)</span> <a href="../../Staged/index.html#type-t">Staged.t</a></span></span></code></div><div class="spec-doc"><p><code>unescape_gen_exn</code> is the inverse operation of <code>escape_gen_exn</code>. That is,</p><pre><code>let escape = Staged.unstage (escape_gen_exn ~escapeworthy_map ~escape_char) in
let unescape = Staged.unstage (unescape_gen_exn ~escapeworthy_map ~escape_char) in
assert (s = unescape (escape s))</code></pre><p>always succeed when ~escapeworthy_map is not causing exceptions.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unescape_gen" class="anchored"><a href="#val-unescape_gen" class="anchor"></a><code><span><span class="keyword">val</span> unescape_gen : <span>escapeworthy_map:<span><span>(char * char)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span>escape_char:char <span class="arrow">&#45;&gt;</span></span>
<span><span>(<span>string <span class="arrow">&#45;&gt;</span></span> string)</span> <a href="../../Or_error/index.html#type-t">Or_error.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-unescape" class="anchored"><a href="#val-unescape" class="anchor"></a><code><span><span class="keyword">val</span> unescape : <span>escape_char:char <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>string <span class="arrow">&#45;&gt;</span></span> string)</span> <a href="../../Staged/index.html#type-t">Staged.t</a></span></span></code></div><div class="spec-doc"><p><code>unescape ~escape_char</code> is defined as <code>unescape_gen_exn ~map:[] ~escape_char</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_char_escaping" class="anchored"><a href="#val-is_char_escaping" class="anchor"></a><code><span><span class="keyword">val</span> is_char_escaping : <span>string <span class="arrow">&#45;&gt;</span></span> <span>escape_char:char <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Any char in an escaped string is either escaping, escaped, or literal. For example, for escaped string <code>&quot;0_a0__0&quot;</code> with <code>escape_char</code> as <code>'_'</code>, pos 1 and 4 are escaping, 2 and 5 are escaped, and the rest are literal.</p><p><code>is_char_escaping s ~escape_char pos</code> returns true if the char at <code>pos</code> is escaping, false otherwise.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_char_escaped" class="anchored"><a href="#val-is_char_escaped" class="anchor"></a><code><span><span class="keyword">val</span> is_char_escaped : <span>string <span class="arrow">&#45;&gt;</span></span> <span>escape_char:char <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_char_escaped s ~escape_char pos</code> returns true if the char at <code>pos</code> is escaped, false otherwise.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_char_literal" class="anchored"><a href="#val-is_char_literal" class="anchor"></a><code><span><span class="keyword">val</span> is_char_literal : <span>string <span class="arrow">&#45;&gt;</span></span> <span>escape_char:char <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_char_literal s ~escape_char pos</code> returns true if the char at <code>pos</code> is not escaped or escaping.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-index" class="anchored"><a href="#val-index" class="anchor"></a><code><span><span class="keyword">val</span> index : <span>string <span class="arrow">&#45;&gt;</span></span> <span>escape_char:char <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> <span>int option</span></span></code></div><div class="spec-doc"><p><code>index s ~escape_char char</code> finds the first literal (not escaped) instance of <code>char</code> in s starting from 0.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-index_exn" class="anchored"><a href="#val-index_exn" class="anchor"></a><code><span><span class="keyword">val</span> index_exn : <span>string <span class="arrow">&#45;&gt;</span></span> <span>escape_char:char <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-rindex" class="anchored"><a href="#val-rindex" class="anchor"></a><code><span><span class="keyword">val</span> rindex : <span>string <span class="arrow">&#45;&gt;</span></span> <span>escape_char:char <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> <span>int option</span></span></code></div><div class="spec-doc"><p><code>rindex s ~escape_char char</code> finds the first literal (not escaped) instance of <code>char</code> in <code>s</code> starting from the end of <code>s</code> and proceeding towards 0.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-rindex_exn" class="anchored"><a href="#val-rindex_exn" class="anchor"></a><code><span><span class="keyword">val</span> rindex_exn : <span>string <span class="arrow">&#45;&gt;</span></span> <span>escape_char:char <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-index_from" class="anchored"><a href="#val-index_from" class="anchor"></a><code><span><span class="keyword">val</span> index_from : <span>string <span class="arrow">&#45;&gt;</span></span> <span>escape_char:char <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> <span>int option</span></span></code></div><div class="spec-doc"><p><code>index_from s ~escape_char pos char</code> finds the first literal (not escaped) instance of <code>char</code> in <code>s</code> starting from <code>pos</code> and proceeding towards the end of <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-index_from_exn" class="anchored"><a href="#val-index_from_exn" class="anchor"></a><code><span><span class="keyword">val</span> index_from_exn : <span>string <span class="arrow">&#45;&gt;</span></span> <span>escape_char:char <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-rindex_from" class="anchored"><a href="#val-rindex_from" class="anchor"></a><code><span><span class="keyword">val</span> rindex_from : <span>string <span class="arrow">&#45;&gt;</span></span> <span>escape_char:char <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> <span>int option</span></span></code></div><div class="spec-doc"><p><code>rindex_from s ~escape_char pos char</code> finds the first literal (not escaped) instance of <code>char</code> in <code>s</code> starting from <code>pos</code> and towards 0.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-rindex_from_exn" class="anchored"><a href="#val-rindex_from_exn" class="anchor"></a><code><span><span class="keyword">val</span> rindex_from_exn : <span>string <span class="arrow">&#45;&gt;</span></span> <span>escape_char:char <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-split" class="anchored"><a href="#val-split" class="anchor"></a><code><span><span class="keyword">val</span> split : <span>string <span class="arrow">&#45;&gt;</span></span> <span>on:char <span class="arrow">&#45;&gt;</span></span> <span>escape_char:char <span class="arrow">&#45;&gt;</span></span> <span>string list</span></span></code></div><div class="spec-doc"><p><code>split s ~escape_char ~on</code> returns a list of substrings of <code>s</code> that are separated by literal versions of <code>on</code>. Consecutive <code>on</code> characters will cause multiple empty strings in the result. Splitting the empty string returns a list of the empty string, not the empty list.</p><p>E.g., <code>split ~escape_char:'_' ~on:',' &quot;foo,bar_,baz&quot; = [&quot;foo&quot;; &quot;bar_,baz&quot;]</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-split_on_chars" class="anchored"><a href="#val-split_on_chars" class="anchor"></a><code><span><span class="keyword">val</span> split_on_chars : <span>string <span class="arrow">&#45;&gt;</span></span> <span>on:<span>char list</span> <span class="arrow">&#45;&gt;</span></span> <span>escape_char:char <span class="arrow">&#45;&gt;</span></span> <span>string list</span></span></code></div><div class="spec-doc"><p><code>split_on_chars s ~on</code> returns a list of all substrings of <code>s</code> that are separated by one of the literal chars from <code>on</code>. <code>on</code> are not grouped. So a grouping of <code>on</code> in the source string will produce multiple empty string splits in the result.</p><p>E.g., <code>split_on_chars ~escape_char:'_' ~on:[',';'|'] &quot;foo_|bar,baz|0&quot; -&gt;
      [&quot;foo_|bar&quot;; &quot;baz&quot;; &quot;0&quot;]</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-lsplit2" class="anchored"><a href="#val-lsplit2" class="anchor"></a><code><span><span class="keyword">val</span> lsplit2 : <span>string <span class="arrow">&#45;&gt;</span></span> <span>on:char <span class="arrow">&#45;&gt;</span></span> <span>escape_char:char <span class="arrow">&#45;&gt;</span></span> <span><span>(string * string)</span> option</span></span></code></div><div class="spec-doc"><p><code>lsplit2 s ~on ~escape_char</code> splits s into a pair on the first literal instance of <code>on</code> (meaning the first unescaped instance) starting from the left.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-lsplit2_exn" class="anchored"><a href="#val-lsplit2_exn" class="anchor"></a><code><span><span class="keyword">val</span> lsplit2_exn : <span>string <span class="arrow">&#45;&gt;</span></span> <span>on:char <span class="arrow">&#45;&gt;</span></span> <span>escape_char:char <span class="arrow">&#45;&gt;</span></span> string * string</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-rsplit2" class="anchored"><a href="#val-rsplit2" class="anchor"></a><code><span><span class="keyword">val</span> rsplit2 : <span>string <span class="arrow">&#45;&gt;</span></span> <span>on:char <span class="arrow">&#45;&gt;</span></span> <span>escape_char:char <span class="arrow">&#45;&gt;</span></span> <span><span>(string * string)</span> option</span></span></code></div><div class="spec-doc"><p><code>rsplit2 s ~on ~escape_char</code> splits <code>s</code> into a pair on the first literal instance of <code>on</code> (meaning the first unescaped instance) starting from the right.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-rsplit2_exn" class="anchored"><a href="#val-rsplit2_exn" class="anchor"></a><code><span><span class="keyword">val</span> rsplit2_exn : <span>string <span class="arrow">&#45;&gt;</span></span> <span>on:char <span class="arrow">&#45;&gt;</span></span> <span>escape_char:char <span class="arrow">&#45;&gt;</span></span> string * string</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-lstrip_literal" class="anchored"><a href="#val-lstrip_literal" class="anchor"></a><code><span><span class="keyword">val</span> lstrip_literal : <span>?drop:<span>(<span>char <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>escape_char:char <span class="arrow">&#45;&gt;</span></span> <a href="../index.html#type-t">t</a></span></code></div><div class="spec-doc"><p>These are the same as <code>lstrip</code>, <code>rstrip</code>, and <code>strip</code> for generic strings, except that they only drop literal characters -- they do not drop characters that are escaping or escaped. This makes sense if you're trying to get rid of junk whitespace (for example), because escaped whitespace seems more likely to be deliberate and not junk.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-rstrip_literal" class="anchored"><a href="#val-rstrip_literal" class="anchor"></a><code><span><span class="keyword">val</span> rstrip_literal : <span>?drop:<span>(<span>char <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>escape_char:char <span class="arrow">&#45;&gt;</span></span> <a href="../index.html#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-strip_literal" class="anchored"><a href="#val-strip_literal" class="anchor"></a><code><span><span class="keyword">val</span> strip_literal : <span>?drop:<span>(<span>char <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>escape_char:char <span class="arrow">&#45;&gt;</span></span> <a href="../index.html#type-t">t</a></span></code></div></div></div></body></html>