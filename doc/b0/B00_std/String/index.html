<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>String (b0.B00_std.String)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">b0</a> &#x00BB; <a href="../index.html">B00_std</a> &#x00BB; String</nav><header class="odoc-preamble"><h1>Module <code><span>B00_std.String</span></code></h1><p>Strings.</p></header><nav class="odoc-toc"><ul><li><a href="#stdlib_string">Stdlib <code>String</code></a></li><li><a href="#strings_2">Strings</a></li><li><a href="#preds">Predicates</a></li><li><a href="#find">Finding substrings</a></li><li><a href="#subs">Extracting substrings</a></li><li><a href="#break">Breaking</a><ul><li><a href="#break_mag">Breaking with magnitudes</a></li><li><a href="#break_pred">Breaking with predicates</a></li><li><a href="#break_sep">Breaking with separators</a></li></ul></li><li><a href="#fmt">Formatting</a></li><li><a href="#unique">Uniqueness</a></li><li><a href="#suggesting">Suggesting</a></li><li><a href="#escunesc">(Un)escaping bytes</a></li><li><a href="#ascii">US-ASCII strings</a></li><li><a href="#version">Version strings</a></li><li><a href="#setmap">Sets and maps</a></li><li><a href="#var_subst">Variable substitution</a></li></ul></nav><div class="odoc-content"><h2 id="stdlib_string"><a href="#stdlib_string" class="anchor"></a>Stdlib <code>String</code></h2><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> <a href="../../../ocaml/Stdlib/String/index.html">String</a></span></code></summary><h2 id="strings"><a href="#strings" class="anchor"></a>Strings</h2><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span><span> = string</span></code></div><div class="spec-doc"><p>The type for strings.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-make" class="anchored"><a href="#val-make" class="anchor"></a><code><span><span class="keyword">val</span> make : <span>int <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>make n c</code> is a string of length <code>n</code> with each index holding the character <code>c</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if <code>n &lt; 0</code> or <code>n &gt; </code><code>Sys</code>.max_string_length.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-init" class="anchored"><a href="#val-init" class="anchor"></a><code><span><span class="keyword">val</span> init : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> char)</span> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>init n f</code> is a string of length <code>n</code> with index <code>i</code> holding the character <code>f i</code> (called in increasing index order).</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if <code>n &lt; 0</code> or <code>n &gt; </code><code>Sys</code>.max_string_length.</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.02.0</li></ul></div></div><div class="odoc-spec"><div class="spec value external" id="val-length" class="anchored"><a href="#val-length" class="anchor"></a><code><span><span class="keyword">val</span> length : <span>string <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>length s</code> is the length (number of bytes/characters) of <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec value external" id="val-get" class="anchored"><a href="#val-get" class="anchor"></a><code><span><span class="keyword">val</span> get : <span>string <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> char</span></code></div><div class="spec-doc"><p><code>get s i</code> is the character at index <code>i</code> in <code>s</code>. This is the same as writing <code>s.[i]</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if <code>i</code> not an index of <code>s</code>.</p></li></ul></div></div><h2 id="concat"><a href="#concat" class="anchor"></a>Concatenating</h2><p><b>Note.</b> The <code>Stdlib</code>.( ^ ) binary operator concatenates two strings.</p><div class="odoc-spec"><div class="spec value" id="val-concat" class="anchored"><a href="#val-concat" class="anchor"></a><code><span><span class="keyword">val</span> concat : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>string list</span> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>concat sep ss</code> concatenates the list of strings <code>ss</code>, inserting the separator string <code>sep</code> between each.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if the result is longer than <code>Sys</code>.max_string_length bytes.</p></li></ul></div></div><h2 id="predicates"><a href="#predicates" class="anchor"></a>Predicates and comparisons</h2><div class="odoc-spec"><div class="spec value" id="val-equal" class="anchored"><a href="#val-equal" class="anchor"></a><code><span><span class="keyword">val</span> equal : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>equal s0 s1</code> is <code>true</code> if and only if <code>s0</code> and <code>s1</code> are character-wise equal.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.03.0 (4.05.0 in StringLabels)</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-compare" class="anchored"><a href="#val-compare" class="anchor"></a><code><span><span class="keyword">val</span> compare : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>compare s0 s1</code> sorts <code>s0</code> and <code>s1</code> in lexicographical order. <code>compare</code> behaves like <a href="../../../ocaml/Stdlib/index.html#val-compare"><code>Stdlib.compare</code></a> on strings but may be more efficient.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-contains_from" class="anchored"><a href="#val-contains_from" class="anchor"></a><code><span><span class="keyword">val</span> contains_from : <span>string <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>contains_from s start c</code> is <code>true</code> if and only if <code>c</code> appears in <code>s</code> after position <code>start</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if <code>start</code> is not a valid position in <code>s</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-rcontains_from" class="anchored"><a href="#val-rcontains_from" class="anchor"></a><code><span><span class="keyword">val</span> rcontains_from : <span>string <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>rcontains_from s stop c</code> is <code>true</code> if and only if <code>c</code> appears in <code>s</code> before position <code>stop+1</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if <code>stop &lt; 0</code> or <code>stop+1</code> is not a valid position in <code>s</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-contains" class="anchored"><a href="#val-contains" class="anchor"></a><code><span><span class="keyword">val</span> contains : <span>string <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>contains s c</code> is <a href="#val-contains_from"><code>String.contains_from</code></a><code> s 0 c</code>.</p></div></div><h2 id="extract"><a href="#extract" class="anchor"></a>Extracting substrings</h2><div class="odoc-spec"><div class="spec value" id="val-sub" class="anchored"><a href="#val-sub" class="anchor"></a><code><span><span class="keyword">val</span> sub : <span>string <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>sub s pos len</code> is a string of length <code>len</code>, containing the substring of <code>s</code> that starts at position <code>pos</code> and has length <code>len</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if <code>pos</code> and <code>len</code> do not designate a valid substring of <code>s</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-split_on_char" class="anchored"><a href="#val-split_on_char" class="anchor"></a><code><span><span class="keyword">val</span> split_on_char : <span>char <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>string list</span></span></code></div><div class="spec-doc"><p><code>split_on_char sep s</code> is the list of all (possibly empty) substrings of <code>s</code> that are delimited by the character <code>sep</code>.</p><p>The function's result is specified by the following invariants:</p><ul><li>The list is not empty.</li><li>Concatenating its elements using <code>sep</code> as a separator returns a string equal to the input (<code>concat (make 1 sep)
      (split_on_char sep s) = s</code>).</li><li>No string in the result contains the <code>sep</code> character.</li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.04.0 (4.05.0 in StringLabels)</li></ul></div></div><h2 id="transforming"><a href="#transforming" class="anchor"></a>Transforming</h2><div class="odoc-spec"><div class="spec value" id="val-map" class="anchored"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span><span>(<span>char <span class="arrow">&#45;&gt;</span></span> char)</span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>map f s</code> is the string resulting from applying <code>f</code> to all the characters of <code>s</code> in increasing order.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.00.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-mapi" class="anchored"><a href="#val-mapi" class="anchor"></a><code><span><span class="keyword">val</span> mapi : <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> char)</span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>mapi f s</code> is like <a href="#val-map"><code>map</code></a> but the index of the character is also passed to <code>f</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.02.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-trim" class="anchored"><a href="#val-trim" class="anchor"></a><code><span><span class="keyword">val</span> trim : <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>trim s</code> is <code>s</code> without leading and trailing whitespace. Whitespace characters are: <code>' '</code>, <code>'\x0C'</code> (form feed), <code>'\n'</code>, <code>'\r'</code>, and <code>'\t'</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.00.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-escaped" class="anchored"><a href="#val-escaped" class="anchor"></a><code><span><span class="keyword">val</span> escaped : <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>escaped s</code> is <code>s</code> with special characters represented by escape sequences, following the lexical conventions of OCaml.</p><p>All characters outside the US-ASCII printable range [0x20;0x7E] are escaped, as well as backslash (0x2F) and double-quote (0x22).</p><p>The function <code>Scanf</code>.unescaped is a left inverse of <code>escaped</code>, i.e. <code>Scanf.unescaped (escaped s) = s</code> for any string <code>s</code> (unless <code>escaped s</code> fails).</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if the result is longer than <code>Sys</code>.max_string_length bytes.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-uppercase_ascii" class="anchored"><a href="#val-uppercase_ascii" class="anchor"></a><code><span><span class="keyword">val</span> uppercase_ascii : <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>uppercase_ascii s</code> is <code>s</code> with all lowercase letters translated to uppercase, using the US-ASCII character set.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.03.0 (4.05.0 in StringLabels)</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-lowercase_ascii" class="anchored"><a href="#val-lowercase_ascii" class="anchor"></a><code><span><span class="keyword">val</span> lowercase_ascii : <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>lowercase_ascii s</code> is <code>s</code> with all uppercase letters translated to lowercase, using the US-ASCII character set.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.03.0 (4.05.0 in StringLabels)</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-capitalize_ascii" class="anchored"><a href="#val-capitalize_ascii" class="anchor"></a><code><span><span class="keyword">val</span> capitalize_ascii : <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>capitalize_ascii s</code> is <code>s</code> with the first character set to uppercase, using the US-ASCII character set.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.03.0 (4.05.0 in StringLabels)</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-uncapitalize_ascii" class="anchored"><a href="#val-uncapitalize_ascii" class="anchor"></a><code><span><span class="keyword">val</span> uncapitalize_ascii : <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>uncapitalize_ascii s</code> is <code>s</code> with the first character set to lowercase, using the US-ASCII character set.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.03.0 (4.05.0 in StringLabels)</li></ul></div></div><h2 id="traversing"><a href="#traversing" class="anchor"></a>Traversing</h2><div class="odoc-spec"><div class="spec value" id="val-iter" class="anchored"><a href="#val-iter" class="anchor"></a><code><span><span class="keyword">val</span> iter : <span><span>(<span>char <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>iter f s</code> applies function <code>f</code> in turn to all the characters of <code>s</code>. It is equivalent to <code>f s.[0]; f s.[1]; ...; f s.[length s - 1]; ()</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-iteri" class="anchored"><a href="#val-iteri" class="anchor"></a><code><span><span class="keyword">val</span> iteri : <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>iteri</code> is like <a href="#val-iter"><code>iter</code></a>, but the function is also given the corresponding character index.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.00.0</li></ul></div></div><h2 id="searching"><a href="#searching" class="anchor"></a>Searching</h2><div class="odoc-spec"><div class="spec value" id="val-index_from" class="anchored"><a href="#val-index_from" class="anchor"></a><code><span><span class="keyword">val</span> index_from : <span>string <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>index_from s i c</code> is the index of the first occurrence of <code>c</code> in <code>s</code> after position <code>i</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Not_found</span> <p>if <code>c</code> does not occur in <code>s</code> after position <code>i</code>.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if <code>i</code> is not a valid position in <code>s</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-index_from_opt" class="anchored"><a href="#val-index_from_opt" class="anchor"></a><code><span><span class="keyword">val</span> index_from_opt : <span>string <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> <span>int option</span></span></code></div><div class="spec-doc"><p><code>index_from_opt s i c</code> is the index of the first occurrence of <code>c</code> in <code>s</code> after position <code>i</code> (if any).</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if <code>i</code> is not a valid position in <code>s</code>.</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.05</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-rindex_from" class="anchored"><a href="#val-rindex_from" class="anchor"></a><code><span><span class="keyword">val</span> rindex_from : <span>string <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>rindex_from s i c</code> is the index of the last occurrence of <code>c</code> in <code>s</code> before position <code>i+1</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Not_found</span> <p>if <code>c</code> does not occur in <code>s</code> before position <code>i+1</code>.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if <code>i+1</code> is not a valid position in <code>s</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-rindex_from_opt" class="anchored"><a href="#val-rindex_from_opt" class="anchor"></a><code><span><span class="keyword">val</span> rindex_from_opt : <span>string <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> <span>int option</span></span></code></div><div class="spec-doc"><p><code>rindex_from_opt s i c</code> is the index of the last occurrence of <code>c</code> in <code>s</code> before position <code>i+1</code> (if any).</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if <code>i+1</code> is not a valid position in <code>s</code>.</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.05</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-index" class="anchored"><a href="#val-index" class="anchor"></a><code><span><span class="keyword">val</span> index : <span>string <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>index s c</code> is <a href="#val-index_from"><code>String.index_from</code></a><code> s 0 c</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-index_opt" class="anchored"><a href="#val-index_opt" class="anchor"></a><code><span><span class="keyword">val</span> index_opt : <span>string <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> <span>int option</span></span></code></div><div class="spec-doc"><p><code>index_opt s c</code> is <a href="#val-index_from_opt"><code>String.index_from_opt</code></a><code> s 0 c</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.05</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-rindex" class="anchored"><a href="#val-rindex" class="anchor"></a><code><span><span class="keyword">val</span> rindex : <span>string <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>rindex s c</code> is <a href="#val-rindex_from"><code>String.rindex_from</code></a><code> s (length s - 1) c</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-rindex_opt" class="anchored"><a href="#val-rindex_opt" class="anchor"></a><code><span><span class="keyword">val</span> rindex_opt : <span>string <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> <span>int option</span></span></code></div><div class="spec-doc"><p><code>rindex_opt s c</code> is <a href="#val-rindex_from_opt"><code>String.rindex_from_opt</code></a><code> s (length s - 1) c</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.05</li></ul></div></div><h2 id="converting"><a href="#converting" class="anchor"></a>Converting</h2><div class="odoc-spec"><div class="spec value" id="val-to_seq" class="anchored"><a href="#val-to_seq" class="anchor"></a><code><span><span class="keyword">val</span> to_seq : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>char <a href="../../../ocaml/Stdlib/Seq/index.html#type-t">Seq.t</a></span></span></code></div><div class="spec-doc"><p><code>to_seq s</code> is a sequence made of the string's characters in increasing order. In <code>&quot;unsafe-string&quot;</code> mode, modifications of the string during iteration will be reflected in the iterator.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.07</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-to_seqi" class="anchored"><a href="#val-to_seqi" class="anchor"></a><code><span><span class="keyword">val</span> to_seqi : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(int * char)</span> <a href="../../../ocaml/Stdlib/Seq/index.html#type-t">Seq.t</a></span></span></code></div><div class="spec-doc"><p><code>to_seqi s</code> is like <a href="#val-to_seq"><code>to_seq</code></a> but also tuples the corresponding index.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.07</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-of_seq" class="anchored"><a href="#val-of_seq" class="anchor"></a><code><span><span class="keyword">val</span> of_seq : <span><span>char <a href="../../../ocaml/Stdlib/Seq/index.html#type-t">Seq.t</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_seq s</code> is a string made of the sequence's characters.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.07</li></ul></div></div><h2 id="deprecated"><a href="#deprecated" class="anchor"></a>Deprecated functions</h2><div class="odoc-spec"><div class="spec value external" id="val-create" class="anchored"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : <span>int <span class="arrow">&#45;&gt;</span></span> bytes</span></code></div><div class="spec-doc"><p><code>create n</code> returns a fresh byte sequence of length <code>n</code>. The sequence is uninitialized and contains arbitrary bytes.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if <code>n &lt; 0</code> or <code>n &gt; </code><code>Sys</code>.max_string_length.</p></li></ul><ul class="at-tags"><li class="deprecated"><span class="at-tag">deprecated</span> <p>This is a deprecated alias of <code>Bytes</code>.create/<code>BytesLabels</code>.create.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value external" id="val-set" class="anchored"><a href="#val-set" class="anchor"></a><code><span><span class="keyword">val</span> set : <span>bytes <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set s n c</code> modifies byte sequence <code>s</code> in place, replacing the byte at index <code>n</code> with <code>c</code>. You can also write <code>s.[n] &lt;- c</code> instead of <code>set s n c</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if <code>n</code> is not a valid index in <code>s</code>.</p></li></ul><ul class="at-tags"><li class="deprecated"><span class="at-tag">deprecated</span> <p>This is a deprecated alias of <code>Bytes</code>.set/<code>BytesLabels</code>.set.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-blit" class="anchored"><a href="#val-blit" class="anchor"></a><code><span><span class="keyword">val</span> blit : <span>string <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>bytes <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>blit src src_pos dst dst_pos len</code> copies <code>len</code> bytes from the string <code>src</code>, starting at index <code>src_pos</code>, to byte sequence <code>dst</code>, starting at character number <code>dst_pos</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if <code>src_pos</code> and <code>len</code> do not designate a valid range of <code>src</code>, or if <code>dst_pos</code> and <code>len</code> do not designate a valid range of <code>dst</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-copy" class="anchored"><a href="#val-copy" class="anchor"></a><code><span><span class="keyword">val</span> copy : <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Return a copy of the given string.</p><ul class="at-tags"><li class="deprecated"><span class="at-tag">deprecated</span> <p>Because strings are immutable, it doesn't make much sense to make identical copies of them.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-fill" class="anchored"><a href="#val-fill" class="anchor"></a><code><span><span class="keyword">val</span> fill : <span>bytes <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>fill s pos len c</code> modifies byte sequence <code>s</code> in place, replacing <code>len</code> bytes by <code>c</code>, starting at <code>pos</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if <code>pos</code> and <code>len</code> do not designate a valid substring of <code>s</code>.</p></li></ul><ul class="at-tags"><li class="deprecated"><span class="at-tag">deprecated</span> <p>This is a deprecated alias of <code>Bytes</code>.fill/<code>BytesLabels</code>.fill.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-uppercase" class="anchored"><a href="#val-uppercase" class="anchor"></a><code><span><span class="keyword">val</span> uppercase : <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Return a copy of the argument, with all lowercase letters translated to uppercase, including accented letters of the ISO Latin-1 (8859-1) character set.</p><ul class="at-tags"><li class="deprecated"><span class="at-tag">deprecated</span> <p>Functions operating on Latin-1 character set are deprecated.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-lowercase" class="anchored"><a href="#val-lowercase" class="anchor"></a><code><span><span class="keyword">val</span> lowercase : <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Return a copy of the argument, with all uppercase letters translated to lowercase, including accented letters of the ISO Latin-1 (8859-1) character set.</p><ul class="at-tags"><li class="deprecated"><span class="at-tag">deprecated</span> <p>Functions operating on Latin-1 character set are deprecated.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-capitalize" class="anchored"><a href="#val-capitalize" class="anchor"></a><code><span><span class="keyword">val</span> capitalize : <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Return a copy of the argument, with the first character set to uppercase, using the ISO Latin-1 (8859-1) character set..</p><ul class="at-tags"><li class="deprecated"><span class="at-tag">deprecated</span> <p>Functions operating on Latin-1 character set are deprecated.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-uncapitalize" class="anchored"><a href="#val-uncapitalize" class="anchor"></a><code><span><span class="keyword">val</span> uncapitalize : <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Return a copy of the argument, with the first character set to lowercase, using the ISO Latin-1 (8859-1) character set.</p><ul class="at-tags"><li class="deprecated"><span class="at-tag">deprecated</span> <p>Functions operating on Latin-1 character set are deprecated.</p></li></ul></div></div></details></div><h2 id="strings_2"><a href="#strings_2" class="anchor"></a>Strings</h2><div class="odoc-spec"><div class="spec value" id="val-empty" class="anchored"><a href="#val-empty" class="anchor"></a><code><span><span class="keyword">val</span> empty : string</span></code></div><div class="spec-doc"><p><code>empty</code> is <code>&quot;&quot;</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-head" class="anchored"><a href="#val-head" class="anchor"></a><code><span><span class="keyword">val</span> head : <span>string <span class="arrow">&#45;&gt;</span></span> <span>char option</span></span></code></div><div class="spec-doc"><p><code>head s</code> if <code>Some s.[0]</code> if <code>s &lt;&gt; &quot;&quot;</code> and <code>None</code> otherwise.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_char" class="anchored"><a href="#val-of_char" class="anchor"></a><code><span><span class="keyword">val</span> of_char : <span>char <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>of_char c</code> is <code>c</code> as a string.</p></div></div><h2 id="preds"><a href="#preds" class="anchor"></a>Predicates</h2><div class="odoc-spec"><div class="spec value" id="val-is_empty" class="anchored"><a href="#val-is_empty" class="anchor"></a><code><span><span class="keyword">val</span> is_empty : <span>string <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_empty s</code> is <code>equal empty s</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-starts_with" class="anchored"><a href="#val-starts_with" class="anchor"></a><code><span><span class="keyword">val</span> starts_with : <span>prefix:string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>starts_with ~prefix s</code> is <code>true</code> iff <code>sub.[i] = s.[i]</code> for all indices <code>i</code> of <code>prefix</code>.</p><p><b>Note.</b> Available in 4.12.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-ends_with" class="anchored"><a href="#val-ends_with" class="anchor"></a><code><span><span class="keyword">val</span> ends_with : <span>suffix:string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>eds_with ~suffix s</code> is true iff <code>sub.[i] = s.[m - i]</code> for all indices <code>i</code> of <code>sufix</code> and with <code>m = String.length s - 1</code>.</p><p><b>Note.</b> Available in 4.12.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-includes" class="anchored"><a href="#val-includes" class="anchor"></a><code><span><span class="keyword">val</span> includes : <span>affix:string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>includes ~affix s</code> is <code>true</code> iff there exists an index <code>j</code> such that for all indices <code>i</code> of <code>affix</code>, <code>sub.[i] = s.[j+ 1]</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-for_all" class="anchored"><a href="#val-for_all" class="anchor"></a><code><span><span class="keyword">val</span> for_all : <span><span>(<span>char <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>for_all p s</code> is <code>true</code> iff for all indices <code>i</code> of <code>s</code>, <code>p s.[i]
      = true</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-exists" class="anchored"><a href="#val-exists" class="anchor"></a><code><span><span class="keyword">val</span> exists : <span><span>(<span>char <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>exists p s</code> is <code>true</code> iff there exists an index <code>i</code> of <code>s</code> with <code>p s.[i] = true</code>.</p></div></div><h2 id="find"><a href="#find" class="anchor"></a>Finding substrings</h2><div class="odoc-spec"><div class="spec value" id="val-find_sub" class="anchored"><a href="#val-find_sub" class="anchor"></a><code><span><span class="keyword">val</span> find_sub : <span>?start:int <span class="arrow">&#45;&gt;</span></span> <span>sub:string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>int option</span></span></code></div><div class="spec-doc"><p><code>find_sub ~start ~sub s</code> is the start index (if any) of the first occurence of <code>sub</code> in <code>s</code> at or after <code>start</code>.</p></div></div><h2 id="subs"><a href="#subs" class="anchor"></a>Extracting substrings</h2><div class="odoc-spec"><div class="spec value" id="val-subrange" class="anchored"><a href="#val-subrange" class="anchor"></a><code><span><span class="keyword">val</span> subrange : <span>?first:int <span class="arrow">&#45;&gt;</span></span> <span>?last:int <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>subrange ~first ~last s</code> are the consecutive bytes of <code>s</code> whose indices exist in the range [<code>first</code>;<code>last</code>].</p><p><code>first</code> defaults to <code>0</code> and last to <code>String.length s - 1</code>.</p><p>Note that both <code>first</code> and <code>last</code> can be any integer. If <code>first
      &gt; last</code> the interval is empty and the empty string is returned.</p></div></div><h2 id="break"><a href="#break" class="anchor"></a>Breaking</h2><h3 id="break_mag"><a href="#break_mag" class="anchor"></a>Breaking with magnitudes</h3><div class="odoc-spec"><div class="spec value" id="val-take_left" class="anchored"><a href="#val-take_left" class="anchor"></a><code><span><span class="keyword">val</span> take_left : <span>int <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>take_left n s</code> are the first <code>n</code> bytes of <code>s</code>. This is <code>s</code> if <code>n &gt;= length s</code> and <code>&quot;&quot;</code> if <code>n &lt;= 0</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-take_right" class="anchored"><a href="#val-take_right" class="anchor"></a><code><span><span class="keyword">val</span> take_right : <span>int <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>take_right n s</code> are the last <code>n</code> bytes of <code>s</code>. This is <code>s</code> if <code>n &gt;= length s</code> and <code>&quot;&quot;</code> if <code>n &lt;= 0</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-drop_left" class="anchored"><a href="#val-drop_left" class="anchor"></a><code><span><span class="keyword">val</span> drop_left : <span>int <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>drop_left n s</code> is <code>s</code> without the first <code>n</code> bytes of <code>s</code>. This is <code>&quot;&quot;</code> if <code>n &gt;= length s</code> and <code>s</code> if <code>n &lt;= 0</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-drop_right" class="anchored"><a href="#val-drop_right" class="anchor"></a><code><span><span class="keyword">val</span> drop_right : <span>int <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>drop_right n s</code> is <code>s</code> without the last <code>n</code> bytes of <code>s</code>. This is <code>&quot;&quot;</code> if <code>n &gt;= length s</code> and <code>s</code> if <code>n &lt;= 0</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-break_left" class="anchored"><a href="#val-break_left" class="anchor"></a><code><span><span class="keyword">val</span> break_left : <span>int <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string * string</span></code></div><div class="spec-doc"><p><code>break_left n v</code> is <code>(take_left n v, drop_left n v)</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-break_right" class="anchored"><a href="#val-break_right" class="anchor"></a><code><span><span class="keyword">val</span> break_right : <span>int <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string * string</span></code></div><div class="spec-doc"><p><code>break_right n v</code> is <code>(drop_left n v, take_right n v)</code>.</p></div></div><h3 id="break_pred"><a href="#break_pred" class="anchor"></a>Breaking with predicates</h3><div class="odoc-spec"><div class="spec value" id="val-keep_left" class="anchored"><a href="#val-keep_left" class="anchor"></a><code><span><span class="keyword">val</span> keep_left : <span><span>(<span>char <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>keep_left sat s</code> are the first consecutive <code>sat</code> statisfying bytes of <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-keep_right" class="anchored"><a href="#val-keep_right" class="anchor"></a><code><span><span class="keyword">val</span> keep_right : <span><span>(<span>char <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>keep_right sat s</code> are the last consecutive <code>sat</code> satisfying bytes of <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-lose_left" class="anchored"><a href="#val-lose_left" class="anchor"></a><code><span><span class="keyword">val</span> lose_left : <span><span>(<span>char <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>lose_left sat s</code> is <code>s</code> without the first consecutive <code>sat</code> satisfying bytes of <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-lose_right" class="anchored"><a href="#val-lose_right" class="anchor"></a><code><span><span class="keyword">val</span> lose_right : <span><span>(<span>char <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>lose_right sat s</code> is <code>s</code> without the last consecutive <code>sat</code> satisfying bytes of <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-span_left" class="anchored"><a href="#val-span_left" class="anchor"></a><code><span><span class="keyword">val</span> span_left : <span><span>(<span>char <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string * string</span></code></div><div class="spec-doc"><p><code>span_left sat s</code> is <code>(keep_left sat s, lose_left sat s)</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-span_right" class="anchored"><a href="#val-span_right" class="anchor"></a><code><span><span class="keyword">val</span> span_right : <span><span>(<span>char <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string * string</span></code></div><div class="spec-doc"><p><code>span_right sat s</code> is <code>(lose_right sat s, keep_right sat s)</code>.</p></div></div><h3 id="break_sep"><a href="#break_sep" class="anchor"></a>Breaking with separators</h3><div class="odoc-spec"><div class="spec value" id="val-cut_left" class="anchored"><a href="#val-cut_left" class="anchor"></a><code><span><span class="keyword">val</span> cut_left : <span>sep:string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>(string * string)</span> option</span></span></code></div><div class="spec-doc"><p><code>cut ~sep s</code> is either the pair <code>Some (l,r)</code> of the two (possibly empty) substrings of <code>s</code> that are delimited by the first match of the separator character <code>sep</code> or <code>None</code> if <code>sep</code> can't be matched in <code>s</code>. Matching starts from the left of <code>s</code>.</p><p>The invariant <code>l ^ sep ^ r = s</code> holds.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if <code>sep</code> is the empty string.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-cut_right" class="anchored"><a href="#val-cut_right" class="anchor"></a><code><span><span class="keyword">val</span> cut_right : <span>sep:string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>(string * string)</span> option</span></span></code></div><div class="spec-doc"><p><code>cut_right ~sep s</code> is like <a href="#val-cut_left"><code>cut_left</code></a> but matching starts on the right of <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-cuts_left" class="anchored"><a href="#val-cuts_left" class="anchor"></a><code><span><span class="keyword">val</span> cuts_left : <span>?drop_empty:bool <span class="arrow">&#45;&gt;</span></span> <span>sep:string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>string list</span></span></code></div><div class="spec-doc"><p><code>cuts_left sep s</code> is the list of all substrings of <code>s</code> that are delimited by matches of the non empty separator string <code>sep</code>. Empty substrings are omitted in the list if <code>drop_empty</code> is <code>true</code> (defaults to <code>false</code>).</p><p>Matching separators in <code>s</code> starts from the left of <code>s</code> (<code>rev</code> is <code>false</code>, default) or the end (<code>rev</code> is <code>true</code>). Once one is found, the separator is skipped and matching starts again, that is separator matches can't overlap. If there is no separator match in <code>s</code>, the list <code>[s]</code> is returned.</p><p>The following invariants hold:</p><ul><li><code>concat ~sep (cuts ~drop_empty:false ~sep s) = s</code></li><li><code>cuts ~drop_empty:false ~sep s &lt;&gt; []</code></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if <code>sep</code> is the empty string.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-cuts_right" class="anchored"><a href="#val-cuts_right" class="anchor"></a><code><span><span class="keyword">val</span> cuts_right : <span>?drop_empty:bool <span class="arrow">&#45;&gt;</span></span> <span>sep:string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>string list</span></span></code></div><div class="spec-doc"><p><code>cuts_right sep s</code> is like <a href="#val-cuts_left"><code>cuts_left</code></a> but matching starts on the right of <code>s</code>.</p></div></div><h2 id="fmt"><a href="#fmt" class="anchor"></a>Formatting</h2><div class="odoc-spec"><div class="spec value" id="val-pp" class="anchored"><a href="#val-pp" class="anchor"></a><code><span><span class="keyword">val</span> pp : <span>string <a href="../Fmt/index.html#type-t">Fmt.t</a></span></span></code></div><div class="spec-doc"><p><code>pp ppf s</code> prints <code>s</code>'s bytes on <code>ppf</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_dump" class="anchored"><a href="#val-pp_dump" class="anchor"></a><code><span><span class="keyword">val</span> pp_dump : <span>string <a href="../Fmt/index.html#type-t">Fmt.t</a></span></span></code></div><div class="spec-doc"><p><code>pp_dump ppf s</code> prints <code>s</code> as a syntactically valid OCaml string on <code>ppf</code>.</p></div></div><h2 id="unique"><a href="#unique" class="anchor"></a>Uniqueness</h2><div class="odoc-spec"><div class="spec value" id="val-uniquify" class="anchored"><a href="#val-uniquify" class="anchor"></a><code><span><span class="keyword">val</span> uniquify : <span><span>string list</span> <span class="arrow">&#45;&gt;</span></span> <span>string list</span></span></code></div><div class="spec-doc"><p><code>uniquify ss</code> is <code>ss</code> without duplicates, the list order is preserved.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unique" class="anchored"><a href="#val-unique" class="anchor"></a><code><span><span class="keyword">val</span> unique : <span>exists:<span>(<span>string <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>(string,Â string)</span> <a href="../../../ocaml/Stdlib/index.html#type-result">result</a></span></span></code></div><div class="spec-doc"><p><code>unique ~exist n</code> is <code>n</code> if <code>exists n</code> is <code>false</code> or <code>r = strf
      &quot;%s~%d&quot; n d</code> with <code>d</code> the smallest integer in [<code>1</code>;<code>1e9</code>] such that <code>exists r</code> is <code>false</code> or an error if there is no such string.</p></div></div><h2 id="suggesting"><a href="#suggesting" class="anchor"></a>Suggesting</h2><div class="odoc-spec"><div class="spec value" id="val-edit_distance" class="anchored"><a href="#val-edit_distance" class="anchor"></a><code><span><span class="keyword">val</span> edit_distance : <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>edit_distance s0 s1</code> is the number of single character edits (insertion, deletion, substitution) that are needed to change <code>s0</code> into <code>s1</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-suggest" class="anchored"><a href="#val-suggest" class="anchor"></a><code><span><span class="keyword">val</span> suggest : <span>?dist:int <span class="arrow">&#45;&gt;</span></span> <span><span>string list</span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>string list</span></span></code></div><div class="spec-doc"><p><code>suggest ~dist candidates s</code> are the elements of <code>candidates</code> whose <a href="#val-edit_distance">edit distance</a> is the smallest to <code>s</code> and at most at a distance of <code>dist</code> of <code>s</code> (defaults to <code>2</code>). If multiple results are returned the order of <code>candidates</code> is preserved.</p></div></div><h2 id="escunesc"><a href="#escunesc" class="anchor"></a>(Un)escaping bytes</h2><p>The following functions can only (un)escape a single byte. See also <a href="Ascii/index.html#escunesc">these functions</a> to convert a string to printable US-ASCII characters.</p><div class="odoc-spec"><div class="spec value" id="val-byte_escaper" class="anchored"><a href="#val-byte_escaper" class="anchor"></a><code><span><span class="keyword">val</span> byte_escaper : <span><span>(<span>char <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>bytes <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>byte_escaper char_len set_char</code> is a byte escaper such that:</p><ul><li><code>char_len c</code> is the length of the unescaped byte <code>c</code> in the escaped form. If <code>1</code> is returned then <code>c</code> is assumed to be unchanged use <a href="#val-byte_replacer"><code>byte_replacer</code></a> if that does not hold</li><li><code>set_char b i c</code> sets an unescaped byte <code>c</code> to its escaped form at index <code>i</code> in <code>b</code> and returns the next writable index. <code>set_char</code> is called regardless if <code>c</code> needs to be escaped or not in the latter case <b>you must</b> write <code>c</code> (use <a href="#val-byte_replacer"><code>byte_replacer</code></a> if that is not the case). No bounds check need to be performed on <code>i</code> or the returned value.</li></ul><p>For any <code>b</code>, <code>c</code> and <code>i</code> the invariant <code>i + char_len c = set_char b i c</code> must hold.</p><p>Here's a small example that escapes <code>'&quot;'</code> by prefixing them by backslashes. double quotes from strings:</p><pre><code>let escape_dquotes s =
  let char_len = function '&quot;' -&gt; 2 | _ -&gt; 1 in
  let set_char b i = function
  | '&quot;' -&gt; Bytes.set b i '\\'; Bytes.set b (i+1) '&quot;'; i + 2
  | c -&gt; Bytes.set b i c; i + 1
  in
  String.byte_escaper char_len set_char s</code></pre></div></div><div class="odoc-spec"><div class="spec value" id="val-byte_replacer" class="anchored"><a href="#val-byte_replacer" class="anchor"></a><code><span><span class="keyword">val</span> byte_replacer : <span><span>(<span>char <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>bytes <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>byte_replacer char_len set_char</code> is like <a href="#val-byte_escaper"><code>byte_escaper</code></a> but a byte can be substituted by another one by <code>set_char</code>.</p></div></div><div class="odoc-spec"><div class="spec exception" id="exception-Illegal_escape" class="anchored"><a href="#exception-Illegal_escape" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Illegal_escape</span> <span class="keyword">of</span> int</span></code></div><div class="spec-doc"><p>See <code>unescaper</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-byte_unescaper" class="anchored"><a href="#val-byte_unescaper" class="anchor"></a><code><span><span class="keyword">val</span> byte_unescaper : <span><span>(<span>string <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>bytes <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>(string,Â int)</span> <a href="../../../ocaml/Stdlib/index.html#type-result">result</a></span></span></code></div><div class="spec-doc"><p><code>byte_unescaper char_len_at set_char</code> is a byte unescaper such that:</p><ul><li><code>char_len_at s i</code> is the length of an escaped byte at index <code>i</code> of <code>s</code>. If <code>1</code> is returned then the byte is assumed to be unchanged by the unescape, use <code>byte_unreplace</code> if that does not hold.</li><li><code>set_char b k s i</code> sets at index <code>k</code> in <code>b</code> the unescaped byte read at index <code>i</code> in <code>s</code> and returns the next readable index in <code>s</code>. <code>set_char</code> is called regardless of wheter the byte at <code>i</code> must be unescaped or not in the latter case <b>you must</b> write s.<code>i</code> only (use <a href="#val-byte_unreplacer"><code>byte_unreplacer</code></a> if that is not the case). No bounds check need to be performed on <code>k</code>, <code>i</code> or the returned value.</li></ul><p>For any <code>b</code>, <code>s</code>, <code>k</code> and <code>i</code> the invariant <code>i + char_len_at s i
      = set_char b k s i</code> must hold.</p><p>Both <code>char_len_at</code> and <code>set_char</code> may raise <code>Illegal_escape i</code> if the given index <code>i</code> has an illegal or truncated escape. The unescaper turns this exception into <code>Error i</code> if that happens.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-byte_unreplacer" class="anchored"><a href="#val-byte_unreplacer" class="anchor"></a><code><span><span class="keyword">val</span> byte_unreplacer : <span><span>(<span>string <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>bytes <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>(string,Â int)</span> <a href="../../../ocaml/Stdlib/index.html#type-result">result</a></span></span></code></div><div class="spec-doc"><p><code>byte_unreplacer char_len_at set_char</code> is like <code>byte_unscaper</code> except <code>set_char</code> can set a different byte whenever <code>char_len_at</code> returns <code>1</code>.</p></div></div><h2 id="ascii"><a href="#ascii" class="anchor"></a>US-ASCII strings</h2><div class="odoc-spec"><div class="spec module" id="module-Ascii" class="anchored"><a href="#module-Ascii" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Ascii/index.html">Ascii</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>US-ASCII string support.</p></div></div><h2 id="version"><a href="#version" class="anchor"></a>Version strings</h2><div class="odoc-spec"><div class="spec value" id="val-to_version" class="anchored"><a href="#val-to_version" class="anchor"></a><code><span><span class="keyword">val</span> to_version : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>(int * int * int * <span>string option</span>)</span> option</span></span></code></div><div class="spec-doc"><p><code>to_version</code> parses version strings of the form:</p><pre><code>&quot;[v|V]major.minor[.patchlevel][(+|~)additional-info]&quot;</code></pre><p>into <code>(major, minor, patch, additional_info)</code> tuples. If no <code>patchlevel</code> is found <code>0</code> is used.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-drop_initial_v" class="anchored"><a href="#val-drop_initial_v" class="anchor"></a><code><span><span class="keyword">val</span> drop_initial_v : <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>drop_initial_v s</code> drops a leading <code>'v'</code> or <code>'V'</code> from <code>s</code>.</p></div></div><h2 id="setmap"><a href="#setmap" class="anchor"></a>Sets and maps</h2><div class="odoc-spec"><div class="spec module" id="module-Set" class="anchored"><a href="#module-Set" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Set/index.html">Set</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>String sets.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Map" class="anchored"><a href="#module-Map" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Map/index.html">Map</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>String maps.</p></div></div><h2 id="var_subst"><a href="#var_subst" class="anchor"></a>Variable substitution</h2><div class="odoc-spec"><div class="spec value" id="val-subst_pct_vars" class="anchored"><a href="#val-subst_pct_vars" class="anchor"></a><code><span><span class="keyword">val</span> subst_pct_vars : <span>?buf:<a href="../../../ocaml/Stdlib/Buffer/index.html#type-t">Buffer.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>string <a href="Map/index.html#type-t">Map.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>string option</span></span></code></div><div class="spec-doc"><p><code>subst_pct_vars ~buf vars s</code> substitutes in <code>s</code> strings of the form <code>%%VAR%%</code> by the value of <code>&quot;VAR&quot;</code> in <code>vars</code> (if any). <code>None</code> is returned if no substitution was performed.</p></div></div></div></body></html>