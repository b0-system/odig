<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Async_kernel__Deferred (async_kernel.Async_kernel__Deferred)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">async_kernel</a> &#x00BB; Async_kernel__Deferred</nav><h1>Module <code>Async_kernel__Deferred</code></h1><p>A value that will become determined asynchronously.</p><p>A deferred can be &quot;undetermined&quot; or &quot;determined&quot;. A deferred that is undetermined may at some point become determined with value v, and will henceforth always be determined with value v.</p><nav class="toc"><ul><li><a href="#deferred-collections">Deferred collections</a></li><li><a href="#error-carrying-deferreds">Error-carrying deferreds</a></li></ul></nav></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> +'a t</code><code> = <span class="type-var">'a</span> <a href="../Async_kernel__/Deferred1/index.html#type-t">Async_kernel__.Deferred1.t</a></code></dt></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></span></summary><dl><dt class="spec value" id="val-sexp_of_t"><a href="#val-sexp_of_t" class="anchor"></a><code><span class="keyword">val</span> sexp_of_t : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a></code></dt></dl></details></div></div></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../../base/Base/Invariant/index.html#module-type-S1">Core_kernel.Invariant.S1</a> <span class="keyword">with</span> <span class="keyword">type</span> 'a <a href="../../base/Base/Invariant/module-type-S1/index.html#type-t">t</a> := <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> 'a t</code></dt></dl><dl><dt class="spec value" id="val-invariant"><a href="#val-invariant" class="anchor"></a><code><span class="keyword">val</span> invariant : <span class="type-var">'a</span> <a href="../../base/Base__/Invariant_intf/index.html#type-inv">Base__.Invariant_intf.inv</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="../../base/Base__/Invariant_intf/index.html#type-inv">Base__.Invariant_intf.inv</a></code></dt></dl></details></div></div></div><aside><p><code>sexp_of_t t f</code> returns a sexp of the deferred's value, if it is determined, or an informative string otherwise.</p><p>This is just for display purposes. There is no <code>t_of_sexp</code>.</p></aside><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : (<span class="type-var">'a</span> <a href="../Async_kernel/Ivar/index.html#type-t">Async_kernel.Ivar.t</a> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>create f</code> calls <code>f i</code>, where <code>i</code> is an empty ivar. <code>create</code> returns a deferred that becomes determined when <code>f</code> fills <code>i</code>.</p></dd></dl><dl><dt class="spec value" id="val-upon"><a href="#val-upon" class="anchor"></a><code><span class="keyword">val</span> upon : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit</code></dt><dd><p><code>upon t f</code> will run <code>f v</code> at some point after <code>t</code> becomes determined with value <code>v</code>.</p></dd></dl><dl><dt class="spec value" id="val-peek"><a href="#val-peek" class="anchor"></a><code><span class="keyword">val</span> peek : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt><dd><p><code>peek t</code> returns <code>Some v</code> iff <code>t</code> is determined with value <code>v</code>.</p></dd></dl><dl><dt class="spec value" id="val-value_exn"><a href="#val-value_exn" class="anchor"></a><code><span class="keyword">val</span> value_exn : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>value_exn t</code> returns <code>v</code> if <code>t</code> is determined with value <code>v</code>, and raises otherwise.</p></dd></dl><dl><dt class="spec value" id="val-is_determined"><a href="#val-is_determined" class="anchor"></a><code><span class="keyword">val</span> is_determined : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_determined t</code> returns <code>true</code> iff <code>t</code> is determined.</p></dd></dl><div><div class="spec include"><div class="doc"><p>Deferreds form a monad.</p><p><code>let%bind v = t in f v</code> returns a deferred <code>t'</code> that waits until <code>t</code> is determined with value <code>v</code>, at which point it waits for <code>f v</code> to become determined with value <code>v'</code>, to which <code>t'</code> will become determined.</p><p><code>return v</code> returns a deferred that is immediately determined with value v.</p><p>Note that:</p><pre><code class="ml">upon t f </code></pre><p>is more efficient than:</p><pre><code class="ml">ignore (let%bind a = t in f a; return ()) </code></pre><p>because <code>upon</code>, unlike <code>let%bind</code>, does not create a deferred to hold the result.</p><p>For example, one can write a loop that has good constant factors with:</p><pre><code class="ml">let rec loop () =
  upon t (fun a -&gt; ... loop () ... ) </code></pre><p>although often <code>forever</code> or <code>repeat_until_finished</code> is more clear.</p><p>The same loop written with <code>let%bind</code> would allocate deferreds that would be immediately garbage collected. (In the past, this loop would have also used linear space in recursion depth!)</p><p>In general, for deferreds that are allocated by <code>let%bind</code> to be garbage collected quickly, it is sufficient that the allocating bind be executed in tail-call position of the right-hand side of an outer bind.</p><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../../core_kernel/Core_kernel/index.html#module-type-Monad">Core_kernel.Monad</a> <span class="keyword">with</span> <span class="keyword">type</span> 'a <a href="../../core_kernel/Core_kernel/module-type-Monad/index.html#type-t">t</a> := <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> 'a t</code></dt></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../../base/Base__/Monad_intf/index.html#module-type-S_without_syntax">Base__.Monad_intf.S_without_syntax</a> <span class="keyword">with</span> <span class="keyword">type</span> 'a <a href="../../base/Base__/Monad_intf/module-type-S_without_syntax/index.html#type-t">t</a> := <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> 'a t</code></dt></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../../base/Base__/Monad_intf/index.html#module-type-Infix">Base__.Monad_intf.Infix</a> <span class="keyword">with</span> <span class="keyword">type</span> 'a <a href="../../base/Base__/Monad_intf/module-type-Infix/index.html#type-t">t</a> := <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> 'a t</code></dt></dl><dl><dt class="spec value" id="val-(&gt;&gt;=)"><a href="#val-(&gt;&gt;=)" class="anchor"></a><code><span class="keyword">val</span> (&gt;&gt;=) : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>t &gt;&gt;= f</code> returns a computation that sequences the computations represented by two monad elements. The resulting computation first does <code>t</code> to yield a value <code>v</code>, and then runs the computation returned by <code>f v</code>.</p></dd></dl><dl><dt class="spec value" id="val-(&gt;&gt;|)"><a href="#val-(&gt;&gt;|)" class="anchor"></a><code><span class="keyword">val</span> (&gt;&gt;|) : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>t &gt;&gt;| f</code> is <code>t &gt;&gt;= (fun a -&gt; return (f a))</code>.</p></dd></dl></details></div></div></div><div class="spec module" id="module-Monad_infix"><a href="#module-Monad_infix" class="anchor"></a><code><span class="keyword">module</span> <a href="Monad_infix/index.html">Monad_infix</a> : <a href="../../base/Base__/Monad_intf/index.html#module-type-Infix">Base__.Monad_intf.Infix</a> <span class="keyword">with</span> <span class="keyword">type</span> 'a <a href="../../base/Base__/Monad_intf/module-type-Infix/index.html#type-t">t</a> := <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></div><dl><dt class="spec value" id="val-bind"><a href="#val-bind" class="anchor"></a><code><span class="keyword">val</span> bind : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>bind t ~f</code> = <code>t &gt;&gt;= f</code></p></dd></dl><dl><dt class="spec value" id="val-return"><a href="#val-return" class="anchor"></a><code><span class="keyword">val</span> return : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>return v</code> returns the (trivial) computation that returns v.</p></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>map t ~f</code> is t &gt;&gt;| f.</p></dd></dl><dl><dt class="spec value" id="val-join"><a href="#val-join" class="anchor"></a><code><span class="keyword">val</span> join : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>join t</code> is <code>t &gt;&gt;= (fun t' -&gt; t')</code>.</p></dd></dl><dl><dt class="spec value" id="val-ignore_m"><a href="#val-ignore_m" class="anchor"></a><code><span class="keyword">val</span> ignore_m : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit <a href="index.html#type-t">t</a></code></dt><dd><p><code>ignore_m t</code> is <code>map t ~f:(fun _ -&gt; ())</code>. <code>ignore_m</code> used to be called <code>ignore</code>, but we decided that was a bad name, because it shadowed the widely used <code>Pervasives.ignore</code>. Some monads still do <code>let ignore = ignore_m</code> for historical reasons.</p></dd></dl><dl><dt class="spec value" id="val-all"><a href="#val-all" class="anchor"></a><code><span class="keyword">val</span> all : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-all_unit"><a href="#val-all_unit" class="anchor"></a><code><span class="keyword">val</span> all_unit : unit <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> unit <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-all_ignore"><a href="#val-all_ignore" class="anchor"></a><code><span class="keyword">val</span> all_ignore : unit <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> unit <a href="index.html#type-t">t</a></code></dt></dl></details></div></div></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../../base/Base__/Monad_intf/index.html#module-type-Syntax">Base__.Monad_intf.Syntax</a> <span class="keyword">with</span> <span class="keyword">type</span> 'a <a href="../../base/Base__/Monad_intf/module-type-Syntax/index.html#type-t">t</a> := <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> 'a t</code></dt></dl><div class="spec module" id="module-Let_syntax"><a href="#module-Let_syntax" class="anchor"></a><code><span class="keyword">module</span> <a href="Let_syntax/index.html">Let_syntax</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></details></div></div></div></details></div></div></div><div class="spec module" id="module-Infix"><a href="#module-Infix" class="anchor"></a><code><span class="keyword">module</span> <a href="Infix/index.html">Infix</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-unit"><a href="#val-unit" class="anchor"></a><code><span class="keyword">val</span> unit : unit <a href="index.html#type-t">t</a></code></dt><dd><p><code>unit</code> is a deferred that is always determined with value <code>()</code></p></dd></dl><dl><dt class="spec value" id="val-ignore"><a href="#val-ignore" class="anchor"></a><code><span class="keyword">val</span> ignore : <span class="type-var">_</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-never"><a href="#val-never" class="anchor"></a><code><span class="keyword">val</span> never : unit <span>&#45;&gt;</span> <span class="type-var">_</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>never ()</code> returns a deferred that never becomes determined.</p></dd></dl><dl><dt class="spec value" id="val-both"><a href="#val-both" class="anchor"></a><code><span class="keyword">val</span> both : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>both t1 t2</code> becomes determined after both <code>t1</code> and <code>t2</code> become determined.</p></dd></dl><dl><dt class="spec value" id="val-all"><a href="#val-all" class="anchor"></a><code><span class="keyword">val</span> all : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list <a href="index.html#type-t">t</a></code></dt><dd><p><code>all ts</code> returns a deferred that becomes determined when every <code>t</code> in <code>t</code>s is determined. The output is in the same order as the input.</p></dd></dl><dl><dt class="spec value" id="val-all_unit"><a href="#val-all_unit" class="anchor"></a><code><span class="keyword">val</span> all_unit : unit <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> unit <a href="index.html#type-t">t</a></code></dt><dd><p>Like <code>all</code>, but ignores results of the component deferreds.</p></dd></dl><dl><dt class="spec value" id="val-any"><a href="#val-any" class="anchor"></a><code><span class="keyword">val</span> any : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>any ts</code> returns a deferred that is determined when any of the underlying deferreds is determined.</p></dd></dl><dl><dt class="spec value" id="val-any_unit"><a href="#val-any_unit" class="anchor"></a><code><span class="keyword">val</span> any_unit : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> unit <a href="index.html#type-t">t</a></code></dt><dd><p><code>any_unit</code> is like <code>any</code>, but ignores results of the component deferreds.</p></dd></dl><dl><dt class="spec value" id="val-don't_wait_for"><a href="#val-don't_wait_for" class="anchor"></a><code><span class="keyword">val</span> don't_wait_for : unit <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>don't_wait_for t</code> ignores <code>t</code>. It is like <code>Fn.ignore</code>, but is more constrained because it requires a <code>unit Deferred.t</code>.</p><p>Rather than <code>ignore (t : _ t)</code>, do <code>don't_wait_for (Deferred.ignore t)</code>.</p><p>We chose to give <code>don't_wait_for</code> type <code>unit t</code> rather than <code>_ t</code> to catch errors where a value is accidentally ignored.</p></dd></dl><dl><dt class="spec module" id="module-Choice"><a href="#module-Choice" class="anchor"></a><code><span class="keyword">module</span> <a href="Choice/index.html">Choice</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>A <code>Choice.t</code> is used to produce an argument to <code>enabled</code> or <code>choose</code>. See below.</p></dd></dl><dl><dt class="spec type" id="type-choice"><a href="#type-choice" class="anchor"></a><code><span class="keyword">type</span> 'a choice</code><code> = <span class="type-var">'a</span> <a href="Choice/index.html#type-t">Choice.t</a></code></dt></dl><dl><dt class="spec value" id="val-choice"><a href="#val-choice" class="anchor"></a><code><span class="keyword">val</span> choice : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="Choice/index.html#type-t">Choice.t</a></code></dt><dt class="spec value" id="val-enabled"><a href="#val-enabled" class="anchor"></a><code><span class="keyword">val</span> enabled : <span class="type-var">'b</span> <a href="Choice/index.html#type-t">Choice.t</a> list <span>&#45;&gt;</span> (unit <span>&#45;&gt;</span> <span class="type-var">'b</span> list) <a href="index.html#type-t">t</a></code></dt><dd><p><code>enabled [choice t1 f1; ... choice tn fn;]</code> returns a deferred <code>d</code> that becomes determined when any of the <code>ti</code> becomes determined. The value of <code>d</code> is a function <code>f</code> that when called, for each <code>ti</code> that is enabled, applies <code>fi</code> to <code>ti</code>, and returns a list of the results. It is guaranteed that the list is in the same order as the choices supplied to <code>enabled</code>, but of course it may be shorter than the input list if not all <code>ti</code> are determined.</p></dd></dl><dl><dt class="spec value" id="val-choose"><a href="#val-choose" class="anchor"></a><code><span class="keyword">val</span> choose : <span class="type-var">'b</span> <a href="Choice/index.html#type-t">Choice.t</a> list <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><pre><code class="ml">choose [ choice t1 f1
       ; ...
         ; choice tn fn ] </code></pre><p>returns a deferred <code>t</code> that becomes determined with value <code>fi ai</code> after some <code>ti</code> becomes determined with value <code>ai</code>. It is guaranteed that <code>choose</code> calls at most one of the <code>fi</code>s, the one that determines its result. There is no guarantee that the <code>ti</code> that becomes determined earliest in time will be the one whose value determines the <code>choose</code>. Nor is it guaranteed that the value in <code>t</code> is the first value (in place order) from <code>choices</code> that is determined at the time <code>t</code> is examined.</p><p>For example, in:</p><pre><code class="ml">choose [ choice t1 (fun () -&gt; `X1)
       ; choice t2 (fun () -&gt; `X2) ]
&gt;&gt;&gt; function
| `X1 -&gt; e1
| `X2 -&gt; e2 </code></pre><p>it may be the case that both <code>t1</code> and <code>t2</code> become determined, yet <code>e2</code> actually runs.</p><p>It is guaranteed that if multiple choices are determined with no intervening asynchrony, then the earliest choice in the list will become the value of the <code>choose</code>.</p></dd></dl><dl><dt class="spec value" id="val-for_"><a href="#val-for_" class="anchor"></a><code><span class="keyword">val</span> for_ : int <span>&#45;&gt;</span> to_:int <span>&#45;&gt;</span> do_:(int <span>&#45;&gt;</span> unit <a href="index.html#type-t">t</a>) <span>&#45;&gt;</span> unit <a href="index.html#type-t">t</a></code></dt><dd><p><code>for_ start ~to_:stop ~do_:f</code> is the deferred analog of:</p><pre><code class="ml">for i = start to stop do
  f i;
done </code></pre></dd></dl><dl><dt class="spec value" id="val-repeat_until_finished"><a href="#val-repeat_until_finished" class="anchor"></a><code><span class="keyword">val</span> repeat_until_finished : <span class="type-var">'state</span> <span>&#45;&gt;</span> (<span class="type-var">'state</span> <span>&#45;&gt;</span> [ `Repeat of <span class="type-var">'state</span> | `Finished of <span class="type-var">'result</span> ] <a href="index.html#type-t">t</a>) <span>&#45;&gt;</span> <span class="type-var">'result</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>repeat_until_finished initial_state f</code> repeatedly runs <code>f</code> until <code>f</code> returns <code>`Finished</code>. The first call to <code>f</code> happens immediately when <code>repeat_until_finished</code> is called.</p></dd></dl><dl><dt class="spec value" id="val-forever"><a href="#val-forever" class="anchor"></a><code><span class="keyword">val</span> forever : <span class="type-var">'state</span> <span>&#45;&gt;</span> (<span class="type-var">'state</span> <span>&#45;&gt;</span> <span class="type-var">'state</span> <a href="index.html#type-t">t</a>) <span>&#45;&gt;</span> unit</code></dt><dd><p><code>forever initial_state f</code> repeatedly runs <code>f</code>, supplying the state returned to the next call to <code>f</code>.</p></dd></dl><dl><dt class="spec value" id="val-ok"><a href="#val-ok" class="anchor"></a><code><span class="keyword">val</span> ok : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">_</span>) <a href="../../core_kernel/Core_kernel/Result/index.html#type-t">Core_kernel.Result.t</a> <a href="index.html#type-t">t</a></code></dt><dd><p>Useful for lifting values from the <code>Deferred.t</code> monad to the <code>Result.t Deferred.t</code> monad.</p></dd></dl><section><header><h3 id="deferred-collections"><a href="#deferred-collections" class="anchor"></a>Deferred collections</h3><p>These contain operations for iterating in a deferred manner over different collection types.</p></header><div class="spec module" id="module-Array"><a href="#module-Array" class="anchor"></a><code><span class="keyword">module</span> Array = <a href="../Async_kernel__/index.html#module-Deferred_array">Async_kernel__.Deferred_array</a></code></div><div class="spec module" id="module-List"><a href="#module-List" class="anchor"></a><code><span class="keyword">module</span> List = <a href="../Async_kernel__/index.html#module-Deferred_list">Async_kernel__.Deferred_list</a></code></div><div class="spec module" id="module-Map"><a href="#module-Map" class="anchor"></a><code><span class="keyword">module</span> Map = <a href="../Async_kernel__/index.html#module-Deferred_map">Async_kernel__.Deferred_map</a></code></div><div class="spec module" id="module-Memo"><a href="#module-Memo" class="anchor"></a><code><span class="keyword">module</span> Memo = <a href="../Async_kernel__/index.html#module-Deferred_memo">Async_kernel__.Deferred_memo</a></code></div><div class="spec module" id="module-Queue"><a href="#module-Queue" class="anchor"></a><code><span class="keyword">module</span> Queue = <a href="../Async_kernel__/index.html#module-Deferred_queue">Async_kernel__.Deferred_queue</a></code></div><div class="spec module" id="module-Sequence"><a href="#module-Sequence" class="anchor"></a><code><span class="keyword">module</span> Sequence = <a href="../Async_kernel__/index.html#module-Deferred_sequence">Async_kernel__.Deferred_sequence</a></code></div></section><section><header><h3 id="error-carrying-deferreds"><a href="#error-carrying-deferreds" class="anchor"></a>Error-carrying deferreds</h3><p>These contain interfaces for working with deferred type containing error-aware types, like <code>'a Option.t Deferred.t</code>, or <code>'a Or_error.t Deferred.t</code>. These all include support for monadic programming.</p></header><div class="spec module" id="module-Option"><a href="#module-Option" class="anchor"></a><code><span class="keyword">module</span> Option = <a href="../Async_kernel__/index.html#module-Deferred_option">Async_kernel__.Deferred_option</a></code></div><div class="spec module" id="module-Or_error"><a href="#module-Or_error" class="anchor"></a><code><span class="keyword">module</span> Or_error = <a href="../Async_kernel__/index.html#module-Deferred_or_error">Async_kernel__.Deferred_or_error</a></code></div><div class="spec module" id="module-Result"><a href="#module-Result" class="anchor"></a><code><span class="keyword">module</span> Result = <a href="../Async_kernel__/index.html#module-Deferred_result">Async_kernel__.Deferred_result</a></code></div></section></div></body></html>