<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>ffi_cookbook (brr.ffi_cookbook)</title><link rel="stylesheet" href="../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="index.html">Up</a> – <a href="index.html">brr</a> &#x00BB; ffi_cookbook</nav><header class="odoc-preamble"><h1 id="brr-ffi-cookbook"><a href="#brr-ffi-cookbook" class="anchor"></a>Brr FFI cookbook</h1><p>This cookbook has a few tips and off-the-shelf design answers to common JavaScript binding scenarios. You are likely in a hurry but if you haven't read the <a href="ffi_manual.html">FFI manual</a> yet, it's a good idea to do it before.</p><p>Most of the examples in this manual can be cut and pasted directly into the <a href="ocaml_console.html">OCaml console</a>.</p></header><nav class="odoc-toc"><ul><li><a href="#ressources">JavaScript and Web APIs documentation</a></li><li><a href="#names">OCaml identifier convention</a></li><li><a href="#doc_strings">Documentation strings</a></li><li><a href="#recipe">Recipes</a><ul><li><a href="#full_api">Give me a complete example!</a></li><li><a href="#iface_class">Bindings classes or mixin APIs</a></li><li><a href="#fun">Call a JavaScript function</a></li><li><a href="#obj">Create an object</a></li><li><a href="#obj_class">Create an object of a given class</a></li><li><a href="#call_meth">Call a method</a></li><li><a href="#unit_return">How to return <code>unit</code> ?</a></li><li><a href="#class_membership">How to test for class membership ?</a></li><li><a href="#init_dicts">Deal with initialisation dictionaries</a></li><li><a href="#iterators">Deal with the iterator protocol</a></li><li><a href="#enums">Deal with enums</a></li><li><a href="#arrays">Deal with JavaScript arrays</a></li><li><a href="#exns">Deal with exceptions</a></li><li><a href="#promises">Deal with promises</a></li><li><a href="#buffer_sources">Deal with <code>BufferSource</code>s</a></li><li><a href="#callback">Deal with callbacks to OCaml</a></li><li><a href="#export">Exposing an OCaml function to JavaScript</a></li><li><a href="#testing">Testing for features</a></li></ul></li></ul></nav><div class="odoc-content"><h2 id="ressources"><a href="#ressources" class="anchor"></a>JavaScript and Web APIs documentation</h2><p>These are useful references for browser programming:</p><ul><li><a href="https://eloquentjavascript.net/index.html">Eloquent JavaScript</a> is a good book to teach yourself JavaScript.</li><li><a href="https://developer.mozilla.org/">MDN web docs</a> has documentation and further pointers for JavaScript and Web APIs. Sometimes incomplete but a good substitute for the dryness of standards.</li><li>MDN also has implementation API status and quirks information but <a href="https://caniuse.com/">caniuse.com</a> has it in a way that is easier to search.</li></ul><h2 id="names"><a href="#names" class="anchor"></a>OCaml identifier convention</h2><p>Oddly (but luckily) idiomatic OCaml code uses the <code>snake_case</code> identifier convention, not the <code>CamlCase</code> one.</p><p>To map JavaScript identifiers to OCaml ones, introduce a <code>_</code> in front of non initial upper case letters and down case these. If an identifier name clashes with an OCaml keyword, simply prime' it. A few examples:</p><pre>JavaScript        OCaml
----------------------------------
maxTouchPoints    max_touch_points
parseInt          parse_int
FetchEvent        Fetch_event
new               new'
class             class'
type              type'
for               for'</pre><h2 id="doc_strings"><a href="#doc_strings" class="anchor"></a>Documentation strings</h2><p>Make your APIs productive to use: devise a proper doc string and have direct links to the <em>exact</em> functionality you bind to. What you find painful to do now will result in incomensurate time savings in the future, for yourself and anyone using your binding.</p><p>For standard APIs link either on <a href="https://developer.mozilla.org/">MDN</a> which is sometimes incomplete or, if unavailable, on the appropriate standards which are sometimes a bit dry – but better than nothing.</p><h2 id="recipe"><a href="#recipe" class="anchor"></a>Recipes</h2><h3 id="full_api"><a href="#full_api" class="anchor"></a>Give me a complete example!</h3><p>A reasonably sized complete example is the binding to <a href="https://developer.mozilla.org/en-US/docs/Web/API/Blob"><code>Blob</code> objects</a> via <a href="Brr/Blob/index.html"><code>Brr.Blob</code></a>. It shows how to deal with <a href="#enums">enums</a>, <a href="#init_dicts">initalization dictionaries</a>, <a href="#call_meth">method calls</a> and <a href="#promises">promises</a>.</p><h3 id="iface_class"><a href="#iface_class" class="anchor"></a>Bindings classes or mixin APIs</h3><p>The basic pattern to expose an API exposed by a JavaScript class or mixin is to create a module with an abstract type equal to <a href="Jv/index.html#type-t"><code>Jv.t</code></a> and expose its properties and methods in this module.</p><p>Since these abstract values may need to be used by other APIs, always provide hidden conversion function to <a href="Jv/index.html#type-t"><code>Jv.t</code></a>. One way of quickly doing this is to use <a href="Jv/module-type-CONV/index.html"><code>Jv.CONV</code></a> and <a href="Jv/Id/index.html"><code>Jv.Id</code></a> as follows:</p><pre><code>(** [Object_kind] objects. *)
module Object_kind : sig
  type t
  (** The type for {{:https://example.org/doc/ObjectKind}[ObjectKind]s}. *)
  (**/**)
  include Jv.CONV with type t := t
  (**/**)
end = struct
  type t = Jv.t
  include (Jv.Id : Jv.CONV with type t := t)
end</code></pre><p>For each property <code>p</code> of the object have a function named <code>p</code> modulo <a href="#names">the naming convention</a> to get the property. If the property is mutable have another function <code>set_p</code> to set it – that may seem painful but in practice, at least on web APIs, most object properties are read only.</p><p>For each method <code>m</code> of the object have a function of the same name modulo <a href="#names">the naming convention</a> to call the method on the object.</p><p>See also <a href="#obj_class">Create an object of a given class</a>, <a href="#init_dicts">Deal with initialisation dictionaries</a> and <a href="#call_meth">Call a method</a>.</p><h3 id="fun"><a href="#fun" class="anchor"></a>Call a JavaScript function</h3><p>Look for the function name in the global object (or any another object), construct an array of <a href="Jv/index.html#type-t"><code>Jv.t</code></a> values for the function arguments and call <a href="Jv/index.html#val-apply"><code>Jv.apply</code></a>.</p><p>The following is a binding to the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt">parseInt</a> JavaScript function. We handle JavaScript exceptions and map them on the OCaml <code>result</code> type.</p><pre><code>let parse_int' = Jv.get Jv.global &quot;parseInt&quot;
let parse_int ?radix s =
  let r = Jv.of_option ~none:Jv.undefined Jv.of_int radix in
  match Jv.apply parse_int' Jv.[| of_jstr s; r |] with
  | exception Jv.Error e -&gt; Error e
  | v -&gt; Ok (Jv.to_int v)</code></pre><p>Use <a href="Jv/index.html#val-get'"><code>Jv.get'</code></a> if you have to deal with full Unicode identifiers:</p><pre><code>(* function nπ (n) { return n * Math.PI; } *)
let npi' = Jv.get' Jv.global (Jstr.v &quot;nπ&quot;)
let npi n = Jv.to_float @@ Jv.apply npi' Jv.[| of_float n |]</code></pre><p>Note that <code>js_of_ocaml</code> dead codes away these toplevel gets on the <a href="Jv/index.html#val-global"><code>Jv.global</code></a> object if you end up not using these.</p><h3 id="obj"><a href="#obj" class="anchor"></a>Create an object</h3><p>See <a href="ffi_manual.html#create_obj">this section</a> of the FFI manual.</p><h3 id="obj_class"><a href="#obj_class" class="anchor"></a>Create an object of a given class</h3><p>Lookup the constructor in the global <a href="Jv/index.html#val-global"><code>Jv.global</code></a> object (or any other object) and call <a href="Jv/index.html#val-new'"><code>Jv.new'</code></a> with the constructor and its arguments.</p><pre><code>let url = Jv.get Jv.global &quot;URL&quot; (* the URL JavaScript constructor *)
let url_of_jstr s =              (* 'new URL(s);' and handle error *)
  match Jv.new' url Jv.[| of_jstr s |] with
  | exception Jv.Error e -&gt; Error e
  | v -&gt; Ok v</code></pre><h3 id="call_meth"><a href="#call_meth" class="anchor"></a>Call a method</h3><p>Construct an array of <a href="Jv/index.html#type-t"><code>Jv.t</code></a> values for the method arguments an invoke <a href="Jv/index.html#val-call"><code>Jv.call</code></a> on the object with the method name:</p><pre><code>let to_string o = Jv.to_jstr @@ Jv.call o &quot;toString&quot; [||]
let set_length o l = ignore @@ Jv.call o &quot;setLength&quot; Jv.[| of_int l |]</code></pre><p>If you hit a Unicode method name, use <a href="Jv/index.html#val-call'"><code>Jv.call'</code></a>.</p><p>See also <a href="#unit_return">How to return <code>unit</code> ?</a></p><h3 id="unit_return"><a href="#unit_return" class="anchor"></a>How to return <code>unit</code> ?</h3><p>JavaScript's <code>unit</code> is <code>undefined</code>, when you call functions and methods for side effects they return the <a href="Jv/index.html#val-undefined"><code>Jv.undefined</code></a> value. Simply use OCaml's <code>ignore</code> to ignore the value:</p><pre><code>let log s =
  ignore @@ Jv.call (Jv.get Jv.global &quot;console&quot;) &quot;log&quot; Jv.[| of_jstr s |]</code></pre><h3 id="class_membership"><a href="#class_membership" class="anchor"></a>How to test for class membership ?</h3><p>Get a hand on the class constructor and test using <a href="Jv/index.html#val-instanceof"><code>Jv.instanceof</code></a>.</p><pre><code>let array = Jv.get Jv.global &quot;Array&quot;
let is_array_class a = Jv.instanceof (Jv.repr a) array</code></pre><h3 id="init_dicts"><a href="#init_dicts" class="anchor"></a>Deal with initialisation dictionaries</h3><p>Lots of JavaScript constructors take an optional initialisation dictionary to specify parameters for the resulting object.</p><p>To deal with this pattern:</p><ol><li>Create an abstract data type for the dictionary. Call that type <code>init</code> or <code>opts</code> according to the terminology used by the constructor.</li><li>Make a function of the same name with optional arguments for each of the dictionary field and that returns a dictionary.</li><li>In the constructor have an optional parameter with the same name for the dictionary.</li></ol><p>Sample code:</p><pre><code>module Jobj : sig
 type opts
 (** The the type for [Jobj] options. *)

 val opts : ?param1:int -&gt; ?param2:Jstr.t -&gt; unit -&gt; opts
 (** [opts ()] are options for [Jojb] with given parameters. *)

 type t
 (** The type for [Jobj] objects. *)

 val create : ?opts:opts -&gt; unit -&gt; t
 (** [create () ~opts] is a [Jobj] with options [opts]. *)

end = struct
  type opts = Jv.t
  let opts ?param1 ?param2 () =
    let o = Jv.obj [||] in
    Jv.Int.set_if_some o &quot;param1&quot; param1;
    Jv.Jstr.set_if_some o &quot;param2&quot; param2;
    o

  type t = Jv.t
  let jobj = Jv.get Jv.global &quot;Jobj&quot; (* constructor *)
  let create ?(opts = Jv.undefined) () = Jv.new' jobj [| opts |]
end</code></pre><h3 id="iterators"><a href="#iterators" class="anchor"></a>Deal with the iterator protocol</h3><p>APIs returning sequences of values via the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol">iterator protocol</a> can be dealt with using the functions provided in <a href="Jv/It/index.html"><code>Jv.It</code></a>. Convenience functions are provided to turn them directly into folds.</p><p>The following folds over the Unicode characters of strings returned as strings. The function <a href="Jv/It/index.html#val-iterator"><code>Jv.It.iterator</code></a> accesses the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/@@iterator">JavaScript string iterator</a> (formally the symbolic property <code>Symbol.iterator</code>). The <a href="Jv/It/index.html#val-fold"><code>Jv.It.fold</code></a> combinator takes care of folding over the values it produces.</p><pre><code>let fold_uchar_jstrs f s acc =
  Jv.It.fold Jv.to_jstr f (Jv.It.iterator (Jv.of_jstr s)) acc</code></pre><h3 id="enums"><a href="#enums" class="anchor"></a>Deal with enums</h3><p>In browser APIs enums are strings most of the time used to specify options. Pattern matching is of little use in this case so do not bother to translate them to OCaml variants.</p><p>Use the <a href="#names">naming convention</a> to define a dedicated module for the enum with:</p><ol><li>A type <code>t</code> equal to <a href="Jstr/index.html#type-t"><code>Jstr.t</code></a>.</li><li>Constants for each value.</li><li>At least one link in a <a href="#doc_strings">doc string</a> that explains the semantics of values.</li></ol><p>For example for this <code>Blob</code> object <a href="https://w3c.github.io/FileAPI/#enumdef-endingtype"><code>EndingType</code></a> enum:</p><pre><code>(** The line ending type enum. *)
module Ending_type : sig
  type t = Jstr.t
  (** The type for line
    {{:https://w3c.github.io/FileAPI/#dom-blobpropertybag-endings}
    [EndingType] values}. *)

  val native : Jstr.t
  val transparent : Jstr.t
end = struct
  type t = Jstr.t
  let native = Jstr.v &quot;native&quot;
  let transparent = Jstr.v &quot;transparent&quot;
end</code></pre><p><code>js_of_ocaml</code> dead codes away these constants if they are not used by your program.</p><h3 id="arrays"><a href="#arrays" class="anchor"></a>Deal with JavaScript arrays</h3><p>JavaScript APIs arrays are often used for lists (indexability does not really matter). In this case make the OCaml programmer happy and expose them as such. Use <a href="Jv/index.html#val-to_list"><code>Jv.to_list</code></a> and <a href="Jv/index.html#val-of_list"><code>Jv.of_list</code></a> to convert JavaScript arrays, there are also a few <a href="Jv/index.html#array_special">specialized conversion</a> functions which may be faster.</p><pre><code>let navigator_languages : Navigator.t -&gt; Jstr.t list =
fun n -&gt; Jv.to_jstr_list @@ Jv.get (Navigator.to_jv n) &quot;languages&quot;</code></pre><h3 id="exns"><a href="#exns" class="anchor"></a>Deal with exceptions</h3><p>JavaScript exceptions/errors are thrown in your face as the OCaml <a href="Jv/index.html#exception-Error"><code>Jv.Error</code></a> exception. To handle it simply pattern match on it like you do with any other OCaml exception:</p><pre><code>let atob : Jstr.t -&gt; (Jstr.t, Jv.Error.t) result =
fun a -&gt;
  match Jv.apply (Jv.get Jv.global &quot;atob&quot;) Jv.[| of_jstr a |] with
  | exception Jv.Error e -&gt; Error e
  | v -&gt; Ok (Jv.to_jstr v)</code></pre><p>To throw your own JavaScript exception use <a href="Jv/index.html#val-throw"><code>Jv.throw</code></a>.</p><p>When a function or method throws exceptions distinguish between:</p><ul><li>The exception is thrown because of an exceptional <em>programming error</em>. The programmer did not respect an expected invariant, like <code>Invalid_argument</code> in OCaml.</li><li>The exception is thrown beause of an unexceptional error that can naturally occur at runtime. For example a codec decoding error, a network failure etc.</li></ul><p>In the first case simply bind the function and mention in the documentation that it may raise. In the second case catch the JavaScript exception and turn it into a <a href="../ocaml/Stdlib/index.html#type-result"><code>Stdlib.result</code></a> type, see the example above.</p><p>See also <a href="#promises">Deal with promises</a>.</p><h3 id="promises"><a href="#promises" class="anchor"></a>Deal with promises</h3><p>Brr represents JavaScript promises as <a href="Fut/index.html#type-result"><code>Fut.result</code></a> values which are <a href="Fut/index.html#type-t"><code>Fut.t</code></a> values that determine to a standard OCaml <a href="../ocaml/Stdlib/index.html#type-result"><code>Stdlib.result</code></a> type using the <code>Error</code> case for rejections.</p><p>In JavaScript APIs most promises reject by returning a JavaScript error object <a href="Jv/Error/index.html#type-t"><code>Jv.Error.t</code></a> and the <a href="Fut/index.html#type-or_error"><code>Fut.or_error</code></a> type abbreviation represents exactly that. The <a href="Fut/index.html#val-of_promise"><code>Fut.of_promise</code></a> function converts a promise directly to this type.</p><pre><code>let read_text c = Fut.of_promise ~ok:Jv.to_jstr @@ Jv.call c &quot;readText&quot; [||]
let fullscreen () =
  Fut.of_promise ~ok:ignore @@
  Jv.call (El.to_jv (Document.body G.document)) &quot;requestFullscreen&quot; [||]</code></pre><h3 id="buffer_sources"><a href="#buffer_sources" class="anchor"></a>Deal with <code>BufferSource</code>s</h3><p>Some APIs deal with <a href="https://heycam.github.io/webidl/#common-BufferSource"><code>BufferSource</code>s</a> which makes things a bit more complicated than they could be.</p><p>Any <a href="Brr/Tarray/Buffer/index.html#type-t"><code>Brr.Tarray.Buffer.t</code></a> can be turned into into a <a href="Brr/Tarray/index.html#type-t"><code>Brr.Tarray.t</code></a> if needed so:</p><ul><li>When a <code>BufferSource</code> is specified as an input argument. Use the <a href="Brr/Tarray/index.html#type-t"><code>Brr.Tarray.t</code></a> type. Users who want to use a direct <a href="Brr/Tarray/Buffer/index.html#type-t"><code>Brr.Tarray.Buffer.t</code></a> can use <a href="Brr/Tarray/index.html#val-uint8_of_buffer"><code>Brr.Tarray.uint8_of_buffer</code></a>.</li><li>Usually <code>BufferSource</code> are not the result of functions. No infrastructure is provided by Brr for now, but an ad-hoc variant could be introduced for these.</li></ul><h3 id="callback"><a href="#callback" class="anchor"></a>Deal with callbacks to OCaml</h3><p>Simply pass the <a href="Jv/index.html#val-repr"><code>Jv.repr</code></a> value representation of the function as an argument.</p><pre><code>let set_timeout : ms:int -&gt; (unit -&gt; unit) -&gt; unit =
  let set_timeout = Jv.get Jv.global &quot;setTimeout&quot; in
  fun ~ms f -&gt; ignore @@ Jv.apply set_timeout Jv.[| repr f; of_int ms |]

let () =
  let alert = Jv.get Jv.global &quot;alert&quot; in
  let alert v = ignore @@ Jv.apply alert Jv.[| of_string v |] in
  set_timeout ~ms:1000 @@ fun () -&gt; alert &quot;Iiiiiik!&quot;</code></pre><p>You need to make sure the representations of the function arguments and the result type are compatible with those JavaScript expect. See <a href="#export">here for more discussion</a>.</p><h3 id="export"><a href="#export" class="anchor"></a>Exposing an OCaml function to JavaScript</h3><p>Just name its JavaScript representation in the <a href="Jv/index.html#val-global"><code>Jv.global</code></a> object (or any other object). You need to make sure the representations of the function arguments and the result type are compatible with those JavaScript expect, see the <a href="ffi_manual.html">FFI manual</a> for discussions on this. So for example to expose an OCaml factorial function in the global object as <code>fact</code> you could write:</p><pre><code>let rec fact n = if n &lt;= 0 then 1 else n * fact (n - 1)
let fact' n = Jv.of_int (fact (Jv.to_int n))
let () = Jv.set Jv.global &quot;fact&quot; (Jv.repr fact')</code></pre><p>The JavaScript code or console can now call:</p><pre><code>fact (3);</code></pre><p>Note that technically since <a href="ffi_manual.html#nums">number</a> conversions are nops you could write:</p><pre><code>(* Do not do this *)
let () = Jv.set Jv.global &quot;fact&quot; (Jv.repr fact)</code></pre><p>But it's not advised to do and may break if <code>js_of_ocaml</code> changes the representation of OCaml values in the future.</p><h3 id="testing"><a href="#testing" class="anchor"></a>Testing for features</h3><p>Browser discrepancies do still exist. To quickly test for features <a href="Jv/index.html#val-has"><code>Jv.has</code></a> takes a value of any type and checks whether it has the given property or method name:</p><pre><code>let has_text_method : Blob.t -&gt; bool = fun b -&gt; Jv.has &quot;text&quot; b</code></pre><p><a href="Jv/index.html#val-defined"><code>Jv.defined</code></a><code> v</code> tests that <code>v</code> is neither <code>null</code> nor <code>undefined</code> – this is simply a shortcut for the longer <code>Jv.is_some (J.repr v)</code>.</p></div></body></html>