<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Nativeint (batteries.BatMap.Nativeint)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">batteries</a> &#x00BB; <a href="../index.html">BatMap</a> &#x00BB; Nativeint</nav><header class="odoc-preamble"><h1>Module <code><span>BatMap.Nativeint</span></code></h1></header><nav class="odoc-toc"><ul><li><a href="#boilerplate-code">Boilerplate code</a></li><li><a href="#printing">Printing</a></li><li><a href="#override-modules">Override modules</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-key" class="anchored"><a href="#type-key" class="anchor"></a><code><span><span class="keyword">type</span> key</span><span> = nativeint</span></code></div><div class="spec-doc"><p>The type of the map keys.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>!+'a t</span></span></code></div><div class="spec-doc"><p>The type of maps from type <code>key</code> to type <code>'a</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-empty" class="anchored"><a href="#val-empty" class="anchor"></a><code><span><span class="keyword">val</span> empty : <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>The empty map.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_empty" class="anchored"><a href="#val-is_empty" class="anchor"></a><code><span><span class="keyword">val</span> is_empty : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Test whether a map is empty or not.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-cardinal" class="anchored"><a href="#val-cardinal" class="anchor"></a><code><span><span class="keyword">val</span> cardinal : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Return the number of bindings of a map.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-add" class="anchored"><a href="#val-add" class="anchor"></a><code><span><span class="keyword">val</span> add : <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>add x y m</code> returns a map containing the same bindings as <code>m</code>, plus a binding of <code>x</code> to <code>y</code>. If <code>x</code> was already bound in <code>m</code>, its previous binding disappears. If <code>x</code> was already bound to some <code>z</code> that is physically equal to <code>y</code>, then the returned map is physically equal to <code>m</code>.</p><ul class="at-tags"><li class="before"><span class="at-tag">before</span> <span class="value">3.3.0</span> <p>physical equality was not ensured.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-update_stdlib" class="anchored"><a href="#val-update_stdlib" class="anchor"></a><code><span><span class="keyword">val</span> update_stdlib : <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span><span class="type-var">'a</span> option</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>update_stdlib k f m</code> returns a map containing the same bindings as <code>m</code>, except <code>k</code> has a new binding as determined by <code>f</code>: First, calculate <code>y</code> as <code>f (find_opt k m)</code>. If <code>y = Some v</code> then <code>k</code> will be bound to <code>v</code> in the resulting map. Else <code>k</code> will not be bound in the resulting map. If <code>v</code> is physically equal to the value of the previous binding of <code>k</code> in <code>m</code>, then the returned map will be physically equal to <code>m</code>.</p><p>This function does the same thing as <code>update</code> in the stdlib, but has a different name for backwards compatibility reasons.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.3.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-update" class="anchored"><a href="#val-update" class="anchor"></a><code><span><span class="keyword">val</span> update : <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>update k1 k2 v2 m</code> replace the previous binding of <code>k1</code> in <code>m</code> by <code>k2</code> associated to <code>v2</code>. This is equivalent to <code>add k2 v2 (remove k1) m</code>, but more efficient in the case where <code>k1</code> and <code>k2</code> have the same key ordering. If <code>k1</code> and <code>k2</code> have the same key ordering and <code>v2</code> is physically equal to the value <code>k1</code> is bound to in <code>m</code> then the returned map will be physically equal to <code>m</code></p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Not_found</span> <p>if <code>k1</code> is not bound in <code>m</code>.</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.4.0</li></ul><ul class="at-tags"><li class="before"><span class="at-tag">before</span> <span class="value">3.3.0</span> <p>physical equality was not ensured.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-find" class="anchored"><a href="#val-find" class="anchor"></a><code><span><span class="keyword">val</span> find : <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>find x m</code> returns the current binding of <code>x</code> in <code>m</code>, or raises <code>Not_found</code> if no such binding exists.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-find_opt" class="anchored"><a href="#val-find_opt" class="anchor"></a><code><span><span class="keyword">val</span> find_opt : <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div><div class="spec-doc"><p><code>find_opt x m</code> returns Some b where b is the current binding * of <code>x</code> in <code>m</code>, or None if no such binding exists.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-find_default" class="anchored"><a href="#val-find_default" class="anchor"></a><code><span><span class="keyword">val</span> find_default : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>find_default d x m</code> returns the current binding of <code>x</code> in <code>m</code>, or the default value <code>d</code> if no such binding exists.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-find_first" class="anchored"><a href="#val-find_first" class="anchor"></a><code><span><span class="keyword">val</span> find_first : <span><span>(<span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-key">key</a> * <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>find_first f m</code> returns the first binding <code>(k, v)</code> for which <code>f k</code> is true or raises <code>Not_found</code> if there is no such binding. <code>f</code> must be monotonically increasing, i.e. if <code>k1 &lt; k2 &amp;&amp; f k1</code> is true then <code>f k2</code> must also be true.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.3.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-find_first_opt" class="anchored"><a href="#val-find_first_opt" class="anchor"></a><code><span><span class="keyword">val</span> find_first_opt : <span><span>(<span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-key">key</a> * <span class="type-var">'a</span>)</span> option</span></span></code></div><div class="spec-doc"><p><code>find_first_opt f m</code> returns <code>Some (k, v)</code> for the first binding <code>(k, v)</code> for which <code>f k</code> is true or returns <code>None</code> if there is no such binding. <code>f</code> must be monotonically increasing, i.e. if <code>k1 &lt; k2 &amp;&amp; f k1</code> is true then <code>f k2</code> must also be true.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.3.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-find_last" class="anchored"><a href="#val-find_last" class="anchor"></a><code><span><span class="keyword">val</span> find_last : <span><span>(<span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-key">key</a> * <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>find_last f m</code> returns the last binding <code>(k, v)</code> for which <code>f k</code> is true or raises <code>Not_found</code> if there is no such binding. <code>f</code> must be monotonically decreasing, i.e. if <code>k1 &lt; k2 &amp;&amp; f k2</code> is true then <code>f k1</code> must also be true.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.3.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-find_last_opt" class="anchored"><a href="#val-find_last_opt" class="anchor"></a><code><span><span class="keyword">val</span> find_last_opt : <span><span>(<span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-key">key</a> * <span class="type-var">'a</span>)</span> option</span></span></code></div><div class="spec-doc"><p><code>find_last_opt f m</code> returns <code>Some (k, v)</code> for the last binding <code>(k, v)</code> for which <code>f k</code> is true or returns <code>None</code> if there is no such binding. <code>f</code> must be monotonically decreasing, i.e. if <code>k1 &lt; k2 &amp;&amp; f k2</code> is true then <code>f k1</code> must also be true.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.3.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-remove" class="anchored"><a href="#val-remove" class="anchor"></a><code><span><span class="keyword">val</span> remove : <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>remove x m</code> returns a map containing the same bindings as <code>m</code>, except for <code>x</code> which is unbound in the returned map. The returned map is physically equal to the passed one if <code>x</code> was already unbound.</p><ul class="at-tags"><li class="before"><span class="at-tag">before</span> <span class="value">3.3.0</span> <p>physical equality was not ensured</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-remove_exn" class="anchored"><a href="#val-remove_exn" class="anchor"></a><code><span><span class="keyword">val</span> remove_exn : <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>remove_exn x m</code> behaves like <code>remove x m</code> except that it raises an exception if <code>x</code> is unbound in <code>m</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Not_found</span> <p>if <code>x</code> is unbound in <code>m</code></p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.2.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-modify" class="anchored"><a href="#val-modify" class="anchor"></a><code><span><span class="keyword">val</span> modify : <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>modify k f m</code> replaces the previous binding for <code>k</code> with <code>f</code> applied to that value. If <code>k</code> is unbound in <code>m</code> or <code>Not_found</code> is raised during the search, <code>Not_found</code> is raised.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.2.0</li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Not_found</span> <p>if <code>k</code> is unbound in <code>m</code> (or <code>f</code> raises <code>Not_found</code>)</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-modify_def" class="anchored"><a href="#val-modify_def" class="anchor"></a><code><span><span class="keyword">val</span> modify_def : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>modify_def v0 k f m</code> replaces the previous binding for <code>k</code> with <code>f</code> applied to that value. If <code>k</code> is unbound in <code>m</code> or <code>Not_found</code> is raised during the search, <code>f v0</code> is inserted (as if the value found were <code>v0</code>).</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.3.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-modify_opt" class="anchored"><a href="#val-modify_opt" class="anchor"></a><code><span><span class="keyword">val</span> modify_opt : <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span><span class="type-var">'a</span> option</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>modify_opt k f m</code> allows to modify the binding for <code>k</code> in <code>m</code> or absence thereof.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.1</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-extract" class="anchored"><a href="#val-extract" class="anchor"></a><code><span><span class="keyword">val</span> extract : <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> * <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>extract k m</code> removes the current binding of <code>k</code> from <code>m</code>, returning the value <code>k</code> was bound to and the updated <code>m</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Not_found</span> <p>if <code>k</code> is unbound in <code>m</code></p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.4.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-pop" class="anchored"><a href="#val-pop" class="anchor"></a><code><span><span class="keyword">val</span> pop : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>(<a href="#type-key">key</a> * <span class="type-var">'a</span>)</span> * <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>pop m</code> returns a binding from <code>m</code> and <code>m</code> without that binding.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Not_found</span> <p>if <code>m</code> is empty</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.4.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-mem" class="anchored"><a href="#val-mem" class="anchor"></a><code><span><span class="keyword">val</span> mem : <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>mem x m</code> returns <code>true</code> if <code>m</code> contains a binding for <code>x</code>, and <code>false</code> otherwise.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-iter" class="anchored"><a href="#val-iter" class="anchor"></a><code><span><span class="keyword">val</span> iter : <span><span>(<span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>iter f m</code> applies <code>f</code> to all bindings in map <code>m</code>. <code>f</code> receives the key as first argument, and the associated value as second argument. The bindings are passed to <code>f</code> in increasing order with respect to the ordering over the type of the keys. Only current bindings are presented to <code>f</code>: bindings hidden by more recent bindings are not passed to <code>f</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-map" class="anchored"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>map f m</code> returns a map with same domain as <code>m</code>, where the associated value <code>a</code> of all bindings of <code>m</code> has been replaced by the result of the application of <code>f</code> to <code>a</code>. The bindings are passed to <code>f</code> in increasing order with respect to the ordering over the type of the keys.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mapi" class="anchored"><a href="#val-mapi" class="anchor"></a><code><span><span class="keyword">val</span> mapi : <span><span>(<span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Same as <code>Map</code>.S.map, but the function receives as arguments both the key and the associated value for each binding of the map.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold" class="anchored"><a href="#val-fold" class="anchor"></a><code><span><span class="keyword">val</span> fold : <span><span>(<span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span></span></code></div><div class="spec-doc"><p><code>fold f m a</code> computes <code>(f kN dN ... (f k1 d1 (f k0 d0 a))...)</code>, where <code>k0,k1..kN</code> are the keys of all bindings in <code>m</code> (in increasing order), and <code>d1 ... dN</code> are the associated data.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-filterv" class="anchored"><a href="#val-filterv" class="anchor"></a><code><span><span class="keyword">val</span> filterv : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>filterv f m</code> returns a map where only the values <code>a</code> of <code>m</code> such that <code>f a = true</code> remain. The bindings are passed to <code>f</code> in increasing order with respect to the ordering over the type of the keys.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-filter" class="anchored"><a href="#val-filter" class="anchor"></a><code><span><span class="keyword">val</span> filter : <span><span>(<span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>filter f m</code> returns a map where only the <code>(key, value)</code> pairs of <code>m</code> such that <code>f key value = true</code> remain. The bindings are passed to <code>f</code> in increasing order with respect to the ordering over the type of the keys. If <code>f</code> returns <code>true</code> for all bindings of <code>m</code> the returned map is physically equal to <code>m</code>.</p><ul class="at-tags"><li class="before"><span class="at-tag">before</span> <span class="value">3.3.0</span> <p>physical equality was not ensured.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-filter_map" class="anchored"><a href="#val-filter_map" class="anchor"></a><code><span><span class="keyword">val</span> filter_map : <span><span>(<span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>filter_map f m</code> combines the features of <code>filter</code> and <code>map</code>. It calls calls <code>f key0 a0</code>, <code>f key1 a1</code>, <code>f keyn an</code> where <code>a0,a1..an</code> are the elements of <code>m</code> and <code>key0..keyn</code> the respective corresponding keys. It returns the map of pairs <code>(keyi, bi)</code> such as <code>f keyi ai = Some bi</code> (when <code>f</code> returns <code>None</code>, the corresponding element of <code>m</code> is discarded).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-compare" class="anchored"><a href="#val-compare" class="anchor"></a><code><span><span class="keyword">val</span> compare : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Total ordering between maps. The first argument is a total ordering used to compare data associated with equal keys in the two maps.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-equal" class="anchored"><a href="#val-equal" class="anchor"></a><code><span><span class="keyword">val</span> equal : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>equal cmp m1 m2</code> tests whether the maps <code>m1</code> and <code>m2</code> are equal, that is, contain equal keys and associate them with equal data. <code>cmp</code> is the equality predicate used to compare the data associated with the keys.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-keys" class="anchored"><a href="#val-keys" class="anchor"></a><code><span><span class="keyword">val</span> keys : <span><span><span class="type-var">_</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-key">key</a> <a href="../../BatEnum/index.html#type-t">BatEnum.t</a></span></span></code></div><div class="spec-doc"><p>Return an enumeration of all the keys of a map. The returned enumeration is sorted in increasing key order.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-values" class="anchored"><a href="#val-values" class="anchor"></a><code><span><span class="keyword">val</span> values : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../../BatEnum/index.html#type-t">BatEnum.t</a></span></span></code></div><div class="spec-doc"><p>Return an enumeration of all the values of a map. The returned enumeration is sorted in increasing key order.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-min_binding" class="anchored"><a href="#val-min_binding" class="anchor"></a><code><span><span class="keyword">val</span> min_binding : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-key">key</a> * <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Return the <code>(key, value)</code> pair with the smallest key.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Not_found</span> <p>if the map is empty.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-min_binding_opt" class="anchored"><a href="#val-min_binding_opt" class="anchor"></a><code><span><span class="keyword">val</span> min_binding_opt : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-key">key</a> * <span class="type-var">'a</span>)</span> option</span></span></code></div><div class="spec-doc"><p>Return <code>Some (key, value)</code> for the <code>key, value</code> pair with the smallest key, or <code>None</code> if the map is empty.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.3.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-pop_min_binding" class="anchored"><a href="#val-pop_min_binding" class="anchor"></a><code><span><span class="keyword">val</span> pop_min_binding : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>(<a href="#type-key">key</a> * <span class="type-var">'a</span>)</span> * <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Return the <code>(key, value)</code> pair with the smallest key along with the rest of the map.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-max_binding" class="anchored"><a href="#val-max_binding" class="anchor"></a><code><span><span class="keyword">val</span> max_binding : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-key">key</a> * <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Return the <code>(key, value)</code> pair with the largest key. Raises Not_found if the map is empty.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-max_binding_opt" class="anchored"><a href="#val-max_binding_opt" class="anchor"></a><code><span><span class="keyword">val</span> max_binding_opt : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-key">key</a> * <span class="type-var">'a</span>)</span> option</span></span></code></div><div class="spec-doc"><p>Return <code>Some (key, value)</code> for the <code>key, value</code> pair with the largest key, or <code>None</code> if the map is empty.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.3.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-pop_max_binding" class="anchored"><a href="#val-pop_max_binding" class="anchor"></a><code><span><span class="keyword">val</span> pop_max_binding : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>(<a href="#type-key">key</a> * <span class="type-var">'a</span>)</span> * <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Return the (<code>key, value</code>) pair with the largest key along with the rest of the map.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-choose" class="anchored"><a href="#val-choose" class="anchor"></a><code><span><span class="keyword">val</span> choose : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-key">key</a> * <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Return one binding of the given map. Which binding is chosen is unspecified, but equal bindings will be chosen for equal maps.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Not_found</span> <p>if the map is empty</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-choose_opt" class="anchored"><a href="#val-choose_opt" class="anchor"></a><code><span><span class="keyword">val</span> choose_opt : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-key">key</a> * <span class="type-var">'a</span>)</span> option</span></span></code></div><div class="spec-doc"><p>Return <code>Some (k, v)</code> for one binding <code>(k, v)</code> of the given map, if the map is not empty. Else, return None. Which binding is chosen is unspecified, but equal bindings will be chosen for equal maps.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.3.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-any" class="anchored"><a href="#val-any" class="anchor"></a><code><span><span class="keyword">val</span> any : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-key">key</a> * <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Return one binding of the given map. The difference with choose is that there is no guarantee that equals elements will be picked for equal sets. This merely returns the quickest binding to get (O(1)).</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Not_found</span> <p>if the map is empty.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-split" class="anchored"><a href="#val-split" class="anchor"></a><code><span><span class="keyword">val</span> split : <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> * <span><span class="type-var">'a</span> option</span> * <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>split x m</code> returns a triple <code>(l, data, r)</code>, where <code>l</code> is the map with all the bindings of <code>m</code> whose key is strictly less than <code>x</code>; <code>r</code> is the map with all the bindings of <code>m</code> whose key is strictly greater than <code>x</code>; <code>data</code> is <code>None</code> if <code>m</code> contains no binding for <code>x</code>, or <code>Some v</code> if <code>m</code> binds <code>v</code> to <code>x</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-partition" class="anchored"><a href="#val-partition" class="anchor"></a><code><span><span class="keyword">val</span> partition : <span><span>(<span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> * <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>partition p m</code> returns a pair of maps <code>(m1, m2)</code>, where <code>m1</code> contains all the bindings of <code>s</code> that satisfy the predicate <code>p</code>, and <code>m2</code> is the map with all the bindings of <code>s</code> that do not satisfy <code>p</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.4.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-singleton" class="anchored"><a href="#val-singleton" class="anchor"></a><code><span><span class="keyword">val</span> singleton : <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>singleton x y</code> returns the one-element map that contains a binding <code>y</code> for <code>x</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-bindings" class="anchored"><a href="#val-bindings" class="anchor"></a><code><span><span class="keyword">val</span> bindings : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-key">key</a> * <span class="type-var">'a</span>)</span> list</span></span></code></div><div class="spec-doc"><p>Return the list of all bindings of the given map. The returned list is sorted in increasing key order.</p><p>Added for compatibility with stdlib 3.12</p></div></div><div class="odoc-spec"><div class="spec value" id="val-enum" class="anchored"><a href="#val-enum" class="anchor"></a><code><span><span class="keyword">val</span> enum : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-key">key</a> * <span class="type-var">'a</span>)</span> <a href="../../BatEnum/index.html#type-t">BatEnum.t</a></span></span></code></div><div class="spec-doc"><p>Return an enumeration of <code>(key, value)</code> pairs of a map. The returned enumeration is sorted in increasing order with respect to the ordering <code>Ord.compare</code>, where <code>Ord</code> is the argument given to <code>Map</code>.Make.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-backwards" class="anchored"><a href="#val-backwards" class="anchor"></a><code><span><span class="keyword">val</span> backwards : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-key">key</a> * <span class="type-var">'a</span>)</span> <a href="../../BatEnum/index.html#type-t">BatEnum.t</a></span></span></code></div><div class="spec-doc"><p>Return an enumeration of <code>(key, value)</code> pairs of a map. The returned enumeration is sorted in decreasing order with respect to the ordering <code>Ord.compare</code>, where <code>Ord</code> is the argument given to <code>Map</code>.Make.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_enum" class="anchored"><a href="#val-of_enum" class="anchor"></a><code><span><span class="keyword">val</span> of_enum : <span><span><span>(<a href="#type-key">key</a> * <span class="type-var">'a</span>)</span> <a href="../../BatEnum/index.html#type-t">BatEnum.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Create a map from a (key, value) enumeration.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-for_all" class="anchored"><a href="#val-for_all" class="anchor"></a><code><span><span class="keyword">val</span> for_all : <span><span>(<span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>for_all p m</code> checks if all the bindings of the map satisfy the predicate <code>p</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-exists" class="anchored"><a href="#val-exists" class="anchor"></a><code><span><span class="keyword">val</span> exists : <span><span>(<span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>exists p m</code> checks if at least one binding of the map satisfy the predicate <code>p</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-merge" class="anchored"><a href="#val-merge" class="anchor"></a><code><span><span class="keyword">val</span> merge : <span><span>(<span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> option</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> option</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>merge f m1 m2</code> computes a map whose keys is a subset of keys of <code>m1</code> and of <code>m2</code>. The presence of each such binding, and the corresponding value, is determined with the function <code>f</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-union" class="anchored"><a href="#val-union" class="anchor"></a><code><span><span class="keyword">val</span> union : <span><span>(<span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>union f m1 m2</code> computes a map whose keys are a subset of the keys of <code>m1</code> and of <code>m2</code>. When the same binding is defined in both arguments, the function f is used to combine them. This function is similar to <code>merge</code>, except <code>f</code> is only called if a key is present in both <code>m1</code> and <code>m2</code>. If a key is present in either <code>m1</code> or <code>m2</code> but not in both, it (and the corresponding value) will be present in the resulting map.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.3.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-to_seq" class="anchored"><a href="#val-to_seq" class="anchor"></a><code><span><span class="keyword">val</span> to_seq : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-key">key</a> * <span class="type-var">'a</span>)</span> <a href="../../BatSeq/index.html#type-t">BatSeq.t</a></span></span></code></div><div class="spec-doc"><p>Iterate on the whole map, in ascending order of keys.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.3.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-to_rev_seq" class="anchored"><a href="#val-to_rev_seq" class="anchor"></a><code><span><span class="keyword">val</span> to_rev_seq : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-key">key</a> * <span class="type-var">'a</span>)</span> <a href="../../BatSeq/index.html#type-t">BatSeq.t</a></span></span></code></div><div class="spec-doc"><p>Iterate on the whole map, in descending order of keys.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.3.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-to_seq_from" class="anchored"><a href="#val-to_seq_from" class="anchor"></a><code><span><span class="keyword">val</span> to_seq_from : <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-key">key</a> * <span class="type-var">'a</span>)</span> <a href="../../BatSeq/index.html#type-t">BatSeq.t</a></span></span></code></div><div class="spec-doc"><p><code>to_seq_from k m</code> iterates on a subset of the bindings in <code>m</code>, namely those bindings greater or equal to <code>k</code>, in ascending order.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.3.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-add_seq" class="anchored"><a href="#val-add_seq" class="anchor"></a><code><span><span class="keyword">val</span> add_seq : <span><span><span>(<a href="#type-key">key</a> * <span class="type-var">'a</span>)</span> <a href="../../BatSeq/index.html#type-t">BatSeq.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>add the given bindings to the map, in order.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.3.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-of_seq" class="anchored"><a href="#val-of_seq" class="anchor"></a><code><span><span class="keyword">val</span> of_seq : <span><span><span>(<a href="#type-key">key</a> * <span class="type-var">'a</span>)</span> <a href="../../BatSeq/index.html#type-t">BatSeq.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>build a map from the given bindings</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.3.0</li></ul></div></div><h6 id="boilerplate-code"><a href="#boilerplate-code" class="anchor"></a>Boilerplate code</h6><h6 id="printing"><a href="#printing" class="anchor"></a>Printing</h6><div class="odoc-spec"><div class="spec value" id="val-print" class="anchored"><a href="#val-print" class="anchor"></a><code><span><span class="keyword">val</span> print : <span>?first:string <span class="arrow">&#45;&gt;</span></span> <span>?last:string <span class="arrow">&#45;&gt;</span></span> <span>?sep:string <span class="arrow">&#45;&gt;</span></span> <span>?kvsep:string <span class="arrow">&#45;&gt;</span></span>
<span><span>(<span><span><span class="type-var">'a</span> <a href="../../BatInnerIO/index.html#type-output">BatInnerIO.output</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span><span class="type-var">'a</span> <a href="../../BatInnerIO/index.html#type-output">BatInnerIO.output</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="../../BatInnerIO/index.html#type-output">BatInnerIO.output</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'c</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><p>Output signature of the functor <code>Map</code>.Make.</p><h6 id="override-modules"><a href="#override-modules" class="anchor"></a>Override modules</h6><p>The following modules replace functions defined in <code>Map</code> with functions behaving slightly differently but having the same name. This is by design: the functions meant to override the corresponding functions of <code>Map</code>.</p><div class="odoc-spec"><div class="spec module" id="module-Exceptionless" class="anchored"><a href="#module-Exceptionless" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Exceptionless/index.html">Exceptionless</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Operations on <code>Map</code> without exceptions.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Infix" class="anchored"><a href="#module-Infix" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Infix/index.html">Infix</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Infix operators over a <a href="../index.html"><code>BatMap</code></a></p></div></div><div class="odoc-spec"><div class="spec module" id="module-Labels" class="anchored"><a href="#module-Labels" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Labels/index.html">Labels</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Operations on <code>Map</code> with labels.</p></div></div></div></body></html>