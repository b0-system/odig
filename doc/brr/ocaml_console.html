<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>ocaml_console (brr.ocaml_console)</title><link rel="stylesheet" href="../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="index.html">Up</a> – <a href="index.html">brr</a> &#x00BB; ocaml_console</nav><header class="odoc-preamble"><h1 id="ocaml-console"><a href="#ocaml-console" class="anchor"></a>OCaml console</h1><p>The OCaml console <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions">WebExtension</a> is like the browser JavaScript console but for OCaml. It provides an OCaml toplevel (REPL) to directly interact with the OCaml code that lives in the web page. Follow the <a href="#ext_install">install instructions</a>.</p><p>The extension itself is totally dumb: it inputs OCaml phrases, <code>eval</code>s them in your web page via an <a href="#ocaml_poke"><code>ocaml_poke</code></a> global JavaScript object and writes the result to the OCaml console panel. The burden of providing the poke object and the associated toplevel machinery is on the web page, see <a href="#web_page_instructions">these instructions</a>.</p><p><b>Note.</b> If you write to the <a href="Brr/Console/index.html"><code>Brr.Console</code></a> from the OCaml console the output appears in the JavaScript console which has support to inspect the JavaScript values that underpin many of the OCaml values you manipulate with Brr. Hence it's a good idea to have both open as can be seen in the image below.</p> <img src="_assets/ocaml_console.png" style="width:400px;"/> </header><nav class="odoc-toc"><ul><li><a href="#ext_install">Extension installation</a><ul><li><a href="#firefox">Firefox</a></li><li><a href="#chrome">Google Chrome</a></li><li><a href="#edge">Microsoft Edge</a></li><li><a href="#safari">Safari</a></li></ul></li><li><a href="#web_page_instructions">Web page instructions</a><ul><li><a href="#current_limitations">Current limitations</a></li></ul></li><li><a href="#ocaml_poke">The <code>ocaml_poke</code> object</a><ul><li><a href="#poke_current_limitations">Current limitations</a></li></ul></li></ul></nav><div class="odoc-content"><h2 id="ext_install"><a href="#ext_install" class="anchor"></a>Extension installation</h2><p>The extension is distributed with <code>brr</code> not via the browser specific app stores. It is installed in:</p><pre>$(opam var share)/brr/ocaml_console</pre><p>and can be added to your browser from there.</p><h3 id="firefox"><a href="#firefox" class="anchor"></a>Firefox</h3><p>The easiest at the moment is to install the extension temporarily – this means however that it will vanish if you restart your browser.</p><ol><li>Navigate to <code>about:debugging</code></li><li>Click the button “This Firefox”</li><li>Click the button “Load Temporary Add-on”</li><li>Open the extension directory and select <code>manifest.json</code>. On macOS type <code>shift</code>-<code>/</code> and paste the path to the extension directory; this allows you to access hidden folders (namely <code>.opam</code>) from the file selector.</li></ol><p>These steps are taken from <a href="https://extensionworkshop.com/documentation/develop/temporary-installation-in-firefox/">here</a>.</p><h3 id="chrome"><a href="#chrome" class="anchor"></a>Google Chrome</h3><ol><li>Navigate to <code>chrome://extensions</code>.</li><li>Enable “Developer mode” by clicking the toggle switch.</li><li>Click on the “Load unpacked” button. Select the extension directory and click “Select”. On macOS type <code>shift</code>-<code>/</code> and paste the path to the extension directory; this allows you to access hidden folders (namely <code>.opam</code>) from the file selector.</li></ol><p>The <a href="https://developer.chrome.com/extensions/getstarted">Chrome extension tutorial</a> may also help with a few images.</p><h3 id="edge"><a href="#edge" class="anchor"></a>Microsoft Edge</h3><p>Navigate to <code>edge://extensions</code> and follow the steps of <a href="#chrome">Google Chrome</a>.</p><h3 id="safari"><a href="#safari" class="anchor"></a>Safari</h3><p>The WebExtension API is not supported by Safari yet. But it seems support is on its way for Safari 14.</p><h2 id="web_page_instructions"><a href="#web_page_instructions" class="anchor"></a>Web page instructions</h2><p>You need to compile a JavaScript file that has the <code>js_of_ocaml</code> toplevel machinery in your page and exposes it via the <a href="#ocaml_poke">poke</a> object.</p><p>One way of doing this to link with the <code>brr.poke</code> library and add this line:</p><pre><code>let () = Brr_poke.define ()</code></pre><p>somewhere in your code. Alternatively linking against the <code>brr.poked</code> with <code>-linkall</code> adds the above line to your program without having to modify it.</p><p>To be able to access all your program libraries and modules you need to compile the bytecode executable with <code>-linkall</code> and invoke <code>js_of_ocaml</code> with the <code>--toplevel</code> option, <code>-I</code> options to lookup to cmis of the modules you want to access and link with <code>js_of_ocaml</code>'s support the toplevel and dynlinking. Here is <a href="web_page_howto.html#quick">a minimal example</a> and <a href="web_page_howto.html#ocaml_console">instructions</a> to poke it.</p><p>In practice adding the poke object will result in a insane blowup of your page size budget. This is totally unfit for production. Keep in mind that the whole bytecode OCaml compiler, the <code>js_of_ocaml</code> compiler, the toplevel machinery and the <code>cmi</code> files of the modules you want to access get embedded in the page.</p><h3 id="current_limitations"><a href="#current_limitations" class="anchor"></a>Current limitations</h3><p>It would be nice to be able to separately compile the poke object and needed machinery as its own <code>ocaml_poke.js</code> script and link it separately via the HTML file. However this is not possible at the moment as separate toplevel compilation is not supported – this means excessively long build times are needed for now to use the console on your programs.</p><h2 id="ocaml_poke"><a href="#ocaml_poke" class="anchor"></a>The <code>ocaml_poke</code> object</h2><p>The JavaScript object must be named <code>ocaml_poke</code> and live in the global object (<code>globalThis</code>) of the web page. It must expose the following object members and types (in OCaml record notation) :</p><pre><code>{ version : int; (* current version is 0 *)
  ocaml_version : Jstr.t;
  jsoo_version : Jstr.t;
  init : unit -&gt; unit;
  eval : Jstr.t -&gt; Brr.Json.t;
  use : Jstr.t -&gt; Brr.Json.t; }</code></pre><p><code>init</code>, <code>eval</code> and <code>use</code> should raise <a href="Jv/index.html#exception-Error"><code>Jv.Error</code></a> in case of problem (the right interface would be to return a promise but we cannot because of WebExtension API constraints). For now <code>eval</code> should always return a <a href="Jstr/index.html#type-t"><code>Jstr.t</code></a>.</p><p>Note that this is the only thing the extension needs. If you don't want to use the Brr libraries to define the <code>ocaml_poke</code> object you can perfectly define the object your own way.</p><p>If you want to access an <code>ocaml_poke</code> object yourself use the <a href="Brr_ocaml_poke/index.html"><code>Brr_ocaml_poke</code></a> module.</p><h3 id="poke_current_limitations"><a href="#poke_current_limitations" class="anchor"></a>Current limitations</h3><p>This API is very crude we can do much better than that. A few things that would be nice:</p><ul><li>A function to ask for completions from the <code>cmis</code>. The implementation should likely be done in OCaml's <code>Toplevel</code> upstream, as it would benefit everyone.</li><li>A more structured <code>eval</code> return type to prettify error reports and location highlights. Nothing is done at the moment. (Oddly we get nice user error message when we use the <code>#use</code> button).</li></ul><p>The only hard constraint we have is that eval should return JSON since it's the only thing we can get back in the panel via <a href="https://developer.chrome.com/extensions/devtools_inspectedWindow#method-eval">chrome.devtools.inspectedWindow.eval</a> / <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/devtools.inspectedWindow/eval">devtools.inspectedWindow.eval</a>.</p></div></body></html>